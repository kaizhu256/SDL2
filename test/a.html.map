{"version":3,"file":"a.html","sources":["testdraw2.c","/Users/kaizhu/src/sdl2/src/SDL_log.c","/Users/kaizhu/src/sdl2/src/events/SDL_events.c","/Users/kaizhu/src/sdl2/src/events/SDL_gesture.c","/Users/kaizhu/src/sdl2/src/render/SDL_render.c","/Users/kaizhu/src/sdl2/src/render/SDL_yuv_sw.c","/Users/kaizhu/src/sdl2/src/render/opengles2/SDL_render_gles2.c","/Users/kaizhu/src/sdl2/src/render/opengles2/SDL_gles2funcs.h","/Users/kaizhu/src/sdl2/src/render/opengles2/SDL_shaders_gles2.c","/Users/kaizhu/src/sdl2/src/render/software/SDL_render_sw.c","/Users/kaizhu/src/sdl2/src/render/software/SDL_rotate.c","/Users/kaizhu/src/sdl2/src/stdlib/SDL_malloc.c","/Users/kaizhu/src/sdl2/src/stdlib/SDL_stdlib.c","/Users/kaizhu/src/sdl2/src/stdlib/SDL_string.c","/Users/kaizhu/src/sdl2/src/video/SDL_fillrect.c","/Users/kaizhu/src/sdl2/include/SDL_rect.h","/Users/kaizhu/src/sdl2/include/SDL_stdinc.h","/Users/kaizhu/src/sdl2/src/video/SDL_pixels.c","/Users/kaizhu/src/sdl2/src/video/SDL_rect.c","/Users/kaizhu/src/sdl2/src/video/SDL_RLEaccel.c","/Users/kaizhu/src/sdl2/src/video/SDL_stretch.c","/Users/kaizhu/src/sdl2/src/video/SDL_surface.c","/Users/kaizhu/src/sdl2/src/video/SDL_video.c","/Users/kaizhu/src/sdl2/src/joystick/SDL_joystick.c","/Users/kaizhu/src/sdl2/src/video/dummy/SDL_nullvideo.c","/Users/kaizhu/src/sdl2/src/joystick/emscripten/SDL_sysjoystick.c","/Users/kaizhu/src/sdl2/src/timer/unix/SDL_systimer.c","/Users/kaizhu/src/sdl2/src/video/emscripten/SDL_emscriptenvideo.c","/Users/kaizhu/src/sdl2/src/thread/generic/SDL_sysmutex.c","/Users/kaizhu/src/sdl2/src/thread/generic/SDL_syssem.c","/Users/kaizhu/src/sdl2/src/SDL.c","/Users/kaizhu/src/sdl2/include/SDL_bits.h","/Users/kaizhu/src/sdl2/src/SDL_assert.c","/Users/kaizhu/src/sdl2/src/SDL_error.c","/Users/kaizhu/src/sdl2/src/SDL_hints.c","/Users/kaizhu/src/sdl2/src/atomic/SDL_spinlock.c","/Users/kaizhu/src/sdl2/src/audio/SDL_audio.c","/Users/kaizhu/src/sdl2/src/audio/SDL_audiocvt.c","/Users/kaizhu/src/sdl2/include/SDL_endian.h","/Users/kaizhu/src/sdl2/src/audio/SDL_audiotypecvt.c","/Users/kaizhu/src/sdl2/src/events/SDL_keyboard.c","/Users/kaizhu/src/sdl2/src/events/SDL_mouse.c","/Users/kaizhu/src/sdl2/src/events/SDL_quit.c","/Users/kaizhu/src/sdl2/src/events/SDL_touch.c","/Users/kaizhu/src/sdl2/src/events/SDL_windowevents.c","/Users/kaizhu/src/sdl2/src/render/software/SDL_blendfillrect.c","/Users/kaizhu/src/sdl2/src/render/software/SDL_blendline.c","/Users/kaizhu/src/sdl2/src/render/software/SDL_blendpoint.c","/Users/kaizhu/src/sdl2/src/render/software/SDL_drawline.c","/Users/kaizhu/src/sdl2/src/render/software/SDL_drawpoint.c","/Users/kaizhu/src/sdl2/src/stdlib/SDL_getenv.c","/Users/kaizhu/src/sdl2/src/stdlib/SDL_qsort.c","/Users/kaizhu/src/sdl2/src/thread/SDL_thread.c","/Users/kaizhu/src/sdl2/src/timer/SDL_timer.c","/Users/kaizhu/src/sdl2/src/video/SDL_blit.c","/Users/kaizhu/src/sdl2/src/video/SDL_blit_0.c","/Users/kaizhu/src/sdl2/src/video/SDL_blit_1.c","/Users/kaizhu/src/sdl2/src/video/SDL_blit_A.c","/Users/kaizhu/src/sdl2/src/video/SDL_blit_auto.c","/Users/kaizhu/src/sdl2/src/video/SDL_blit_copy.c","/Users/kaizhu/src/sdl2/src/video/SDL_blit_N.c","/Users/kaizhu/src/sdl2/src/video/SDL_blit_slow.c","/Users/kaizhu/src/sdl2/src/video/SDL_egl.c","/Users/kaizhu/src/sdl2/src/joystick/SDL_gamecontroller.c","/Users/kaizhu/src/sdl2/src/audio/dummy/SDL_dummyaudio.c","/Users/kaizhu/src/sdl2/src/audio/disk/SDL_diskaudio.c","/Users/kaizhu/src/sdl2/src/video/dummy/SDL_nullevents.c","/Users/kaizhu/src/sdl2/src/video/dummy/SDL_nullframebuffer.c","/Users/kaizhu/src/sdl2/src/audio/emscripten/SDL_emscriptenaudio.c","/Users/kaizhu/src/sdl2/src/video/emscripten/SDL_emscriptenevents.c","/Users/kaizhu/src/sdl2/src/video/emscripten/SDL_emscriptenframebuffer.c","/Users/kaizhu/src/sdl2/src/video/emscripten/SDL_emscriptenmouse.c","/Users/kaizhu/src/sdl2/src/video/emscripten/SDL_emscriptenopengles.c","/Users/kaizhu/src/sdl2/src/loadso/dummy/SDL_sysloadso.c","/Users/kaizhu/src/sdl2/src/thread/generic/SDL_systhread.c","/Users/kaizhu/src/sdl2/src/thread/generic/SDL_systls.c","/Users/kaizhu/src/sdl2/src/atomic/SDL_atomic.c","/Users/kaizhu/src/sdl2/src/cpuinfo/SDL_cpuinfo.c","/Users/kaizhu/src/sdl2/src/file/SDL_rwops.c","/Users/kaizhu/src/sdl2/src/video/SDL_bmp.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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AAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;ADg4DA;;AACA;;;;AAYA;AAAA;;AAGA;;AAFA;;AAIA;AAAA;;AACA;AAAA;AAAA;;AAIA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;;AAGA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAOA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAGA;;;;AAFA;AAAA;;;AAEA;AAAA;AAAA;AACA;;AAEA;AACA;;;AAGA;AAAA;AAAA;AAIA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAnLA;AAEA;AAAA;AAAA;;AACA;;AAniDA;AAAA;AAEA;AAAA;AAAA;;AAGA;AAAA;AAEA;AAzHA;AAEA;AAAA;AAAA;;AAIA;;AAAA;AAAA;AAAA;;;;;;;;AAopDA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAHA;AAKA;AAAA;AAAA;AACA;AAAA;AAAA;AAzpDA;AAGA;AAAA;AAAA;;;AAm0DA;;AA7zDA;AAAA;AAAA;AACA;;;AA4zDA;;;;;AA3zDA;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AALA;AAAA;AACA;;;;;;;;AA4zDA;;;AARA;;;AAQA;;;AANA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;AAGA;;;;;;;;;;;AAzpDA;AAEA;AAAA;AAGA;;AAuCA;AACA;;AAxHA;AAAA;AAAA;;;;;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAEA;AAzHA;;;;;;AAEA;AAAA;AAAA;;AAIA;;AAAA;AAAA;AAAA;;;;;;;AAgMA;AAAA;AACA;;AAEA;;;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAJA;;;;;;;;AAWA;AAAA;AACA;;AACA;;;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAHA;;;;;;;;AAOA;AAAA;;AACA;AAAA;AAAA;;;;AAEA;;;AADA;AAAA;AACA;AAAA;AAAA;AA/MA;AAGA;AAAA;AAAA;;AAMA;AAAA;AAAA;AACA;;;;AACA;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AALA;AAAA;AACA;;;;;;;;;AAuMA;AAAA;AACA;AALA;AAAA;;;;;;;AAOA;;;AAAA;;AAEA;AAAA;AAAA;AACA;AAEA;AACA;;;;;;;AAlGA;AAAA;;AAIA;AAOA;;AAbA;AAAA;AAWA;AAAA;AAAA;AAEA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AA3JA;AAAA;AAAA;;;;;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAEA;AAzHA;;;;;;AAEA;AAAA;AAAA;;AAIA;;AAAA;AAAA;AAAA;;;;;;;AA8QA;AAAA;;;;;;AAiBA;;AA8GA;;AA1GA;AACA;;AACA;;AAwGA;;AAtGA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AArDA;AAEA;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;;AAuDA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AAFA;AAAA;AAIA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AACA;;AACA;AACA;;AA4EA;;;AArYA;AAGA;AAAA;AAAA;;AAMA;AAAA;AAAA;AACA;;;;AACA;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AALA;AAAA;AACA;;;;;;;;;AAsTA;AAAA;;AACA;AAAA;AAAA;AAjUA;AAGA;AAAA;AAAA;;AAMA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AALA;AAAA;AACA;;;;;;;;AA2XA;;;AAhEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AA7UA;AAGA;AAAA;AAAA;;AAMA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AALA;AAAA;AACA;;;;;;;;AA2XA;;;AApDA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAvVA;AAGA;AAAA;AAAA;;AAMA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AALA;AAAA;AACA;;;;;;;;AA2XA;;;;AAxCA;AAAA;AAiBA;;AAhBA;AAAA;AA9VA;AAGA;AAAA;AAAA;;AAMA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AALA;AAAA;AACA;;;;;;;;AA2XA;;;AAnCA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAxWA;AAGA;AAAA;AAAA;;AAMA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AALA;AAAA;AACA;;;;;;;;AA2XA;;;;AAvBA;AAAA;AA9WA;AAGA;AAAA;AAAA;;AAMA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AALA;AAAA;AACA;;;;;;;;AA2XA;;;AAnBA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAzXA;AAGA;AAAA;AAAA;;AAMA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AALA;AAAA;AACA;;;;;;;;AA2XA;;;AAPA;AAAA;;AACA;AAAA;AAAA;AAnTA;AAAA;AACA;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;AAEA;AAHA;AACA;;;;;;;;;;;AAMA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;AAuSA;AAAA;;AAEA;AAAA;;AAjYA;AAGA;AAAA;AAAA;;;AAkYA;;AA5XA;AAAA;AAAA;AACA;;;AA2XA;;;;;AA1XA;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AALA;AAAA;AACA;;;;;;;;AA2XA;;;;;;;;;;;;;;;;;;;;;AAoCA;AAGA;AAAA;AACA;AAAA;AA3UA;AAAA;AAAA;;;;;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAEA;AAzHA;;;;;;AAEA;AAAA;AAAA;;AAIA;;AAAA;AAAA;AAAA;;;;;;;AA0bA;AAAA;AAAA;;;AA+DA;;AA/DA;AAAA;AAAA;;;AA+DA;;AA3DA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;;;AA9CA;AAEA;;;;;;AACA;AAAA;AACA;;AACA;;;AAGA;;;;AAEA;AACA;AACA;AAJA;AAAA;;;;;;;;;;;;;;;;AASA;AAAA;AAAA;AACA;;AACA;;;AA6BA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AA7DA;;;;;;AACA;AAAA;AACA;;AACA;;;AAGA;;;;AAEA;AACA;AACA;AAJA;AAAA;;;;;;;;;;;;;;;;AASA;AAAA;AAAA;AACA;;AACA;;;AA+CA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AA5EA;;;;AACA;AAAA;AACA;;AACA;;;;AAGA;;;;AAEA;AACA;AACA;AAJA;AAAA;;;;;;;;;;;;AASA;AAAA;AAAA;AACA;;;;AACA;;;;;AA+DA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AA1FA;AAEA;;;;AACA;AAAA;AACA;;AACA;;;AAGA;;;;AAEA;AACA;AACA;AAJA;AAAA;;;;;;;;;;;;AASA;AAAA;AAAA;AACA;;AACA;;;;AAnaA;AAGA;AAAA;AAAA;;;AA8eA;;AAxeA;AAAA;AAAA;AACA;;;AAueA;;;;;;;;;;;;;;;;AAneA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AALA;AAAA;AACA;;;;;;;;AAueA;;;;;;;;;;;;;;;;;;;;;;AAGA;AAMA;AAAA;AACA;AAAA;AAzZA;AAAA;AAAA;;;;;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAEA;AAzHA;;;;;;AAEA;AAAA;AAAA;;AAIA;;AAAA;AAAA;AAAA;;;;;;;AAwgBA;AAAA;AAAA;;;AAkCA;;AAlCA;AAAA;AAAA;;;AAkCA;;AA/BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAxHA;;;;;;AACA;AAAA;AACA;;AACA;;;AAGA;;;;AAEA;AACA;AACA;AAJA;AAAA;;;;;;;;;;;;;;;;AASA;AAAA;AAAA;AACA;;AACA;;;AA0GA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAlIA;;;;;;AACA;AAAA;AACA;;AACA;;;AAGA;;;;AAEA;AACA;AACA;AAJA;AAAA;;;;;;;;;;;;;;;;AASA;AAAA;AAAA;AACA;;AACA;;;AAoHA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5IA;;;;;;AACA;AAAA;AACA;;AACA;;;AAGA;;;;AAEA;AACA;AACA;AAJA;AAAA;;;;;;;;;;;;;;;;AASA;AAAA;AAAA;AACA;;AACA;;;AAnaA;AAGA;AAAA;AAAA;;;AA+hBA;;AAzhBA;AAAA;AAAA;AACA;;;AAwhBA;;;;;;;;;;;;;;;;AAphBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AALA;AAAA;AACA;;;;;;;;AAwhBA;;;;;;;;;;;AAMA;AAAA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;;;AAAA;AADA;AAAA;AADA;AAGA;AAEA;;;;;;;;;AAMA;AAAA;AAIA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AAGA;AAEA;AAAA;AAIA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAaA;;AAXA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;;;AAKA;;AAJA;;AAIA;;;;;;;;;;;;AA9cA;AAAA;AAEA;AAAA;AAAA;;;AAYA;;AAPA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AADA;AAGA;AAAA;AAAA;;AAuzBA;AAGA;AAAA;;AAAA;AAAA;;AAKA;AAAA;AAAA;AACA;AAIA;AAHA;AAGA;AAAA;AACA;AADA;AAGA;AAAA;AAAA;AAEA;AAMA;AALA;AAKA;AAEA;AAh1BA;AAg1BA;AAIA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;AA9+BA;AAGA;AAAA;AAAA;;;AAmJA;;AA7IA;AAAA;AAAA;AACA;;;AA4IA;;;;;AA3IA;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AALA;AAAA;AACA;;;;;;;;AA4IA;;;;;;;AAKA;AAAA;AAEA;AAAA;AAAA;;AAaA;;AARA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAGA;;AANA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;;;;;;;;;;;;AA42BA;AAAA;AAp7BA;AAAA;AAAA;;;;;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAEA;AAzHA;;;;;;AAEA;AAAA;AAAA;;AAIA;;AAAA;AAAA;AAAA;;;;;;;AAkiCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAuCA;AAAA;AAAA;AAEA;;AAtBA;AAAA;AAAA;;;;AACA;AAAA;;;;;;;;;;AASA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAHA;AAIA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;AAEA;;;;;;;;;;AAsHA;AAAA;AAIA;AAAA;;;AAkBA;;AAbA;AAAA;AACA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AALA;AAAA;;;;;;;;AApCA;AAKA;AAAA;AAAA;;AACA;AAAA;AAAA;AAEA;;;;;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;;AAGA;AAAA;AAAA;AA4BA;AAAA;AAAA;AACA;;AAEA;;;;;;;;;;;AA/FA;AAAA;AACA;AAAA;AAngCA;AAAA;AAAA;;;;;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAEA;AAzHA;;;;;;AAEA;AAAA;AAAA;;AAIA;;AAAA;AAAA;AAAA;;;;;;;AAqkCA;AAAA;AAAA;;;AAeA;AAAA;AAAA;AACA;AAAA;AAAA;;AALA;AAAA;AAAA;AACA;AAAA;AAAA;;AALA;AAAA;AAAA;AACA;AAAA;AAAA;;AAJA;AAAA;AAAA;;AAeA;;AAOA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAEA;;AAmBA;AAAA;;;AA6BA;;AAxBA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;;;;AACA;AAAA;;AAEA;AACA;;;;;;;AAEA;AACA;;;AAHA;AADA;AAOA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAvHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AA+HA;;AARA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;AArRA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCA;AACA;;AAEA;AACA;;;;;AAIA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;;AA2BA;;;;AAlUA;AAMA;AAAA;AACA;AAoSA;;;;;;;AAlSA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;AAEA;AALA;AACA;;;;;;;;AAQA;;;;;AAEA;AAAA;AAAA;AA0RA;AAxRA;;AADA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AACA;AACA;AAAA;AACA;;;;;;;AAMA;AACA;;;AAEA;;AAGA;AAAA;AACA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AACA;;;AAMA;AAAA;AAAA;AAAA;AADA;AAAA;AAGA;AAAA;AAAA;AADA;AAAA;AAGA;AAAA;AAAA;AADA;AAAA;AAGA;AAAA;AAAA;AADA;AAAA;AAGA;AAAA;AAAA;AADA;AAAA;AAGA;AAAA;AAAA;AADA;AAAA;AAIA;AAEA;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;;AAOA;AAAA;;AALA;AAAA;AACA;AAAA;;AAMA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;;;;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AA2HA;AAGA;AAAA;AAAA;AA7HA;AA+HA;;AADA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAtIA;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAwHA;AAGA;AAAA;AAAA;AA1HA;AA4HA;;AADA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAnIA;;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;AA+LA;AAAA;AAAA;AAAA;AAGA;AAoBA;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AACA;AAIA;AAHA;AAGA;AAAA;AACA;AADA;AAGA;AAAA;AAAA;AAEA;AAMA;AALA;AAKA;AAEA;AA3CA;AA2CA;AAIA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;AA1CA;;;AANA;AAAA;AAAA;;AAzFA;AAGA;AAAA;AAAA;AAuFA;AArFA;;AADA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;;AA8EA;;AAAA;AAAA;AAAA;;AA3FA;AAGA;AAAA;AAAA;AAyFA;AAvFA;;AADA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;;;;;AAgFA;AAAA;;AAEA;;;;;;;;;;;;;;;;;;;AAzMA;AAAA;AAIA;AAIA;AACA;;AAEA;;AA0FA;;AArFA;AAAA;;AAEA;AAAA;AAAA;AAMA;;;;AAFA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AANA;AAAA;AAAA;AAAA;;;;;;;;;AAFA;AAAA;AAAA;AAAA;;;;;;;;AAoBA;AAAA;AACA;;;;;AAEA;AAAA;AAAA;;;;;AAEA;AALA;AACA;;;;;;;AAgEA;;;AAtDA;AACA;;AAEA;;AAmDA;;AAhDA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAOA;AAAA;;AAGA;AAEA;AAAA;AAAA;AACA;AAAA;;AACA;AACA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AACA;;;;;;AAEA;;AAEA;AAAA;AAAA;AAAA;AACA;;AAaA;;;AAnCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AA0BA;AAAA;;AAEA;AAAA;AACA;AAAA;;AAEA;AACA;AAAA;AAAA;AAAA;;AAEA;;;;AAtEA;;AAsEA;;;;;;;;;;;;;AAsWA;AAEA;AAAA;AAIA;AAAA;;;AAyBA;;AApBA;AAAA;AACA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AALA;AAAA;;;;;;;;AA/DA;AAKA;AAAA;AAAA;;AACA;AAAA;AAAA;AAEA;;;;;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAuDA;AAAA;AAAA;AAGA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AACA;AAAA;;AAEA;AAluCA;AAGA;AAAA;AAAA;;;AAkuCA;;AA5tCA;AAAA;AAAA;AACA;;;AA2tCA;;;;;AA1tCA;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AALA;AAAA;AACA;;;;;;;;AA2tCA;;;;;;;;;;;;;;AAKA;AAAA;AAIA;AAAA;;;AA0BA;;AArBA;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;;AAfA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA/GA;AAKA;AAAA;AAAA;;AACA;AAAA;AAAA;AAEA;;;;;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAiGA;AAAA;AAlBA;AAAA;;;;;;;;AAnvCA;AAGA;AAAA;AAAA;;;AAqwCA;;AA/vCA;AAAA;AAAA;AACA;;;AA8vCA;;;;;AA7vCA;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AALA;AAAA;AACA;;;;;;;;AA8vCA;;;;;;;;;;;;;;;;;;;AA6KA;AAAA;AAn1CA;AAAA;AAAA;;;;;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAEA;AAzHA;;;;;;AAEA;AAAA;AAAA;;AAIA;;AAAA;AAAA;AAAA;;;;;;;AAm8CA;AAAA;;;AA4BA;;AAvBA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AApTA;AAKA;AAAA;AAAA;;AACA;AAAA;AAAA;AAEA;;;;;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAsSA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AA9TA;AAKA;AAAA;AAAA;;AACA;AAAA;AAAA;AAEA;;;;;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAgTA;AAAA;AAAA;AAp9CA;AAGA;AAAA;AAAA;;;AAo9CA;;AA98CA;AAAA;AAAA;AACA;;;AA68CA;;;;;AA58CA;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AALA;AAAA;AACA;;;;;;;;AA68CA;;;;;;;;;;;;;;;AA5MA;AAAA;AAEA;AAAA;AACA;AAAA;AAOA;AAAA;AACA;AAAA;AAAA;;;AAyEA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AAyBA;;AAuDA;;;AAvJA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkEA;;AAqFA;;;;;AAnDA;AAAA;;;AAmDA;;AA9CA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAEA;AAAA;AAAA;;AAMA;AAAA;;;AALA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAGA;AAAA;AACA;AAAA;AAEA;AAAA;;;;AACA;AAAA;;AAEA;AACA;;;;;;;AAEA;AACA;;;AAHA;AADA;AAOA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAtZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAqZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;AA1WA;AAAA;AAAA;;;AAWA;AAAA;AAAA;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;;AATA;AAAA;AAAA;AACA;AAAA;AAAA;;AAJA;AAAA;AAAA;;AAeA;;AAOA;AAAA;AAAA;;;AAwVA;;AAtVA;AAAA;AAAA;AAIA;;AAkVA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8CA;AAAA;AA33CA;AAAA;AAAA;;;;;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAEA;AAzHA;;;;;;AAEA;AAAA;AAAA;;AAIA;;AAAA;AAAA;AAAA;;;;;;;AA8+CA;AAAA;;;AAsDA;;AAlDA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;;AAEA;AAAA;AACA;AAAA;;AAEA;AAAA;;AAEA;AAAA;AACA;AAAA;;AA/WA;AAKA;AAAA;AAAA;;AACA;AAAA;AAAA;AAEA;;;;;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAjBA;AAKA;AAAA;AAAA;;AACA;AAAA;AAAA;AAEA;;;;;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAjBA;AAKA;AAAA;AAAA;;AACA;AAAA;AAAA;AAEA;;;;;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAyWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAjYA;AAKA;AAAA;AAAA;;AACA;AAAA;AAAA;AAEA;;;;;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAmXA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAzhDA;AAGA;AAAA;AAAA;;;AAyhDA;;AAnhDA;AAAA;AAAA;AACA;;;AAkhDA;;;;;AAjhDA;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AALA;AAAA;AACA;;;;;;;;AAkhDA;;;;;;;;;;;;;;;;;;AAMA;AAAA;AAh8CA;AAAA;AAAA;;;;;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAEA;AAzHA;;;;;;AAEA;AAAA;AAAA;;AAIA;;AAAA;AAAA;AAAA;;;;;;;AAojDA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AACA;;AAgCA;;AA7BA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AApjDA;AAGA;AAAA;AAAA;;AAMA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AALA;AAAA;AACA;;;;;;;;AAqkDA;;;AApBA;AAAA;AACA;AAEA;AACA;AACA;AAAA;;AADA;AAHA;AAAA;AAAA;AASA;;;AALA;AACA;AACA;AACA;AACA;AACA;AALA;;;;;;;;AAOA;AAEA;AAAA;AAAA;AAGA;;AAGA;;;;;;;AA/+CA;AAAA;AAEA;AAAA;AAAA;;;;;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAEA;AAzHA;;;;;;AAEA;AAAA;AAAA;;AAIA;;AAAA;AAAA;AAAA;;;;;;;AA+lDA;AAAA;AAAA;AACA;;;;;;;;AA7/BA;AAAA;AACA;AAAA;AA1fA;AAAA;AAAA;;;;;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAEA;AAzHA;;;;;;AAEA;AAAA;AAAA;;AAIA;;AAAA;AAAA;AAAA;;;;;;;AAymBA;;AAaA;;AAXA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AACA;AACA;AAEA;;;;;;;;;;AAq/BA;AAAA;AACA;AAAA;AAlgDA;AAAA;AAAA;;;;;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAEA;AAzHA;;;;;;AAEA;AAAA;AAAA;;AAIA;;AAAA;AAAA;AAAA;;;;;;;AA+mDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;;AACA;;AAEA;;AAFA;AAEA;;;;;;;;AAKA;AAAA;AACA;AAAA;AAhhDA;AAAA;AAAA;;;;;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAEA;AAzHA;;;;;;AAEA;AAAA;AAAA;;AAIA;;AAAA;AAAA;AAAA;;;;;;;AA6nDA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AE19BA;;;;;;;;;AC9wBA;AAKA;;AACA;;AA+CA;;AA3CA;AACA;;AACA;;AAyCA;;AArCA;AACA;;AA+jBA;AAAA;AAEA;AACA;AAhkBA;;AAkCA;;AA/BA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAhEA;AAAA;;;AAqEA;;AApEA;AAAA;AAEA;;;AAkEA;;AAjEA;AAAA;AAAA;AACA;;;AAgEA;;AA/DA;AAAA;AA0NA;AACA;AAEA;;;AA9JA;;AAmKA;AAAA;AAOA;AACA;AACA;;;AA5KA;;AA6KA;AAAA;AAAA;;AAGA;;AAhLA;;AA8KA;AAAA;;AA9KA;;;;;;;;AA2hBA;AAAA;AAEA;AACA;AACA;;;;;;;AA9gBA;AAAA;AAEA;AAAA;AAAA;;AAIA;;AAHA;AACA;AAAA;AAEA;;;;;;;;;;AAGA;AAjGA;AAAA;AAEA;AAAA;;AACA;AAAA;AAAA;AAEA;;;AACA;AAAA;AAAA;AACA;;;AACA;AAAA;AA0NA;AACA;AAEA;;AAKA;AAAA;AAOA;AACA;AACA;;AACA;AAAA;AAAA;;AAGA;;;AAFA;AAAA;;;;;;;AAvOA;;;;;AAuFA;;AASA;;AAGA;;;;;;;AAXA;;AACA;AAAA;AAAA;;AAEA;;;AAQA;;AAPA;AAAA;AAAA;;AAOA;;;;;;;;;;;;;;;;AASA;AAAA;AADA;AAAA;;AAEA;;AAmBA;;AAfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AADA;AADA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AADA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;;AAGA;AAAA;AACA;;AAGA;;;;;;;AAKA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AADA;AAAA;;;;;;;AAOA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;;;AAMA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAOA;AAAA;AAKA;AAAA;AAAA;;AACA;;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAJA;AAAA;AAEA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAIA;AACA;AACA;AAAA;AAHA;AAAA;AAAA;;;;;;;;AAKA;AAAA;AAAA;;AAEA;;AADA;AACA;;;;;;;;;;AAOA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AADA;AAGA;AACA;;;;;;;AAMA;;;;;;;AAKA;AAAA;AAEA;;AAGA;AAAA;AAAA;AAEA;;AAJA;AAAA;AAAA;AAIA;;;;;;;;AAMA;AAAA;AACA;AAEA;;AAOA;;AAFA;AAAA;AAEA;;;;;;AAKA;AAAA;AACA;AACA;;AAOA;;AANA;AAAA;AAAA;;AAGA;AAGA;;AALA;AAAA;AAKA;;;;;;;;;;;;AA1PA;AAAA;AAEA;AAAA;;AACA;AAAA;AAAA;AAEA;;;AACA;AAAA;AAAA;AACA;;;AACA;AAAA;AA0NA;AACA;AAEA;;AAKA;AAAA;AAOA;AACA;AACA;;AACA;AAAA;AAAA;;AAGA;;;AAFA;AAAA;;;;;;;AAvOA;;;;;AAsPA;;;AAaA;;;;;;;AATA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAIA;AAAA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AAjRA;AAAA;AAEA;AAAA;;AACA;AAAA;AAAA;AAEA;;;AACA;AAAA;AAAA;AACA;;;AACA;AAAA;AA0NA;AACA;AAEA;;AAKA;AAAA;AAOA;AACA;AACA;;AACA;AAAA;AAAA;;AAGA;;;AAFA;AAAA;;;;;;;AAvOA;;;;;AA6QA;;;AAuCA;;;;;;;AAnCA;AAAA;AACA;;AACA;;AAiCA;;AA/BA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AASA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;;;;;;;;;;;;;;;AALA;;AAFA;AAAA;AAGA;AACA;;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;;;;;;;;;AAYA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAFA;AAAA;AAAA;AAIA;;;AAEA;;;AAKA;;AAGA;;;;;;;;;;;;AAlUA;AAAA;AAEA;AAAA;;AACA;AAAA;AAAA;AAEA;;;AACA;AAAA;AAAA;AACA;;;AACA;AAAA;AA0NA;AACA;AAEA;;AAKA;AAAA;AAOA;AACA;AACA;;AACA;AAAA;AAAA;;AAGA;;;AAFA;AAAA;;;;;;;AAvOA;;;;;AA8TA;;;AAuCA;;;;;;;AAnCA;AAAA;AACA;;AACA;;AAiCA;;AA/BA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AASA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;;;;;;;;;;;;;;;AALA;;AAFA;AAAA;AAGA;AACA;;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;;;;;;;;;AAYA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAFA;AAAA;AAAA;AAIA;;;AAEA;;;AAKA;;AAGA;;;;;;;;;;;;;AAnXA;AAAA;AAEA;AAAA;;AACA;AAAA;AAAA;AAEA;;;AACA;AAAA;AAAA;AACA;;;AACA;AAAA;AA0NA;AACA;AAEA;;AAKA;AAAA;AAOA;AACA;AACA;;AACA;AAAA;AAAA;;AAGA;;;AAFA;AAAA;;;;;;;AAvOA;;;;;AA8WA;;;AAyCA;;;;;;;AArCA;AAAA;AACA;;AACA;;AAmCA;;AAjCA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAWA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAJA;AAAA;;;;;;;;;;;;;;;AAPA;;AAFA;AAAA;AAGA;AACA;;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAJA;AAAA;;;;;;;;;AAeA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAFA;AAAA;AAAA;AAGA;;;AAEA;;;AAKA;;AAGA;;;;;;;;;;;;;;AAraA;AAAA;AAEA;AAAA;;AACA;AAAA;AAAA;AAEA;;;AACA;AAAA;AAAA;AACA;;;AACA;AAAA;AA0NA;AACA;AAEA;;AAKA;AAAA;AAOA;AACA;AACA;;AACA;AAAA;AAAA;;AAGA;;;AAFA;AAAA;;;;;;;AAvOA;;;;;AAiaA;;;AAmBA;;;;;;;AAtBA;AAAA;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAJA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;;AAIA;;;AAFA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAlcA;AAAA;AAEA;AAAA;;AACA;AAAA;AAAA;AAEA;;;AACA;AAAA;AAAA;AACA;;;AACA;AAAA;AA0NA;AACA;AAEA;;AAKA;AAAA;AAOA;AACA;AACA;;AACA;AAAA;AAAA;;AAGA;;;AAFA;AAAA;;;;;;;AAvOA;;;;;AA+cA;;;AA0EA;;;;;;;AAjFA;AAAA;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AACA;AAAA;;;AAJA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAAA;AADA;AAMA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAFA;AAGA;;;AAyDA;;AAxDA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;;;AAiDA;;AAhDA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAjDA;AAEA;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;;AA+CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AA8CA;;AA5CA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAGA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAKA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;;AAQA;;;;;;;;;;;;;;;;;AAviBA;AAAA;AAEA;AAAA;;AACA;AAAA;AAAA;AAEA;;;AACA;AAAA;AAAA;AACA;;;AACA;AAAA;AA0NA;AACA;AAEA;;AAKA;AAAA;AAOA;AACA;AACA;;AACA;AAAA;AAAA;;AAGA;;;AAFA;AAAA;;;;;;;AAvOA;;;;;AAoiBA;;;AAyBA;;;;;;;AArBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;;;;AAPA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAIA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAGA;;AAGA;;;;;AAXA;;AAWA;;;;;;AAKA;AAAA;AAEA;;AAGA;;AAFA;AAEA;;;;;;;AAKA;AAAA;AAEA;AACA;;;;;;;AA/gBA;AACA;;;;AAGA;;;AACA;;;;;;;;;;;;;;;;;;;;ACvEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;AAAA;;;;AAAA;;;;;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;AAAA;AAAA;AAAA;;AAAA;;;;AAAA;;;;;AAAA;;;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;AAAA;;;;AAAA;;;;;AAAA;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;AAAA;AAAA;AAAA;;AAAA;;;;AAAA;;;;;AAAA;;;;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;AAAA;;;;AAAA;;;;;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;AAAA;AAAA;AAAA;;AAAA;;;;AAAA;;;;;AAAA;;;;AAAA;AAAA;AAAA;;;AAEA;AACA;AACA;;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;AAAA;;;;AAAA;;;;;AAAA;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;AAAA;AAAA;AAAA;;AAAA;;;;AAAA;;;;;AAAA;;;;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgOA;;;AA6IA;;AA1IA;AAAA;AAAA;;AASA;;;AA1RA;AACA;AACA;AAkRA;AAAA;AAAA;;;AAMA;AAAA;AAAA;AAAA;;AAqCA;AACA;AAWA;;;;;AAOA;;;;AA5CA;AAAA;AAAA;AAAA;AAAA;AAOA;;AAGA;;AAFA;AAEA;AAGA;;AAYA;AACA;AAWA;;AACA;;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAFA;;;AAWA;;;AAqEA;;AAjEA;AAAA;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAMA;AAAA;AAAA;;AACA;;;AAWA;AAAA;AAlSA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAKA;AAsDA;;;AAEA;AACA;AAIA;AACA;AAEA;AAAA;;;AATA;AACA;AAAA;AACA;AAAA;AACA;;;;;;AACA;AACA;;;;AAEA;AAAA;AAAA;;;AACA;AAAA;;;AAAA;AAAA;;;;;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AARA;;;;;;AAUA;AACA;AACA;AAZA;AAAA;;;;;;;;;;;;;;AAEA;AADA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AARA;;;;;AAUA;AACA;AACA;AAZA;AAAA;;;;;;;;;;AAEA;AADA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AARA;;;;;;AAUA;AACA;AACA;AAZA;AAAA;;;;;;;;;;AAJA;;;;;AAkBA;AAlBA;AAAA;;;;;;;;;;AAnDA;AACA;AAIA;AACA;AAEA;AACA;;;AAVA;AACA;AAAA;AACA;AAAA;AACA;;;;;AACA;AACA;AAEA;AAAA;AACA;AAAA;;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAxCA;;;;;;;;;AA0CA;AACA;AACA;AA5CA;AAAA;;;;;;;;;;;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAxCA;;;;;;;;;AA0CA;AACA;AACA;AA5CA;AAAA;;;;;;;;;AAJA;;;;;AAkDA;AAlDA;AAAA;;;;;;;;;AA5FA;AACA;AACA;AAsXA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;AAEA;AAKA;AAAA;AAjMA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AACA;AAAA;AAAA;AAzMA;AACA;AACA;AA2MA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;;AAVA;AAAA;AAAA;AADA;AAAA;AADA;AAAA;AADA;AAAA;AAeA;AACA;AAIA;AACA;AAEA;AACA;AAPA;;;AAHA;AAGA;;AADA;AAAA;AADA;AAAA;;;AAGA;AACA;;;;AACA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;;;AACA;AAAA;;;AAAA;AAAA;;AAAA;AAAA;;;;;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AARA;;;;;;;;;AAUA;AACA;AACA;AAZA;AAAA;;;;;;;;AAJA;;;;;AAkBA;AAlBA;AAAA;;;;;;;;AAjNA;AACA;AACA;AAqYA;;AAKA;AAAA;AAAA;;AACA;;AAMA;;;AAQA;;AAPA;;AAOA;;;;;;ACjdA;AAAA;;;;;;;AAKA;AAAA;;;;;;;AAKA;AAAA;;;;;;AAKA;AACA;;;;;;;ACJA;AAAA;;;;;;AA8CA;AAAA;;;;;;AA2BA;AAAA;;;;;;AAoBA;AAAA;;;;;;AAUA;AAAA;;;;;;AA0CA;AAAA;;;;;;AAoBA;AAAA;;;;;;AAuCA;AAAA;AAAA;AAAA;;;;;;AAOA;AAAA;AAAA;AAAA;;;;;;;;ACUA;AAAA;AAAA;;;;;;;;AA+CA;AAAA;;;;;;;;AAkDA;AAAA;;;;;;;;AAwBA;AAAA;;;;;;AAmBA;AAAA;;;;;;;;AA2DA;AAAA;;;;;;;;;AA3DA;AA0EA;AAAA;AAAA;AAGA;;;AAsBA;AAAA;AACA;;AArBA;AAAA;AAAA;AACA;AAAA;;;;;AAEA;AAAA;AAAA;AAEA;AAFA;;;;AAlcA;AAAA;;;;;;;AAEA;AAAA;;;;;AAEA;AAAA;;;;;AAgcA;AAAA;;;;;;AAEA;AAtcA;AAAA;;;;;;;;;;AA0cA;AAAA;AAAA;;;;;AAvLA;;AAgMA;AAAA;AACA;;;;;;AAsBA;AAAA;;;;;;;AAgEA;AAAA;;;;;;;;AAkEA;AAAA;;;;;;;;;;AAsBA;;AACA;AAAA;AACA;;;AAmBA;AAAA;AAAA;AAAA;AAAA;AACA;AAFA;;;;;;;;AAOA;AA7SA;AA8IA;AACA;;AA0IA;;AA5IA;;;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAHA;;;;;;;AA0IA;;AAYA;;AAMA;AAAA;;;;;AAJA;AAAA;AAAA;AAAA;AAAA;AACA;AAFA;;;;;;;;;AAOA;AA7SA;AA8IA;AACA;;AA0IA;;AA5IA;AAAA;;;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAHA;;;;;;;AA0IA;;;;;;AA4EA;AAAA;;;;;;AASA;AAAA;;;;;;;AA+HA;AAAA;;;;;;;;AAgBA;AAAA;;;;;;;AAoBA;AAAA;;;;;;;;AAwBA;AAAA;;;;;;;;;;AA8BA;AAUA;AAPA;;;;;;;;;;;AAuRA;AAUA;AAAA;AAGA;AATA;;;;;;;;;AAMA;AAAA;AAGA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AC3hCA;;AACA;;AAiFA;;AA7EA;AAAA;AAAA;AAAA;AAAA;;AACA;;AA4EA;;AAxEA;AAOA;;ACzKA;AAAA;AAAA;;;AD0OA;;AC1OA;AAAA;AAAA;;;AD0OA;;;;;AAtEA;AAAA;;;AAsEA;;;;;AAzDA;AAAA;AAAA;;AACA;;AAwDA;;AArDA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;;AAoBA;AAAA;AAOA;AAAA;AAAA;AAAA;AAlHA;AAAA;;;AA4IA;;AAxIA;AAEA;AACA;;;;AAIA;AAAA;;;;AACA;AAAA;;AAEA;AAdA;AAAA;;;;;;;;AA4IA;;;AAvIA;AAAA;AAAA;;;;AACA;AAAA;;;AAGA;AEwLA;AAAA;AAGA;;;AAEA;;;;;;;;;;;;;;;;;;;AAEA;AAAA;;;;;;;AACA;AAAA;;;;;;;AACA;AAAA;;;;;;;AACA;AAAA;AACA;AAAA;;;;;;;;;;;;AFjMA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAdA;AAAA;;;;;;;;AA4IA;;AAnBA;AAAA;AAAA;AAAA;AApGA;AAAA;AACA;AAAA;AACA;AAIA;AAIA;AAJA;;;AAiHA;;;;;;;AA7GA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAHA;;;;;;;AAJA;AASA;AATA;;;;;;;;AAiHA;;AA/CA;AAAA;AACA;AAAA;AAOA;AAAA;AAAA;AAAA;AA5IA;AAAA;;;AAmLA;;AA/KA;AAGA;AACA;;;;AAUA;AAAA;AACA;AAGA;;;;;AAHA;;AAGA;AAAA;;;;;;;;;;;;;AAEA;AAAA;AAAA;;;AAEA;;;AAGA;AA7BA;AAAA;;;;;;;;AAmLA;;;AA9KA;AAAA;;;;;;;;AAEA;AAAA;;;;;;;;AAGA;AAAA;AACA;;;;;;AAEA;AAAA;AACA;;;AAEA;AEwNA;AAAA;AAGA;;;AAEA;;;;;;;;;;;;;;;;;;;AAEA;AAAA;;;;;;;AACA;AAAA;;;;;;;AACA;AAAA;;;;;;;AACA;AAAA;AACA;AAAA;;;;;;;;;;;;AFjOA;AAAA;;;AACA;AAAA;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAEA;AAAA;AAAA;;;AAEA;;;AAGA;AA7BA;AAAA;;;;;;;;AAmLA;;AAPA;AAAA;AAAA;AAAA;AA1FA;;;AAiGA;;AEqDA;AAAA;AAGA;AAEA;;;AF3JA;;;;;;;;;;;;;;;;;;;;;AE6JA;AAAA;;;;;;;AACA;AAAA;;;;;;;AACA;AAAA;;;;;;;AACA;AAAA;AACA;AAAA;;;;;;;;;;;;AF/JA;AAFA;;;;;;;;AAiGA;;;AAAA;;;;;;;;;;;;AAGA;AAMA;;AACA;;;AAGA;;;;AACA;AAAA;AAAA;AADA;AAAA;;;;;;;;;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AG5MA;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAMA;;AAAA;AAAA;;;AAMA;AAAA;AAGA;AAAA;AAFA;AAAA;AADA;AACA;AAIA;AAAA;AAAA;AAAA;;AAQA;AACA;AACA;;;;AAWA;AACA;AACA;;;;AAKA;AAAA;AAAA;AAAA;;;;;AAOA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkDA;;;;;AAIA;AAAA;;;AA6BA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;;;;;;AAzBA;AACA;AACA;AACA;;;;;;AATA;AACA;AACA;AACA;;;;;;AARA;AACA;AACA;;;;;;AAPA;AACA;AACA;;;;;;AAoBA;AACA;AACA;;;;;;AAoBA;;;;;;;AAjJA;;;;AAqJA;;;;;;;;;;;;;;;;;;;;;;AAcA;;;;AAGA;AACA;AADA;AAEA;AAFA;AAGA;AAHA;;;;;;;;;;;;;;AAmBA;;;;;;;;;AAKA;;;;;;;;;AAhBA;;;;AAGA;AACA;AADA;AAEA;AAFA;AAGA;AAHA;;;;;;;;;;AA0GA;;;;;;;;;;;;;;;;;;;;;;;;;AA1FA;AACA;AADA;AAEA;AAFA;AAGA;AAHA;;;;AAMA;AAAA;AAEA;AAFA;AAAA;;;;AAMA;AACA;AADA;AAEA;AAFA;AAGA;AAHA;;;;AAMA;AACA;AADA;AAEA;AAFA;AAGA;AAHA;;;;AAMA;AAAA;AAEA;AAFA;AAAA;;;;AAMA;AAAA;AAEA;AAFA;AAAA;;;;AASA;AAHA;;;;AAMA;AACA;AADA;AAEA;AAFA;AAGA;AAHA;;;;AAMA;;;;AAMA;AAAA;AAEA;AAFA;AAAA;;;;AAOA;AADA;AAAA;AAAA;;;;AAMA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AA2BA;AACA;AADA;AAEA;AAFA;AAGA;AAHA;;;;AAMA;AACA;AADA;AAEA;AAFA;AAAA;;;;AAMA;AAAA;AAEA;AAFA;AAAA;;;;AAMA;AAAA;AAEA;AAFA;AAAA;;;;AASA;AAHA;;;;AASA;AAHA;;;;AAMA;;;;AAMA;;;;AAMA;AACA;AADA;AAEA;AAFA;AAGA;AAHA;;;;;;;;;;;;;;;;;;AAQA;;;;;;;;AAKA;AAKA;AAAA;;;;;AACA;AAAA;;;;;AADA;AAAA;AAAA;;;;;;;AAEA;AAAA;AAAA;AAAA;;AAuBA;;;AAjBA;AACA;;AACA;;AAeA;;AAZA;AAAA;;AACA;AACA;AAAA;;AAUA;;AANA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AAMA;;;AAJA;AAAA;AAAA;AACA;;AAGA;;;;;;;;;;;;;;;;;;AASA;AAAA;;;AAwDA;;AAlDA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;AACA;AAAA;;;;AACA;AADA;AAAA;AAAA;;;;;;;;AACA;;;;;AACA;AAAA;;;;AACA;AADA;AAAA;AAAA;;;;;;;;AACA;;;AAGA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;AACA;AAAA;;;;AACA;AADA;AAAA;AAAA;;;;;;;;AACA;;;;;AACA;AAAA;;;;AACA;AADA;AAAA;AAAA;;;;;;;;AACA;;;AAGA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;AACA;AAAA;;;;AACA;AADA;AAAA;AAAA;;;;;;;;AACA;;;;;AACA;AAAA;;;;AACA;AADA;AAAA;AAAA;;;;;;;;AACA;;;AAGA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;AACA;AAAA;;;;AACA;AADA;AAAA;AAAA;;;;;;;;AACA;;;;;AACA;AAAA;;;;AACA;AADA;AAAA;AAAA;;;;;;;;AACA;;;AAGA;AAAA;AACA;AAAA;AACA;AAAA;;AAGA;;;;;;;;AAGA;AAIA;;AACA;AAAA;AAuBA;;AApBA;AAAA;AAAA;AAAA;AAAA;;AAoBA;;AAfA;AAAA;;;AACA;AAAA;AAAA;;AACA;;;;AACA;AAAA;AAAA;;;;AACA;;;;;;;;AACA;AAAA;AAAA;;;;AAMA;AAAA;AAAA;;AAmGA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;;;AApGA;AACA;;;;;;;AAyFA;AAEA;;AACA;AAAA;AAQA;;AALA;AAAA;AAAA;AAAA;AAAA;;AAKA;;AAFA;AAAA;AAAA;AACA;AACA;;;;;;;AAjGA;AAKA;;AACA;AAAA;;AAsBA;;AAlBA;AACA;;AACA;;AAgBA;;AAZA;AAAA;AADA;AAAA;AAEA;;AACA;;AAUA;;AAPA;AACA;AAAA;AACA;AAAA;AAEA;;AAGA;;;;;;;;;;;AAGA;AAAA;AAEA;;AACA;;AAsBA;;AAnBA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAkBA;;;AAfA;AAAA;AAAA;;;AAeA;;AAXA;;AA+CA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;;;AA/CA;;;AAOA;;AAJA;AAAA;AAAA;AAAA;;AAIA;;;;;;AAgFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAKA;AAAA;;;AAHA;AAAA;;;;;AAQA;AAAA;AACA;;;;;;;;;;;;AAsCA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;;AA5BA;AAAA;;;AACA;AAAA;AAAA;AACA;AACA;;;AAFA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AACA;;;;;;;;;;AARA;AAAA;;;;;;;;;;;;AA0BA;;AAEA;;;;;;;;;;;;;;AAOA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;;AA3CA;AAAA;;;AACA;AAAA;AAAA;AACA;AACA;AACA;;;AAHA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AACA;;;;;;;;;;AARA;AAAA;;;;;;;;;;;;AAyCA;;AAEA;;;;;;;;;;;;;AAMA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;;AARA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;;AAHA;AAAA;AAAA;AAGA;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;;AATA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;;AAHA;AAAA;AAAA;AAAA;AAGA;;;;;;AAqFA;AACA;;AACA;;AAUA;;AAPA;AACA;;AAMA;;;;;;;;AAKA;;AAcA;;AAXA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;;;AAGA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AAUA;AAAA;AACA;AAAA;AAAA;;AACA;;AA1BA;;AAGA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;;;AAGA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;;AAkBA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAEA;AAAA;AACA;AADA;;;AA6DA;;AAxDA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AA1GA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;AAqGA;AAAA;;AAoDA;;AApJA;AAAA;;AAgGA;AAAA;;;;AA/FA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAFA;AADA;AADA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AALA;AAAA;AAAA;;;;;;;AAgGA;AAAA;;;;;;;;;;;AAQA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AArFA;;;AAzNA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAdA;AAAA;;;;;;;AA+NA;AAAA;AACA;AAoFA;AAAA;AACA;AAAA;AACA;AADA;;;AAyCA;;AApCA;;;;;;AAGA;;AACA;;;;;;;;AAKA;;;;AAAA;AAEA;;;;;;AAQA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;;;;AACA;AAAA;;;AAEA;AAAA;AAGA;AAAA;AAAA;;;;AACA;AAAA;;;AAEA;AAAA;AAIA;;AACA;;;;;;AAKA;;AAIA;;AA1GA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;;;AAGA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AA8FA;AAEA;;;;;;;;;;;AA1MA;;AACA;AAAA;AAAA;;;AAEA;;AAGA;AAAA;AAAA;AAAA;AACA;AAFA;AAEA;;;;;AACA;;AAiBA;;;AAbA;;AAEA;AAAA;AACA;;AACA;;AASA;;AANA;AAAA;;;AAMA;;AAJA;AAzHA;;;AAyHA;AA1HA;AAAA;;;AA2HA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAzHA;AAAA;AACA;AACA;AACA;;;AAHA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AACA;;;;;;;;;;AARA;AAAA;;;;;;;;;;;;AAyHA;AAAA;AADA;AAAA;AAAA;;;;;;;;AAMA;;;;;;;;;ACh3BA;AAAA;AAIA;;AACA;AAAA;;AAuCA;;AAnCA;;AACA;AAAA;;AAkCA;;AHYA;AAAA;AAAA;;;AGZA;;AHYA;AAAA;AAAA;;;AGZA;;AHYA;AAAA;AAAA;;;AGZA;;AHYA;AAAA;AAAA;;;AGZA;;AAxBA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAEA;;;AAgBA;;AAZA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AAAA;AAEA;AAGA;;AACA;;;;;;;;;;;AAGA;AAAA;AAAA;AAIA;;AACA;AAAA;;AA8CA;;AA1CA;;AACA;AAAA;;AAyCA;;AArCA;;AACA;AAAA;;AAoCA;;AH1CA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AGkBA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AAGA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AHvCA;AAAA;AAAA;AGyCA;AAAA;;AACA;;;;;AA9BA;AAAA;AACA;AAAA;;AA6BA;;;;;;;;;;;;;;;AAkEA;AAAA;AASA;;AACA;AAAA;;AAyFA;;AArFA;;AACA;AAAA;;AAoFA;;AAhFA;;AAgDA;;;AAgCA;;AA3BA;AACA;AAAA;AAEA;;;;AACA;AAAA;AACA;AAAA;AAEA;AAEA;AAAA;AAFA;AAAA;AAKA;AAEA;AAAA;AAFA;AAAA;AATA;AAAA;;;;;;;;;;;;;AAtDA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AHpIA;AAAA;AGuIA;;;AAwEA;;AA1DA;;;;AATA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AADA;AACA;AADA;;;;;;AAJA;AAAA;;;;;;;;;;AAoEA;;;;;;AAnEA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AADA;AACA;AADA;;;;AAIA;;;;AAYA;AAEA;AAAA;AAFA;AAAA;AAKA;;;;AAEA;AAAA;;;;;AA3BA;AAAA;;;;;;;;AA+BA;;;AAqCA;;;;;;;AAPA;;;AAOA;;;;;AANA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAGA;;;;;;;;;;;;;;;;;;;;AA0BA;AAAA;AAAA;AAAA;AAAA;AAaA;;AACA;AAAA;;AAiIA;;AA7HA;;AACA;AAAA;;AA4HA;;AAxHA;;AACA;AAAA;;AAuHA;;AAnHA;;AACA;AAAA;;AAkHA;;AA9GA;;AACA;AAAA;;AA6GA;;AHxXA;AAAA;AAAA;;;AGwXA;;AHxXA;AAAA;AAAA;;;AGwXA;;AApGA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;;;AA0FA;;AApFA;AAAA;AAAA;AACA;AADA;AACA;AADA;;;AAoFA;;AA/EA;;;AAGA;;;AAEA;;;;AAGA;;AAuEA;;;;AAAA;;AArEA;;AAqEA;;AAhEA;;;AAGA;;;AAEA;;;;AAGA;;AAwDA;;;;AAAA;;AAtDA;;AAsDA;;AA3JA;AAAA;AAFA;;AAMA;;;AACA;AAAA;AACA;AADA;;;AALA;AAAA;AAFA;;AAMA;;;AACA;AAAA;AACA;AADA;;;AAwGA;AAAA;;;;;AAxGA;;;AAwGA;AAkCA;AAHA;AAHA;AAHA;;;;;AAxBA;AAAA;;;;;;AAKA;AAAA;;;AAGA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;AATA;AAAA;AAAA;AAAA;AAAA;;;;AAvHA;AAEA;AAAA;AAFA;AAKA;;AACA;;;AACA;AACA;AADA;;;AAwGA;AAAA;;;;;;;;;AA8CA;;AAtJA;;;AAyGA;AAAA;;;;;AAsBA;AAAA;;;AAGA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;AATA;AAAA;AAAA;AAAA;AAAA;;;;AAxIA;AAEA;AAAA;AAFA;AAKA;;AACA;;;AACA;AACA;AADA;;;AAwGA;AAAA;;;;;;;;AA8CA;;;AALA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAOA;;AACA;AAAA;;AAoDA;;AAhDA;;AACA;AAAA;;AA+CA;;AA3CA;;AACA;AAAA;;AA0CA;;AAtCA;;AACA;AAAA;;AAqCA;;AAjCA;;AACA;AAAA;;AAgCA;;;;;AAvBA;AAAA;AACA;AAAA;AAAA;AAGA;AAEA;AAAA;AAFA;AAKA;AAEA;AAAA;AAFA;AAVA;AAAA;;;;;;;;AAgBA;;;AAQA;;AAPA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7EA;AAAA;AAIA;AAAA;AAAA;;AACA;AAAA;;;AAkGA;;;AA5FA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAEA;;;;;;;;;;;AAsBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;AASA;AAAA;AAAA;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AA6BA;;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;;;;;;;;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;;;;;;;;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AA1JA;AAAA;AA+CA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA+EA;AAAA;AA/EA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA+EA;AAAA;AA/EA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA+EA;AAAA;AA/EA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA+EA;AAAA;AA/EA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA+EA;AAAA;AA/EA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AA+EA;AAAA;AAAA;;;;;AA/EA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA+EA;AAAA;AA/EA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AA+EA;AAAA;AAAA;;;;;AA/EA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA+EA;AAAA;AA/EA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;AAkHA;AAAA;AAAA;;;AAIA;;AAHA;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6KA;AAAA;AAEA;AAAA;AAGA;AAAA;AAAA;;AACA;AAAA;;;AA6IA;;;AAxIA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AACA;;;;;;AAEA;;;;AAgCA;;;;;AAKA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;;AADA;AAIA;;;;;;;AAFA;AAAA;AAAA;AACA;;;AAGA;;;;;;;;AACA;AAAA;;;;;;;;;;;;;AAvCA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;;AADA;AAIA;;;;;;;AAFA;AAAA;AAAA;AACA;;;AAGA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;AAMA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;;;;;;;;AACA;AAAA;;;;;;;;;;;;;AAuBA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AA+DA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAPA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAGA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAFA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAhOA;AA0EA;AAAA;AAAA;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAqFA;AAAA;AArFA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AANA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAwFA;AAAA;AAxFA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;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;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;AAeA;AAAA;AAAA;AAAA;;AAFA;AAAA;;;AAGA;AD30CA;AC40CA;AAFA;AAAA;AAAA;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;AAeA;AAAA;AAAA;AAAA;;AAFA;AAAA;;;AAGA;AAAA;AAAA;AACA;AAFA;AAAA;AAAA;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;AAeA;AAAA;AAAA;AAAA;;AAFA;AAAA;;;AAGA;AAAA;AAAA;ADj0CA;AAxDA;AC03CA;AAFA;AAAA;AAAA;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;AAaA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AACA;AAFA;AAAA;AAAA;AAAA;;;;;;;AAKA;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;AAaA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AACA;AAFA;AAAA;AAAA;AAAA;;;;;;;AAKA;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;AAaA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;AACA;ADh8CA;ACg8CA;AAAA;AAAA;AACA;AAFA;AAAA;AAAA;AAAA;;;;;;;;AAKA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;AAaA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;AACA;ADx9CA;ACw9CA;AAAA;AACA;AAFA;AAAA;AAAA;AAAA;;;;;;;;AAKA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;AAaA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;AACA;ADh/CA;ACg/CA;ADxhDA;AAAA;AAAA;AAAA;AAAA;ACyhDA;AAFA;AAAA;AAAA;AAAA;;;;;;;;AAKA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;AAaA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;AACA;ADxgDA;ACwgDA;ADhjDA;AAAA;AAAA;AAAA;ACijDA;AAFA;AAAA;AAAA;AAAA;;;;;;;;AAKA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;AAeA;AAAA;AAAA;AAAA;;AAFA;AAAA;;;AAGA;ADhiDA;ACiiDA;AAFA;AAAA;AAAA;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;AAeA;AAAA;AAAA;AAAA;;AAFA;AAAA;;;AAGA;ADvjDA;ACujDA;AAAA;AACA;AAFA;AAAA;AAAA;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;AAeA;AAAA;AAAA;AAAA;;AAFA;AAAA;;;AAGA;AD9kDA;AC8kDA;AAAA;ADthDA;AAxDA;AC+kDA;AAFA;AAAA;AAAA;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;AAaA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AACA;AAFA;AAAA;AAAA;AAAA;;;;;;;AAKA;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;AAaA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AACA;AAFA;AAAA;AAAA;AAAA;;;;;;;AAKA;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;AAaA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AACA;AAFA;AAAA;AAAA;AAAA;;;;;;;;AAKA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;AAaA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAFA;AAAA;AAAA;AAAA;;;;;;;;AAKA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;AAaA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AD7uDA;AAAA;AAAA;AAAA;AAAA;AC8uDA;AAFA;AAAA;AAAA;AAAA;;;;;;;;AAKA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;AAaA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;ADrwDA;AAAA;AAAA;AAAA;AAAA;ACswDA;AAFA;AAAA;AAAA;AAAA;;;;;;;;AAKA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;AAeA;AAAA;AAAA;AAAA;;AAFA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AACA;AAFA;AAAA;AAAA;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;AAeA;AAAA;AAAA;AAAA;;AAFA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AD5wDA;AC6wDA;AAFA;AAAA;AAAA;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;AAeA;AAAA;AAAA;AAAA;;AAFA;AAAA;;;AAGA;ADnyDA;ACoyDA;AAFA;AAAA;AAAA;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;AAaA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;;;AACA;AD1zDA;AA0DA;ACgwDA;AAAA;AAAA;AACA;AAFA;AAAA;AAAA;AAAA;;;;;;;AAKA;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;AAaA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;;;AACA;ADl1DA;AA0DA;ACwxDA;AAAA;AACA;AAFA;AAAA;AAAA;AAAA;;;;;;;AAKA;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;AAaA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;AACA;AD12DA;AA0DA;ACgzDA;AAAA;AAAA;AACA;AAFA;AAAA;AAAA;AAAA;;;;;;;;AAKA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;AAaA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;AACA;ADl4DA;AA0DA;ACw0DA;AAAA;AACA;AAFA;AAAA;AAAA;AAAA;;;;;;;;AAKA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;AAaA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;AACA;AD15DA;AA0DA;ACg2DA;AAAA;AAAA;ADl8DA;AAAA;AAAA;AAAA;AAAA;ACm8DA;AAFA;AAAA;AAAA;AAAA;;;;;;;;AAKA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;AAaA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;AACA;ADl7DA;AA0DA;ACw3DA;AAAA;AD19DA;AAAA;AAAA;AAAA;AAAA;AC29DA;AAFA;AAAA;AAAA;AAAA;;;;;;;;AAKA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;AAeA;AAAA;AAAA;AAAA;;AAFA;AAAA;;;AAGA;AD18DA;AA0DA;ACg5DA;AAAA;AAAA;AACA;AAFA;AAAA;AAAA;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;AAeA;AAAA;AAAA;AAAA;;AAFA;AAAA;;;AAGA;ADj+DA;AA0DA;ACu6DA;AAAA;AAAA;ADj+DA;ACk+DA;AAFA;AAAA;AAAA;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AA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A;AACA;AACA;AD7oIA;AAAA;AAAA;AC6oIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AD9oIA;AAAA;AAAA;AC8oIA;AAAA;AAAA;AAAA;AAAA;AAGA;AAXA;;;;;;;;AAcA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;;;;AAjEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AD7lIA;AAAA;AAAA;AAAA;AC8lIA;AD9lIA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACimIA;;;;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;AACA;AACA;AAAA;ADxmIA;AAAA;AAAA;ACwmIA;AAAA;AAAA;AAAA;AAAA;AACA;ADzmIA;AAAA;AAAA;ACymIA;AAAA;AAAA;AAAA;AAAA;AAGA;;;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;;;;;;AA6FA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;ADttIA;ACutIA;AAAA;ADvtIA;ACwtIA;AAAA;ADxtIA;ACytIA;AAAA;ADztIA;AC8tIA;;AD9tIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AC+tIA;AACA;AACA;AAAA;;;;;;;;ADjuIA;AAAA;AAAA;AAAA;AAAA;ACkuIA;ADluIA;AAAA;AAAA;AAAA;AAAA;ACmuIA;AAAA;ADnuIA;AAAA;AAAA;AAAA;AAAA;ACouIA;AAAA;ADpuIA;AAAA;AAAA;AAAA;AAAA;ACquIA;AAAA;AACA;AACA;ADvuIA;AAAA;AAAA;ACuuIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;ADxuIA;AAAA;AAAA;ACwuIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;ADzuIA;AAAA;AAAA;ACyuIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AD1uIA;AAAA;AAAA;AC0uIA;AAAA;AAAA;AAAA;AAAA;AAKA;AAjBA;;;;;;;;AAoBA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;;;;;;AArFA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;ADvqIA;AAAA;AAAA;AAAA;ACwqIA;AAAA;AAAA;ADxqIA;AAAA;AAAA;AAAA;ACyqIA;AAAA;AAAA;ADzqIA;AAAA;AAAA;AAAA;AC0qIA;AD1qIA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AC+qIA;;;;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;AACA;AACA;AAAA;ADxrIA;AAAA;AAAA;ACwrIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;ADzrIA;AAAA;AAAA;ACyrIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AD1rIA;AAAA;AAAA;AC0rIA;AAAA;AAAA;AAAA;AAAA;AACA;AD3rIA;AAAA;AAAA;AC2rIA;AAAA;AAAA;AAAA;AAAA;AAKA;;;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;;;;;;;;AAiHA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AD9zIA;AC+zIA;AAAA;AD/zIA;ACg0IA;AAAA;ADh0IA;ACi0IA;AAAA;ADj0IA;ACk0IA;AAAA;ADl0IA;ACm0IA;AAAA;ADn0IA;AC00IA;;AD10IA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AC20IA;AACA;AACA;AAAA;;;;;;;;AD70IA;AAAA;AAAA;AAAA;AAAA;AC80IA;AD90IA;AAAA;AAAA;AAAA;AAAA;AC+0IA;AAAA;AD/0IA;AAAA;AAAA;AAAA;AAAA;ACg1IA;AAAA;ADh1IA;AAAA;AAAA;AAAA;AAAA;ACi1IA;AAAA;ADj1IA;AAAA;AAAA;AAAA;AAAA;ACk1IA;AAAA;ADl1IA;AAAA;AAAA;AAAA;AAAA;ACm1IA;AAAA;AACA;AACA;ADr1IA;AAAA;AAAA;ACq1IA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;ADt1IA;AAAA;AAAA;ACs1IA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;ADv1IA;AAAA;AAAA;ACu1IA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;ADx1IA;AAAA;AAAA;ACw1IA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;ADz1IA;AAAA;AAAA;ACy1IA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AD11IA;AAAA;AAAA;AC01IA;AAAA;AAAA;AAAA;AAAA;AAOA;AAvBA;;;;;;;;AA0BA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;;;;;;;;AAzGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;ADrwIA;AAAA;AAAA;AAAA;ACswIA;AAAA;AAAA;ADtwIA;AAAA;AAAA;AAAA;ACuwIA;AAAA;AAAA;ADvwIA;AAAA;AAAA;AAAA;ACwwIA;AAAA;AAAA;ADxwIA;AAAA;AAAA;AAAA;ACywIA;AAAA;AAAA;ADzwIA;AAAA;AAAA;AAAA;AC0wIA;AD1wIA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACixIA;;;;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;AACA;AACA;AAAA;AD5xIA;AAAA;AAAA;AC4xIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AD7xIA;AAAA;AAAA;AC6xIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AD9xIA;AAAA;AAAA;AC8xIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AD/xIA;AAAA;AAAA;AC+xIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;ADhyIA;AAAA;AAAA;ACgyIA;AAAA;AAAA;AAAA;AAAA;AACA;ADjyIA;AAAA;AAAA;ACiyIA;AAAA;AAAA;AAAA;AAAA;AAOA;;;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;;;;;;;;;;AAqIA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AD17IA;AC27IA;AAAA;AD37IA;AC47IA;AAAA;AD57IA;AC67IA;AAAA;AD77IA;AC87IA;AAAA;AD97IA;AC+7IA;AAAA;AD/7IA;ACg8IA;AAAA;ADh8IA;ACi8IA;AAAA;ADj8IA;AC08IA;;AD18IA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AC28IA;AACA;AACA;AAAA;;;;;;;;AD78IA;AAAA;AAAA;AAAA;AAAA;AC88IA;AD98IA;AAAA;AAAA;AAAA;AAAA;AC+8IA;AAAA;AD/8IA;AAAA;AAAA;AAAA;AAAA;ACg9IA;AAAA;ADh9IA;AAAA;AAAA;AAAA;AAAA;ACi9IA;AAAA;ADj9IA;AAAA;AAAA;AAAA;AAAA;ACk9IA;AAAA;ADl9IA;AAAA;AAAA;AAAA;AAAA;ACm9IA;AAAA;ADn9IA;AAAA;AAAA;AAAA;AAAA;ACo9IA;AAAA;ADp9IA;AAAA;AAAA;AAAA;AAAA;ACq9IA;AAAA;AACA;AACA;ADv9IA;AAAA;AAAA;ACu9IA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;ADx9IA;AAAA;AAAA;ACw9IA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;ADz9IA;AAAA;AAAA;ACy9IA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AD19IA;AAAA;AAAA;AC09IA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AD39IA;AAAA;AAAA;AC29IA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AD59IA;AAAA;AAAA;AC49IA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AD79IA;AAAA;AAAA;AC69IA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AD99IA;AAAA;AAAA;AC89IA;AAAA;AAAA;AAAA;AAAA;AASA;AA7BA;;;;;;;;AAgCA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;;;;;;;;;;;AA7HA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;ADv3IA;AAAA;AAAA;AAAA;ACw3IA;AAAA;AAAA;ADx3IA;AAAA;AAAA;AAAA;ACy3IA;AAAA;AAAA;ADz3IA;AAAA;AAAA;AAAA;AC03IA;AAAA;AAAA;AD13IA;AAAA;AAAA;AAAA;AC23IA;AAAA;AAAA;AD33IA;AAAA;AAAA;AAAA;AC43IA;AAAA;AAAA;AD53IA;AAAA;AAAA;AAAA;AC63IA;AAAA;AAAA;AD73IA;AAAA;AAAA;AAAA;AC83IA;AD93IA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACu4IA;;;;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;AACA;AACA;AAAA;ADp5IA;AAAA;AAAA;ACo5IA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;ADr5IA;AAAA;AAAA;ACq5IA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;ADt5IA;AAAA;AAAA;ACs5IA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;ADv5IA;AAAA;AAAA;ACu5IA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;ADx5IA;AAAA;AAAA;ACw5IA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;ADz5IA;AAAA;AAAA;ACy5IA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AD15IA;AAAA;AAAA;AC05IA;AAAA;AAAA;AAAA;AAAA;AACA;AD35IA;AAAA;AAAA;AC25IA;AAAA;AAAA;AAAA;AAAA;AASA;;;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;;AA4GA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AD7hJA;AC+hJA;;AD/hJA;AAAA;AAAA;;;;;ACgiJA;AACA;AACA;AAAA;;;;;;;;ADliJA;AAAA;AAAA;AAAA;AAAA;ACmiJA;AACA;AACA;ADriJA;AAAA;AAAA;AAAA;ACqiJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AARA;;;;;;;;AAWA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;;;AAvDA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AD7/IA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AC+/IA;;;;AACA;AACA;AACA;AACA;AAAA;;;;;;;;AACA;AACA;ADrgJA;AAAA;AAAA;AAAA;ACqgJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;;;;AA8EA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;ADlmJA;ACmmJA;AAAA;ADnmJA;ACsmJA;;ADtmJA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;ACumJA;AACA;AACA;AAAA;;;;;;;;ADzmJA;AAAA;AAAA;AAAA;AAAA;AC0mJA;AD1mJA;AAAA;AAAA;AAAA;AAAA;AC2mJA;AAAA;AACA;AACA;AD7mJA;AAAA;AAAA;AAAA;AC6mJA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AD9mJA;AAAA;AAAA;AAAA;AC8mJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAXA;;;;;;;;AAcA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;;;;AAjEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AD7jJA;AAAA;AAAA;AAAA;AC8jJA;AD9jJA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACikJA;;;;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;AACA;AACA;AAAA;ADxkJA;AAAA;AAAA;AAAA;ACwkJA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;ADzkJA;AAAA;AAAA;AAAA;ACykJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;;;;;;AA6FA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;ADtrJA;ACurJA;AAAA;ADvrJA;ACwrJA;AAAA;ADxrJA;ACyrJA;AAAA;ADzrJA;AC8rJA;;AD9rJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AC+rJA;AACA;AACA;AAAA;;;;;;;;ADjsJA;AAAA;AAAA;AAAA;AAAA;ACksJA;ADlsJA;AAAA;AAAA;AAAA;AAAA;ACmsJA;AAAA;ADnsJA;AAAA;AAAA;AAAA;AAAA;ACosJA;AAAA;ADpsJA;AAAA;AAAA;AAAA;AAAA;ACqsJA;AAAA;AACA;AACA;ADvsJA;AAAA;AAAA;AAAA;ACusJA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;ADxsJA;AAAA;AAAA;AAAA;ACwsJA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;ADzsJA;AAAA;AAAA;AAAA;ACysJA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AD1sJA;AAAA;AAAA;AAAA;AC0sJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAjBA;;;;;;;;AAoBA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;;;;;;AArFA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;ADvoJA;AAAA;AAAA;AAAA;ACwoJA;AAAA;AAAA;ADxoJA;AAAA;AAAA;AAAA;ACyoJA;AAAA;AAAA;ADzoJA;AAAA;AAAA;AAAA;AC0oJA;AD1oJA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AC+oJA;;;;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;AACA;AACA;AAAA;ADxpJA;AAAA;AAAA;AAAA;ACwpJA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;ADzpJA;AAAA;AAAA;AAAA;ACypJA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AD1pJA;AAAA;AAAA;AAAA;AC0pJA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AD3pJA;AAAA;AAAA;AAAA;AC2pJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;;;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;;;;;;;;;AAiHA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AD9xJA;AC+xJA;AAAA;AD/xJA;ACgyJA;AAAA;ADhyJA;ACiyJA;AAAA;ADjyJA;ACkyJA;AAAA;ADlyJA;ACmyJA;AAAA;ADnyJA;AC0yJA;;AD1yJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AC2yJA;AACA;AACA;AAAA;;;;;;;;AD7yJA;AAAA;AAAA;AAAA;AAAA;AC8yJA;AD9yJA;AAAA;AAAA;AAAA;AAAA;AC+yJA;AAAA;AD/yJA;AAAA;AAAA;AAAA;AAAA;ACgzJA;AAAA;ADhzJA;AAAA;AAAA;AAAA;AAAA;ACizJA;AAAA;ADjzJA;AAAA;AAAA;AAAA;AAAA;ACkzJA;AAAA;ADlzJA;AAAA;AAAA;AAAA;AAAA;ACmzJA;AAAA;AACA;AACA;ADrzJA;AAAA;AAAA;AAAA;ACqzJA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;ADtzJA;AAAA;AAAA;AAAA;ACszJA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;ADvzJA;AAAA;AAAA;AAAA;ACuzJA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;ADxzJA;AAAA;AAAA;AAAA;ACwzJA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;ADzzJA;AAAA;AAAA;AAAA;ACyzJA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AD1zJA;AAAA;AAAA;AAAA;AC0zJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAvBA;;;;;;;;AA0BA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;;;;;;;;;AAzGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;ADruJA;AAAA;AAAA;AAAA;ACsuJA;AAAA;AAAA;ADtuJA;AAAA;AAAA;AAAA;ACuuJA;AAAA;AAAA;ADvuJA;AAAA;AAAA;AAAA;ACwuJA;AAAA;AAAA;ADxuJA;AAAA;AAAA;AAAA;ACyuJA;AAAA;AAAA;ADzuJA;AAAA;AAAA;AAAA;AC0uJA;AD1uJA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACivJA;;;;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;AACA;AACA;AAAA;AD5vJA;AAAA;AAAA;AAAA;AC4vJA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AD7vJA;AAAA;AAAA;AAAA;AC6vJA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AD9vJA;AAAA;AAAA;AAAA;AC8vJA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AD/vJA;AAAA;AAAA;AAAA;AC+vJA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;ADhwJA;AAAA;AAAA;AAAA;ACgwJA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;ADjwJA;AAAA;AAAA;AAAA;ACiwJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;;;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;;;;;;;;;;;AAqIA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AD15JA;AC25JA;AAAA;AD35JA;AC45JA;AAAA;AD55JA;AC65JA;AAAA;AD75JA;AC85JA;AAAA;AD95JA;AC+5JA;AAAA;AD/5JA;ACg6JA;AAAA;ADh6JA;ACi6JA;AAAA;ADj6JA;AC06JA;;AD16JA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AC26JA;AACA;AACA;AAAA;;;;;;;;AD76JA;AAAA;AAAA;AAAA;AAAA;AC86JA;AD96JA;AAAA;AAAA;AAAA;AAAA;AC+6JA;AAAA;AD/6JA;AAAA;AAAA;AAAA;AAAA;ACg7JA;AAAA;ADh7JA;AAAA;AAAA;AAAA;AAAA;ACi7JA;AAAA;ADj7JA;AAAA;AAAA;AAAA;AAAA;ACk7JA;AAAA;ADl7JA;AAAA;AAAA;AAAA;AAAA;ACm7JA;AAAA;ADn7JA;AAAA;AAAA;AAAA;AAAA;ACo7JA;AAAA;ADp7JA;AAAA;AAAA;AAAA;AAAA;ACq7JA;AAAA;AACA;AACA;ADv7JA;AAAA;AAAA;AAAA;ACu7JA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;ADx7JA;AAAA;AAAA;AAAA;ACw7JA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;ADz7JA;AAAA;AAAA;AAAA;ACy7JA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AD17JA;AAAA;AAAA;AAAA;AC07JA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AD37JA;AAAA;AAAA;AAAA;AC27JA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AD57JA;AAAA;AAAA;AAAA;AC47JA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AD77JA;AAAA;AAAA;AAAA;AC67JA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AD97JA;AAAA;AAAA;AAAA;AC87JA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AA7BA;;;;;;;;AAgCA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;;;;;;;;;;;;AA7HA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;ADv1JA;AAAA;AAAA;AAAA;ACw1JA;AAAA;AAAA;ADx1JA;AAAA;AAAA;AAAA;ACy1JA;AAAA;AAAA;ADz1JA;AAAA;AAAA;AAAA;AC01JA;AAAA;AAAA;AD11JA;AAAA;AAAA;AAAA;AC21JA;AAAA;AAAA;AD31JA;AAAA;AAAA;AAAA;AC41JA;AAAA;AAAA;AD51JA;AAAA;AAAA;AAAA;AC61JA;AAAA;AAAA;AD71JA;AAAA;AAAA;AAAA;AC81JA;AD91JA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA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A;ADtsLA;ACusLA;AAAA;ADvsLA;ACwsLA;AAAA;ADxsLA;ACysLA;AAAA;ADzsLA;AC0sLA;AAAA;AD1sLA;AC2sLA;AAAA;AACA;AACA;AD7sLA;AC6sLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AD9sLA;AC8sLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AD/sLA;AC+sLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;ADhtLA;ACgtLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;ADjtLA;ACitLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;ADltLA;ACktLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAvBA;;;;;;;;AA0BA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;;;;;;;AAzGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AD7nLA;AC8nLA;AAAA;AAAA;AD9nLA;AC+nLA;AAAA;AAAA;AD/nLA;ACgoLA;AAAA;AAAA;ADhoLA;ACioLA;AAAA;AAAA;ADjoLA;ACkoLA;ADloLA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACyoLA;;;;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;AACA;AACA;AAAA;ADppLA;ACopLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;ADrpLA;ACqpLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;ADtpLA;ACspLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;ADvpLA;ACupLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;ADxpLA;ACwpLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;ADzpLA;ACyp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AA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;;;;;;;;;;AArGA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;ADpsVA;ACqsVA;AAAA;AAAA;ADrsVA;ACssVA;AAAA;AAAA;ADtsVA;ACusVA;AAAA;AAAA;ADvsVA;ACwsVA;AAAA;AAAA;ADxsVA;ACysVA;ADzsVA;AC0sVA;;;AATA;ADjsVA;ACysVA;ADzsVA;ACysVA;ADzsVA;ACwsVA;ADxsVA;ACwsVA;ADxsVA;ACusVA;ADvsVA;ACusVA;ADvsVA;ACssVA;ADtsVA;ACssVA;ADtsVA;ACqsVA;ADrsVA;ACqsVA;ADrsVA;ACosVA;ADpsVA;ACosVA;;;AAOA;AAAA;AD3sVA;AAAA;AAAA;AAAA;AAAA;AC2sVA;AACA;AAAA;AD5sVA;AAAA;AAAA;AAAA;AAAA;AC4sVA;AACA;AAAA;AD7sVA;AAAA;AAAA;AAAA;AAAA;AC6sVA;AACA;AAAA;AD9sVA;AAAA;AAAA;AAAA;AAAA;AC8sVA;AACA;AAAA;AD/sVA;AAAA;AAAA;AAAA;AAAA;AC+sVA;AD/sVA;AAAA;AAAA;AAAA;AAAA;ACgtVA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAC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AD76VA;AC46VA;AD56VA;AC46VA;AD56VA;AC26VA;AD36VA;AC26VA;AD36VA;AC06VA;AD16VA;AC06VA;AD16VA;ACy6VA;ADz6VA;ACy6VA;ADz6VA;ACw6VA;ADx6VA;ACw6VA;ADx6VA;ACu6VA;ADv6VA;ACu6VA;ADv6VA;ACs6VA;ADt6VA;ACs6VA;;;AASA;AAAA;AD/6VA;AAAA;AAAA;AAAA;AAAA;AC+6VA;AACA;AAAA;ADh7VA;AAAA;AAAA;AAAA;AAAA;ACg7VA;AACA;AAAA;ADj7VA;AAAA;AAAA;AAAA;AAAA;ACi7VA;AACA;AAAA;ADl7VA;AAAA;AAAA;AAAA;AAAA;ACk7VA;AACA;AAAA;ADn7VA;AAAA;AAAA;AAAA;AAAA;ACm7VA;AACA;AAAA;ADp7VA;AAAA;AAAA;AAAA;AAAA;ACo7VA;AACA;AAAA;ADr7VA;AAAA;AAAA;AAAA;AAAA;ACq7VA;ADr7VA;AAAA;AAAA;AAAA;AAAA;ACs7VA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;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3HA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;ADlwXA;ACmwXA;AAAA;AAAA;ADnwXA;ACowXA;AAAA;AAAA;ADpwXA;ACqwXA;AAAA;AAAA;ADrwXA;ACswXA;AAAA;AAAA;ADtwXA;ACuwXA;AAAA;AAAA;ADvwXA;ACwwXA;AAAA;AAAA;ADxwXA;ACywXA;ADzwXA;AC0wXA;;;AAXA;AD/vXA;AAAA;AAAA;ACywXA;AAAA;ADzwXA;AAAA;AAAA;ACwwXA;AAAA;ADxwXA;AAAA;AAAA;ACuwXA;AAAA;ADvwXA;AAAA;AAAA;ACswXA;AAAA;ADtwXA;AAAA;AAAA;ACqwXA;AAAA;ADrwXA;AAAA;AAAA;ACowXA;AAAA;ADpwXA;AAAA;AAAA;ACmwXA;AAAA;ADnwXA;AAAA;AAAA;ACkwXA;AAAA;;;AASA;AAAA;AD3wXA;AAAA;AAAA;AAAA;AAAA;AC2wXA;AAAA;AACA;AAAA;AD5wXA;AAAA;AAAA;AAAA;AAAA;AC4wXA;AAAA;AACA;AAAA;AD7wXA;AAAA;AAAA;AAAA;AAAA;AC6wXA;AAAA;AACA;AAAA;AD9wXA;AAAA;AAAA;AAAA;AAAA;AC8wXA;AAAA;AACA;AAAA;AD/wXA;AAAA;AAAA;AAAA;AAAA;AC+wXA;AAAA;AACA;AAAA;ADhxXA;AAAA;AAAA;AAAA;AAAA;ACgxXA;AAAA;AACA;AAAA;ADjxXA;AAAA;AAAA;AAAA;AAAA;ACixXA;AAAA;ADjxXA;AAAA;AAAA;AAAA;AAAA;ACkxXA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;A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;;;;;;;;;;;;;;;;;;;AA3HA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAUA;;;AAXA;AAUA;ADz5aA;ACy5aA;AAAA;AADA;AAAA;AAAA;ADx5aA;ACw5aA;AAAA;AADA;AAAA;AAAA;ADv5aA;ACu5aA;AAAA;AADA;AAAA;AAAA;ADt5aA;ACs5aA;AAAA;AADA;AAAA;AAAA;ADr5aA;ACq5aA;AAAA;AADA;AAAA;AAAA;ADp5aA;ACo5aA;AAAA;AADA;AAAA;AAAA;ADn5aA;ACm5aA;AAAA;AADA;AAAA;AAAA;ADl5aA;ACk5aA;AAAA;;;AASA;AAAA;AD35aA;AC25aA;AAAA;AACA;AAAA;AD55aA;AC45aA;AAAA;AACA;AAAA;AD75aA;AC65aA;AAAA;AACA;AAAA;AD95aA;AC85aA;AAAA;AACA;AAAA;AD/5aA;AC+5aA;AAAA;AACA;AAAA;ADh6aA;ACg6aA;AAAA;AACA;AAAA;ADj6aA;ACi6aA;AAAA;ADj6aA;ACk6aA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA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A;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;AAMA;;AAZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAYA;;AAZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;;;;AAAA;;;;AAAA;;;;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;AAYA;;AATA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASA;;AATA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;;;;AAAA;;;;AAAA;;;;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;AASA;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;AAGA;;AAHA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;AAGA;;AAHA;AAAA;;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;AAGA;;AAHA;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;AAMA;;AAZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAYA;;AAZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;AAYA;;AATA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASA;;AATA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;AASA;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;AAGA;;AAHA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;AAGA;;;;;;;;;;;;;;;;;AAHA;AAAA;;;;;;;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAYA;;AAZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;AAYA;;AATA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASA;;AATA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;AASA;;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;AAMA;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;AAGA;;;;;;;;;;;;;;;;;;;;;AAHA;AAAA;;;;;;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAYA;;AAZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;AAYA;;AATA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASA;;AATA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;AASA;;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;AAMA;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;;;AAoBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAgBA;;AAhBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;;AAgBA;;AAbA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAaA;;AAbA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;;AAaA;;AAVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAUA;;AAVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;;AAUA;;AAPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAOA;;AAPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;;AAOA;;;;AA7BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AA6BA;;AA7BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;;AA6BA;;AAhCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAgCA;;AAhCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;;AAgCA;;AA1BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AA0BA;;AA1BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;;AA0BA;;AAvBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAuBA;;AAvBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;;AAuBA;;;AAFA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAkBA;;AAEA;;;AAbA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAaA;;AAbA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;;AAaA;;AAVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAUA;;AAVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;;AAUA;;AAhBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAgBA;;AAhBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAAA;AA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AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AA8BA;;AA9BA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AA8BA;;AA3BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AA2BA;;AA3BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;;;;AA2BA;;;;AAXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAWA;;AAXA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAWA;;AAhBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAgBA;;AAhBA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAgBA;;AArBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAqBA;;AArBA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAqBA;;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA3QA;AAAA;AAGA;AAAA;AACA;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAIA;AACA;AACA;;;AAEA;AAEA;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AA+DA;;AA/DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AA+DA;;AA5DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AA4DA;;AA5DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AA4DA;;AAlEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAkEA;;AAlEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAkEA;;AAzDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAyDA;;AAzDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;;;;AAyDA;;;AAtDA;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAgDA;;AAhDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAgDA;;AA7CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AA6CA;;AA7CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AA6CA;;AAnDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAmDA;;AAnDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAmDA;;AA1CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AA0CA;;AA1CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;;;;AA0CA;;;AAvCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAiCA;;AAjCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAiCA;;AApCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAoCA;;AApCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAoCA;;AA9BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AA8BA;;AA9BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AA8BA;;AA3BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AA2BA;;AA3BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;;;;AA2BA;;;;AArBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAqBA;;AArBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAqBA;;AAhBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAgBA;;AAhBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAgBA;;AAXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAWA;;AAXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAWA;;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;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;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAoCA;;AA9BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AA8BA;;AA9BA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AA8BA;;AA3BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AA2BA;;AA3BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;;;;AA2BA;;;;AArBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAqBA;;AArBA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAqBA;;AAXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAWA;;AAXA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAWA;;AAhBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAgBA;;AAhBA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAgBA;;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuXA;AAA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gBA;;AAhBA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAgBA;;AArBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAqBA;;AArBA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAqBA;;AAXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAWA;;AAXA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAWA;;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA7KA;AAAA;AACA;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAIA;AACA;AACA;;;AAEA;AAEA;;;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AA4DA;;AA5DA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AA4DA;;AAlEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAkEA;;AAlEA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAkEA;;AA/DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AA+DA;;AA/DA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AA+DA;;AAzDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAyDA;;AAzDA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;;;;AAyDA;;;AAtDA;;;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AA6CA;;AA7CA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AA6CA;;AAnDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAmDA;;AAnDA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAmDA;;AAhDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAgDA;;AAhDA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAgDA;;AA1CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AA0CA;;AA1CA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;;;;AA0CA;;;AAvCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAiCA;;AAjCA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAiCA;;AApCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAoCA;;AApCA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAoCA;;AA9BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AA8BA;;AA9BA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AA8BA;;AA3BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AA2BA;;AA3BA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;;;;AA2BA;;;;AArBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAqBA;;AArBA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAqBA;;AAXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAWA;;AAXA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAWA;;AAhBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAgBA;;AAhBA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAgBA;;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAhLA;AAAA;AAGA;AAAA;AACA;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAIA;AACA;AACA;;;AAEA;AAEA;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AA+DA;;AA/DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AA+DA;;AAlEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAkEA;;AAlEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAkEA;;AA5DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AA4DA;;AA5DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AA4DA;;AAzDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAyDA;;AAzDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;;;;AAyDA;;;AAtDA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAmDA;;AAnDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAmDA;;AAhDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAgDA;;AAhDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAgDA;;AA7CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AA6CA;;AA7CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AA6CA;;AA1CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AA0CA;;AA1CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;;;;AA0CA;;;AAvCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAoCA;;AApCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAoCA;;AAjCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAiCA;;AAjCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAiCA;;AA9BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AA8BA;;AA9BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AA8BA;;AA3BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AA2BA;;AA3BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;;;;AA2BA;;;;AArBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAqBA;;AArBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAqBA;;AAhBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAgBA;;AAhBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAgBA;;AAXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAWA;;AAXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAWA;;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A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A;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAmDA;;AAhDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAgDA;;AAhDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAgDA;;AA7CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AA6CA;;AA7CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AA6CA;;AA1CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AA0CA;;AA1CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AA0CA;;;AAvCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAoCA;;AApCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAoCA;;AAjCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAiCA;;AAjCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAiCA;;AA9BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AA8BA;;AA9BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AA8BA;;AA3BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AA2BA;;AA3BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AA2BA;;;;AArBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAqBA;;AArBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAqBA;;AAhBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAgBA;;AAhBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAgBA;;AAXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAWA;;AAXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA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AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAUA;;AAhBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAgBA;;AAPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOA;;;;AAhCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAgCA;;AA1BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA0BA;;AA7BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA6BA;;AAvBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAuBA;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A;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAdA;AAAA;;;;;;;;;;;;;;;AACA;AAAA;;AACA;AAAA;;;;;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA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AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAaA;AACA;AAhBA;;;;;;;;;;AAkBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AACA;AAAA;AAEA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAKA;AAAA;AAAA;AAGA;AAAA;AAAA;AAEA;;AAoBA;;AAlCA;AAAA;AAFA;AAkBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAeA;AACA;AAlBA;;;;;;;;;;AAoBA;;;;;;;;;;;;;;;;;AApdA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AA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AA;AAFA;AAkBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAFA;;;;;;;;;;;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAaA;AACA;AAhBA;;;;;;;;;;AAkBA;;;;;;;;;;;;;;;;;;;;;;AAjNA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;;AAiCA;;AA/BA;AAAA;AAAA;;;AA4BA;AACA;;;;;AA7BA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;AA4BA;AACA;AA/BA;AAAA;;;;;;;AAiCA;;;;;;;;;;;;;;;;;;;;;AA/BA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA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A;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA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A;AAAA;AAAA;;;;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAuBA;AACA;AA1BA;;;;;;;;;;AA4BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2/BA;AAAA;AACA;AAAA;AAEA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAIA;AAAA;AAAA;AAEA;;AAmBA;;AA/BA;AAAA;AAFA;AAgBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAFA;;;;;;;;;;;;;;;;;;;;;AAEA;AAAA;;;AAAA;AAAA;;;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;;;;;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;;;;;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;;;;;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAcA;AACA;AAjBA;;;;;;;;;;AAmBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAxnCA;AAAA;AACA;AAAA;AAEA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAKA;;AA0BA;;AAhCA;AAAA;AAJA;AAAA;AAFA;AAcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAFA;;;;;;;;;;;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAqBA;AACA;AAxBA;;;;;;;;;;AA0BA;;;;;;;;;;;;;AAwVA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;;AAwCA;;AA3CA;AAAA;AAFA;AAOA;AAAA;AAAA;;;AAFA;;;;;;;;;;;;;;;;;;;;AAEA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAmCA;AACA;AAtCA;;;;;;;;;;AAwCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA9dA;AAAA;AACA;AAAA;AAEA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAIA;AAAA;AAAA;AAEA;;AA0BA;;AAjCA;AAAA;AAJA;AAAA;AAFA;AAeA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAFA;;;;;;;;;;;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA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;;;;;;;;;;;;;;;;;;;;AAjmBA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;;;AAgEA;;AA7DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAHA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAyBA;AACA;AA7BA;;;;;;;;;;AAgEA;;;AAAA;;AA7BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAHA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAyBA;AACA;AA7BA;;;;;;;;;;AAgCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuDA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;AAEA;;AAkBA;;AAhBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAaA;AACA;AAhBA;;;;;;;;;;AAkBA;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AACA;AAAA;AAEA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAGA;;AAYA;;AApBA;AAAA;AAFA;AAWA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAJA;AAAA;;;AAAA;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AANA;AAAA;;;;;;;;;;AAQA;AACA;AAVA;;;;;;;AAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyGA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAGA;AAEA;;AAqBA;;AAnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;;;;;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;;;;;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;;;;;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;;;;;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;;;;;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;;;;;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A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AAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AA2BA;AACA;AA/BA;AAAA;;;;;;;AAgFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA7EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AA2BA;AACA;AA/BA;AAAA;;;;;;;;;;AAgFA;;;;;;;;;;;;;;;;;;;;AAqBA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;;;AAgFA;;AA7EA;AAAA;AAAA;;;AAHA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AA2BA;AACA;AA/BA;;;;;;;;;;AAgFA;;;AAAA;;AAzCA;AAAA;AAAA;;;AAHA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAqCA;AACA;AAzCA;;;;;;;;;;AA4CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkvCA;AAAA;AACA;AAAA;AAEA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAIA;;AAeA;;AAtBA;AAAA;AAFA;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAUA;AACA;AAbA;;;;;;;;;;AAeA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;AACA;AAAA;AAEA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAIA;;AAeA;;AAtBA;AAAA;AAFA;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;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AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAeA;AACA;AAlBA;;;;;;;;;;AA0CA;;;AAAA;;AAnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAeA;AACA;AAlBA;;;;;;;;;;AAqBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkFA;AAAA;AACA;AAAA;AAEA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAUA;AAEA;;AAgBA;;AAnBA;AAAA;AADA;AAAA;AAbA;AAAA;AAFA;AAqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA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AKA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAUA;AAAA;AAAA;AACA;AAAA;AAAA;AADA;AACA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;;;;;;;;AAMA;AAAA;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AASA;AAAA;AACA;AAAA;AACA;AAAA;;;AAGA;AAAA;AADA;AAKA;AAFA;;AAGA;AAAA;AACA;AAAA;AACA;AAAA;;;;;;;;AAWA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAGA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;;;AAIA;AAAA;AACA;AAAA;AACA;AAAA;;;;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AA3DA;AADA;AAxBA;;;;;;;;AA4FA;AAAA;AAAA;AAAA;AAtGA;AAAA;AAAA;AAAA;;;;AAqGA;AAlGA;;;AAqGA;;;;;;;AC7CA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AACA;;AAMA;;;;;AAOA;;;;AAPA;AAAA;AACA;;;AAMA;;AANA;AAAA;;;AAMA;;AALA;AACA;AACA;AAAA;AAAA;;AAGA;;;;;;;AAKA;AAAA;AAAA;;AAkBA;;AAjBA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAGA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;;;AAEA;AAAA;;;;AAEA;AAAA;;;AAGA;AACA;AAEA;;;;;;;;;;;;;;;;;;AA2IA;AAKA;AAAA;AAAA;;;AAkGA;;AA3FA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;;;AACA;AAAA;AACA;AAAA;;;AAGA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAGA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAGA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAEA;AAGA;AAAA;AAAA;;;AAIA;AAAA;AAAA;;;AADA;AAAA;AAPA;AAWA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;AACA;AADA;;AAEA;;AAmCA;;AA7BA;;;;;AA6BA;;;AAfA;;;AAXA;AAAA;AAAA;;;;;AAIA;AAAA;AAAA;AAAA;;AACA;AADA;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;AAbA;AAAA;;;;;;;;AAiBA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;;AAKA;AAzBA;;AAAA;AAyBA;;;;;;;;AAIA;;;;;;;;;;;;;;;;AAKA;AAYA;AAAA;AAAA;;;AAiEA;;AA5DA;AAAA;AAAA;;;;AACA;AAKA;;;AADA;AAAA;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AADA;;;AAKA;AAuBA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AADA;;;AAKA;;AACA;;AAaA;;AATA;AAAA;AAAA;AAgBA;;;AACA;;;AAMA;AAIA;AAAA;AAAA;AAAA;;AAHA;;AAfA;;AAkBA;AAAA;;AAEA;;;;;AApBA;;;;AAPA;;;AAOA;;AAmEA;AAAA;;AAjDA;AAAA;AAAA;AAAA;AAHA;AA0DA;AA/EA;AA+EA;AA/EA;AA+EA;AAAA;;AA9EA;;AAKA;;;;;;;;;AAGA;AAAA;AAIA;AAAA;AAAA;;AACA;;AAiBA;;AAXA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;;AAHA;;AAUA;;AAPA;AAAA;;;AAOA;;AALA;;AAKA;;;;;;;AA0CA;AAAA;AAAA;AAIA;AAJA;;AASA;;AA1DA;AAAA;AAAA;AAAA;AAHA;AA0DA;;AAAA;;AAAA;AAAA;AAGA;;;;;;;;AAhDA;AAAA;AAIA;AAAA;AAAA;;AACA;;AAUA;;AAPA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AAKA;;AADA;;AACA;;;;;;;;;AAGA;AAEA;AAAA;AAAA;;AACA;;AAIA;;AADA;AAAA;;AACA;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;AAsBA;AAAA;;;AAsBA;;AAJA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAFA;;AAIA;;;;;;;AAKA;AAAA;AAAA;AAIA;AAJA;;AAOA;;AAFA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;AC9dA;;;AAoCA;AAAA;AAAA;;AA0FA;;AAxFA;AACA;;AAuFA;;AAtFA;AAAA;;;AAAA;AAAA;AAAA;;;;;AAQA;AAVA;AACA;;;;;;;;;AAuFA;;AArFA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAmFA;;AAlFA;AAAA;AA8+BA;AAAA;;AA55BA;;AAlFA;AAAA;AAg/BA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAl6BA;;AApFA;AAAA;AA0gCA;;AAKA;;;;AAHA;;;;;AAcA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;;;AA18BA;;;;AAzHA;AAAA;AAAA;;AAyHA;;AAvHA;AACA;;AAsHA;;AArHA;AAAA;;;AAAA;AAAA;AAAA;;;;;AAkBA;AApBA;AACA;;;;;;;;;AAsHA;;AApHA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;;AAIA;AAAA;AAAA;AAAA;;;;;AAygCA;AAAA;;AA55BA;;AA85BA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAl6BA;;AAxGA;AAAA;AAAA;;AAwGA;;AAvGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA6hCA;;AAKA;;;;AAHA;;;;;AAcA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;;;AA18BA;;;;AAjBA;AACA;;AAgBA;;AAfA;AAAA;;;AAAA;AAAA;AAAA;;;;AAOA;AATA;AACA;;;;;;;;;AAgBA;;AAbA;AACA;AAAA;AACA;AAWA;;;;AAtEA;AAAA;AAAA;;AAsEA;;AApEA;AACA;;AAmEA;;AAlEA;AAAA;;;AAAA;AAAA;AAAA;;;;;AAiCA;AAnCA;AACA;;;;;;;;;AAmEA;;AAjEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AA6+BA;;AAQA;AAWA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;;;;AAngCA;AAAA;;AACA;AAAA;AAAA;AA2+BA;;AAQA;AAWA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;;;;AAjgCA;AAAA;;AACA;AAAA;AAAA;AAy+BA;;AAQA;AAWA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;;;;AA//BA;AAAA;;AACA;AAAA;AAAA;AAu+BA;;AAQA;AAWA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;;;;AA3/BA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAi+BA;;AAKA;AAcA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;;;;AAv/BA;AAAA;;AACA;AAAA;AAAA;AA+9BA;;AAKA;AAcA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;;;;AAr/BA;AAAA;;AACA;AAAA;AAAA;AA69BA;;AAKA;AAcA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;;;;AAn/BA;AAAA;;AACA;AAAA;AAAA;AA29BA;;AAKA;AAcA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;;;;AA/+BA;AAAA;AAAA;AAAA;AAAA;AAqCA;;;;AA3BA;AAAA;AAyDA;AAAA;;;AAMA;AA5BA;AACA;;;;AACA;AAAA;;;;AAGA;AALA;AACA;;;;;;;;AATA;;;AAzBA;AACA;AAAA;AAAA;AACA;AAuBA;;;;AAAA;;;;;;;;;AAyDA;;;;AAAA;AAAA;;;;AAIA;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;;;;;;;AAsCA;;;;AAAA;AAAA;;;;AAIA;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;AAIA;;;;;;;;;;AAgBA;AAAA;AAAA;AAKA;AACA;AACA;AAAA;AAEA;;AAgBA;;AACA;AAAA;AA+BA;;AA5BA;;AACA;AAAA;AACA;AAAA;AA0BA;;AAzBA;;AAyBA;;AAxBA;AAAA;AACA;AAAA;AAuBA;;AA/CA;;AACA;AAAA;AA8CA;;AA3CA;;AACA;AAAA;AACA;AAAA;AAyCA;;AAxCA;;AAwCA;;AAvCA;AAAA;AACA;AAAA;AAsCA;;AAlBA;AACA;AAAA;AACA;;AACA;AAAA;;AAGA;;AAYA;;AAVA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAOA;;AAAA;;;;;;;;;;;;;;;;;AA4DA;AACA;AAAA;AAIA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AANA;;;AAUA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAJA;AAAA;;;;;;;;AAQA;AAnEA;AACA;AAEA;;;;;AAAA;;;;;;;;;;;AASA;AACA;AACA;;;;AAEA;AACA;;;;;;AAWA;AAAA;AACA;;;;;;;;AARA;AAAA;AACA;;;;;;AASA;;;;AAbA;AAAA;AAqDA;;;AA9CA;AAAA;AA8CA;;;;AArCA;AAqCA;;;;;;;;;;;;;;;;;;;AA2KA;;AACA;AAAA;;AA0DA;;AA9NA;AACA;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;;AAGA;AACA;AAAA;AAmKA;AAAA;AAGA;AAAA;AAGA;AAAA;AACA;AA3JA;AACA;;;AAGA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AACA;;AACA;;;AAGA;AACA;AAAA;AAAA;AAYA;AACA;;AAGA;AAAA;AACA;;AAGA;AAAA;AAiIA;;AAxcA;AACA;;;;;AACA;AAAA;;;;;AAGA;AALA;AACA;;;;;;;AAgdA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAxIA;AACA;;;AA+JA;;AA3JA;;;AAHA;AAAA;AAAA;;AAEA;AACA;AAAA;AAAA;AACA;AAGA;AAAA;AAAA;AAAA;;AAGA;AAZA;AACA;;;;;;;;AA+JA;;;AAnBA;AACA;;AACA;AACA;AACA;;AAeA;;;AAZA;;;AAGA;;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;;AAGA;;;;AAnCA;AACA;AAAA;;AAkCA;;;;AAxCA;AAAA;;AAwCA;;;AArDA;AAAA;;AAqDA;;;;;;;;AA4EA;AAGA;AArCA;AACA;;AAAA;AAAA;;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;;AAGA;AACA;;;;;;AACA;AAEA;AAGA;AAPA;AACA;;;;;;;;;AAGA;;AAQA;;;AAyBA;AAGA;AAAA;;AASA;;AALA;;;AAtjBA;AAAA;;;AAMA;AA5BA;AACA;;;;AACA;AAAA;;;;;AAGA;AALA;AACA;;;;;;;;;;;;;;AA0kBA;AACA;AACA;;AALA;AAAA;AAAA;;;;;;;AASA;;;;;;AAuSA;AAtCA;;;;AAuCA;AAnCA;AAIA;AAAA;AAEA;AAEA;;;;;AACA;;;;;AAWA;AAdA;AAEA;;;;;;;AAEA;AAIA;AAAA;;AAAA;;;AAFA;AAAA;;;;;AAWA;AAWA;AAtCA;;;;;;;;AA2CA;AAAA;;AAQA;AAEA;;;;;AARA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AALA;AAAA;;;;;;;AAQA;AAEA;;;;;;ACvlCA;AAAA;AACA;AAAA;AACA;;;;;;;;;AATA;;;;;;ACoHA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAEA;;;;;;;;;;;;AArDA;AAEA;AA1DA;;AACA;AACA;AAAA;;;;;AA4DA;AADA;AAAA;AAEA;;AACA;;AA+BA;;AA7BA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;AAAA;AADA;;;AAAA;AAAA;AAIA;AAAA;AAAA;AACA;;AA/BA;;;AAoDA;;AAnDA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;;;AAEA;AACA;;AA4CA;;AAfA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;AAOA;;AApDA;;;AAoDA;;AAnDA;AACA;AAAA;AAAA;AACA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;;;AAEA;AACA;;AA4CA;;;;;;AAlFA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;;AAMA;;AALA;AAKA;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;;;;;;AAMA;AAAA;AAAA;;AAUA;;AATA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;;;AAEA;AACA;AAEA;;;;;;AC/DA;;;;;;;;;;;;;;;;;;;ACGA;AACA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAUA;;AALA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;;;;;;;;;;;;;AAOA;AACA;;AACA;;AAWA;;AAPA;AAAA;;;AAOA;;AAJA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAGA;;;;;;;AAMA;AACA;AACA;;;;;;ACiKA;AAAA;AACA;AAAA;AAGA;AAAA;AAGA;AAAA;AACA;AAAA;AAGA;AASA;;;;;;;;;;;;AAhHA;AAAA;AAGA;AAAA;AAAA;AAAA;AAKA;;;;;AACA;;;;AAOA;AARA;;;;;;;AAGA;AAKA;AAUA;AADA;AAAA;AAEA;;AACA;;AA0DA;;AAxDA;AAKA;AAkBA;;AACA;;AAgCA;;AA5BA;AAIA;AAAA;AAeA;;AAdA;AAAA;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;AAFA;;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;AAKA;;AAGA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASA;;;AAjEA;;AAiEA;;;;;;;;;;;;;;AAjLA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;AAqEA;;AAlEA;AAAA;AAAA;;AAkEA;;AA/DA;AAAA;AACA;AAAA;;AAoCA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAFA;AAGA;AAAA;AACA;AAAA;;;AA5CA;AAAA;AAAA;;;AAMA;;;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AADA;AAGA;AACA;AACA;AAAA;AAGA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AApDA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AACA;AAFA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AAFA;;;AALA;;;AAEA;AAAA;;;;;AAGA;AACA;AADA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AA2CA;AAAA;;;AACA;AAAA;AACA;AACA;AAFA;AAGA;AA/DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA;AACA;AAFA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;;;AAPA;;;AAEA;AAAA;;;;;AAGA;AAAA;AACA;AADA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AA2CA;AAAA;;;;;;;;;AASA;AAAA;AAAA;AACA;AAAA;;;;AAeA;;AAeA;;AAdA;AAAA;AAAA;AAAA;AAAA;AAAA;AAcA;;;;;;AAKA;AAAA;AAAA;;AAUA;;AATA;AAAA;;;;AAEA;AACA;AAAA;;;AAGA;AACA;AAEA;;;;;;;;;;;;;;AC8JA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAEA;;AASA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAEA;;AAdA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;;AAMA;AAAA;AAEA;;;;;;;;;;AAOA;AAAA;AAAA;;;AAeA;;AAfA;AAAA;AAaA;AAAA;AAAA;AAAA;AAAA;;AAEA;;;;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;AAIA;AACA;AAEA;AAAA;AAAA;;AAGA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;;;AAAA;AAEA;;AAFA;AAAA;;AAAA;AAEA;;;;;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AASA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AAUA;AAAA;;AACA;AAAA;;;AAiCA;;;AA1BA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;;AAqBA;;;;;AAlBA;AAAA;AAAA;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAXA;;;AAAA;AAAA;;;;;;;;AAqBA;;;;AAlBA;AAAA;AAAA;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAKA;AANA;AAAA;AAAA;AAAA;AAAA;AAMA;AAPA;AAAA;AAOA;AAAA;AAAA;AAbA;;;AAAA;AAAA;;;;;;;;AAqBA;;;;AAlBA;AAAA;AAAA;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAKA;AANA;AAAA;AAAA;AAAA;AAAA;AAMA;AAPA;AAAA;AAOA;AAAA;AAEA;AAfA;;;AAAA;AAAA;;;;;;;;AAqBA;;;;;;;;;;;AAQA;AAAA;AAAA;;AACA;AAAA;AAEA;;AAEA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AAgBA;AAAA;AAAA;;;AAQA;AAAA;AAAA;AAAA;;;AACA;AADA;;AACA;AAAA;AAAA;;AAAA;AADA;;;;;;;;;;;;AAQA;AAAA;AAtNA;;;AACA;AAAA;AACA;AAAA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AACA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAwMA;;;;AAFA;AAEA;;;;;;;;AAOA;AAAA;;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;AAZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAGA;AAAA;AAOA;;;;;;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAuBA;;AAlBA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;;;AACA;AAGA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;;;;;;;;;;;AASA;AAAA;AAAA;;AAOA;;AAJA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;;;;;;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;AAOA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;;;;;;AAMA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAIA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;;;;;;;;;;;;;;;;;;;AC9lBA;AAAA;AACA;AAAA;AACA;AAGA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAUA;;AALA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;;;;;;;;;;AAEA;AAIA;AAAA;AACA;AAAA;AACA;;AACA;;AAoGA;;AA/FA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA+FA;;;;;;;;;AAIA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;;;;;AC2BA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAtKA;AACA;;AAYA;;AA2JA;AACA;;AAvKA;AACA;;AACA;AACA;;AAmKA;AACA;;AAhKA;AACA;AAAA;;AA8JA;AACA;;;;;;AAKA;AAEA;AAAA;AAjFA;;AACA;AAAA;AAEA;;AACA;;AAGA;;AA2EA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;AAzLA;AACA;;AAYA;;AASA;;AApBA;AACA;;AACA;AACA;;AAiBA;;AAbA;AACA;AAAA;;AAYA;;;;;;;;AAwFA;AAAA;;;AACA;;AAAA;AAAA;AAAA;;AAGA;AAAA;;;;AACA;;;;AASA;;;AAOA;;;;;;AApCA;;AASA;;AARA;AAAA;AAEA;;AACA;;AAGA;AAEA;;;;;;;;AAiCA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAjEA;AACA;;AACA;;;;AAGA;AACA;;AACA;AACA;;;;AAIA;AACA;AAAA;;;;;;AAGA;;;;;;AAuDA;;AAKA;AAAA;;;;;;;AAJA;AAAA;;;;;;;;;;AASA;;;;;;;;;AChKA;AAAA;AAEA;AAAA;AAAA;AACA;;AACA;;AAsCA;;AAnCA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AAgBA;;AAbA;AAAA;AAAA;AAAA;;AACA;;AAYA;;AATA;AAAA;AAEA;AACA;;AAEA;;AAIA;;AANA;;AAMA;;;;;;;;;AAUA;AAEA;AACA;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;;AAAA;;;;;;;;;;;;AAMA;AAAA;AAAA;;AAWA;;AARA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAIA;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;;;;;;;ACzEA;AAGA;AAAA;AAAA;AAAA;AACA;;;;;;AAOA;;;;;;;;ACfA;AAGA;AAAA;;;;;AAYA;;;;;;AAMA;;;;;;AAMA;;;;;ACjCA;AAAA;;;;;;AAMA;AAAA;;;;;;;AC6HA;AAzFA;AAAA;AAAA;AAEA;AAAA;AA8BA;AAAA;;;AACA;AAvBA;AAiFA;;;AAjFA;AA+EA;AAvFA;AA8BA;AAAA;;;;;;AACA;AAvBA;AAiFA;;;;;;;AA2CA;AAtIA;AAAA;AAAA;AAEA;AAAA;AA8BA;AAAA;;;;;AAtBA;AA4HA;AApIA;AA8BA;AAAA;;;;;;;AAuGA;AAtGA;AAvBA;AA8HA;;;;;;;AC2XA;AAAA;;AACA;AAvTA;AAuBA;AAoSA;AA+BA;;;;AA9BA;AAAA;;;;;;AAgDA;AAAA;AACA;;;;;;;AAvDA;AAAA;;AACA;AAvTA;AAuBA;AAoSA;AA+BA;;;;AA9BA;AAAA;;;;;;AAyDA;AAAA;AACA;;;;;;;AAhEA;AAAA;;AACA;AAvTA;AAuBA;AAoSA;AA+BA;;;;AA9BA;AAAA;;;;;;AAkEA;AAAA;AACA;;;;;;;AAzEA;AAAA;;AACA;AAvTA;AAuBA;AAoSA;AA+BA;;;;AA9BA;AAAA;;;;;;AA2EA;AAAA;AACA;;;;;;;AAlFA;AAAA;;AACA;AAvTA;AAuBA;AAoSA;AA+BA;;;;AA9BA;AAAA;;;;;;AAoFA;AAAA;AACA;;;;;;;;;ACnNA;AAAA;AAGA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAoEA;AAEA;;AACA;AAAA;;AAUA;;AA2FA;AACA;;AACA;;AA7FA;;AA+FA;AArFA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;;AAjBA;;;;;AAhFA;;AAgFA;;;;;;;;AAwHA;AAEA;AAAA;AAAA;AACA;AAAA;;;;;;;;AAeA;AAEA;AAAA;AAAA;AACA;AAAA;;;;;;;;;AAuCA;AACA;AAAA;AAAA;AAAA;;;;;;;;;AAaA;AACA;AAAA;AAAA;AAAA;;;;;;AA3bA;AAAA;AAAA;AAAA;AACA;;;AAOA;AAAA;;AAJA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAEA;AAAA;;;;;;;;;AAUA;AAAA;AAAA;AAAA;;AACA;AAAA;;;AAWA;;;AAXA;AAAA;AAYA;AAAA;;;;;;;;;AAOA;AAAA;AAAA;AACA;;AAGA;;AAHA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;;;;AAQA;AAAA;AAAA;AACA;;AAGA;;AAHA;AAAA;AAAA;;AAGA;;AAFA;AAEA;;;;;;AAOA;;;AASA;;AARA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;;;;AACA;;;;AA8RA;;AAzRA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxPA;;;;;;AAMA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;;;AAKA;AAAA;;AACA;;;;AAIA;AACA;AACA;AACA;AAGA;AACA;;AACA;AAAA;AACA;AAAA;AACA;AACA;;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;;;;AAEA;;;;;;;;AAcA;AACA;AACA;AAGA;;;;;AAEA;;;;AAIA;;AACA;AACA;AACA;AAEA;;AACA;;;;;;;;;;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;;;;;;;;;AAGA;AAEA;AAFA;AAQA;AAAA;AAAA;;AAMA;;;;;;;;AA4DA;;;AA1CA;;;;;;;;;;;;;;;AAmCA;;;;;AAOA;AAEA;;;;AAMA;AAAA;AAAA;AAAA;AACA;;;AAEA;AACA;AADA;AAGA;AAAA;;;AAIA;AAAA;AACA;AADA;AAGA;;AACA;;;;AAIA;AACA;;;;AACA;;AACA;;;;AAGA;;;;;AACA;AAAA;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAJA;AAAA;;;;;;;;;;;AAQA;AAAA;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAVA;AAAA;;;;;;;;;;AAgBA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;;;AAIA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;;;AAMA;AAAA;AAHA;AAKA;AAAA;AAAA;;;AAkDA;AAEA;AA/CA;AACA;;AA4CA;AAAA;;;;;AA9CA;AAEA;AAAA;;;;AACA;AAAA;;AACA;AAAA;AAAA;;;;AAMA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AATA;AAAA;AAAA;;;;;;;;;;;AA+CA;AAAA;AADA;AAAA;;;;;;;;AAKA;AAEA;AAHA;AACA;AAzDA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAEA;AAAA;;AACA;;;AAAA;AAAA;;AACA;AAAA;AAAA;;;;AAMA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AATA;AAAA;AAAA;;;;;;;;;AAeA;AAAA;AACA;AAAA;;;;;;;;AA+BA;AAAA;AADA;AAAA;;;;;;;;AAKA;AAEA;AAHA;AACA;AAzDA;AAAA;AAAA;;;;;;;;AAuBA;;;;;AAdA;;;;;;;AAqDA;;;;;;;AAxXA;AACA;AAAA;AAAA;AAEA;;;;;;;;AACA;AAAA;AAIA;;;;;AALA;;;;;;;;;AAWA;AACA;AAFA;;;;;;;;;;;;;AA4DA;;;;AAqTA;AAAA;AAAA;;;;;;AAEA;;;AAGA;AAAA;AAAA;;AAGA;;AAFA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;AAYA;AAAA;AAAA;;;AAAA;AAqBA;;AAmKA;AAAA;AAAA;AAAA;AAAA;;AA/JA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;;;AAAA;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;;;;;;;AAcA;;AAQA;;AAEA;AACA;;AAEA;AAAA;AAAA;AADA;AAAA;;;;;;;;AApCA;;;;;AAGA;AAAA;;;;;AAuCA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAIA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAGA;AAAA;AAAA;;;;AACA;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AAAA;AAAA;;AAIA;AAAA;AACA;AACA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAJA;AAAA;;;;;;;;;AASA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;AAFA;AAQA;AAEA;AAPA;AAAA;AACA;AAAA;AAAA;;;;;AAFA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;AAKA;;;;AAEA;AAAA;AADA;AAAA;;;;;;;;AARA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;AACA;;;AAYA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAIA;AACA;;AACA;;;;AAIA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAFA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA","sourcesContent":["/*\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely.\n*/\n\n/* Simple program:  draw as many random objects on the screen as possible */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\n\n#ifdef __EMSCRIPTEN__\n#include <emscripten/emscripten.h>\n#endif\n\n#include \"SDL_test_common.h\"\n\n#define NUM_OBJECTS 100\n\nstatic SDLTest_CommonState *state;\nstatic int num_objects;\nstatic SDL_bool cycle_color;\nstatic SDL_bool cycle_alpha;\nstatic int cycle_direction = 1;\nstatic int current_alpha = 255;\nstatic int current_color = 255;\nstatic SDL_BlendMode blendMode = SDL_BLENDMODE_NONE;\n\nint done;\n\nvoid\nDrawPoints(SDL_Renderer * renderer)\n{\n    int i;\n    int x, y;\n    SDL_Rect viewport;\n\n    /* Query the sizes */\n    SDL_RenderGetViewport(renderer, &viewport);\n\n    for (i = 0; i < num_objects * 4; ++i) {\n        /* Cycle the color and alpha, if desired */\n        if (cycle_color) {\n            current_color += cycle_direction;\n            if (current_color < 0) {\n                current_color = 0;\n                cycle_direction = -cycle_direction;\n            }\n            if (current_color > 255) {\n                current_color = 255;\n                cycle_direction = -cycle_direction;\n            }\n        }\n        if (cycle_alpha) {\n            current_alpha += cycle_direction;\n            if (current_alpha < 0) {\n                current_alpha = 0;\n                cycle_direction = -cycle_direction;\n            }\n            if (current_alpha > 255) {\n                current_alpha = 255;\n                cycle_direction = -cycle_direction;\n            }\n        }\n        SDL_SetRenderDrawColor(renderer, 255, (Uint8) current_color,\n                               (Uint8) current_color, (Uint8) current_alpha);\n\n        x = rand() % viewport.w;\n        y = rand() % viewport.h;\n        SDL_RenderDrawPoint(renderer, x, y);\n    }\n}\n\nvoid\nDrawLines(SDL_Renderer * renderer)\n{\n    int i;\n    int x1, y1, x2, y2;\n    SDL_Rect viewport;\n\n    /* Query the sizes */\n    SDL_RenderGetViewport(renderer, &viewport);\n\n    for (i = 0; i < num_objects; ++i) {\n        /* Cycle the color and alpha, if desired */\n        if (cycle_color) {\n            current_color += cycle_direction;\n            if (current_color < 0) {\n                current_color = 0;\n                cycle_direction = -cycle_direction;\n            }\n            if (current_color > 255) {\n                current_color = 255;\n                cycle_direction = -cycle_direction;\n            }\n        }\n        if (cycle_alpha) {\n            current_alpha += cycle_direction;\n            if (current_alpha < 0) {\n                current_alpha = 0;\n                cycle_direction = -cycle_direction;\n            }\n            if (current_alpha > 255) {\n                current_alpha = 255;\n                cycle_direction = -cycle_direction;\n            }\n        }\n        SDL_SetRenderDrawColor(renderer, 255, (Uint8) current_color,\n                               (Uint8) current_color, (Uint8) current_alpha);\n\n        if (i == 0) {\n            SDL_RenderDrawLine(renderer, 0, 0, viewport.w - 1, viewport.h - 1);\n            SDL_RenderDrawLine(renderer, 0, viewport.h - 1, viewport.w - 1, 0);\n            SDL_RenderDrawLine(renderer, 0, viewport.h / 2, viewport.w - 1, viewport.h / 2);\n            SDL_RenderDrawLine(renderer, viewport.w / 2, 0, viewport.w / 2, viewport.h - 1);\n        } else {\n            x1 = (rand() % (viewport.w*2)) - viewport.w;\n            x2 = (rand() % (viewport.w*2)) - viewport.w;\n            y1 = (rand() % (viewport.h*2)) - viewport.h;\n            y2 = (rand() % (viewport.h*2)) - viewport.h;\n            SDL_RenderDrawLine(renderer, x1, y1, x2, y2);\n        }\n    }\n}\n\nvoid\nDrawRects(SDL_Renderer * renderer)\n{\n    int i;\n    SDL_Rect rect;\n    SDL_Rect viewport;\n\n    /* Query the sizes */\n    SDL_RenderGetViewport(renderer, &viewport);\n\n    for (i = 0; i < num_objects / 4; ++i) {\n        /* Cycle the color and alpha, if desired */\n        if (cycle_color) {\n            current_color += cycle_direction;\n            if (current_color < 0) {\n                current_color = 0;\n                cycle_direction = -cycle_direction;\n            }\n            if (current_color > 255) {\n                current_color = 255;\n                cycle_direction = -cycle_direction;\n            }\n        }\n        if (cycle_alpha) {\n            current_alpha += cycle_direction;\n            if (current_alpha < 0) {\n                current_alpha = 0;\n                cycle_direction = -cycle_direction;\n            }\n            if (current_alpha > 255) {\n                current_alpha = 255;\n                cycle_direction = -cycle_direction;\n            }\n        }\n        SDL_SetRenderDrawColor(renderer, 255, (Uint8) current_color,\n                               (Uint8) current_color, (Uint8) current_alpha);\n\n        rect.w = rand() % (viewport.h / 2);\n        rect.h = rand() % (viewport.h / 2);\n        rect.x = (rand() % (viewport.w*2) - viewport.w) - (rect.w / 2);\n        rect.y = (rand() % (viewport.h*2) - viewport.h) - (rect.h / 2);\n        SDL_RenderFillRect(renderer, &rect);\n    }\n}\n\nvoid\nloop()\n{\n    int i;\n    SDL_Event event;\n\n    /* Check for events */\n    while (SDL_PollEvent(&event)) {\n        SDLTest_CommonEvent(state, &event, &done);\n    }\n    for (i = 0; i < state->num_windows; ++i) {\n        SDL_Renderer *renderer = state->renderers[i];\n        if (state->windows[i] == NULL)\n            continue;\n        SDL_SetRenderDrawColor(renderer, 0xA0, 0xA0, 0xA0, 0xFF);\n        SDL_RenderClear(renderer);\n\n        DrawRects(renderer);\n        DrawLines(renderer);\n        DrawPoints(renderer);\n\n        SDL_RenderPresent(renderer);\n    }\n}\n\nint\nmain(int argc, char *argv[])\n{\n    int i;\n    Uint32 then, now, frames;\n\n\t/* Enable standard application logging */\n\tSDL_LogSetPriority(SDL_LOG_CATEGORY_APPLICATION, SDL_LOG_PRIORITY_INFO);\n\n    /* Initialize parameters */\n    num_objects = NUM_OBJECTS;\n\n    /* Initialize test framework */\n    state = SDLTest_CommonCreateState(argv, SDL_INIT_VIDEO);\n    if (!state) {\n        return 1;\n    }\n    for (i = 1; i < argc;) {\n        int consumed;\n\n        consumed = SDLTest_CommonArg(state, i);\n        if (consumed == 0) {\n            consumed = -1;\n            if (SDL_strcasecmp(argv[i], \"--blend\") == 0) {\n                if (argv[i + 1]) {\n                    if (SDL_strcasecmp(argv[i + 1], \"none\") == 0) {\n                        blendMode = SDL_BLENDMODE_NONE;\n                        consumed = 2;\n                    } else if (SDL_strcasecmp(argv[i + 1], \"blend\") == 0) {\n                        blendMode = SDL_BLENDMODE_BLEND;\n                        consumed = 2;\n                    } else if (SDL_strcasecmp(argv[i + 1], \"add\") == 0) {\n                        blendMode = SDL_BLENDMODE_ADD;\n                        consumed = 2;\n                    } else if (SDL_strcasecmp(argv[i + 1], \"mod\") == 0) {\n                        blendMode = SDL_BLENDMODE_MOD;\n                        consumed = 2;\n                    }\n                }\n            } else if (SDL_strcasecmp(argv[i], \"--cyclecolor\") == 0) {\n                cycle_color = SDL_TRUE;\n                consumed = 1;\n            } else if (SDL_strcasecmp(argv[i], \"--cyclealpha\") == 0) {\n                cycle_alpha = SDL_TRUE;\n                consumed = 1;\n            } else if (SDL_isdigit(*argv[i])) {\n                num_objects = SDL_atoi(argv[i]);\n                consumed = 1;\n            }\n        }\n        if (consumed < 0) {\n            SDL_Log(\"Usage: %s %s [--blend none|blend|add|mod] [--cyclecolor] [--cyclealpha]\\n\",\n                    argv[0], SDLTest_CommonUsage(state));\n            return 1;\n        }\n        i += consumed;\n    }\n    if (!SDLTest_CommonInit(state)) {\n        return 2;\n    }\n\n    /* Create the windows and initialize the renderers */\n    for (i = 0; i < state->num_windows; ++i) {\n        SDL_Renderer *renderer = state->renderers[i];\n        SDL_SetRenderDrawBlendMode(renderer, blendMode);\n        SDL_SetRenderDrawColor(renderer, 0xA0, 0xA0, 0xA0, 0xFF);\n        SDL_RenderClear(renderer);\n    }\n\n    srand((unsigned int)time(NULL));\n\n    /* Main render loop */\n    frames = 0;\n    then = SDL_GetTicks();\n    done = 0;\n\n#ifdef __EMSCRIPTEN__\n    emscripten_set_main_loop(loop, 0, 1);\n#else\n    while (!done) {\n        ++frames;\n        loop();\n        }\n#endif\n\n\n    SDLTest_CommonQuit(state);\n\n    /* Print out some timing information */\n    now = SDL_GetTicks();\n    if (now > then) {\n        double fps = ((double) frames * 1000) / (now - then);\n        SDL_Log(\"%2.2f frames per second\\n\", fps);\n    }\n    return 0;\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"./SDL_internal.h\"\n\n#if defined(__WIN32__) || defined(__WINRT__)\n#include \"core/windows/SDL_windows.h\"\n#endif\n\n/* Simple log messages in SDL */\n\n#include \"SDL_error.h\"\n#include \"SDL_log.h\"\n\n#if HAVE_STDIO_H\n#include <stdio.h>\n#endif\n\n#if defined(__ANDROID__)\n#include <android/log.h>\n#endif\n\n#define DEFAULT_PRIORITY                SDL_LOG_PRIORITY_CRITICAL\n#define DEFAULT_ASSERT_PRIORITY         SDL_LOG_PRIORITY_WARN\n#define DEFAULT_APPLICATION_PRIORITY    SDL_LOG_PRIORITY_INFO\n#define DEFAULT_TEST_PRIORITY           SDL_LOG_PRIORITY_VERBOSE\n\ntypedef struct SDL_LogLevel\n{\n    int category;\n    SDL_LogPriority priority;\n    struct SDL_LogLevel *next;\n} SDL_LogLevel;\n\n/* The default log output function */\nstatic void SDL_LogOutput(void *userdata,\n                          int category, SDL_LogPriority priority,\n                          const char *message);\n\nstatic SDL_LogLevel *SDL_loglevels;\nstatic SDL_LogPriority SDL_default_priority = DEFAULT_PRIORITY;\nstatic SDL_LogPriority SDL_assert_priority = DEFAULT_ASSERT_PRIORITY;\nstatic SDL_LogPriority SDL_application_priority = DEFAULT_APPLICATION_PRIORITY;\nstatic SDL_LogPriority SDL_test_priority = DEFAULT_TEST_PRIORITY;\nstatic SDL_LogOutputFunction SDL_log_function = SDL_LogOutput;\nstatic void *SDL_log_userdata = NULL;\n\nstatic const char *SDL_priority_prefixes[SDL_NUM_LOG_PRIORITIES] = {\n    NULL,\n    \"VERBOSE\",\n    \"DEBUG\",\n    \"INFO\",\n    \"WARN\",\n    \"ERROR\",\n    \"CRITICAL\"\n};\n\n#ifdef __ANDROID__\nstatic const char *SDL_category_prefixes[SDL_LOG_CATEGORY_RESERVED1] = {\n    \"APP\",\n    \"ERROR\",\n    \"SYSTEM\",\n    \"AUDIO\",\n    \"VIDEO\",\n    \"RENDER\",\n    \"INPUT\"\n};\n\nstatic int SDL_android_priority[SDL_NUM_LOG_PRIORITIES] = {\n    ANDROID_LOG_UNKNOWN,\n    ANDROID_LOG_VERBOSE,\n    ANDROID_LOG_DEBUG,\n    ANDROID_LOG_INFO,\n    ANDROID_LOG_WARN,\n    ANDROID_LOG_ERROR,\n    ANDROID_LOG_FATAL\n};\n#endif /* __ANDROID__ */\n\n\nvoid\nSDL_LogSetAllPriority(SDL_LogPriority priority)\n{\n    SDL_LogLevel *entry;\n\n    for (entry = SDL_loglevels; entry; entry = entry->next) {\n        entry->priority = priority;\n    }\n    SDL_default_priority = priority;\n    SDL_assert_priority = priority;\n    SDL_application_priority = priority;\n}\n\nvoid\nSDL_LogSetPriority(int category, SDL_LogPriority priority)\n{\n    SDL_LogLevel *entry;\n\n    for (entry = SDL_loglevels; entry; entry = entry->next) {\n        if (entry->category == category) {\n            entry->priority = priority;\n            return;\n        }\n    }\n\n    /* Create a new entry */\n    entry = (SDL_LogLevel *)SDL_malloc(sizeof(*entry));\n    if (entry) {\n        entry->category = category;\n        entry->priority = priority;\n        entry->next = SDL_loglevels;\n        SDL_loglevels = entry;\n    }\n}\n\nSDL_LogPriority\nSDL_LogGetPriority(int category)\n{\n    SDL_LogLevel *entry;\n\n    for (entry = SDL_loglevels; entry; entry = entry->next) {\n        if (entry->category == category) {\n            return entry->priority;\n        }\n    }\n\n    if (category == SDL_LOG_CATEGORY_TEST) {\n        return SDL_test_priority;\n    } else if (category == SDL_LOG_CATEGORY_APPLICATION) {\n        return SDL_application_priority;\n    } else if (category == SDL_LOG_CATEGORY_ASSERT) {\n        return SDL_assert_priority;\n    } else {\n        return SDL_default_priority;\n    }\n}\n\nvoid\nSDL_LogResetPriorities(void)\n{\n    SDL_LogLevel *entry;\n\n    while (SDL_loglevels) {\n        entry = SDL_loglevels;\n        SDL_loglevels = entry->next;\n        SDL_free(entry);\n    }\n\n    SDL_default_priority = DEFAULT_PRIORITY;\n    SDL_assert_priority = DEFAULT_ASSERT_PRIORITY;\n    SDL_application_priority = DEFAULT_APPLICATION_PRIORITY;\n    SDL_test_priority = DEFAULT_TEST_PRIORITY;\n}\n\nvoid\nSDL_Log(SDL_PRINTF_FORMAT_STRING const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    SDL_LogMessageV(SDL_LOG_CATEGORY_APPLICATION, SDL_LOG_PRIORITY_INFO, fmt, ap);\n    va_end(ap);\n}\n\nvoid\nSDL_LogVerbose(int category, SDL_PRINTF_FORMAT_STRING const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    SDL_LogMessageV(category, SDL_LOG_PRIORITY_VERBOSE, fmt, ap);\n    va_end(ap);\n}\n\nvoid\nSDL_LogDebug(int category, SDL_PRINTF_FORMAT_STRING const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    SDL_LogMessageV(category, SDL_LOG_PRIORITY_DEBUG, fmt, ap);\n    va_end(ap);\n}\n\nvoid\nSDL_LogInfo(int category, SDL_PRINTF_FORMAT_STRING const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    SDL_LogMessageV(category, SDL_LOG_PRIORITY_INFO, fmt, ap);\n    va_end(ap);\n}\n\nvoid\nSDL_LogWarn(int category, SDL_PRINTF_FORMAT_STRING const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    SDL_LogMessageV(category, SDL_LOG_PRIORITY_WARN, fmt, ap);\n    va_end(ap);\n}\n\nvoid\nSDL_LogError(int category, SDL_PRINTF_FORMAT_STRING const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    SDL_LogMessageV(category, SDL_LOG_PRIORITY_ERROR, fmt, ap);\n    va_end(ap);\n}\n\nvoid\nSDL_LogCritical(int category, SDL_PRINTF_FORMAT_STRING const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    SDL_LogMessageV(category, SDL_LOG_PRIORITY_CRITICAL, fmt, ap);\n    va_end(ap);\n}\n\nvoid\nSDL_LogMessage(int category, SDL_LogPriority priority, SDL_PRINTF_FORMAT_STRING const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    SDL_LogMessageV(category, priority, fmt, ap);\n    va_end(ap);\n}\n\n#ifdef __ANDROID__\nstatic const char *\nGetCategoryPrefix(int category)\n{\n    if (category < SDL_LOG_CATEGORY_RESERVED1) {\n        return SDL_category_prefixes[category];\n    }\n    if (category < SDL_LOG_CATEGORY_CUSTOM) {\n        return \"RESERVED\";\n    }\n    return \"CUSTOM\";\n}\n#endif /* __ANDROID__ */\n\nvoid\nSDL_LogMessageV(int category, SDL_LogPriority priority, const char *fmt, va_list ap)\n{\n    char *message;\n    size_t len;\n\n    /* Nothing to do if we don't have an output function */\n    if (!SDL_log_function) {\n        return;\n    }\n\n    /* Make sure we don't exceed array bounds */\n    if ((int)priority < 0 || priority >= SDL_NUM_LOG_PRIORITIES) {\n        return;\n    }\n\n    /* See if we want to do anything with this message */\n    if (priority < SDL_LogGetPriority(category)) {\n        return;\n    }\n\n    message = SDL_stack_alloc(char, SDL_MAX_LOG_MESSAGE);\n    if (!message) {\n        return;\n    }\n\n    SDL_vsnprintf(message, SDL_MAX_LOG_MESSAGE, fmt, ap);\n\n    /* Chop off final endline. */\n    len = SDL_strlen(message);\n    if ((len > 0) && (message[len-1] == '\\n')) {\n        message[--len] = '\\0';\n        if ((len > 0) && (message[len-1] == '\\r')) {  /* catch \"\\r\\n\", too. */\n            message[--len] = '\\0';\n        }\n    }\n\n    SDL_log_function(SDL_log_userdata, category, priority, message);\n    SDL_stack_free(message);\n}\n\n#if defined(__WIN32__)\n/* Flag tracking the attachment of the console: 0=unattached, 1=attached, -1=error */\nstatic int consoleAttached = 0;\n\n/* Handle to stderr output of console. */\nstatic HANDLE stderrHandle = NULL;\n#endif\n\nstatic void\nSDL_LogOutput(void *userdata, int category, SDL_LogPriority priority,\n              const char *message)\n{\n#if defined(__WIN32__) || defined(__WINRT__)\n    /* Way too many allocations here, urgh */\n    /* Note: One can't call SDL_SetError here, since that function itself logs. */\n    {\n        char *output;\n        size_t length;\n        LPTSTR tstr;\n\n#ifndef __WINRT__\n        BOOL attachResult;\n        DWORD attachError;\n        unsigned long charsWritten; \n\n        /* Maybe attach console and get stderr handle */\n        if (consoleAttached == 0) {\n            attachResult = AttachConsole(ATTACH_PARENT_PROCESS);\n            if (!attachResult) {\n                    attachError = GetLastError();\n                    if (attachError == ERROR_INVALID_HANDLE) {\n                        OutputDebugString(TEXT(\"Parent process has no console\\r\\n\"));\n                        consoleAttached = -1;\n                    } else if (attachError == ERROR_GEN_FAILURE) {\n                         OutputDebugString(TEXT(\"Could not attach to console of parent process\\r\\n\"));\n                         consoleAttached = -1;\n                    } else if (attachError == ERROR_ACCESS_DENIED) {  \n                         /* Already attached */\n                        consoleAttached = 1;\n                    } else {\n                        OutputDebugString(TEXT(\"Error attaching console\\r\\n\"));\n                        consoleAttached = -1;\n                    }\n                } else {\n                    /* Newly attached */\n                    consoleAttached = 1;\n                }\n\t\t\t\n                if (consoleAttached == 1) {\n                        stderrHandle = GetStdHandle(STD_ERROR_HANDLE);\n                }\n        }\n#endif /* ifndef __WINRT__ */\n\n        length = SDL_strlen(SDL_priority_prefixes[priority]) + 2 + SDL_strlen(message) + 1 + 1 + 1;\n        output = SDL_stack_alloc(char, length);\n        SDL_snprintf(output, length, \"%s: %s\\r\\n\", SDL_priority_prefixes[priority], message);\n        tstr = WIN_UTF8ToString(output);\n        \n        /* Output to debugger */\n        OutputDebugString(tstr);\n       \n#ifndef __WINRT__\n        /* Screen output to stderr, if console was attached. */\n        if (consoleAttached == 1) {\n                if (!WriteConsole(stderrHandle, tstr, lstrlen(tstr), &charsWritten, NULL)) {\n                    OutputDebugString(TEXT(\"Error calling WriteConsole\\r\\n\"));\n                }\n                if (charsWritten == ERROR_NOT_ENOUGH_MEMORY) {\n                    OutputDebugString(TEXT(\"Insufficient heap memory to write message\\r\\n\"));\n                }\n        }\n#endif /* ifndef __WINRT__ */\n\n        SDL_free(tstr);\n        SDL_stack_free(output);\n    }\n#elif defined(__ANDROID__)\n    {\n        char tag[32];\n\n        SDL_snprintf(tag, SDL_arraysize(tag), \"SDL/%s\", GetCategoryPrefix(category));\n        __android_log_write(SDL_android_priority[priority], tag, message);\n    }\n#elif defined(__APPLE__) && defined(SDL_VIDEO_DRIVER_COCOA)\n    /* Technically we don't need SDL_VIDEO_DRIVER_COCOA, but that's where this function is defined for now.\n    */\n    extern void SDL_NSLog(const char *text);\n    {\n        char *text;\n\n        text = SDL_stack_alloc(char, SDL_MAX_LOG_MESSAGE);\n        if (text) {\n            SDL_snprintf(text, SDL_MAX_LOG_MESSAGE, \"%s: %s\", SDL_priority_prefixes[priority], message);\n            SDL_NSLog(text);\n            SDL_stack_free(text);\n            return;\n        }\n    }\n#elif defined(__PSP__)\n    {\n        FILE*        pFile;\n        pFile = fopen (\"SDL_Log.txt\", \"a\");\n        fprintf(pFile, \"%s: %s\\n\", SDL_priority_prefixes[priority], message);\n        fclose (pFile);\n    }\n#endif\n#if HAVE_STDIO_H\n    fprintf(stderr, \"%s: %s\\n\", SDL_priority_prefixes[priority], message);\n#if __NACL__\n    fflush(stderr);\n#endif\n#endif\n}\n\nvoid\nSDL_LogGetOutputFunction(SDL_LogOutputFunction *callback, void **userdata)\n{\n    if (callback) {\n        *callback = SDL_log_function;\n    }\n    if (userdata) {\n        *userdata = SDL_log_userdata;\n    }\n}\n\nvoid\nSDL_LogSetOutputFunction(SDL_LogOutputFunction callback, void *userdata)\n{\n    SDL_log_function = callback;\n    SDL_log_userdata = userdata;\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../SDL_internal.h\"\n\n/* General event handling code for SDL */\n\n#include \"SDL.h\"\n#include \"SDL_events.h\"\n#include \"SDL_syswm.h\"\n#include \"SDL_thread.h\"\n#include \"SDL_events_c.h\"\n#include \"../timer/SDL_timer_c.h\"\n#if !SDL_JOYSTICK_DISABLED\n#include \"../joystick/SDL_joystick_c.h\"\n#endif\n#include \"../video/SDL_sysvideo.h\"\n\n/* An arbitrary limit so we don't have unbounded growth */\n#define SDL_MAX_QUEUED_EVENTS   65535\n\n/* Public data -- the event filter */\nSDL_EventFilter SDL_EventOK = NULL;\nvoid *SDL_EventOKParam;\n\ntypedef struct SDL_EventWatcher {\n    SDL_EventFilter callback;\n    void *userdata;\n    struct SDL_EventWatcher *next;\n} SDL_EventWatcher;\n\nstatic SDL_EventWatcher *SDL_event_watchers = NULL;\n\ntypedef struct {\n    Uint32 bits[8];\n} SDL_DisabledEventBlock;\n\nstatic SDL_DisabledEventBlock *SDL_disabled_events[256];\nstatic Uint32 SDL_userevents = SDL_USEREVENT;\n\n/* Private data -- event queue */\ntypedef struct _SDL_EventEntry\n{\n    SDL_Event event;\n    SDL_SysWMmsg msg;\n    struct _SDL_EventEntry *prev;\n    struct _SDL_EventEntry *next;\n} SDL_EventEntry;\n\ntypedef struct _SDL_SysWMEntry\n{\n    SDL_SysWMmsg msg;\n    struct _SDL_SysWMEntry *next;\n} SDL_SysWMEntry;\n\nstatic struct\n{\n    SDL_mutex *lock;\n    volatile SDL_bool active;\n    volatile int count;\n    SDL_EventEntry *head;\n    SDL_EventEntry *tail;\n    SDL_EventEntry *free;\n    SDL_SysWMEntry *wmmsg_used;\n    SDL_SysWMEntry *wmmsg_free;\n} SDL_EventQ = { NULL, SDL_TRUE };\n\n\n/* Public functions */\n\nvoid\nSDL_StopEventLoop(void)\n{\n    int i;\n    SDL_EventEntry *entry;\n    SDL_SysWMEntry *wmmsg;\n\n    if (SDL_EventQ.lock) {\n        SDL_LockMutex(SDL_EventQ.lock);\n    }\n\n    SDL_EventQ.active = SDL_FALSE;\n\n    /* Clean out EventQ */\n    for (entry = SDL_EventQ.head; entry; ) {\n        SDL_EventEntry *next = entry->next;\n        SDL_free(entry);\n        entry = next;\n    }\n    for (entry = SDL_EventQ.free; entry; ) {\n        SDL_EventEntry *next = entry->next;\n        SDL_free(entry);\n        entry = next;\n    }\n    for (wmmsg = SDL_EventQ.wmmsg_used; wmmsg; ) {\n        SDL_SysWMEntry *next = wmmsg->next;\n        SDL_free(wmmsg);\n        wmmsg = next;\n    }\n    for (wmmsg = SDL_EventQ.wmmsg_free; wmmsg; ) {\n        SDL_SysWMEntry *next = wmmsg->next;\n        SDL_free(wmmsg);\n        wmmsg = next;\n    }\n    SDL_EventQ.count = 0;\n    SDL_EventQ.head = NULL;\n    SDL_EventQ.tail = NULL;\n    SDL_EventQ.free = NULL;\n    SDL_EventQ.wmmsg_used = NULL;\n    SDL_EventQ.wmmsg_free = NULL;\n\n    /* Clear disabled event state */\n    for (i = 0; i < SDL_arraysize(SDL_disabled_events); ++i) {\n        SDL_free(SDL_disabled_events[i]);\n        SDL_disabled_events[i] = NULL;\n    }\n\n    while (SDL_event_watchers) {\n        SDL_EventWatcher *tmp = SDL_event_watchers;\n        SDL_event_watchers = tmp->next;\n        SDL_free(tmp);\n    }\n    SDL_EventOK = NULL;\n\n    if (SDL_EventQ.lock) {\n        SDL_UnlockMutex(SDL_EventQ.lock);\n        SDL_DestroyMutex(SDL_EventQ.lock);\n        SDL_EventQ.lock = NULL;\n    }\n}\n\n/* This function (and associated calls) may be called more than once */\nint\nSDL_StartEventLoop(void)\n{\n    /* We'll leave the event queue alone, since we might have gotten\n       some important events at launch (like SDL_DROPFILE)\n\n       FIXME: Does this introduce any other bugs with events at startup?\n     */\n\n    /* Create the lock and set ourselves active */\n#if !SDL_THREADS_DISABLED\n    if (!SDL_EventQ.lock) {\n        SDL_EventQ.lock = SDL_CreateMutex();\n    }\n    if (SDL_EventQ.lock == NULL) {\n        return (-1);\n    }\n#endif /* !SDL_THREADS_DISABLED */\n\n    /* Process most event types */\n    SDL_EventState(SDL_TEXTINPUT, SDL_DISABLE);\n    SDL_EventState(SDL_TEXTEDITING, SDL_DISABLE);\n    SDL_EventState(SDL_SYSWMEVENT, SDL_DISABLE);\n\n    SDL_EventQ.active = SDL_TRUE;\n\n    return (0);\n}\n\n\n/* Add an event to the event queue -- called with the queue locked */\nstatic int\nSDL_AddEvent(SDL_Event * event)\n{\n    SDL_EventEntry *entry;\n\n    if (SDL_EventQ.count >= SDL_MAX_QUEUED_EVENTS) {\n        SDL_SetError(\"Event queue is full (%d events)\", SDL_EventQ.count);\n        return 0;\n    }\n\n    if (SDL_EventQ.free == NULL) {\n        entry = (SDL_EventEntry *)SDL_malloc(sizeof(*entry));\n        if (!entry) {\n            return 0;\n        }\n    } else {\n        entry = SDL_EventQ.free;\n        SDL_EventQ.free = entry->next;\n    }\n\n    entry->event = *event;\n    if (event->type == SDL_SYSWMEVENT) {\n        entry->msg = *event->syswm.msg;\n        entry->event.syswm.msg = &entry->msg;\n    }\n\n    if (SDL_EventQ.tail) {\n        SDL_EventQ.tail->next = entry;\n        entry->prev = SDL_EventQ.tail;\n        SDL_EventQ.tail = entry;\n        entry->next = NULL;\n    } else {\n        SDL_assert(!SDL_EventQ.head);\n        SDL_EventQ.head = entry;\n        SDL_EventQ.tail = entry;\n        entry->prev = NULL;\n        entry->next = NULL;\n    }\n    ++SDL_EventQ.count;\n\n    return 1;\n}\n\n/* Remove an event from the queue -- called with the queue locked */\nstatic void\nSDL_CutEvent(SDL_EventEntry *entry)\n{\n    if (entry->prev) {\n        entry->prev->next = entry->next;\n    }\n    if (entry->next) {\n        entry->next->prev = entry->prev;\n    }\n\n    if (entry == SDL_EventQ.head) {\n        SDL_assert(entry->prev == NULL);\n        SDL_EventQ.head = entry->next;\n    }\n    if (entry == SDL_EventQ.tail) {\n        SDL_assert(entry->next == NULL);\n        SDL_EventQ.tail = entry->prev;\n    }\n\n    entry->next = SDL_EventQ.free;\n    SDL_EventQ.free = entry;\n    SDL_assert(SDL_EventQ.count > 0);\n    --SDL_EventQ.count;\n}\n\n/* Lock the event queue, take a peep at it, and unlock it */\nint\nSDL_PeepEvents(SDL_Event * events, int numevents, SDL_eventaction action,\n               Uint32 minType, Uint32 maxType)\n{\n    int i, used;\n\n    /* Don't look after we've quit */\n    if (!SDL_EventQ.active) {\n        /* We get a few spurious events at shutdown, so don't warn then */\n        if (action != SDL_ADDEVENT) {\n            SDL_SetError(\"The event system has been shut down\");\n        }\n        return (-1);\n    }\n    /* Lock the event queue */\n    used = 0;\n    if (!SDL_EventQ.lock || SDL_LockMutex(SDL_EventQ.lock) == 0) {\n        if (action == SDL_ADDEVENT) {\n            for (i = 0; i < numevents; ++i) {\n                used += SDL_AddEvent(&events[i]);\n            }\n        } else {\n            SDL_EventEntry *entry, *next;\n            SDL_SysWMEntry *wmmsg, *wmmsg_next;\n            SDL_Event tmpevent;\n            Uint32 type;\n\n            /* If 'events' is NULL, just see if they exist */\n            if (events == NULL) {\n                action = SDL_PEEKEVENT;\n                numevents = 1;\n                events = &tmpevent;\n            }\n\n            /* Clean out any used wmmsg data\n               FIXME: Do we want to retain the data for some period of time?\n             */\n            for (wmmsg = SDL_EventQ.wmmsg_used; wmmsg; wmmsg = wmmsg_next) {\n                wmmsg_next = wmmsg->next;\n                wmmsg->next = SDL_EventQ.wmmsg_free;\n                SDL_EventQ.wmmsg_free = wmmsg;\n            }\n            SDL_EventQ.wmmsg_used = NULL;\n\n            for (entry = SDL_EventQ.head; entry && used < numevents; entry = next) {\n                next = entry->next;\n                type = entry->event.type;\n                if (minType <= type && type <= maxType) {\n                    events[used] = entry->event;\n                    if (entry->event.type == SDL_SYSWMEVENT) {\n                        /* We need to copy the wmmsg somewhere safe.\n                           For now we'll guarantee it's valid at least until\n                           the next call to SDL_PeepEvents()\n                         */\n                        if (SDL_EventQ.wmmsg_free) {\n                            wmmsg = SDL_EventQ.wmmsg_free;\n                            SDL_EventQ.wmmsg_free = wmmsg->next;\n                        } else {\n                            wmmsg = (SDL_SysWMEntry *)SDL_malloc(sizeof(*wmmsg));\n                        }\n                        wmmsg->msg = *entry->event.syswm.msg;\n                        wmmsg->next = SDL_EventQ.wmmsg_used;\n                        SDL_EventQ.wmmsg_used = wmmsg;\n                        events[used].syswm.msg = &wmmsg->msg;\n                    }\n                    ++used;\n\n                    if (action == SDL_GETEVENT) {\n                        SDL_CutEvent(entry);\n                    }\n                }\n            }\n        }\n        SDL_UnlockMutex(SDL_EventQ.lock);\n    } else {\n        return SDL_SetError(\"Couldn't lock event queue\");\n    }\n    return (used);\n}\n\nSDL_bool\nSDL_HasEvent(Uint32 type)\n{\n    return (SDL_PeepEvents(NULL, 0, SDL_PEEKEVENT, type, type) > 0);\n}\n\nSDL_bool\nSDL_HasEvents(Uint32 minType, Uint32 maxType)\n{\n    return (SDL_PeepEvents(NULL, 0, SDL_PEEKEVENT, minType, maxType) > 0);\n}\n\nvoid\nSDL_FlushEvent(Uint32 type)\n{\n    SDL_FlushEvents(type, type);\n}\n\nvoid\nSDL_FlushEvents(Uint32 minType, Uint32 maxType)\n{\n    /* Don't look after we've quit */\n    if (!SDL_EventQ.active) {\n        return;\n    }\n\n    /* Make sure the events are current */\n#if 0\n    /* Actually, we can't do this since we might be flushing while processing\n       a resize event, and calling this might trigger further resize events.\n    */\n    SDL_PumpEvents();\n#endif\n\n    /* Lock the event queue */\n    if (SDL_LockMutex(SDL_EventQ.lock) == 0) {\n        SDL_EventEntry *entry, *next;\n        Uint32 type;\n        for (entry = SDL_EventQ.head; entry; entry = next) {\n            next = entry->next;\n            type = entry->event.type;\n            if (minType <= type && type <= maxType) {\n                SDL_CutEvent(entry);\n            }\n        }\n        SDL_UnlockMutex(SDL_EventQ.lock);\n    }\n}\n\n/* Run the system dependent event loops */\nvoid\nSDL_PumpEvents(void)\n{\n    SDL_VideoDevice *_this = SDL_GetVideoDevice();\n\n    /* Get events from the video subsystem */\n    if (_this) {\n        _this->PumpEvents(_this);\n    }\n#if !SDL_JOYSTICK_DISABLED\n    /* Check for joystick state change */\n    if ((!SDL_disabled_events[SDL_JOYAXISMOTION >> 8] || SDL_JoystickEventState(SDL_QUERY))) {\n        SDL_JoystickUpdate();\n    }\n#endif\n}\n\n/* Public functions */\n\nint\nSDL_PollEvent(SDL_Event * event)\n{\n    return SDL_WaitEventTimeout(event, 0);\n}\n\nint\nSDL_WaitEvent(SDL_Event * event)\n{\n    return SDL_WaitEventTimeout(event, -1);\n}\n\nint\nSDL_WaitEventTimeout(SDL_Event * event, int timeout)\n{\n    Uint32 expiration = 0;\n\n    if (timeout > 0)\n        expiration = SDL_GetTicks() + timeout;\n\n    for (;;) {\n        SDL_PumpEvents();\n        switch (SDL_PeepEvents(event, 1, SDL_GETEVENT, SDL_FIRSTEVENT, SDL_LASTEVENT)) {\n        case -1:\n            return 0;\n        case 1:\n            return 1;\n        case 0:\n            if (timeout == 0) {\n                /* Polling and no events, just return */\n                return 0;\n            }\n            if (timeout > 0 && SDL_TICKS_PASSED(SDL_GetTicks(), expiration)) {\n                /* Timeout expired and no events */\n                return 0;\n            }\n            SDL_Delay(10);\n            break;\n        }\n    }\n}\n\nint\nSDL_PushEvent(SDL_Event * event)\n{\n    SDL_EventWatcher *curr;\n\n    event->common.timestamp = SDL_GetTicks();\n\n    if (SDL_EventOK && !SDL_EventOK(SDL_EventOKParam, event)) {\n        return 0;\n    }\n\n    for (curr = SDL_event_watchers; curr; curr = curr->next) {\n        curr->callback(curr->userdata, event);\n    }\n\n    if (SDL_PeepEvents(event, 1, SDL_ADDEVENT, 0, 0) <= 0) {\n        return -1;\n    }\n\n    SDL_GestureProcessEvent(event);\n\n    return 1;\n}\n\nvoid\nSDL_SetEventFilter(SDL_EventFilter filter, void *userdata)\n{\n    /* Set filter and discard pending events */\n    SDL_EventOK = NULL;\n    SDL_FlushEvents(SDL_FIRSTEVENT, SDL_LASTEVENT);\n    SDL_EventOKParam = userdata;\n    SDL_EventOK = filter;\n}\n\nSDL_bool\nSDL_GetEventFilter(SDL_EventFilter * filter, void **userdata)\n{\n    if (filter) {\n        *filter = SDL_EventOK;\n    }\n    if (userdata) {\n        *userdata = SDL_EventOKParam;\n    }\n    return SDL_EventOK ? SDL_TRUE : SDL_FALSE;\n}\n\n/* FIXME: This is not thread-safe yet */\nvoid\nSDL_AddEventWatch(SDL_EventFilter filter, void *userdata)\n{\n    SDL_EventWatcher *watcher, *tail;\n\n    watcher = (SDL_EventWatcher *)SDL_malloc(sizeof(*watcher));\n    if (!watcher) {\n        /* Uh oh... */\n        return;\n    }\n\n    /* create the watcher */\n    watcher->callback = filter;\n    watcher->userdata = userdata;\n    watcher->next = NULL;\n\n    /* add the watcher to the end of the list */\n    if (SDL_event_watchers) {\n        for (tail = SDL_event_watchers; tail->next; tail = tail->next) {\n            continue;\n        }\n        tail->next = watcher;\n    } else {\n        SDL_event_watchers = watcher;\n    }\n}\n\n/* FIXME: This is not thread-safe yet */\nvoid\nSDL_DelEventWatch(SDL_EventFilter filter, void *userdata)\n{\n    SDL_EventWatcher *prev = NULL;\n    SDL_EventWatcher *curr;\n\n    for (curr = SDL_event_watchers; curr; prev = curr, curr = curr->next) {\n        if (curr->callback == filter && curr->userdata == userdata) {\n            if (prev) {\n                prev->next = curr->next;\n            } else {\n                SDL_event_watchers = curr->next;\n            }\n            SDL_free(curr);\n            break;\n        }\n    }\n}\n\nvoid\nSDL_FilterEvents(SDL_EventFilter filter, void *userdata)\n{\n    if (SDL_EventQ.lock && SDL_LockMutex(SDL_EventQ.lock) == 0) {\n        SDL_EventEntry *entry, *next;\n        for (entry = SDL_EventQ.head; entry; entry = next) {\n            next = entry->next;\n            if (!filter(userdata, &entry->event)) {\n                SDL_CutEvent(entry);\n            }\n        }\n        SDL_UnlockMutex(SDL_EventQ.lock);\n    }\n}\n\nUint8\nSDL_EventState(Uint32 type, int state)\n{\n    Uint8 current_state;\n    Uint8 hi = ((type >> 8) & 0xff);\n    Uint8 lo = (type & 0xff);\n\n    if (SDL_disabled_events[hi] &&\n        (SDL_disabled_events[hi]->bits[lo/32] & (1 << (lo&31)))) {\n        current_state = SDL_DISABLE;\n    } else {\n        current_state = SDL_ENABLE;\n    }\n\n    if (state != current_state)\n    {\n        switch (state) {\n        case SDL_DISABLE:\n            /* Disable this event type and discard pending events */\n            if (!SDL_disabled_events[hi]) {\n                SDL_disabled_events[hi] = (SDL_DisabledEventBlock*) SDL_calloc(1, sizeof(SDL_DisabledEventBlock));\n                if (!SDL_disabled_events[hi]) {\n                    /* Out of memory, nothing we can do... */\n                    break;\n                }\n            }\n            SDL_disabled_events[hi]->bits[lo/32] |= (1 << (lo&31));\n            SDL_FlushEvent(type);\n            break;\n        case SDL_ENABLE:\n            SDL_disabled_events[hi]->bits[lo/32] &= ~(1 << (lo&31));\n            break;\n        default:\n            /* Querying state... */\n            break;\n        }\n    }\n\n    return current_state;\n}\n\nUint32\nSDL_RegisterEvents(int numevents)\n{\n    Uint32 event_base;\n\n    if ((numevents > 0) && (SDL_userevents+numevents <= SDL_LASTEVENT)) {\n        event_base = SDL_userevents;\n        SDL_userevents += numevents;\n    } else {\n        event_base = (Uint32)-1;\n    }\n    return event_base;\n}\n\nint\nSDL_SendAppEvent(SDL_EventType eventType)\n{\n    int posted;\n\n    posted = 0;\n    if (SDL_GetEventState(eventType) == SDL_ENABLE) {\n        SDL_Event event;\n        event.type = eventType;\n        posted = (SDL_PushEvent(&event) > 0);\n    }\n    return (posted);\n}\n\nint\nSDL_SendSysWMEvent(SDL_SysWMmsg * message)\n{\n    int posted;\n\n    posted = 0;\n    if (SDL_GetEventState(SDL_SYSWMEVENT) == SDL_ENABLE) {\n        SDL_Event event;\n        SDL_memset(&event, 0, sizeof(event));\n        event.type = SDL_SYSWMEVENT;\n        event.syswm.msg = message;\n        posted = (SDL_PushEvent(&event) > 0);\n    }\n    /* Update internal event state */\n    return (posted);\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n\n#include \"../SDL_internal.h\"\n\n/* General mouse handling code for SDL */\n\n#include \"SDL_events.h\"\n#include \"SDL_events_c.h\"\n#include \"SDL_gesture_c.h\"\n\n/*\n#include <stdio.h>\n*/\n\n/* TODO: Replace with malloc */\n\n#define MAXPATHSIZE 1024\n\n#define DOLLARNPOINTS 64\n#define DOLLARSIZE 256\n\n#define ENABLE_DOLLAR\n\n#define PHI 0.618033989\n\ntypedef struct {\n    float x,y;\n} SDL_FloatPoint;\n\ntypedef struct {\n    float length;\n\n    int numPoints;\n    SDL_FloatPoint p[MAXPATHSIZE];\n} SDL_DollarPath;\n\ntypedef struct {\n    SDL_FloatPoint path[DOLLARNPOINTS];\n    unsigned long hash;\n} SDL_DollarTemplate;\n\ntypedef struct {\n    SDL_TouchID id;\n    SDL_FloatPoint centroid;\n    SDL_DollarPath dollarPath;\n    Uint16 numDownFingers;\n\n    int numDollarTemplates;\n    SDL_DollarTemplate *dollarTemplate;\n\n    SDL_bool recording;\n} SDL_GestureTouch;\n\nSDL_GestureTouch *SDL_gestureTouch;\nint SDL_numGestureTouches = 0;\nSDL_bool recordAll;\n\n#if 0\nstatic void PrintPath(SDL_FloatPoint *path)\n{\n    int i;\n    printf(\"Path:\");\n    for (i=0; i<DOLLARNPOINTS; i++) {\n        printf(\" (%f,%f)\",path[i].x,path[i].y);\n    }\n    printf(\"\\n\");\n}\n#endif\n\nint SDL_RecordGesture(SDL_TouchID touchId)\n{\n    int i;\n    if (touchId < 0) recordAll = SDL_TRUE;\n    for (i = 0; i < SDL_numGestureTouches; i++) {\n        if ((touchId < 0) || (SDL_gestureTouch[i].id == touchId)) {\n            SDL_gestureTouch[i].recording = SDL_TRUE;\n            if (touchId >= 0)\n                return 1;\n        }\n    }\n    return (touchId < 0);\n}\n\nstatic unsigned long SDL_HashDollar(SDL_FloatPoint* points)\n{\n    unsigned long hash = 5381;\n    int i;\n    for (i = 0; i < DOLLARNPOINTS; i++) {\n        hash = ((hash<<5) + hash) + (unsigned long)points[i].x;\n        hash = ((hash<<5) + hash) + (unsigned long)points[i].y;\n    }\n    return hash;\n}\n\n\nstatic int SaveTemplate(SDL_DollarTemplate *templ, SDL_RWops *dst)\n{\n    if (dst == NULL) return 0;\n\n    /* No Longer storing the Hash, rehash on load */\n    /* if (SDL_RWops.write(dst, &(templ->hash), sizeof(templ->hash), 1) != 1) return 0; */\n\n    if (SDL_RWwrite(dst, templ->path,\n                    sizeof(templ->path[0]),DOLLARNPOINTS) != DOLLARNPOINTS)\n        return 0;\n\n    return 1;\n}\n\n\nint SDL_SaveAllDollarTemplates(SDL_RWops *dst)\n{\n    int i,j,rtrn = 0;\n    for (i = 0; i < SDL_numGestureTouches; i++) {\n        SDL_GestureTouch* touch = &SDL_gestureTouch[i];\n        for (j = 0; j < touch->numDollarTemplates; j++) {\n            rtrn += SaveTemplate(&touch->dollarTemplate[j], dst);\n        }\n    }\n    return rtrn;\n}\n\nint SDL_SaveDollarTemplate(SDL_GestureID gestureId, SDL_RWops *dst)\n{\n    int i,j;\n    for (i = 0; i < SDL_numGestureTouches; i++) {\n        SDL_GestureTouch* touch = &SDL_gestureTouch[i];\n        for (j = 0; j < touch->numDollarTemplates; j++) {\n            if (touch->dollarTemplate[j].hash == gestureId) {\n                return SaveTemplate(&touch->dollarTemplate[j], dst);\n            }\n        }\n    }\n    return SDL_SetError(\"Unknown gestureId\");\n}\n\n/* path is an already sampled set of points\nReturns the index of the gesture on success, or -1 */\nstatic int SDL_AddDollarGesture_one(SDL_GestureTouch* inTouch, SDL_FloatPoint* path)\n{\n    SDL_DollarTemplate* dollarTemplate;\n    SDL_DollarTemplate *templ;\n    int index;\n\n    index = inTouch->numDollarTemplates;\n    dollarTemplate =\n        (SDL_DollarTemplate *)SDL_realloc(inTouch->dollarTemplate,\n                                          (index + 1) *\n                                          sizeof(SDL_DollarTemplate));\n    if (!dollarTemplate) {\n        return SDL_OutOfMemory();\n    }\n    inTouch->dollarTemplate = dollarTemplate;\n\n    templ = &inTouch->dollarTemplate[index];\n    SDL_memcpy(templ->path, path, DOLLARNPOINTS*sizeof(SDL_FloatPoint));\n    templ->hash = SDL_HashDollar(templ->path);\n    inTouch->numDollarTemplates++;\n\n    return index;\n}\n\nstatic int SDL_AddDollarGesture(SDL_GestureTouch* inTouch, SDL_FloatPoint* path)\n{\n    int index = -1;\n    int i = 0;\n    if (inTouch == NULL) {\n        if (SDL_numGestureTouches == 0) return -1;\n        for (i = 0; i < SDL_numGestureTouches; i++) {\n            inTouch = &SDL_gestureTouch[i];\n            index = SDL_AddDollarGesture_one(inTouch, path);\n            if (index < 0)\n                return -1;\n        }\n        /* Use the index of the last one added. */\n        return index;\n    }\n    return SDL_AddDollarGesture_one(inTouch, path);\n}\n\nint SDL_LoadDollarTemplates(SDL_TouchID touchId, SDL_RWops *src)\n{\n    int i,loaded = 0;\n    SDL_GestureTouch *touch = NULL;\n    if (src == NULL) return 0;\n    if (touchId >= 0) {\n        for (i = 0; i < SDL_numGestureTouches; i++)\n            if (SDL_gestureTouch[i].id == touchId)\n                touch = &SDL_gestureTouch[i];\n        if (touch == NULL) return -1;\n    }\n\n    while (1) {\n        SDL_DollarTemplate templ;\n\n        if (SDL_RWread(src,templ.path,sizeof(templ.path[0]),DOLLARNPOINTS) <\n           DOLLARNPOINTS) break;\n\n        if (touchId >= 0) {\n            /* printf(\"Adding loaded gesture to 1 touch\\n\"); */\n            if (SDL_AddDollarGesture(touch, templ.path) >= 0)\n                loaded++;\n        }\n        else {\n            /* printf(\"Adding to: %i touches\\n\",SDL_numGestureTouches); */\n            for (i = 0; i < SDL_numGestureTouches; i++) {\n                touch = &SDL_gestureTouch[i];\n                /* printf(\"Adding loaded gesture to + touches\\n\"); */\n                /* TODO: What if this fails? */\n                SDL_AddDollarGesture(touch,templ.path);\n            }\n            loaded++;\n        }\n    }\n\n    return loaded;\n}\n\n\nstatic float dollarDifference(SDL_FloatPoint* points,SDL_FloatPoint* templ,float ang)\n{\n    /*  SDL_FloatPoint p[DOLLARNPOINTS]; */\n    float dist = 0;\n    SDL_FloatPoint p;\n    int i;\n    for (i = 0; i < DOLLARNPOINTS; i++) {\n        p.x = (float)(points[i].x * SDL_cos(ang) - points[i].y * SDL_sin(ang));\n        p.y = (float)(points[i].x * SDL_sin(ang) + points[i].y * SDL_cos(ang));\n        dist += (float)(SDL_sqrt((p.x-templ[i].x)*(p.x-templ[i].x)+\n                                 (p.y-templ[i].y)*(p.y-templ[i].y)));\n    }\n    return dist/DOLLARNPOINTS;\n\n}\n\nstatic float bestDollarDifference(SDL_FloatPoint* points,SDL_FloatPoint* templ)\n{\n    /*------------BEGIN DOLLAR BLACKBOX------------------\n      -TRANSLATED DIRECTLY FROM PSUDEO-CODE AVAILABLE AT-\n      -\"http://depts.washington.edu/aimgroup/proj/dollar/\"\n    */\n    double ta = -M_PI/4;\n    double tb = M_PI/4;\n    double dt = M_PI/90;\n    float x1 = (float)(PHI*ta + (1-PHI)*tb);\n    float f1 = dollarDifference(points,templ,x1);\n    float x2 = (float)((1-PHI)*ta + PHI*tb);\n    float f2 = dollarDifference(points,templ,x2);\n    while (SDL_fabs(ta-tb) > dt) {\n        if (f1 < f2) {\n            tb = x2;\n            x2 = x1;\n            f2 = f1;\n            x1 = (float)(PHI*ta + (1-PHI)*tb);\n            f1 = dollarDifference(points,templ,x1);\n        }\n        else {\n            ta = x1;\n            x1 = x2;\n            f1 = f2;\n            x2 = (float)((1-PHI)*ta + PHI*tb);\n            f2 = dollarDifference(points,templ,x2);\n        }\n    }\n    /*\n      if (f1 <= f2)\n          printf(\"Min angle (x1): %f\\n\",x1);\n      else if (f1 >  f2)\n          printf(\"Min angle (x2): %f\\n\",x2);\n    */\n    return SDL_min(f1,f2);\n}\n\n/* DollarPath contains raw points, plus (possibly) the calculated length */\nstatic int dollarNormalize(const SDL_DollarPath *path,SDL_FloatPoint *points)\n{\n    int i;\n    float interval;\n    float dist;\n    int numPoints = 0;\n    SDL_FloatPoint centroid;\n    float xmin,xmax,ymin,ymax;\n    float ang;\n    float w,h;\n    float length = path->length;\n\n    /* Calculate length if it hasn't already been done */\n    if (length <= 0) {\n        for (i=1;i < path->numPoints; i++) {\n            float dx = path->p[i  ].x - path->p[i-1].x;\n            float dy = path->p[i  ].y - path->p[i-1].y;\n            length += (float)(SDL_sqrt(dx*dx+dy*dy));\n        }\n    }\n\n    /* Resample */\n    interval = length/(DOLLARNPOINTS - 1);\n    dist = interval;\n\n    centroid.x = 0;centroid.y = 0;\n\n    /* printf(\"(%f,%f)\\n\",path->p[path->numPoints-1].x,path->p[path->numPoints-1].y); */\n    for (i = 1; i < path->numPoints; i++) {\n        float d = (float)(SDL_sqrt((path->p[i-1].x-path->p[i].x)*(path->p[i-1].x-path->p[i].x)+\n                                   (path->p[i-1].y-path->p[i].y)*(path->p[i-1].y-path->p[i].y)));\n        /* printf(\"d = %f dist = %f/%f\\n\",d,dist,interval); */\n        while (dist + d > interval) {\n            points[numPoints].x = path->p[i-1].x +\n                ((interval-dist)/d)*(path->p[i].x-path->p[i-1].x);\n            points[numPoints].y = path->p[i-1].y +\n                ((interval-dist)/d)*(path->p[i].y-path->p[i-1].y);\n            centroid.x += points[numPoints].x;\n            centroid.y += points[numPoints].y;\n            numPoints++;\n\n            dist -= interval;\n        }\n        dist += d;\n    }\n    if (numPoints < DOLLARNPOINTS-1) {\n        SDL_SetError(\"ERROR: NumPoints = %i\\n\",numPoints);\n        return 0;\n    }\n    /* copy the last point */\n    points[DOLLARNPOINTS-1] = path->p[path->numPoints-1];\n    numPoints = DOLLARNPOINTS;\n\n    centroid.x /= numPoints;\n    centroid.y /= numPoints;\n\n    /* printf(\"Centroid (%f,%f)\",centroid.x,centroid.y); */\n    /* Rotate Points so point 0 is left of centroid and solve for the bounding box */\n    xmin = centroid.x;\n    xmax = centroid.x;\n    ymin = centroid.y;\n    ymax = centroid.y;\n\n    ang = (float)(SDL_atan2(centroid.y - points[0].y,\n                            centroid.x - points[0].x));\n\n    for (i = 0; i<numPoints; i++) {\n        float px = points[i].x;\n        float py = points[i].y;\n        points[i].x = (float)((px - centroid.x)*SDL_cos(ang) -\n                              (py - centroid.y)*SDL_sin(ang) + centroid.x);\n        points[i].y = (float)((px - centroid.x)*SDL_sin(ang) +\n                              (py - centroid.y)*SDL_cos(ang) + centroid.y);\n\n\n        if (points[i].x < xmin) xmin = points[i].x;\n        if (points[i].x > xmax) xmax = points[i].x;\n        if (points[i].y < ymin) ymin = points[i].y;\n        if (points[i].y > ymax) ymax = points[i].y;\n    }\n\n    /* Scale points to DOLLARSIZE, and translate to the origin */\n    w = xmax-xmin;\n    h = ymax-ymin;\n\n    for (i=0; i<numPoints; i++) {\n        points[i].x = (points[i].x - centroid.x)*DOLLARSIZE/w;\n        points[i].y = (points[i].y - centroid.y)*DOLLARSIZE/h;\n    }\n    return numPoints;\n}\n\nstatic float dollarRecognize(const SDL_DollarPath *path,int *bestTempl,SDL_GestureTouch* touch)\n{\n    SDL_FloatPoint points[DOLLARNPOINTS];\n    int i;\n    float bestDiff = 10000;\n\n    SDL_memset(points, 0, sizeof(points));\n\n    dollarNormalize(path,points);\n\n    /* PrintPath(points); */\n    *bestTempl = -1;\n    for (i = 0; i < touch->numDollarTemplates; i++) {\n        float diff = bestDollarDifference(points,touch->dollarTemplate[i].path);\n        if (diff < bestDiff) {bestDiff = diff; *bestTempl = i;}\n    }\n    return bestDiff;\n}\n\nint SDL_GestureAddTouch(SDL_TouchID touchId)\n{\n    SDL_GestureTouch *gestureTouch = (SDL_GestureTouch *)SDL_realloc(SDL_gestureTouch,\n                                                                     (SDL_numGestureTouches + 1) *\n                                                                     sizeof(SDL_GestureTouch));\n\n    if (!gestureTouch) {\n        return SDL_OutOfMemory();\n    }\n\n    SDL_gestureTouch = gestureTouch;\n\n    SDL_zero(SDL_gestureTouch[SDL_numGestureTouches]);\n    SDL_gestureTouch[SDL_numGestureTouches].id = touchId;\n    SDL_numGestureTouches++;\n    return 0;\n}\n\nstatic SDL_GestureTouch * SDL_GetGestureTouch(SDL_TouchID id)\n{\n    int i;\n    for (i = 0; i < SDL_numGestureTouches; i++) {\n        /* printf(\"%i ?= %i\\n\",SDL_gestureTouch[i].id,id); */\n        if (SDL_gestureTouch[i].id == id)\n            return &SDL_gestureTouch[i];\n    }\n    return NULL;\n}\n\nint SDL_SendGestureMulti(SDL_GestureTouch* touch,float dTheta,float dDist)\n{\n    SDL_Event event;\n    event.mgesture.type = SDL_MULTIGESTURE;\n    event.mgesture.touchId = touch->id;\n    event.mgesture.x = touch->centroid.x;\n    event.mgesture.y = touch->centroid.y;\n    event.mgesture.dTheta = dTheta;\n    event.mgesture.dDist = dDist;\n    event.mgesture.numFingers = touch->numDownFingers;\n    return SDL_PushEvent(&event) > 0;\n}\n\nstatic int SDL_SendGestureDollar(SDL_GestureTouch* touch,\n                          SDL_GestureID gestureId,float error)\n{\n    SDL_Event event;\n    event.dgesture.type = SDL_DOLLARGESTURE;\n    event.dgesture.touchId = touch->id;\n    event.dgesture.x = touch->centroid.x;\n    event.dgesture.y = touch->centroid.y;\n    event.dgesture.gestureId = gestureId;\n    event.dgesture.error = error;\n    /* A finger came up to trigger this event. */\n    event.dgesture.numFingers = touch->numDownFingers + 1;\n    return SDL_PushEvent(&event) > 0;\n}\n\n\nstatic int SDL_SendDollarRecord(SDL_GestureTouch* touch,SDL_GestureID gestureId)\n{\n    SDL_Event event;\n    event.dgesture.type = SDL_DOLLARRECORD;\n    event.dgesture.touchId = touch->id;\n    event.dgesture.gestureId = gestureId;\n    return SDL_PushEvent(&event) > 0;\n}\n\n\nvoid SDL_GestureProcessEvent(SDL_Event* event)\n{\n    float x,y;\n    int index;\n    int i;\n    float pathDx, pathDy;\n    SDL_FloatPoint lastP;\n    SDL_FloatPoint lastCentroid;\n    float lDist;\n    float Dist;\n    float dtheta;\n    float dDist;\n\n    if (event->type == SDL_FINGERMOTION ||\n        event->type == SDL_FINGERDOWN ||\n        event->type == SDL_FINGERUP) {\n        SDL_GestureTouch* inTouch = SDL_GetGestureTouch(event->tfinger.touchId);\n\n        /* Shouldn't be possible */\n        if (inTouch == NULL) return;\n\n        x = event->tfinger.x;\n        y = event->tfinger.y;\n\n        /* Finger Up */\n        if (event->type == SDL_FINGERUP) {\n            SDL_FloatPoint path[DOLLARNPOINTS];\n\n            inTouch->numDownFingers--;\n\n#ifdef ENABLE_DOLLAR\n            if (inTouch->recording) {\n                inTouch->recording = SDL_FALSE;\n                dollarNormalize(&inTouch->dollarPath,path);\n                /* PrintPath(path); */\n                if (recordAll) {\n                    index = SDL_AddDollarGesture(NULL,path);\n                    for (i = 0; i < SDL_numGestureTouches; i++)\n                        SDL_gestureTouch[i].recording = SDL_FALSE;\n                }\n                else {\n                    index = SDL_AddDollarGesture(inTouch,path);\n                }\n\n                if (index >= 0) {\n                    SDL_SendDollarRecord(inTouch,inTouch->dollarTemplate[index].hash);\n                }\n                else {\n                    SDL_SendDollarRecord(inTouch,-1);\n                }\n            }\n            else {\n                int bestTempl;\n                float error;\n                error = dollarRecognize(&inTouch->dollarPath,\n                                        &bestTempl,inTouch);\n                if (bestTempl >= 0){\n                    /* Send Event */\n                    unsigned long gestureId = inTouch->dollarTemplate[bestTempl].hash;\n                    SDL_SendGestureDollar(inTouch,gestureId,error);\n                    /* printf (\"%s\\n\",);(\"Dollar error: %f\\n\",error); */\n                }\n            }\n#endif\n            /* inTouch->gestureLast[j] = inTouch->gestureLast[inTouch->numDownFingers]; */\n            if (inTouch->numDownFingers > 0) {\n                inTouch->centroid.x = (inTouch->centroid.x*(inTouch->numDownFingers+1)-\n                                       x)/inTouch->numDownFingers;\n                inTouch->centroid.y = (inTouch->centroid.y*(inTouch->numDownFingers+1)-\n                                       y)/inTouch->numDownFingers;\n            }\n        }\n        else if (event->type == SDL_FINGERMOTION) {\n            float dx = event->tfinger.dx;\n            float dy = event->tfinger.dy;\n#ifdef ENABLE_DOLLAR\n            SDL_DollarPath* path = &inTouch->dollarPath;\n            if (path->numPoints < MAXPATHSIZE) {\n                path->p[path->numPoints].x = inTouch->centroid.x;\n                path->p[path->numPoints].y = inTouch->centroid.y;\n                pathDx =\n                    (path->p[path->numPoints].x-path->p[path->numPoints-1].x);\n                pathDy =\n                    (path->p[path->numPoints].y-path->p[path->numPoints-1].y);\n                path->length += (float)SDL_sqrt(pathDx*pathDx + pathDy*pathDy);\n                path->numPoints++;\n            }\n#endif\n            lastP.x = x - dx;\n            lastP.y = y - dy;\n            lastCentroid = inTouch->centroid;\n\n            inTouch->centroid.x += dx/inTouch->numDownFingers;\n            inTouch->centroid.y += dy/inTouch->numDownFingers;\n            /* printf(\"Centrid : (%f,%f)\\n\",inTouch->centroid.x,inTouch->centroid.y); */\n            if (inTouch->numDownFingers > 1) {\n                SDL_FloatPoint lv; /* Vector from centroid to last x,y position */\n                SDL_FloatPoint v; /* Vector from centroid to current x,y position */\n                /* lv = inTouch->gestureLast[j].cv; */\n                lv.x = lastP.x - lastCentroid.x;\n                lv.y = lastP.y - lastCentroid.y;\n                lDist = (float)SDL_sqrt(lv.x*lv.x + lv.y*lv.y);\n                /* printf(\"lDist = %f\\n\",lDist); */\n                v.x = x - inTouch->centroid.x;\n                v.y = y - inTouch->centroid.y;\n                /* inTouch->gestureLast[j].cv = v; */\n                Dist = (float)SDL_sqrt(v.x*v.x+v.y*v.y);\n                /* SDL_cos(dTheta) = (v . lv)/(|v| * |lv|) */\n\n                /* Normalize Vectors to simplify angle calculation */\n                lv.x/=lDist;\n                lv.y/=lDist;\n                v.x/=Dist;\n                v.y/=Dist;\n                dtheta = (float)SDL_atan2(lv.x*v.y - lv.y*v.x,lv.x*v.x + lv.y*v.y);\n\n                dDist = (Dist - lDist);\n                if (lDist == 0) {dDist = 0;dtheta = 0;} /* To avoid impossible values */\n\n                /* inTouch->gestureLast[j].dDist = dDist;\n                inTouch->gestureLast[j].dtheta = dtheta;\n\n                printf(\"dDist = %f, dTheta = %f\\n\",dDist,dtheta);\n                gdtheta = gdtheta*.9 + dtheta*.1;\n                gdDist  =  gdDist*.9 +  dDist*.1\n                knob.r += dDist/numDownFingers;\n                knob.ang += dtheta;\n                printf(\"thetaSum = %f, distSum = %f\\n\",gdtheta,gdDist);\n                printf(\"id: %i dTheta = %f, dDist = %f\\n\",j,dtheta,dDist); */\n                SDL_SendGestureMulti(inTouch,dtheta,dDist);\n            }\n            else {\n                /* inTouch->gestureLast[j].dDist = 0;\n                inTouch->gestureLast[j].dtheta = 0;\n                inTouch->gestureLast[j].cv.x = 0;\n                inTouch->gestureLast[j].cv.y = 0; */\n            }\n            /* inTouch->gestureLast[j].f.p.x = x;\n            inTouch->gestureLast[j].f.p.y = y;\n            break;\n            pressure? */\n        }\n\n        if (event->type == SDL_FINGERDOWN) {\n\n            inTouch->numDownFingers++;\n            inTouch->centroid.x = (inTouch->centroid.x*(inTouch->numDownFingers - 1)+\n                                   x)/inTouch->numDownFingers;\n            inTouch->centroid.y = (inTouch->centroid.y*(inTouch->numDownFingers - 1)+\n                                   y)/inTouch->numDownFingers;\n            /* printf(\"Finger Down: (%f,%f). Centroid: (%f,%f\\n\",x,y,\n                 inTouch->centroid.x,inTouch->centroid.y); */\n\n#ifdef ENABLE_DOLLAR\n            inTouch->dollarPath.length = 0;\n            inTouch->dollarPath.p[0].x = x;\n            inTouch->dollarPath.p[0].y = y;\n            inTouch->dollarPath.numPoints = 1;\n#endif\n        }\n    }\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../SDL_internal.h\"\n\n/* The SDL 2D rendering system */\n\n#include \"SDL_assert.h\"\n#include \"SDL_hints.h\"\n#include \"SDL_log.h\"\n#include \"SDL_render.h\"\n#include \"SDL_sysrender.h\"\n#include \"software/SDL_render_sw_c.h\"\n\n\n#define SDL_WINDOWRENDERDATA    \"_SDL_WindowRenderData\"\n\n#define CHECK_RENDERER_MAGIC(renderer, retval) \\\n    if (!renderer || renderer->magic != &renderer_magic) { \\\n        SDL_SetError(\"Invalid renderer\"); \\\n        return retval; \\\n    }\n\n#define CHECK_TEXTURE_MAGIC(texture, retval) \\\n    if (!texture || texture->magic != &texture_magic) { \\\n        SDL_SetError(\"Invalid texture\"); \\\n        return retval; \\\n    }\n\n\n#if !SDL_RENDER_DISABLED\nstatic const SDL_RenderDriver *render_drivers[] = {\n#if SDL_VIDEO_RENDER_D3D\n    &D3D_RenderDriver,\n#endif\n#if SDL_VIDEO_RENDER_D3D11\n    &D3D11_RenderDriver,\n#endif\n#if SDL_VIDEO_RENDER_OGL\n    &GL_RenderDriver,\n#endif\n#if SDL_VIDEO_RENDER_OGL_ES2\n    &GLES2_RenderDriver,\n#endif\n#if SDL_VIDEO_RENDER_OGL_ES\n    &GLES_RenderDriver,\n#endif\n#if SDL_VIDEO_RENDER_DIRECTFB\n    &DirectFB_RenderDriver,\n#endif\n#if SDL_VIDEO_RENDER_PSP\n    &PSP_RenderDriver,\n#endif\n    &SW_RenderDriver\n};\n#endif /* !SDL_RENDER_DISABLED */\n\nstatic char renderer_magic;\nstatic char texture_magic;\n\nstatic int UpdateLogicalSize(SDL_Renderer *renderer);\n\nint\nSDL_GetNumRenderDrivers(void)\n{\n#if !SDL_RENDER_DISABLED\n    return SDL_arraysize(render_drivers);\n#else\n    return 0;\n#endif\n}\n\nint\nSDL_GetRenderDriverInfo(int index, SDL_RendererInfo * info)\n{\n#if !SDL_RENDER_DISABLED\n    if (index < 0 || index >= SDL_GetNumRenderDrivers()) {\n        return SDL_SetError(\"index must be in the range of 0 - %d\",\n                            SDL_GetNumRenderDrivers() - 1);\n    }\n    *info = render_drivers[index]->info;\n    return 0;\n#else\n    return SDL_SetError(\"SDL not built with rendering support\");\n#endif\n}\n\nstatic int\nSDL_RendererEventWatch(void *userdata, SDL_Event *event)\n{\n    SDL_Renderer *renderer = (SDL_Renderer *)userdata;\n\n    if (event->type == SDL_WINDOWEVENT) {\n        SDL_Window *window = SDL_GetWindowFromID(event->window.windowID);\n        if (window == renderer->window) {\n            if (renderer->WindowEvent) {\n                renderer->WindowEvent(renderer, &event->window);\n            }\n\n            if (event->window.event == SDL_WINDOWEVENT_SIZE_CHANGED) {\n                /* Make sure we're operating on the default render target */\n                SDL_Texture *saved_target = SDL_GetRenderTarget(renderer);\n                if (saved_target) {\n                    SDL_SetRenderTarget(renderer, NULL);\n                }\n\n                if (renderer->logical_w) {\n                    UpdateLogicalSize(renderer);\n                } else {\n                    /* Window was resized, reset viewport */\n                    int w, h;\n\n                    if (renderer->GetOutputSize) {\n                        renderer->GetOutputSize(renderer, &w, &h);\n                    } else {\n                        SDL_GetWindowSize(renderer->window, &w, &h);\n                    }\n\n                    if (renderer->target) {\n                        renderer->viewport_backup.x = 0;\n                        renderer->viewport_backup.y = 0;\n                        renderer->viewport_backup.w = w;\n                        renderer->viewport_backup.h = h;\n                    } else {\n                        renderer->viewport.x = 0;\n                        renderer->viewport.y = 0;\n                        renderer->viewport.w = w;\n                        renderer->viewport.h = h;\n                        renderer->UpdateViewport(renderer);\n                    }\n                }\n\n                if (saved_target) {\n                    SDL_SetRenderTarget(renderer, saved_target);\n                }\n            } else if (event->window.event == SDL_WINDOWEVENT_HIDDEN) {\n                renderer->hidden = SDL_TRUE;\n            } else if (event->window.event == SDL_WINDOWEVENT_SHOWN) {\n                if (!(SDL_GetWindowFlags(window) & SDL_WINDOW_MINIMIZED)) {\n                    renderer->hidden = SDL_FALSE;\n                }\n            } else if (event->window.event == SDL_WINDOWEVENT_MINIMIZED) {\n                renderer->hidden = SDL_TRUE;\n            } else if (event->window.event == SDL_WINDOWEVENT_RESTORED) {\n                if (!(SDL_GetWindowFlags(window) & SDL_WINDOW_HIDDEN)) {\n                    renderer->hidden = SDL_FALSE;\n                }\n            }\n        }\n    } else if (event->type == SDL_MOUSEMOTION) {\n        if (renderer->logical_w) {\n            event->motion.x -= renderer->viewport.x;\n            event->motion.y -= renderer->viewport.y;\n            event->motion.x = (int)(event->motion.x / renderer->scale.x);\n            event->motion.y = (int)(event->motion.y / renderer->scale.y);\n            if (event->motion.xrel > 0) {\n                event->motion.xrel = SDL_max(1, (int)(event->motion.xrel / renderer->scale.x));\n            } else if (event->motion.xrel < 0) {\n                event->motion.xrel = SDL_min(-1, (int)(event->motion.xrel / renderer->scale.x));\n            }\n            if (event->motion.yrel > 0) {\n                event->motion.yrel = SDL_max(1, (int)(event->motion.yrel / renderer->scale.y));\n            } else if (event->motion.yrel < 0) {\n                event->motion.yrel = SDL_min(-1, (int)(event->motion.yrel / renderer->scale.y));\n            }\n        }\n    } else if (event->type == SDL_MOUSEBUTTONDOWN ||\n               event->type == SDL_MOUSEBUTTONUP) {\n        if (renderer->logical_w) {\n            event->button.x -= renderer->viewport.x;\n            event->button.y -= renderer->viewport.y;\n            event->button.x = (int)(event->button.x / renderer->scale.x);\n            event->button.y = (int)(event->button.y / renderer->scale.y);\n        }\n    }\n    return 0;\n}\n\nint\nSDL_CreateWindowAndRenderer(int width, int height, Uint32 window_flags,\n                            SDL_Window **window, SDL_Renderer **renderer)\n{\n    *window = SDL_CreateWindow(NULL, SDL_WINDOWPOS_UNDEFINED,\n                                     SDL_WINDOWPOS_UNDEFINED,\n                                     width, height, window_flags);\n    if (!*window) {\n        *renderer = NULL;\n        return -1;\n    }\n\n    *renderer = SDL_CreateRenderer(*window, -1, 0);\n    if (!*renderer) {\n        return -1;\n    }\n\n    return 0;\n}\n\nSDL_Renderer *\nSDL_CreateRenderer(SDL_Window * window, int index, Uint32 flags)\n{\n#if !SDL_RENDER_DISABLED\n    SDL_Renderer *renderer = NULL;\n    int n = SDL_GetNumRenderDrivers();\n    const char *hint;\n\n    if (!window) {\n        SDL_SetError(\"Invalid window\");\n        return NULL;\n    }\n\n    if (SDL_GetRenderer(window)) {\n        SDL_SetError(\"Renderer already associated with window\");\n        return NULL;\n    }\n\n    hint = SDL_GetHint(SDL_HINT_RENDER_VSYNC);\n    if (hint) {\n        if (*hint == '0') {\n            flags &= ~SDL_RENDERER_PRESENTVSYNC;\n        } else {\n            flags |= SDL_RENDERER_PRESENTVSYNC;\n        }\n    }\n\n    if (index < 0) {\n        hint = SDL_GetHint(SDL_HINT_RENDER_DRIVER);\n        if (hint) {\n            for (index = 0; index < n; ++index) {\n                const SDL_RenderDriver *driver = render_drivers[index];\n\n                if (SDL_strcasecmp(hint, driver->info.name) == 0) {\n                    /* Create a new renderer instance */\n                    renderer = driver->CreateRenderer(window, flags);\n                    break;\n                }\n            }\n        }\n\n        if (!renderer) {\n            for (index = 0; index < n; ++index) {\n                const SDL_RenderDriver *driver = render_drivers[index];\n\n                if ((driver->info.flags & flags) == flags) {\n                    /* Create a new renderer instance */\n                    renderer = driver->CreateRenderer(window, flags);\n                    if (renderer) {\n                        /* Yay, we got one! */\n                        break;\n                    }\n                }\n            }\n        }\n        if (index == n) {\n            SDL_SetError(\"Couldn't find matching render driver\");\n            return NULL;\n        }\n    } else {\n        if (index >= SDL_GetNumRenderDrivers()) {\n            SDL_SetError(\"index must be -1 or in the range of 0 - %d\",\n                         SDL_GetNumRenderDrivers() - 1);\n            return NULL;\n        }\n        /* Create a new renderer instance */\n        renderer = render_drivers[index]->CreateRenderer(window, flags);\n    }\n\n    if (renderer) {\n        renderer->magic = &renderer_magic;\n        renderer->window = window;\n        renderer->scale.x = 1.0f;\n        renderer->scale.y = 1.0f;\n\n        if (SDL_GetWindowFlags(window) & (SDL_WINDOW_HIDDEN|SDL_WINDOW_MINIMIZED)) {\n            renderer->hidden = SDL_TRUE;\n        } else {\n            renderer->hidden = SDL_FALSE;\n        }\n\n        SDL_SetWindowData(window, SDL_WINDOWRENDERDATA, renderer);\n\n        SDL_RenderSetViewport(renderer, NULL);\n\n        SDL_AddEventWatch(SDL_RendererEventWatch, renderer);\n\n        SDL_LogInfo(SDL_LOG_CATEGORY_RENDER,\n                    \"Created renderer: %s\", renderer->info.name);\n    }\n    return renderer;\n#else\n    SDL_SetError(\"SDL not built with rendering support\");\n    return NULL;\n#endif\n}\n\nSDL_Renderer *\nSDL_CreateSoftwareRenderer(SDL_Surface * surface)\n{\n#if !SDL_RENDER_DISABLED\n    SDL_Renderer *renderer;\n\n    renderer = SW_CreateRendererForSurface(surface);\n\n    if (renderer) {\n        renderer->magic = &renderer_magic;\n        renderer->scale.x = 1.0f;\n        renderer->scale.y = 1.0f;\n\n        SDL_RenderSetViewport(renderer, NULL);\n    }\n    return renderer;\n#else\n    SDL_SetError(\"SDL not built with rendering support\");\n    return NULL;\n#endif /* !SDL_RENDER_DISABLED */\n}\n\nSDL_Renderer *\nSDL_GetRenderer(SDL_Window * window)\n{\n    return (SDL_Renderer *)SDL_GetWindowData(window, SDL_WINDOWRENDERDATA);\n}\n\nint\nSDL_GetRendererInfo(SDL_Renderer * renderer, SDL_RendererInfo * info)\n{\n    CHECK_RENDERER_MAGIC(renderer, -1);\n\n    *info = renderer->info;\n    return 0;\n}\n\nint\nSDL_GetRendererOutputSize(SDL_Renderer * renderer, int *w, int *h)\n{\n    CHECK_RENDERER_MAGIC(renderer, -1);\n\n    if (renderer->target) {\n        return SDL_QueryTexture(renderer->target, NULL, NULL, w, h);\n    } else if (renderer->GetOutputSize) {\n        return renderer->GetOutputSize(renderer, w, h);\n    } else if (renderer->window) {\n        SDL_GetWindowSize(renderer->window, w, h);\n        return 0;\n    } else {\n        SDL_assert(0 && \"This should never happen\");\n        return SDL_SetError(\"Renderer doesn't support querying output size\");\n    }\n}\n\nstatic SDL_bool\nIsSupportedFormat(SDL_Renderer * renderer, Uint32 format)\n{\n    Uint32 i;\n\n    for (i = 0; i < renderer->info.num_texture_formats; ++i) {\n        if (renderer->info.texture_formats[i] == format) {\n            return SDL_TRUE;\n        }\n    }\n    return SDL_FALSE;\n}\n\nstatic Uint32\nGetClosestSupportedFormat(SDL_Renderer * renderer, Uint32 format)\n{\n    Uint32 i;\n\n    if (SDL_ISPIXELFORMAT_FOURCC(format)) {\n        /* Look for an exact match */\n        for (i = 0; i < renderer->info.num_texture_formats; ++i) {\n            if (renderer->info.texture_formats[i] == format) {\n                return renderer->info.texture_formats[i];\n            }\n        }\n    } else {\n        SDL_bool hasAlpha = SDL_ISPIXELFORMAT_ALPHA(format);\n\n        /* We just want to match the first format that has the same channels */\n        for (i = 0; i < renderer->info.num_texture_formats; ++i) {\n            if (!SDL_ISPIXELFORMAT_FOURCC(renderer->info.texture_formats[i]) &&\n                SDL_ISPIXELFORMAT_ALPHA(renderer->info.texture_formats[i]) == hasAlpha) {\n                return renderer->info.texture_formats[i];\n            }\n        }\n    }\n    return renderer->info.texture_formats[0];\n}\n\nSDL_Texture *\nSDL_CreateTexture(SDL_Renderer * renderer, Uint32 format, int access, int w, int h)\n{\n    SDL_Texture *texture;\n\n    CHECK_RENDERER_MAGIC(renderer, NULL);\n\n    if (!format) {\n        format = renderer->info.texture_formats[0];\n    }\n    if (SDL_BYTESPERPIXEL(format) == 0) {\n        SDL_SetError(\"Invalid texture format\");\n        return NULL;\n    }\n    if (SDL_ISPIXELFORMAT_INDEXED(format)) {\n        SDL_SetError(\"Palettized textures are not supported\");\n        return NULL;\n    }\n    if (w <= 0 || h <= 0) {\n        SDL_SetError(\"Texture dimensions can't be 0\");\n        return NULL;\n    }\n    if ((renderer->info.max_texture_width && w > renderer->info.max_texture_width) ||\n        (renderer->info.max_texture_height && h > renderer->info.max_texture_height)) {\n        SDL_SetError(\"Texture dimensions are limited to %dx%d\", renderer->info.max_texture_width, renderer->info.max_texture_height);\n        return NULL;\n    }\n    texture = (SDL_Texture *) SDL_calloc(1, sizeof(*texture));\n    if (!texture) {\n        SDL_OutOfMemory();\n        return NULL;\n    }\n    texture->magic = &texture_magic;\n    texture->format = format;\n    texture->access = access;\n    texture->w = w;\n    texture->h = h;\n    texture->r = 255;\n    texture->g = 255;\n    texture->b = 255;\n    texture->a = 255;\n    texture->renderer = renderer;\n    texture->next = renderer->textures;\n    if (renderer->textures) {\n        renderer->textures->prev = texture;\n    }\n    renderer->textures = texture;\n\n    if (IsSupportedFormat(renderer, format)) {\n        if (renderer->CreateTexture(renderer, texture) < 0) {\n            SDL_DestroyTexture(texture);\n            return 0;\n        }\n    } else {\n        texture->native = SDL_CreateTexture(renderer,\n                                GetClosestSupportedFormat(renderer, format),\n                                access, w, h);\n        if (!texture->native) {\n            SDL_DestroyTexture(texture);\n            return NULL;\n        }\n\n        /* Swap textures to have texture before texture->native in the list */\n        texture->native->next = texture->next;\n        if (texture->native->next) {\n            texture->native->next->prev = texture->native;\n        }\n        texture->prev = texture->native->prev;\n        if (texture->prev) {\n            texture->prev->next = texture;\n        }\n        texture->native->prev = texture;\n        texture->next = texture->native;\n        renderer->textures = texture;\n\n        if (SDL_ISPIXELFORMAT_FOURCC(texture->format)) {\n            texture->yuv = SDL_SW_CreateYUVTexture(format, w, h);\n            if (!texture->yuv) {\n                SDL_DestroyTexture(texture);\n                return NULL;\n            }\n        } else if (access == SDL_TEXTUREACCESS_STREAMING) {\n            /* The pitch is 4 byte aligned */\n            texture->pitch = (((w * SDL_BYTESPERPIXEL(format)) + 3) & ~3);\n            texture->pixels = SDL_calloc(1, texture->pitch * h);\n            if (!texture->pixels) {\n                SDL_DestroyTexture(texture);\n                return NULL;\n            }\n        }\n    }\n    return texture;\n}\n\nSDL_Texture *\nSDL_CreateTextureFromSurface(SDL_Renderer * renderer, SDL_Surface * surface)\n{\n    const SDL_PixelFormat *fmt;\n    SDL_bool needAlpha;\n    Uint32 i;\n    Uint32 format;\n    SDL_Texture *texture;\n\n    CHECK_RENDERER_MAGIC(renderer, NULL);\n\n    if (!surface) {\n        SDL_SetError(\"SDL_CreateTextureFromSurface() passed NULL surface\");\n        return NULL;\n    }\n\n    /* See what the best texture format is */\n    fmt = surface->format;\n    if (fmt->Amask || SDL_GetColorKey(surface, NULL) == 0) {\n        needAlpha = SDL_TRUE;\n    } else {\n        needAlpha = SDL_FALSE;\n    }\n    format = renderer->info.texture_formats[0];\n    for (i = 0; i < renderer->info.num_texture_formats; ++i) {\n        if (!SDL_ISPIXELFORMAT_FOURCC(renderer->info.texture_formats[i]) &&\n            SDL_ISPIXELFORMAT_ALPHA(renderer->info.texture_formats[i]) == needAlpha) {\n            format = renderer->info.texture_formats[i];\n            break;\n        }\n    }\n\n    texture = SDL_CreateTexture(renderer, format, SDL_TEXTUREACCESS_STATIC,\n                                surface->w, surface->h);\n    if (!texture) {\n        return NULL;\n    }\n\n    if (format == surface->format->format) {\n        if (SDL_MUSTLOCK(surface)) {\n            SDL_LockSurface(surface);\n            SDL_UpdateTexture(texture, NULL, surface->pixels, surface->pitch);\n            SDL_UnlockSurface(surface);\n        } else {\n            SDL_UpdateTexture(texture, NULL, surface->pixels, surface->pitch);\n        }\n    } else {\n        SDL_PixelFormat *dst_fmt;\n        SDL_Surface *temp = NULL;\n\n        /* Set up a destination surface for the texture update */\n        dst_fmt = SDL_AllocFormat(format);\n        if (!dst_fmt) {\n           SDL_DestroyTexture(texture);\n           return NULL;\n        }\n        temp = SDL_ConvertSurface(surface, dst_fmt, 0);\n        SDL_FreeFormat(dst_fmt);\n        if (temp) {\n            SDL_UpdateTexture(texture, NULL, temp->pixels, temp->pitch);\n            SDL_FreeSurface(temp);\n        } else {\n            SDL_DestroyTexture(texture);\n            return NULL;\n        }\n    }\n\n    {\n        Uint8 r, g, b, a;\n        SDL_BlendMode blendMode;\n\n        SDL_GetSurfaceColorMod(surface, &r, &g, &b);\n        SDL_SetTextureColorMod(texture, r, g, b);\n\n        SDL_GetSurfaceAlphaMod(surface, &a);\n        SDL_SetTextureAlphaMod(texture, a);\n\n        if (SDL_GetColorKey(surface, NULL) == 0) {\n            /* We converted to a texture with alpha format */\n            SDL_SetTextureBlendMode(texture, SDL_BLENDMODE_BLEND);\n        } else {\n            SDL_GetSurfaceBlendMode(surface, &blendMode);\n            SDL_SetTextureBlendMode(texture, blendMode);\n        }\n    }\n    return texture;\n}\n\nint\nSDL_QueryTexture(SDL_Texture * texture, Uint32 * format, int *access,\n                 int *w, int *h)\n{\n    CHECK_TEXTURE_MAGIC(texture, -1);\n\n    if (format) {\n        *format = texture->format;\n    }\n    if (access) {\n        *access = texture->access;\n    }\n    if (w) {\n        *w = texture->w;\n    }\n    if (h) {\n        *h = texture->h;\n    }\n    return 0;\n}\n\nint\nSDL_SetTextureColorMod(SDL_Texture * texture, Uint8 r, Uint8 g, Uint8 b)\n{\n    SDL_Renderer *renderer;\n\n    CHECK_TEXTURE_MAGIC(texture, -1);\n\n    renderer = texture->renderer;\n    if (r < 255 || g < 255 || b < 255) {\n        texture->modMode |= SDL_TEXTUREMODULATE_COLOR;\n    } else {\n        texture->modMode &= ~SDL_TEXTUREMODULATE_COLOR;\n    }\n    texture->r = r;\n    texture->g = g;\n    texture->b = b;\n    if (texture->native) {\n        return SDL_SetTextureColorMod(texture->native, r, g, b);\n    } else if (renderer->SetTextureColorMod) {\n        return renderer->SetTextureColorMod(renderer, texture);\n    } else {\n        return 0;\n    }\n}\n\nint\nSDL_GetTextureColorMod(SDL_Texture * texture, Uint8 * r, Uint8 * g,\n                       Uint8 * b)\n{\n    CHECK_TEXTURE_MAGIC(texture, -1);\n\n    if (r) {\n        *r = texture->r;\n    }\n    if (g) {\n        *g = texture->g;\n    }\n    if (b) {\n        *b = texture->b;\n    }\n    return 0;\n}\n\nint\nSDL_SetTextureAlphaMod(SDL_Texture * texture, Uint8 alpha)\n{\n    SDL_Renderer *renderer;\n\n    CHECK_TEXTURE_MAGIC(texture, -1);\n\n    renderer = texture->renderer;\n    if (alpha < 255) {\n        texture->modMode |= SDL_TEXTUREMODULATE_ALPHA;\n    } else {\n        texture->modMode &= ~SDL_TEXTUREMODULATE_ALPHA;\n    }\n    texture->a = alpha;\n    if (texture->native) {\n        return SDL_SetTextureAlphaMod(texture->native, alpha);\n    } else if (renderer->SetTextureAlphaMod) {\n        return renderer->SetTextureAlphaMod(renderer, texture);\n    } else {\n        return 0;\n    }\n}\n\nint\nSDL_GetTextureAlphaMod(SDL_Texture * texture, Uint8 * alpha)\n{\n    CHECK_TEXTURE_MAGIC(texture, -1);\n\n    if (alpha) {\n        *alpha = texture->a;\n    }\n    return 0;\n}\n\nint\nSDL_SetTextureBlendMode(SDL_Texture * texture, SDL_BlendMode blendMode)\n{\n    SDL_Renderer *renderer;\n\n    CHECK_TEXTURE_MAGIC(texture, -1);\n\n    renderer = texture->renderer;\n    texture->blendMode = blendMode;\n    if (texture->native) {\n        return SDL_SetTextureBlendMode(texture->native, blendMode);\n    } else if (renderer->SetTextureBlendMode) {\n        return renderer->SetTextureBlendMode(renderer, texture);\n    } else {\n        return 0;\n    }\n}\n\nint\nSDL_GetTextureBlendMode(SDL_Texture * texture, SDL_BlendMode *blendMode)\n{\n    CHECK_TEXTURE_MAGIC(texture, -1);\n\n    if (blendMode) {\n        *blendMode = texture->blendMode;\n    }\n    return 0;\n}\n\nstatic int\nSDL_UpdateTextureYUV(SDL_Texture * texture, const SDL_Rect * rect,\n                     const void *pixels, int pitch)\n{\n    SDL_Texture *native = texture->native;\n    SDL_Rect full_rect;\n\n    if (SDL_SW_UpdateYUVTexture(texture->yuv, rect, pixels, pitch) < 0) {\n        return -1;\n    }\n\n    full_rect.x = 0;\n    full_rect.y = 0;\n    full_rect.w = texture->w;\n    full_rect.h = texture->h;\n    rect = &full_rect;\n\n    if (texture->access == SDL_TEXTUREACCESS_STREAMING) {\n        /* We can lock the texture and copy to it */\n        void *native_pixels;\n        int native_pitch;\n\n        if (SDL_LockTexture(native, rect, &native_pixels, &native_pitch) < 0) {\n            return -1;\n        }\n        SDL_SW_CopyYUVToRGB(texture->yuv, rect, native->format,\n                            rect->w, rect->h, native_pixels, native_pitch);\n        SDL_UnlockTexture(native);\n    } else {\n        /* Use a temporary buffer for updating */\n        void *temp_pixels;\n        int temp_pitch;\n\n        temp_pitch = (((rect->w * SDL_BYTESPERPIXEL(native->format)) + 3) & ~3);\n        temp_pixels = SDL_malloc(rect->h * temp_pitch);\n        if (!temp_pixels) {\n            return SDL_OutOfMemory();\n        }\n        SDL_SW_CopyYUVToRGB(texture->yuv, rect, native->format,\n                            rect->w, rect->h, temp_pixels, temp_pitch);\n        SDL_UpdateTexture(native, rect, temp_pixels, temp_pitch);\n        SDL_free(temp_pixels);\n    }\n    return 0;\n}\n\nstatic int\nSDL_UpdateTextureNative(SDL_Texture * texture, const SDL_Rect * rect,\n                        const void *pixels, int pitch)\n{\n    SDL_Texture *native = texture->native;\n\n    if (texture->access == SDL_TEXTUREACCESS_STREAMING) {\n        /* We can lock the texture and copy to it */\n        void *native_pixels;\n        int native_pitch;\n\n        if (SDL_LockTexture(native, rect, &native_pixels, &native_pitch) < 0) {\n            return -1;\n        }\n        SDL_ConvertPixels(rect->w, rect->h,\n                          texture->format, pixels, pitch,\n                          native->format, native_pixels, native_pitch);\n        SDL_UnlockTexture(native);\n    } else {\n        /* Use a temporary buffer for updating */\n        void *temp_pixels;\n        int temp_pitch;\n\n        temp_pitch = (((rect->w * SDL_BYTESPERPIXEL(native->format)) + 3) & ~3);\n        temp_pixels = SDL_malloc(rect->h * temp_pitch);\n        if (!temp_pixels) {\n            return SDL_OutOfMemory();\n        }\n        SDL_ConvertPixels(rect->w, rect->h,\n                          texture->format, pixels, pitch,\n                          native->format, temp_pixels, temp_pitch);\n        SDL_UpdateTexture(native, rect, temp_pixels, temp_pitch);\n        SDL_free(temp_pixels);\n    }\n    return 0;\n}\n\nint\nSDL_UpdateTexture(SDL_Texture * texture, const SDL_Rect * rect,\n                  const void *pixels, int pitch)\n{\n    SDL_Renderer *renderer;\n    SDL_Rect full_rect;\n\n    CHECK_TEXTURE_MAGIC(texture, -1);\n\n    if (!pixels) {\n        return SDL_InvalidParamError(\"pixels\");\n    }\n    if (!pitch) {\n        return SDL_InvalidParamError(\"pitch\");\n    }\n\n    if (!rect) {\n        full_rect.x = 0;\n        full_rect.y = 0;\n        full_rect.w = texture->w;\n        full_rect.h = texture->h;\n        rect = &full_rect;\n    }\n\n    if (texture->yuv) {\n        return SDL_UpdateTextureYUV(texture, rect, pixels, pitch);\n    } else if (texture->native) {\n        return SDL_UpdateTextureNative(texture, rect, pixels, pitch);\n    } else {\n        renderer = texture->renderer;\n        return renderer->UpdateTexture(renderer, texture, rect, pixels, pitch);\n    }\n}\n\nstatic int\nSDL_UpdateTextureYUVPlanar(SDL_Texture * texture, const SDL_Rect * rect,\n                           const Uint8 *Yplane, int Ypitch,\n                           const Uint8 *Uplane, int Upitch,\n                           const Uint8 *Vplane, int Vpitch)\n{\n    SDL_Texture *native = texture->native;\n    SDL_Rect full_rect;\n\n    if (SDL_SW_UpdateYUVTexturePlanar(texture->yuv, rect, Yplane, Ypitch, Uplane, Upitch, Vplane, Vpitch) < 0) {\n        return -1;\n    }\n\n    full_rect.x = 0;\n    full_rect.y = 0;\n    full_rect.w = texture->w;\n    full_rect.h = texture->h;\n    rect = &full_rect;\n\n    if (texture->access == SDL_TEXTUREACCESS_STREAMING) {\n        /* We can lock the texture and copy to it */\n        void *native_pixels;\n        int native_pitch;\n\n        if (SDL_LockTexture(native, rect, &native_pixels, &native_pitch) < 0) {\n            return -1;\n        }\n        SDL_SW_CopyYUVToRGB(texture->yuv, rect, native->format,\n                            rect->w, rect->h, native_pixels, native_pitch);\n        SDL_UnlockTexture(native);\n    } else {\n        /* Use a temporary buffer for updating */\n        void *temp_pixels;\n        int temp_pitch;\n\n        temp_pitch = (((rect->w * SDL_BYTESPERPIXEL(native->format)) + 3) & ~3);\n        temp_pixels = SDL_malloc(rect->h * temp_pitch);\n        if (!temp_pixels) {\n            return SDL_OutOfMemory();\n        }\n        SDL_SW_CopyYUVToRGB(texture->yuv, rect, native->format,\n                            rect->w, rect->h, temp_pixels, temp_pitch);\n        SDL_UpdateTexture(native, rect, temp_pixels, temp_pitch);\n        SDL_free(temp_pixels);\n    }\n    return 0;\n}\n\nint SDL_UpdateYUVTexture(SDL_Texture * texture, const SDL_Rect * rect,\n                         const Uint8 *Yplane, int Ypitch,\n                         const Uint8 *Uplane, int Upitch,\n                         const Uint8 *Vplane, int Vpitch)\n{\n    SDL_Renderer *renderer;\n    SDL_Rect full_rect;\n\n    CHECK_TEXTURE_MAGIC(texture, -1);\n\n    if (!Yplane) {\n        return SDL_InvalidParamError(\"Yplane\");\n    }\n    if (!Ypitch) {\n        return SDL_InvalidParamError(\"Ypitch\");\n    }\n    if (!Uplane) {\n        return SDL_InvalidParamError(\"Uplane\");\n    }\n    if (!Upitch) {\n        return SDL_InvalidParamError(\"Upitch\");\n    }\n    if (!Vplane) {\n        return SDL_InvalidParamError(\"Vplane\");\n    }\n    if (!Vpitch) {\n        return SDL_InvalidParamError(\"Vpitch\");\n    }\n\n    if (texture->format != SDL_PIXELFORMAT_YV12 &&\n        texture->format != SDL_PIXELFORMAT_IYUV) {\n        return SDL_SetError(\"Texture format must by YV12 or IYUV\");\n    }\n\n    if (!rect) {\n        full_rect.x = 0;\n        full_rect.y = 0;\n        full_rect.w = texture->w;\n        full_rect.h = texture->h;\n        rect = &full_rect;\n    }\n\n    if (texture->yuv) {\n        return SDL_UpdateTextureYUVPlanar(texture, rect, Yplane, Ypitch, Uplane, Upitch, Vplane, Vpitch);\n    } else {\n        SDL_assert(!texture->native);\n        renderer = texture->renderer;\n        SDL_assert(renderer->UpdateTextureYUV);\n        if (renderer->UpdateTextureYUV) {\n            return renderer->UpdateTextureYUV(renderer, texture, rect, Yplane, Ypitch, Uplane, Upitch, Vplane, Vpitch);\n        } else {\n            return SDL_Unsupported();\n        }\n    }\n}\n\nstatic int\nSDL_LockTextureYUV(SDL_Texture * texture, const SDL_Rect * rect,\n                   void **pixels, int *pitch)\n{\n    return SDL_SW_LockYUVTexture(texture->yuv, rect, pixels, pitch);\n}\n\nstatic int\nSDL_LockTextureNative(SDL_Texture * texture, const SDL_Rect * rect,\n                      void **pixels, int *pitch)\n{\n    texture->locked_rect = *rect;\n    *pixels = (void *) ((Uint8 *) texture->pixels +\n                        rect->y * texture->pitch +\n                        rect->x * SDL_BYTESPERPIXEL(texture->format));\n    *pitch = texture->pitch;\n    return 0;\n}\n\nint\nSDL_LockTexture(SDL_Texture * texture, const SDL_Rect * rect,\n                void **pixels, int *pitch)\n{\n    SDL_Renderer *renderer;\n    SDL_Rect full_rect;\n\n    CHECK_TEXTURE_MAGIC(texture, -1);\n\n    if (texture->access != SDL_TEXTUREACCESS_STREAMING) {\n        return SDL_SetError(\"SDL_LockTexture(): texture must be streaming\");\n    }\n\n    if (!rect) {\n        full_rect.x = 0;\n        full_rect.y = 0;\n        full_rect.w = texture->w;\n        full_rect.h = texture->h;\n        rect = &full_rect;\n    }\n\n    if (texture->yuv) {\n        return SDL_LockTextureYUV(texture, rect, pixels, pitch);\n    } else if (texture->native) {\n        return SDL_LockTextureNative(texture, rect, pixels, pitch);\n    } else {\n        renderer = texture->renderer;\n        return renderer->LockTexture(renderer, texture, rect, pixels, pitch);\n    }\n}\n\nstatic void\nSDL_UnlockTextureYUV(SDL_Texture * texture)\n{\n    SDL_Texture *native = texture->native;\n    void *native_pixels = NULL;\n    int native_pitch = 0;\n    SDL_Rect rect;\n\n    rect.x = 0;\n    rect.y = 0;\n    rect.w = texture->w;\n    rect.h = texture->h;\n\n    if (SDL_LockTexture(native, &rect, &native_pixels, &native_pitch) < 0) {\n        return;\n    }\n    SDL_SW_CopyYUVToRGB(texture->yuv, &rect, native->format,\n                        rect.w, rect.h, native_pixels, native_pitch);\n    SDL_UnlockTexture(native);\n}\n\nstatic void\nSDL_UnlockTextureNative(SDL_Texture * texture)\n{\n    SDL_Texture *native = texture->native;\n    void *native_pixels = NULL;\n    int native_pitch = 0;\n    const SDL_Rect *rect = &texture->locked_rect;\n    const void* pixels = (void *) ((Uint8 *) texture->pixels +\n                        rect->y * texture->pitch +\n                        rect->x * SDL_BYTESPERPIXEL(texture->format));\n    int pitch = texture->pitch;\n\n    if (SDL_LockTexture(native, rect, &native_pixels, &native_pitch) < 0) {\n        return;\n    }\n    SDL_ConvertPixels(rect->w, rect->h,\n                      texture->format, pixels, pitch,\n                      native->format, native_pixels, native_pitch);\n    SDL_UnlockTexture(native);\n}\n\nvoid\nSDL_UnlockTexture(SDL_Texture * texture)\n{\n    SDL_Renderer *renderer;\n\n    CHECK_TEXTURE_MAGIC(texture, );\n\n    if (texture->access != SDL_TEXTUREACCESS_STREAMING) {\n        return;\n    }\n    if (texture->yuv) {\n        SDL_UnlockTextureYUV(texture);\n    } else if (texture->native) {\n        SDL_UnlockTextureNative(texture);\n    } else {\n        renderer = texture->renderer;\n        renderer->UnlockTexture(renderer, texture);\n    }\n}\n\nSDL_bool\nSDL_RenderTargetSupported(SDL_Renderer *renderer)\n{\n    if (!renderer || !renderer->SetRenderTarget) {\n        return SDL_FALSE;\n    }\n    return (renderer->info.flags & SDL_RENDERER_TARGETTEXTURE) != 0;\n}\n\nint\nSDL_SetRenderTarget(SDL_Renderer *renderer, SDL_Texture *texture)\n{\n    if (!SDL_RenderTargetSupported(renderer)) {\n        return SDL_Unsupported();\n    }\n    if (texture == renderer->target) {\n        /* Nothing to do! */\n        return 0;\n    }\n\n    /* texture == NULL is valid and means reset the target to the window */\n    if (texture) {\n        CHECK_TEXTURE_MAGIC(texture, -1);\n        if (renderer != texture->renderer) {\n            return SDL_SetError(\"Texture was not created with this renderer\");\n        }\n        if (texture->access != SDL_TEXTUREACCESS_TARGET) {\n            return SDL_SetError(\"Texture not created with SDL_TEXTUREACCESS_TARGET\");\n        }\n        if (texture->native) {\n            /* Always render to the native texture */\n            texture = texture->native;\n        }\n    }\n\n    if (texture && !renderer->target) {\n        /* Make a backup of the viewport */\n        renderer->viewport_backup = renderer->viewport;\n        renderer->clip_rect_backup = renderer->clip_rect;\n        renderer->clipping_enabled_backup = renderer->clipping_enabled;\n        renderer->scale_backup = renderer->scale;\n        renderer->logical_w_backup = renderer->logical_w;\n        renderer->logical_h_backup = renderer->logical_h;\n    }\n    renderer->target = texture;\n\n    if (renderer->SetRenderTarget(renderer, texture) < 0) {\n        return -1;\n    }\n\n    if (texture) {\n        renderer->viewport.x = 0;\n        renderer->viewport.y = 0;\n        renderer->viewport.w = texture->w;\n        renderer->viewport.h = texture->h;\n        renderer->scale.x = 1.0f;\n        renderer->scale.y = 1.0f;\n        renderer->logical_w = texture->w;\n        renderer->logical_h = texture->h;\n    } else {\n        renderer->viewport = renderer->viewport_backup;\n        renderer->clip_rect = renderer->clip_rect_backup;\n        renderer->clipping_enabled = renderer->clipping_enabled_backup;\n        renderer->scale = renderer->scale_backup;\n        renderer->logical_w = renderer->logical_w_backup;\n        renderer->logical_h = renderer->logical_h_backup;\n    }\n    if (renderer->UpdateViewport(renderer) < 0) {\n        return -1;\n    }\n    if (renderer->UpdateClipRect(renderer) < 0) {\n        return -1;\n    }\n\n    /* All set! */\n    return 0;\n}\n\nSDL_Texture *\nSDL_GetRenderTarget(SDL_Renderer *renderer)\n{\n    return renderer->target;\n}\n\nstatic int\nUpdateLogicalSize(SDL_Renderer *renderer)\n{\n    int w = 1, h = 1;\n    float want_aspect;\n    float real_aspect;\n    float scale;\n    SDL_Rect viewport;\n\n    if (SDL_GetRendererOutputSize(renderer, &w, &h) < 0) {\n        return -1;\n    }\n\n    want_aspect = (float)renderer->logical_w / renderer->logical_h;\n    real_aspect = (float)w / h;\n\n    /* Clear the scale because we're setting viewport in output coordinates */\n    SDL_RenderSetScale(renderer, 1.0f, 1.0f);\n\n    if (SDL_fabs(want_aspect-real_aspect) < 0.0001) {\n        /* The aspect ratios are the same, just scale appropriately */\n        scale = (float)w / renderer->logical_w;\n        SDL_RenderSetViewport(renderer, NULL);\n    } else if (want_aspect > real_aspect) {\n        /* We want a wider aspect ratio than is available - letterbox it */\n        scale = (float)w / renderer->logical_w;\n        viewport.x = 0;\n        viewport.w = w;\n        viewport.h = (int)SDL_ceil(renderer->logical_h * scale);\n        viewport.y = (h - viewport.h) / 2;\n        SDL_RenderSetViewport(renderer, &viewport);\n    } else {\n        /* We want a narrower aspect ratio than is available - use side-bars */\n        scale = (float)h / renderer->logical_h;\n        viewport.y = 0;\n        viewport.h = h;\n        viewport.w = (int)SDL_ceil(renderer->logical_w * scale);\n        viewport.x = (w - viewport.w) / 2;\n        SDL_RenderSetViewport(renderer, &viewport);\n    }\n\n    /* Set the new scale */\n    SDL_RenderSetScale(renderer, scale, scale);\n\n    return 0;\n}\n\nint\nSDL_RenderSetLogicalSize(SDL_Renderer * renderer, int w, int h)\n{\n    CHECK_RENDERER_MAGIC(renderer, -1);\n\n    if (!w || !h) {\n        /* Clear any previous logical resolution */\n        renderer->logical_w = 0;\n        renderer->logical_h = 0;\n        SDL_RenderSetViewport(renderer, NULL);\n        SDL_RenderSetScale(renderer, 1.0f, 1.0f);\n        return 0;\n    }\n\n    renderer->logical_w = w;\n    renderer->logical_h = h;\n\n    return UpdateLogicalSize(renderer);\n}\n\nvoid\nSDL_RenderGetLogicalSize(SDL_Renderer * renderer, int *w, int *h)\n{\n    CHECK_RENDERER_MAGIC(renderer, );\n\n    if (w) {\n        *w = renderer->logical_w;\n    }\n    if (h) {\n        *h = renderer->logical_h;\n    }\n}\n\nint\nSDL_RenderSetViewport(SDL_Renderer * renderer, const SDL_Rect * rect)\n{\n    CHECK_RENDERER_MAGIC(renderer, -1);\n\n    if (rect) {\n        renderer->viewport.x = (int)SDL_floor(rect->x * renderer->scale.x);\n        renderer->viewport.y = (int)SDL_floor(rect->y * renderer->scale.y);\n        renderer->viewport.w = (int)SDL_ceil(rect->w * renderer->scale.x);\n        renderer->viewport.h = (int)SDL_ceil(rect->h * renderer->scale.y);\n    } else {\n        renderer->viewport.x = 0;\n        renderer->viewport.y = 0;\n        if (SDL_GetRendererOutputSize(renderer, &renderer->viewport.w, &renderer->viewport.h) < 0) {\n            return -1;\n        }\n    }\n    return renderer->UpdateViewport(renderer);\n}\n\nvoid\nSDL_RenderGetViewport(SDL_Renderer * renderer, SDL_Rect * rect)\n{\n    CHECK_RENDERER_MAGIC(renderer, );\n\n    if (rect) {\n        rect->x = (int)(renderer->viewport.x / renderer->scale.x);\n        rect->y = (int)(renderer->viewport.y / renderer->scale.y);\n        rect->w = (int)(renderer->viewport.w / renderer->scale.x);\n        rect->h = (int)(renderer->viewport.h / renderer->scale.y);\n    }\n}\n\nint\nSDL_RenderSetClipRect(SDL_Renderer * renderer, const SDL_Rect * rect)\n{\n    CHECK_RENDERER_MAGIC(renderer, -1)\n\n    if (rect) {\n        renderer->clipping_enabled = SDL_TRUE;\n        renderer->clip_rect.x = (int)SDL_floor(rect->x * renderer->scale.x);\n        renderer->clip_rect.y = (int)SDL_floor(rect->y * renderer->scale.y);\n        renderer->clip_rect.w = (int)SDL_ceil(rect->w * renderer->scale.x);\n        renderer->clip_rect.h = (int)SDL_ceil(rect->h * renderer->scale.y);\n    } else {\n        renderer->clipping_enabled = SDL_FALSE;\n        SDL_zero(renderer->clip_rect);\n    }\n    return renderer->UpdateClipRect(renderer);\n}\n\nvoid\nSDL_RenderGetClipRect(SDL_Renderer * renderer, SDL_Rect * rect)\n{\n    CHECK_RENDERER_MAGIC(renderer, )\n\n    if (rect) {\n        rect->x = (int)(renderer->clip_rect.x / renderer->scale.x);\n        rect->y = (int)(renderer->clip_rect.y / renderer->scale.y);\n        rect->w = (int)(renderer->clip_rect.w / renderer->scale.x);\n        rect->h = (int)(renderer->clip_rect.h / renderer->scale.y);\n    }\n}\n\nSDL_bool\nSDL_RenderIsClipEnabled(SDL_Renderer * renderer)\n{\n    CHECK_RENDERER_MAGIC(renderer, SDL_FALSE)\n    return renderer->clipping_enabled;\n}\n\nint\nSDL_RenderSetScale(SDL_Renderer * renderer, float scaleX, float scaleY)\n{\n    CHECK_RENDERER_MAGIC(renderer, -1);\n\n    renderer->scale.x = scaleX;\n    renderer->scale.y = scaleY;\n    return 0;\n}\n\nvoid\nSDL_RenderGetScale(SDL_Renderer * renderer, float *scaleX, float *scaleY)\n{\n    CHECK_RENDERER_MAGIC(renderer, );\n\n    if (scaleX) {\n        *scaleX = renderer->scale.x;\n    }\n    if (scaleY) {\n        *scaleY = renderer->scale.y;\n    }\n}\n\nint\nSDL_SetRenderDrawColor(SDL_Renderer * renderer,\n                       Uint8 r, Uint8 g, Uint8 b, Uint8 a)\n{\n    CHECK_RENDERER_MAGIC(renderer, -1);\n\n    renderer->r = r;\n    renderer->g = g;\n    renderer->b = b;\n    renderer->a = a;\n    return 0;\n}\n\nint\nSDL_GetRenderDrawColor(SDL_Renderer * renderer,\n                       Uint8 * r, Uint8 * g, Uint8 * b, Uint8 * a)\n{\n    CHECK_RENDERER_MAGIC(renderer, -1);\n\n    if (r) {\n        *r = renderer->r;\n    }\n    if (g) {\n        *g = renderer->g;\n    }\n    if (b) {\n        *b = renderer->b;\n    }\n    if (a) {\n        *a = renderer->a;\n    }\n    return 0;\n}\n\nint\nSDL_SetRenderDrawBlendMode(SDL_Renderer * renderer, SDL_BlendMode blendMode)\n{\n    CHECK_RENDERER_MAGIC(renderer, -1);\n\n    renderer->blendMode = blendMode;\n    return 0;\n}\n\nint\nSDL_GetRenderDrawBlendMode(SDL_Renderer * renderer, SDL_BlendMode *blendMode)\n{\n    CHECK_RENDERER_MAGIC(renderer, -1);\n\n    *blendMode = renderer->blendMode;\n    return 0;\n}\n\nint\nSDL_RenderClear(SDL_Renderer * renderer)\n{\n    CHECK_RENDERER_MAGIC(renderer, -1);\n\n    /* Don't draw while we're hidden */\n    if (renderer->hidden) {\n        return 0;\n    }\n    return renderer->RenderClear(renderer);\n}\n\nint\nSDL_RenderDrawPoint(SDL_Renderer * renderer, int x, int y)\n{\n    SDL_Point point;\n\n    point.x = x;\n    point.y = y;\n    return SDL_RenderDrawPoints(renderer, &point, 1);\n}\n\nstatic int\nRenderDrawPointsWithRects(SDL_Renderer * renderer,\n                     const SDL_Point * points, int count)\n{\n    SDL_FRect *frects;\n    int i;\n    int status;\n\n    frects = SDL_stack_alloc(SDL_FRect, count);\n    if (!frects) {\n        return SDL_OutOfMemory();\n    }\n    for (i = 0; i < count; ++i) {\n        frects[i].x = points[i].x * renderer->scale.x;\n        frects[i].y = points[i].y * renderer->scale.y;\n        frects[i].w = renderer->scale.x;\n        frects[i].h = renderer->scale.y;\n    }\n\n    status = renderer->RenderFillRects(renderer, frects, count);\n\n    SDL_stack_free(frects);\n\n    return status;\n}\n\nint\nSDL_RenderDrawPoints(SDL_Renderer * renderer,\n                     const SDL_Point * points, int count)\n{\n    SDL_FPoint *fpoints;\n    int i;\n    int status;\n\n    CHECK_RENDERER_MAGIC(renderer, -1);\n\n    if (!points) {\n        return SDL_SetError(\"SDL_RenderDrawPoints(): Passed NULL points\");\n    }\n    if (count < 1) {\n        return 0;\n    }\n    /* Don't draw while we're hidden */\n    if (renderer->hidden) {\n        return 0;\n    }\n\n    if (renderer->scale.x != 1.0f || renderer->scale.y != 1.0f) {\n        return RenderDrawPointsWithRects(renderer, points, count);\n    }\n\n    fpoints = SDL_stack_alloc(SDL_FPoint, count);\n    if (!fpoints) {\n        return SDL_OutOfMemory();\n    }\n    for (i = 0; i < count; ++i) {\n        fpoints[i].x = points[i].x * renderer->scale.x;\n        fpoints[i].y = points[i].y * renderer->scale.y;\n    }\n\n    status = renderer->RenderDrawPoints(renderer, fpoints, count);\n\n    SDL_stack_free(fpoints);\n\n    return status;\n}\n\nint\nSDL_RenderDrawLine(SDL_Renderer * renderer, int x1, int y1, int x2, int y2)\n{\n    SDL_Point points[2];\n\n    points[0].x = x1;\n    points[0].y = y1;\n    points[1].x = x2;\n    points[1].y = y2;\n    return SDL_RenderDrawLines(renderer, points, 2);\n}\n\nstatic int\nRenderDrawLinesWithRects(SDL_Renderer * renderer,\n                     const SDL_Point * points, int count)\n{\n    SDL_FRect *frect;\n    SDL_FRect *frects;\n    SDL_FPoint fpoints[2];\n    int i, nrects;\n    int status;\n\n    frects = SDL_stack_alloc(SDL_FRect, count-1);\n    if (!frects) {\n        return SDL_OutOfMemory();\n    }\n\n    status = 0;\n    nrects = 0;\n    for (i = 0; i < count-1; ++i) {\n        if (points[i].x == points[i+1].x) {\n            int minY = SDL_min(points[i].y, points[i+1].y);\n            int maxY = SDL_max(points[i].y, points[i+1].y);\n\n            frect = &frects[nrects++];\n            frect->x = points[i].x * renderer->scale.x;\n            frect->y = minY * renderer->scale.y;\n            frect->w = renderer->scale.x;\n            frect->h = (maxY - minY + 1) * renderer->scale.y;\n        } else if (points[i].y == points[i+1].y) {\n            int minX = SDL_min(points[i].x, points[i+1].x);\n            int maxX = SDL_max(points[i].x, points[i+1].x);\n\n            frect = &frects[nrects++];\n            frect->x = minX * renderer->scale.x;\n            frect->y = points[i].y * renderer->scale.y;\n            frect->w = (maxX - minX + 1) * renderer->scale.x;\n            frect->h = renderer->scale.y;\n        } else {\n            /* FIXME: We can't use a rect for this line... */\n            fpoints[0].x = points[i].x * renderer->scale.x;\n            fpoints[0].y = points[i].y * renderer->scale.y;\n            fpoints[1].x = points[i+1].x * renderer->scale.x;\n            fpoints[1].y = points[i+1].y * renderer->scale.y;\n            status += renderer->RenderDrawLines(renderer, fpoints, 2);\n        }\n    }\n\n    status += renderer->RenderFillRects(renderer, frects, nrects);\n\n    SDL_stack_free(frects);\n\n    if (status < 0) {\n        status = -1;\n    }\n    return status;\n}\n\nint\nSDL_RenderDrawLines(SDL_Renderer * renderer,\n                    const SDL_Point * points, int count)\n{\n    SDL_FPoint *fpoints;\n    int i;\n    int status;\n\n    CHECK_RENDERER_MAGIC(renderer, -1);\n\n    if (!points) {\n        return SDL_SetError(\"SDL_RenderDrawLines(): Passed NULL points\");\n    }\n    if (count < 2) {\n        return 0;\n    }\n    /* Don't draw while we're hidden */\n    if (renderer->hidden) {\n        return 0;\n    }\n\n    if (renderer->scale.x != 1.0f || renderer->scale.y != 1.0f) {\n        return RenderDrawLinesWithRects(renderer, points, count);\n    }\n\n    fpoints = SDL_stack_alloc(SDL_FPoint, count);\n    if (!fpoints) {\n        return SDL_OutOfMemory();\n    }\n    for (i = 0; i < count; ++i) {\n        fpoints[i].x = points[i].x * renderer->scale.x;\n        fpoints[i].y = points[i].y * renderer->scale.y;\n    }\n\n    status = renderer->RenderDrawLines(renderer, fpoints, count);\n\n    SDL_stack_free(fpoints);\n\n    return status;\n}\n\nint\nSDL_RenderDrawRect(SDL_Renderer * renderer, const SDL_Rect * rect)\n{\n    SDL_Rect full_rect;\n    SDL_Point points[5];\n\n    CHECK_RENDERER_MAGIC(renderer, -1);\n\n    /* If 'rect' == NULL, then outline the whole surface */\n    if (!rect) {\n        SDL_RenderGetViewport(renderer, &full_rect);\n        full_rect.x = 0;\n        full_rect.y = 0;\n        rect = &full_rect;\n    }\n\n    points[0].x = rect->x;\n    points[0].y = rect->y;\n    points[1].x = rect->x+rect->w-1;\n    points[1].y = rect->y;\n    points[2].x = rect->x+rect->w-1;\n    points[2].y = rect->y+rect->h-1;\n    points[3].x = rect->x;\n    points[3].y = rect->y+rect->h-1;\n    points[4].x = rect->x;\n    points[4].y = rect->y;\n    return SDL_RenderDrawLines(renderer, points, 5);\n}\n\nint\nSDL_RenderDrawRects(SDL_Renderer * renderer,\n                    const SDL_Rect * rects, int count)\n{\n    int i;\n\n    CHECK_RENDERER_MAGIC(renderer, -1);\n\n    if (!rects) {\n        return SDL_SetError(\"SDL_RenderDrawRects(): Passed NULL rects\");\n    }\n    if (count < 1) {\n        return 0;\n    }\n\n    /* Don't draw while we're hidden */\n    if (renderer->hidden) {\n        return 0;\n    }\n    for (i = 0; i < count; ++i) {\n        if (SDL_RenderDrawRect(renderer, &rects[i]) < 0) {\n            return -1;\n        }\n    }\n    return 0;\n}\n\nint\nSDL_RenderFillRect(SDL_Renderer * renderer, const SDL_Rect * rect)\n{\n    SDL_Rect full_rect = { 0, 0, 0, 0 };\n\n    CHECK_RENDERER_MAGIC(renderer, -1);\n\n    /* If 'rect' == NULL, then outline the whole surface */\n    if (!rect) {\n        SDL_RenderGetViewport(renderer, &full_rect);\n        full_rect.x = 0;\n        full_rect.y = 0;\n        rect = &full_rect;\n    }\n    return SDL_RenderFillRects(renderer, rect, 1);\n}\n\nint\nSDL_RenderFillRects(SDL_Renderer * renderer,\n                    const SDL_Rect * rects, int count)\n{\n    SDL_FRect *frects;\n    int i;\n    int status;\n\n    CHECK_RENDERER_MAGIC(renderer, -1);\n\n    if (!rects) {\n        return SDL_SetError(\"SDL_RenderFillRects(): Passed NULL rects\");\n    }\n    if (count < 1) {\n        return 0;\n    }\n    /* Don't draw while we're hidden */\n    if (renderer->hidden) {\n        return 0;\n    }\n\n    frects = SDL_stack_alloc(SDL_FRect, count);\n    if (!frects) {\n        return SDL_OutOfMemory();\n    }\n    for (i = 0; i < count; ++i) {\n        frects[i].x = rects[i].x * renderer->scale.x;\n        frects[i].y = rects[i].y * renderer->scale.y;\n        frects[i].w = rects[i].w * renderer->scale.x;\n        frects[i].h = rects[i].h * renderer->scale.y;\n    }\n\n    status = renderer->RenderFillRects(renderer, frects, count);\n\n    SDL_stack_free(frects);\n\n    return status;\n}\n\nint\nSDL_RenderCopy(SDL_Renderer * renderer, SDL_Texture * texture,\n               const SDL_Rect * srcrect, const SDL_Rect * dstrect)\n{\n    SDL_Rect real_srcrect = { 0, 0, 0, 0 };\n    SDL_Rect real_dstrect = { 0, 0, 0, 0 };\n    SDL_FRect frect;\n\n    CHECK_RENDERER_MAGIC(renderer, -1);\n    CHECK_TEXTURE_MAGIC(texture, -1);\n\n    if (renderer != texture->renderer) {\n        return SDL_SetError(\"Texture was not created with this renderer\");\n    }\n\n    real_srcrect.x = 0;\n    real_srcrect.y = 0;\n    real_srcrect.w = texture->w;\n    real_srcrect.h = texture->h;\n    if (srcrect) {\n        if (!SDL_IntersectRect(srcrect, &real_srcrect, &real_srcrect)) {\n            return 0;\n        }\n    }\n\n    SDL_RenderGetViewport(renderer, &real_dstrect);\n    real_dstrect.x = 0;\n    real_dstrect.y = 0;\n    if (dstrect) {\n        if (!SDL_HasIntersection(dstrect, &real_dstrect)) {\n            return 0;\n        }\n        real_dstrect = *dstrect;\n    }\n\n    if (texture->native) {\n        texture = texture->native;\n    }\n\n    /* Don't draw while we're hidden */\n    if (renderer->hidden) {\n        return 0;\n    }\n\n    frect.x = real_dstrect.x * renderer->scale.x;\n    frect.y = real_dstrect.y * renderer->scale.y;\n    frect.w = real_dstrect.w * renderer->scale.x;\n    frect.h = real_dstrect.h * renderer->scale.y;\n\n    return renderer->RenderCopy(renderer, texture, &real_srcrect, &frect);\n}\n\n\nint\nSDL_RenderCopyEx(SDL_Renderer * renderer, SDL_Texture * texture,\n               const SDL_Rect * srcrect, const SDL_Rect * dstrect,\n               const double angle, const SDL_Point *center, const SDL_RendererFlip flip)\n{\n    SDL_Rect real_srcrect = { 0, 0, 0, 0 };\n    SDL_Rect real_dstrect = { 0, 0, 0, 0 };\n    SDL_Point real_center;\n    SDL_FRect frect;\n    SDL_FPoint fcenter;\n\n    CHECK_RENDERER_MAGIC(renderer, -1);\n    CHECK_TEXTURE_MAGIC(texture, -1);\n\n    if (renderer != texture->renderer) {\n        return SDL_SetError(\"Texture was not created with this renderer\");\n    }\n    if (!renderer->RenderCopyEx) {\n        return SDL_SetError(\"Renderer does not support RenderCopyEx\");\n    }\n\n    real_srcrect.x = 0;\n    real_srcrect.y = 0;\n    real_srcrect.w = texture->w;\n    real_srcrect.h = texture->h;\n    if (srcrect) {\n        if (!SDL_IntersectRect(srcrect, &real_srcrect, &real_srcrect)) {\n            return 0;\n        }\n    }\n\n    /* We don't intersect the dstrect with the viewport as RenderCopy does because of potential rotation clipping issues... TODO: should we? */\n    if (dstrect) {\n        real_dstrect = *dstrect;\n    } else {\n        SDL_RenderGetViewport(renderer, &real_dstrect);\n        real_dstrect.x = 0;\n        real_dstrect.y = 0;\n    }\n\n    if (texture->native) {\n        texture = texture->native;\n    }\n\n    if(center) real_center = *center;\n    else {\n        real_center.x = real_dstrect.w/2;\n        real_center.y = real_dstrect.h/2;\n    }\n\n    frect.x = real_dstrect.x * renderer->scale.x;\n    frect.y = real_dstrect.y * renderer->scale.y;\n    frect.w = real_dstrect.w * renderer->scale.x;\n    frect.h = real_dstrect.h * renderer->scale.y;\n\n    fcenter.x = real_center.x * renderer->scale.x;\n    fcenter.y = real_center.y * renderer->scale.y;\n\n    return renderer->RenderCopyEx(renderer, texture, &real_srcrect, &frect, angle, &fcenter, flip);\n}\n\nint\nSDL_RenderReadPixels(SDL_Renderer * renderer, const SDL_Rect * rect,\n                     Uint32 format, void * pixels, int pitch)\n{\n    SDL_Rect real_rect;\n\n    CHECK_RENDERER_MAGIC(renderer, -1);\n\n    if (!renderer->RenderReadPixels) {\n        return SDL_Unsupported();\n    }\n\n    if (!format) {\n        format = SDL_GetWindowPixelFormat(renderer->window);\n    }\n\n    real_rect.x = renderer->viewport.x;\n    real_rect.y = renderer->viewport.y;\n    real_rect.w = renderer->viewport.w;\n    real_rect.h = renderer->viewport.h;\n    if (rect) {\n        if (!SDL_IntersectRect(rect, &real_rect, &real_rect)) {\n            return 0;\n        }\n        if (real_rect.y > rect->y) {\n            pixels = (Uint8 *)pixels + pitch * (real_rect.y - rect->y);\n        }\n        if (real_rect.x > rect->x) {\n            int bpp = SDL_BYTESPERPIXEL(format);\n            pixels = (Uint8 *)pixels + bpp * (real_rect.x - rect->x);\n        }\n    }\n\n    return renderer->RenderReadPixels(renderer, &real_rect,\n                                      format, pixels, pitch);\n}\n\nvoid\nSDL_RenderPresent(SDL_Renderer * renderer)\n{\n    CHECK_RENDERER_MAGIC(renderer, );\n\n    /* Don't draw while we're hidden */\n    if (renderer->hidden) {\n        return;\n    }\n    renderer->RenderPresent(renderer);\n}\n\nvoid\nSDL_DestroyTexture(SDL_Texture * texture)\n{\n    SDL_Renderer *renderer;\n\n    CHECK_TEXTURE_MAGIC(texture, );\n\n    renderer = texture->renderer;\n    if (texture == renderer->target) {\n        SDL_SetRenderTarget(renderer, NULL);\n    }\n\n    texture->magic = NULL;\n\n    if (texture->next) {\n        texture->next->prev = texture->prev;\n    }\n    if (texture->prev) {\n        texture->prev->next = texture->next;\n    } else {\n        renderer->textures = texture->next;\n    }\n\n    if (texture->native) {\n        SDL_DestroyTexture(texture->native);\n    }\n    if (texture->yuv) {\n        SDL_SW_DestroyYUVTexture(texture->yuv);\n    }\n    SDL_free(texture->pixels);\n\n    renderer->DestroyTexture(renderer, texture);\n    SDL_free(texture);\n}\n\nvoid\nSDL_DestroyRenderer(SDL_Renderer * renderer)\n{\n    CHECK_RENDERER_MAGIC(renderer, );\n\n    SDL_DelEventWatch(SDL_RendererEventWatch, renderer);\n\n    /* Free existing textures for this renderer */\n    while (renderer->textures) {\n        SDL_DestroyTexture(renderer->textures);\n    }\n\n    if (renderer->window) {\n        SDL_SetWindowData(renderer->window, SDL_WINDOWRENDERDATA, NULL);\n    }\n\n    /* It's no longer magical... */\n    renderer->magic = NULL;\n\n    /* Free the renderer instance */\n    renderer->DestroyRenderer(renderer);\n}\n\nint SDL_GL_BindTexture(SDL_Texture *texture, float *texw, float *texh)\n{\n    SDL_Renderer *renderer;\n\n    CHECK_TEXTURE_MAGIC(texture, -1);\n    renderer = texture->renderer;\n    if (texture->native) {\n        return SDL_GL_BindTexture(texture->native, texw, texh);\n    } else if (renderer && renderer->GL_BindTexture) {\n        return renderer->GL_BindTexture(renderer, texture, texw, texh);\n    } else {\n        return SDL_Unsupported();\n    }\n}\n\nint SDL_GL_UnbindTexture(SDL_Texture *texture)\n{\n    SDL_Renderer *renderer;\n\n    CHECK_TEXTURE_MAGIC(texture, -1);\n    renderer = texture->renderer;\n    if (texture->native) {\n        return SDL_GL_UnbindTexture(texture->native);\n    } else if (renderer && renderer->GL_UnbindTexture) {\n        return renderer->GL_UnbindTexture(renderer, texture);\n    }\n\n    return SDL_Unsupported();\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../SDL_internal.h\"\n\n/* This is the software implementation of the YUV texture support */\n\n/* This code was derived from code carrying the following copyright notices:\n\n * Copyright (c) 1995 The Regents of the University of California.\n * All rights reserved.\n *\n * Permission to use, copy, modify, and distribute this software and its\n * documentation for any purpose, without fee, and without written agreement is\n * hereby granted, provided that the above copyright notice and the following\n * two paragraphs appear in all copies of this software.\n *\n * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\n * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF\n * CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n * ON AN \"AS IS\" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n\n * Copyright (c) 1995 Erik Corry\n * All rights reserved.\n *\n * Permission to use, copy, modify, and distribute this software and its\n * documentation for any purpose, without fee, and without written agreement is\n * hereby granted, provided that the above copyright notice and the following\n * two paragraphs appear in all copies of this software.\n *\n * IN NO EVENT SHALL ERIK CORRY BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,\n * SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OF\n * THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF ERIK CORRY HAS BEEN ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ERIK CORRY SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN \"AS IS\"\n * BASIS, AND ERIK CORRY HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT,\n * UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n\n * Portions of this software Copyright (c) 1995 Brown University.\n * All rights reserved.\n *\n * Permission to use, copy, modify, and distribute this software and its\n * documentation for any purpose, without fee, and without written agreement\n * is hereby granted, provided that the above copyright notice and the\n * following two paragraphs appear in all copies of this software.\n *\n * IN NO EVENT SHALL BROWN UNIVERSITY BE LIABLE TO ANY PARTY FOR\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\n * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF BROWN\n * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * BROWN UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN \"AS IS\"\n * BASIS, AND BROWN UNIVERSITY HAS NO OBLIGATION TO PROVIDE MAINTENANCE,\n * SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n */\n\n#include \"SDL_assert.h\"\n#include \"SDL_video.h\"\n#include \"SDL_cpuinfo.h\"\n#include \"SDL_yuv_sw_c.h\"\n\n\n/* The colorspace conversion functions */\n\n#if (__GNUC__ > 2) && defined(__i386__) && __OPTIMIZE__ && SDL_ASSEMBLY_ROUTINES\nextern void Color565DitherYV12MMX1X(int *colortab, Uint32 * rgb_2_pix,\n                                    unsigned char *lum, unsigned char *cr,\n                                    unsigned char *cb, unsigned char *out,\n                                    int rows, int cols, int mod);\nextern void ColorRGBDitherYV12MMX1X(int *colortab, Uint32 * rgb_2_pix,\n                                    unsigned char *lum, unsigned char *cr,\n                                    unsigned char *cb, unsigned char *out,\n                                    int rows, int cols, int mod);\n#endif\n\nstatic void\nColor16DitherYV12Mod1X(int *colortab, Uint32 * rgb_2_pix,\n                       unsigned char *lum, unsigned char *cr,\n                       unsigned char *cb, unsigned char *out,\n                       int rows, int cols, int mod)\n{\n    unsigned short *row1;\n    unsigned short *row2;\n    unsigned char *lum2;\n    int x, y;\n    int cr_r;\n    int crb_g;\n    int cb_b;\n    int cols_2 = cols / 2;\n\n    row1 = (unsigned short *) out;\n    row2 = row1 + cols + mod;\n    lum2 = lum + cols;\n\n    mod += cols + mod;\n\n    y = rows / 2;\n    while (y--) {\n        x = cols_2;\n        while (x--) {\n            register int L;\n\n            cr_r = 0 * 768 + 256 + colortab[*cr + 0 * 256];\n            crb_g = 1 * 768 + 256 + colortab[*cr + 1 * 256]\n                + colortab[*cb + 2 * 256];\n            cb_b = 2 * 768 + 256 + colortab[*cb + 3 * 256];\n            ++cr;\n            ++cb;\n\n            L = *lum++;\n            *row1++ = (unsigned short) (rgb_2_pix[L + cr_r] |\n                                        rgb_2_pix[L + crb_g] |\n                                        rgb_2_pix[L + cb_b]);\n\n            L = *lum++;\n            *row1++ = (unsigned short) (rgb_2_pix[L + cr_r] |\n                                        rgb_2_pix[L + crb_g] |\n                                        rgb_2_pix[L + cb_b]);\n\n\n            /* Now, do second row.  */\n\n            L = *lum2++;\n            *row2++ = (unsigned short) (rgb_2_pix[L + cr_r] |\n                                        rgb_2_pix[L + crb_g] |\n                                        rgb_2_pix[L + cb_b]);\n\n            L = *lum2++;\n            *row2++ = (unsigned short) (rgb_2_pix[L + cr_r] |\n                                        rgb_2_pix[L + crb_g] |\n                                        rgb_2_pix[L + cb_b]);\n        }\n\n        /*\n         * These values are at the start of the next line, (due\n         * to the ++'s above),but they need to be at the start\n         * of the line after that.\n         */\n        lum += cols;\n        lum2 += cols;\n        row1 += mod;\n        row2 += mod;\n    }\n}\n\nstatic void\nColor24DitherYV12Mod1X(int *colortab, Uint32 * rgb_2_pix,\n                       unsigned char *lum, unsigned char *cr,\n                       unsigned char *cb, unsigned char *out,\n                       int rows, int cols, int mod)\n{\n    unsigned int value;\n    unsigned char *row1;\n    unsigned char *row2;\n    unsigned char *lum2;\n    int x, y;\n    int cr_r;\n    int crb_g;\n    int cb_b;\n    int cols_2 = cols / 2;\n\n    row1 = out;\n    row2 = row1 + cols * 3 + mod * 3;\n    lum2 = lum + cols;\n\n    mod += cols + mod;\n    mod *= 3;\n\n    y = rows / 2;\n    while (y--) {\n        x = cols_2;\n        while (x--) {\n            register int L;\n\n            cr_r = 0 * 768 + 256 + colortab[*cr + 0 * 256];\n            crb_g = 1 * 768 + 256 + colortab[*cr + 1 * 256]\n                + colortab[*cb + 2 * 256];\n            cb_b = 2 * 768 + 256 + colortab[*cb + 3 * 256];\n            ++cr;\n            ++cb;\n\n            L = *lum++;\n            value = (rgb_2_pix[L + cr_r] |\n                     rgb_2_pix[L + crb_g] | rgb_2_pix[L + cb_b]);\n            *row1++ = (value) & 0xFF;\n            *row1++ = (value >> 8) & 0xFF;\n            *row1++ = (value >> 16) & 0xFF;\n\n            L = *lum++;\n            value = (rgb_2_pix[L + cr_r] |\n                     rgb_2_pix[L + crb_g] | rgb_2_pix[L + cb_b]);\n            *row1++ = (value) & 0xFF;\n            *row1++ = (value >> 8) & 0xFF;\n            *row1++ = (value >> 16) & 0xFF;\n\n\n            /* Now, do second row.  */\n\n            L = *lum2++;\n            value = (rgb_2_pix[L + cr_r] |\n                     rgb_2_pix[L + crb_g] | rgb_2_pix[L + cb_b]);\n            *row2++ = (value) & 0xFF;\n            *row2++ = (value >> 8) & 0xFF;\n            *row2++ = (value >> 16) & 0xFF;\n\n            L = *lum2++;\n            value = (rgb_2_pix[L + cr_r] |\n                     rgb_2_pix[L + crb_g] | rgb_2_pix[L + cb_b]);\n            *row2++ = (value) & 0xFF;\n            *row2++ = (value >> 8) & 0xFF;\n            *row2++ = (value >> 16) & 0xFF;\n        }\n\n        /*\n         * These values are at the start of the next line, (due\n         * to the ++'s above),but they need to be at the start\n         * of the line after that.\n         */\n        lum += cols;\n        lum2 += cols;\n        row1 += mod;\n        row2 += mod;\n    }\n}\n\nstatic void\nColor32DitherYV12Mod1X(int *colortab, Uint32 * rgb_2_pix,\n                       unsigned char *lum, unsigned char *cr,\n                       unsigned char *cb, unsigned char *out,\n                       int rows, int cols, int mod)\n{\n    unsigned int *row1;\n    unsigned int *row2;\n    unsigned char *lum2;\n    int x, y;\n    int cr_r;\n    int crb_g;\n    int cb_b;\n    int cols_2 = cols / 2;\n\n    row1 = (unsigned int *) out;\n    row2 = row1 + cols + mod;\n    lum2 = lum + cols;\n\n    mod += cols + mod;\n\n    y = rows / 2;\n    while (y--) {\n        x = cols_2;\n        while (x--) {\n            register int L;\n\n            cr_r = 0 * 768 + 256 + colortab[*cr + 0 * 256];\n            crb_g = 1 * 768 + 256 + colortab[*cr + 1 * 256]\n                + colortab[*cb + 2 * 256];\n            cb_b = 2 * 768 + 256 + colortab[*cb + 3 * 256];\n            ++cr;\n            ++cb;\n\n            L = *lum++;\n            *row1++ = (rgb_2_pix[L + cr_r] |\n                       rgb_2_pix[L + crb_g] | rgb_2_pix[L + cb_b]);\n\n            L = *lum++;\n            *row1++ = (rgb_2_pix[L + cr_r] |\n                       rgb_2_pix[L + crb_g] | rgb_2_pix[L + cb_b]);\n\n\n            /* Now, do second row.  */\n\n            L = *lum2++;\n            *row2++ = (rgb_2_pix[L + cr_r] |\n                       rgb_2_pix[L + crb_g] | rgb_2_pix[L + cb_b]);\n\n            L = *lum2++;\n            *row2++ = (rgb_2_pix[L + cr_r] |\n                       rgb_2_pix[L + crb_g] | rgb_2_pix[L + cb_b]);\n        }\n\n        /*\n         * These values are at the start of the next line, (due\n         * to the ++'s above),but they need to be at the start\n         * of the line after that.\n         */\n        lum += cols;\n        lum2 += cols;\n        row1 += mod;\n        row2 += mod;\n    }\n}\n\n/*\n * In this function I make use of a nasty trick. The tables have the lower\n * 16 bits replicated in the upper 16. This means I can write ints and get\n * the horisontal doubling for free (almost).\n */\nstatic void\nColor16DitherYV12Mod2X(int *colortab, Uint32 * rgb_2_pix,\n                       unsigned char *lum, unsigned char *cr,\n                       unsigned char *cb, unsigned char *out,\n                       int rows, int cols, int mod)\n{\n    unsigned int *row1 = (unsigned int *) out;\n    const int next_row = cols + (mod / 2);\n    unsigned int *row2 = row1 + 2 * next_row;\n    unsigned char *lum2;\n    int x, y;\n    int cr_r;\n    int crb_g;\n    int cb_b;\n    int cols_2 = cols / 2;\n\n    lum2 = lum + cols;\n\n    mod = (next_row * 3) + (mod / 2);\n\n    y = rows / 2;\n    while (y--) {\n        x = cols_2;\n        while (x--) {\n            register int L;\n\n            cr_r = 0 * 768 + 256 + colortab[*cr + 0 * 256];\n            crb_g = 1 * 768 + 256 + colortab[*cr + 1 * 256]\n                + colortab[*cb + 2 * 256];\n            cb_b = 2 * 768 + 256 + colortab[*cb + 3 * 256];\n            ++cr;\n            ++cb;\n\n            L = *lum++;\n            row1[0] = row1[next_row] = (rgb_2_pix[L + cr_r] |\n                                        rgb_2_pix[L + crb_g] |\n                                        rgb_2_pix[L + cb_b]);\n            row1++;\n\n            L = *lum++;\n            row1[0] = row1[next_row] = (rgb_2_pix[L + cr_r] |\n                                        rgb_2_pix[L + crb_g] |\n                                        rgb_2_pix[L + cb_b]);\n            row1++;\n\n\n            /* Now, do second row. */\n\n            L = *lum2++;\n            row2[0] = row2[next_row] = (rgb_2_pix[L + cr_r] |\n                                        rgb_2_pix[L + crb_g] |\n                                        rgb_2_pix[L + cb_b]);\n            row2++;\n\n            L = *lum2++;\n            row2[0] = row2[next_row] = (rgb_2_pix[L + cr_r] |\n                                        rgb_2_pix[L + crb_g] |\n                                        rgb_2_pix[L + cb_b]);\n            row2++;\n        }\n\n        /*\n         * These values are at the start of the next line, (due\n         * to the ++'s above),but they need to be at the start\n         * of the line after that.\n         */\n        lum += cols;\n        lum2 += cols;\n        row1 += mod;\n        row2 += mod;\n    }\n}\n\nstatic void\nColor24DitherYV12Mod2X(int *colortab, Uint32 * rgb_2_pix,\n                       unsigned char *lum, unsigned char *cr,\n                       unsigned char *cb, unsigned char *out,\n                       int rows, int cols, int mod)\n{\n    unsigned int value;\n    unsigned char *row1 = out;\n    const int next_row = (cols * 2 + mod) * 3;\n    unsigned char *row2 = row1 + 2 * next_row;\n    unsigned char *lum2;\n    int x, y;\n    int cr_r;\n    int crb_g;\n    int cb_b;\n    int cols_2 = cols / 2;\n\n    lum2 = lum + cols;\n\n    mod = next_row * 3 + mod * 3;\n\n    y = rows / 2;\n    while (y--) {\n        x = cols_2;\n        while (x--) {\n            register int L;\n\n            cr_r = 0 * 768 + 256 + colortab[*cr + 0 * 256];\n            crb_g = 1 * 768 + 256 + colortab[*cr + 1 * 256]\n                + colortab[*cb + 2 * 256];\n            cb_b = 2 * 768 + 256 + colortab[*cb + 3 * 256];\n            ++cr;\n            ++cb;\n\n            L = *lum++;\n            value = (rgb_2_pix[L + cr_r] |\n                     rgb_2_pix[L + crb_g] | rgb_2_pix[L + cb_b]);\n            row1[0 + 0] = row1[3 + 0] = row1[next_row + 0] =\n                row1[next_row + 3 + 0] = (value) & 0xFF;\n            row1[0 + 1] = row1[3 + 1] = row1[next_row + 1] =\n                row1[next_row + 3 + 1] = (value >> 8) & 0xFF;\n            row1[0 + 2] = row1[3 + 2] = row1[next_row + 2] =\n                row1[next_row + 3 + 2] = (value >> 16) & 0xFF;\n            row1 += 2 * 3;\n\n            L = *lum++;\n            value = (rgb_2_pix[L + cr_r] |\n                     rgb_2_pix[L + crb_g] | rgb_2_pix[L + cb_b]);\n            row1[0 + 0] = row1[3 + 0] = row1[next_row + 0] =\n                row1[next_row + 3 + 0] = (value) & 0xFF;\n            row1[0 + 1] = row1[3 + 1] = row1[next_row + 1] =\n                row1[next_row + 3 + 1] = (value >> 8) & 0xFF;\n            row1[0 + 2] = row1[3 + 2] = row1[next_row + 2] =\n                row1[next_row + 3 + 2] = (value >> 16) & 0xFF;\n            row1 += 2 * 3;\n\n\n            /* Now, do second row. */\n\n            L = *lum2++;\n            value = (rgb_2_pix[L + cr_r] |\n                     rgb_2_pix[L + crb_g] | rgb_2_pix[L + cb_b]);\n            row2[0 + 0] = row2[3 + 0] = row2[next_row + 0] =\n                row2[next_row + 3 + 0] = (value) & 0xFF;\n            row2[0 + 1] = row2[3 + 1] = row2[next_row + 1] =\n                row2[next_row + 3 + 1] = (value >> 8) & 0xFF;\n            row2[0 + 2] = row2[3 + 2] = row2[next_row + 2] =\n                row2[next_row + 3 + 2] = (value >> 16) & 0xFF;\n            row2 += 2 * 3;\n\n            L = *lum2++;\n            value = (rgb_2_pix[L + cr_r] |\n                     rgb_2_pix[L + crb_g] | rgb_2_pix[L + cb_b]);\n            row2[0 + 0] = row2[3 + 0] = row2[next_row + 0] =\n                row2[next_row + 3 + 0] = (value) & 0xFF;\n            row2[0 + 1] = row2[3 + 1] = row2[next_row + 1] =\n                row2[next_row + 3 + 1] = (value >> 8) & 0xFF;\n            row2[0 + 2] = row2[3 + 2] = row2[next_row + 2] =\n                row2[next_row + 3 + 2] = (value >> 16) & 0xFF;\n            row2 += 2 * 3;\n        }\n\n        /*\n         * These values are at the start of the next line, (due\n         * to the ++'s above),but they need to be at the start\n         * of the line after that.\n         */\n        lum += cols;\n        lum2 += cols;\n        row1 += mod;\n        row2 += mod;\n    }\n}\n\nstatic void\nColor32DitherYV12Mod2X(int *colortab, Uint32 * rgb_2_pix,\n                       unsigned char *lum, unsigned char *cr,\n                       unsigned char *cb, unsigned char *out,\n                       int rows, int cols, int mod)\n{\n    unsigned int *row1 = (unsigned int *) out;\n    const int next_row = cols * 2 + mod;\n    unsigned int *row2 = row1 + 2 * next_row;\n    unsigned char *lum2;\n    int x, y;\n    int cr_r;\n    int crb_g;\n    int cb_b;\n    int cols_2 = cols / 2;\n\n    lum2 = lum + cols;\n\n    mod = (next_row * 3) + mod;\n\n    y = rows / 2;\n    while (y--) {\n        x = cols_2;\n        while (x--) {\n            register int L;\n\n            cr_r = 0 * 768 + 256 + colortab[*cr + 0 * 256];\n            crb_g = 1 * 768 + 256 + colortab[*cr + 1 * 256]\n                + colortab[*cb + 2 * 256];\n            cb_b = 2 * 768 + 256 + colortab[*cb + 3 * 256];\n            ++cr;\n            ++cb;\n\n            L = *lum++;\n            row1[0] = row1[1] = row1[next_row] = row1[next_row + 1] =\n                (rgb_2_pix[L + cr_r] |\n                 rgb_2_pix[L + crb_g] | rgb_2_pix[L + cb_b]);\n            row1 += 2;\n\n            L = *lum++;\n            row1[0] = row1[1] = row1[next_row] = row1[next_row + 1] =\n                (rgb_2_pix[L + cr_r] |\n                 rgb_2_pix[L + crb_g] | rgb_2_pix[L + cb_b]);\n            row1 += 2;\n\n\n            /* Now, do second row. */\n\n            L = *lum2++;\n            row2[0] = row2[1] = row2[next_row] = row2[next_row + 1] =\n                (rgb_2_pix[L + cr_r] |\n                 rgb_2_pix[L + crb_g] | rgb_2_pix[L + cb_b]);\n            row2 += 2;\n\n            L = *lum2++;\n            row2[0] = row2[1] = row2[next_row] = row2[next_row + 1] =\n                (rgb_2_pix[L + cr_r] |\n                 rgb_2_pix[L + crb_g] | rgb_2_pix[L + cb_b]);\n            row2 += 2;\n        }\n\n        /*\n         * These values are at the start of the next line, (due\n         * to the ++'s above),but they need to be at the start\n         * of the line after that.\n         */\n        lum += cols;\n        lum2 += cols;\n        row1 += mod;\n        row2 += mod;\n    }\n}\n\nstatic void\nColor16DitherYUY2Mod1X(int *colortab, Uint32 * rgb_2_pix,\n                       unsigned char *lum, unsigned char *cr,\n                       unsigned char *cb, unsigned char *out,\n                       int rows, int cols, int mod)\n{\n    unsigned short *row;\n    int x, y;\n    int cr_r;\n    int crb_g;\n    int cb_b;\n    int cols_2 = cols / 2;\n\n    row = (unsigned short *) out;\n\n    y = rows;\n    while (y--) {\n        x = cols_2;\n        while (x--) {\n            register int L;\n\n            cr_r = 0 * 768 + 256 + colortab[*cr + 0 * 256];\n            crb_g = 1 * 768 + 256 + colortab[*cr + 1 * 256]\n                + colortab[*cb + 2 * 256];\n            cb_b = 2 * 768 + 256 + colortab[*cb + 3 * 256];\n            cr += 4;\n            cb += 4;\n\n            L = *lum;\n            lum += 2;\n            *row++ = (unsigned short) (rgb_2_pix[L + cr_r] |\n                                       rgb_2_pix[L + crb_g] |\n                                       rgb_2_pix[L + cb_b]);\n\n            L = *lum;\n            lum += 2;\n            *row++ = (unsigned short) (rgb_2_pix[L + cr_r] |\n                                       rgb_2_pix[L + crb_g] |\n                                       rgb_2_pix[L + cb_b]);\n\n        }\n\n        row += mod;\n    }\n}\n\nstatic void\nColor24DitherYUY2Mod1X(int *colortab, Uint32 * rgb_2_pix,\n                       unsigned char *lum, unsigned char *cr,\n                       unsigned char *cb, unsigned char *out,\n                       int rows, int cols, int mod)\n{\n    unsigned int value;\n    unsigned char *row;\n    int x, y;\n    int cr_r;\n    int crb_g;\n    int cb_b;\n    int cols_2 = cols / 2;\n\n    row = (unsigned char *) out;\n    mod *= 3;\n    y = rows;\n    while (y--) {\n        x = cols_2;\n        while (x--) {\n            register int L;\n\n            cr_r = 0 * 768 + 256 + colortab[*cr + 0 * 256];\n            crb_g = 1 * 768 + 256 + colortab[*cr + 1 * 256]\n                + colortab[*cb + 2 * 256];\n            cb_b = 2 * 768 + 256 + colortab[*cb + 3 * 256];\n            cr += 4;\n            cb += 4;\n\n            L = *lum;\n            lum += 2;\n            value = (rgb_2_pix[L + cr_r] |\n                     rgb_2_pix[L + crb_g] | rgb_2_pix[L + cb_b]);\n            *row++ = (value) & 0xFF;\n            *row++ = (value >> 8) & 0xFF;\n            *row++ = (value >> 16) & 0xFF;\n\n            L = *lum;\n            lum += 2;\n            value = (rgb_2_pix[L + cr_r] |\n                     rgb_2_pix[L + crb_g] | rgb_2_pix[L + cb_b]);\n            *row++ = (value) & 0xFF;\n            *row++ = (value >> 8) & 0xFF;\n            *row++ = (value >> 16) & 0xFF;\n\n        }\n        row += mod;\n    }\n}\n\nstatic void\nColor32DitherYUY2Mod1X(int *colortab, Uint32 * rgb_2_pix,\n                       unsigned char *lum, unsigned char *cr,\n                       unsigned char *cb, unsigned char *out,\n                       int rows, int cols, int mod)\n{\n    unsigned int *row;\n    int x, y;\n    int cr_r;\n    int crb_g;\n    int cb_b;\n    int cols_2 = cols / 2;\n\n    row = (unsigned int *) out;\n    y = rows;\n    while (y--) {\n        x = cols_2;\n        while (x--) {\n            register int L;\n\n            cr_r = 0 * 768 + 256 + colortab[*cr + 0 * 256];\n            crb_g = 1 * 768 + 256 + colortab[*cr + 1 * 256]\n                + colortab[*cb + 2 * 256];\n            cb_b = 2 * 768 + 256 + colortab[*cb + 3 * 256];\n            cr += 4;\n            cb += 4;\n\n            L = *lum;\n            lum += 2;\n            *row++ = (rgb_2_pix[L + cr_r] |\n                      rgb_2_pix[L + crb_g] | rgb_2_pix[L + cb_b]);\n\n            L = *lum;\n            lum += 2;\n            *row++ = (rgb_2_pix[L + cr_r] |\n                      rgb_2_pix[L + crb_g] | rgb_2_pix[L + cb_b]);\n\n\n        }\n        row += mod;\n    }\n}\n\n/*\n * In this function I make use of a nasty trick. The tables have the lower\n * 16 bits replicated in the upper 16. This means I can write ints and get\n * the horisontal doubling for free (almost).\n */\nstatic void\nColor16DitherYUY2Mod2X(int *colortab, Uint32 * rgb_2_pix,\n                       unsigned char *lum, unsigned char *cr,\n                       unsigned char *cb, unsigned char *out,\n                       int rows, int cols, int mod)\n{\n    unsigned int *row = (unsigned int *) out;\n    const int next_row = cols + (mod / 2);\n    int x, y;\n    int cr_r;\n    int crb_g;\n    int cb_b;\n    int cols_2 = cols / 2;\n\n    y = rows;\n    while (y--) {\n        x = cols_2;\n        while (x--) {\n            register int L;\n\n            cr_r = 0 * 768 + 256 + colortab[*cr + 0 * 256];\n            crb_g = 1 * 768 + 256 + colortab[*cr + 1 * 256]\n                + colortab[*cb + 2 * 256];\n            cb_b = 2 * 768 + 256 + colortab[*cb + 3 * 256];\n            cr += 4;\n            cb += 4;\n\n            L = *lum;\n            lum += 2;\n            row[0] = row[next_row] = (rgb_2_pix[L + cr_r] |\n                                      rgb_2_pix[L + crb_g] |\n                                      rgb_2_pix[L + cb_b]);\n            row++;\n\n            L = *lum;\n            lum += 2;\n            row[0] = row[next_row] = (rgb_2_pix[L + cr_r] |\n                                      rgb_2_pix[L + crb_g] |\n                                      rgb_2_pix[L + cb_b]);\n            row++;\n\n        }\n        row += next_row;\n    }\n}\n\nstatic void\nColor24DitherYUY2Mod2X(int *colortab, Uint32 * rgb_2_pix,\n                       unsigned char *lum, unsigned char *cr,\n                       unsigned char *cb, unsigned char *out,\n                       int rows, int cols, int mod)\n{\n    unsigned int value;\n    unsigned char *row = out;\n    const int next_row = (cols * 2 + mod) * 3;\n    int x, y;\n    int cr_r;\n    int crb_g;\n    int cb_b;\n    int cols_2 = cols / 2;\n    y = rows;\n    while (y--) {\n        x = cols_2;\n        while (x--) {\n            register int L;\n\n            cr_r = 0 * 768 + 256 + colortab[*cr + 0 * 256];\n            crb_g = 1 * 768 + 256 + colortab[*cr + 1 * 256]\n                + colortab[*cb + 2 * 256];\n            cb_b = 2 * 768 + 256 + colortab[*cb + 3 * 256];\n            cr += 4;\n            cb += 4;\n\n            L = *lum;\n            lum += 2;\n            value = (rgb_2_pix[L + cr_r] |\n                     rgb_2_pix[L + crb_g] | rgb_2_pix[L + cb_b]);\n            row[0 + 0] = row[3 + 0] = row[next_row + 0] =\n                row[next_row + 3 + 0] = (value) & 0xFF;\n            row[0 + 1] = row[3 + 1] = row[next_row + 1] =\n                row[next_row + 3 + 1] = (value >> 8) & 0xFF;\n            row[0 + 2] = row[3 + 2] = row[next_row + 2] =\n                row[next_row + 3 + 2] = (value >> 16) & 0xFF;\n            row += 2 * 3;\n\n            L = *lum;\n            lum += 2;\n            value = (rgb_2_pix[L + cr_r] |\n                     rgb_2_pix[L + crb_g] | rgb_2_pix[L + cb_b]);\n            row[0 + 0] = row[3 + 0] = row[next_row + 0] =\n                row[next_row + 3 + 0] = (value) & 0xFF;\n            row[0 + 1] = row[3 + 1] = row[next_row + 1] =\n                row[next_row + 3 + 1] = (value >> 8) & 0xFF;\n            row[0 + 2] = row[3 + 2] = row[next_row + 2] =\n                row[next_row + 3 + 2] = (value >> 16) & 0xFF;\n            row += 2 * 3;\n\n        }\n        row += next_row;\n    }\n}\n\nstatic void\nColor32DitherYUY2Mod2X(int *colortab, Uint32 * rgb_2_pix,\n                       unsigned char *lum, unsigned char *cr,\n                       unsigned char *cb, unsigned char *out,\n                       int rows, int cols, int mod)\n{\n    unsigned int *row = (unsigned int *) out;\n    const int next_row = cols * 2 + mod;\n    int x, y;\n    int cr_r;\n    int crb_g;\n    int cb_b;\n    int cols_2 = cols / 2;\n    mod += mod;\n    y = rows;\n    while (y--) {\n        x = cols_2;\n        while (x--) {\n            register int L;\n\n            cr_r = 0 * 768 + 256 + colortab[*cr + 0 * 256];\n            crb_g = 1 * 768 + 256 + colortab[*cr + 1 * 256]\n                + colortab[*cb + 2 * 256];\n            cb_b = 2 * 768 + 256 + colortab[*cb + 3 * 256];\n            cr += 4;\n            cb += 4;\n\n            L = *lum;\n            lum += 2;\n            row[0] = row[1] = row[next_row] = row[next_row + 1] =\n                (rgb_2_pix[L + cr_r] |\n                 rgb_2_pix[L + crb_g] | rgb_2_pix[L + cb_b]);\n            row += 2;\n\n            L = *lum;\n            lum += 2;\n            row[0] = row[1] = row[next_row] = row[next_row + 1] =\n                (rgb_2_pix[L + cr_r] |\n                 rgb_2_pix[L + crb_g] | rgb_2_pix[L + cb_b]);\n            row += 2;\n\n\n        }\n\n        row += next_row;\n    }\n}\n\n/*\n * How many 1 bits are there in the Uint32.\n * Low performance, do not call often.\n */\nstatic int\nnumber_of_bits_set(Uint32 a)\n{\n    if (!a)\n        return 0;\n    if (a & 1)\n        return 1 + number_of_bits_set(a >> 1);\n    return (number_of_bits_set(a >> 1));\n}\n\n/*\n * How many 0 bits are there at least significant end of Uint32.\n * Low performance, do not call often.\n */\nstatic int\nfree_bits_at_bottom(Uint32 a)\n{\n    /* assume char is 8 bits */\n    if (!a)\n        return sizeof(Uint32) * 8;\n    if (((Sint32) a) & 1l)\n        return 0;\n    return 1 + free_bits_at_bottom(a >> 1);\n}\n\nstatic int\nSDL_SW_SetupYUVDisplay(SDL_SW_YUVTexture * swdata, Uint32 target_format)\n{\n    Uint32 *r_2_pix_alloc;\n    Uint32 *g_2_pix_alloc;\n    Uint32 *b_2_pix_alloc;\n    int i;\n    int bpp;\n    Uint32 Rmask, Gmask, Bmask, Amask;\n\n    if (!SDL_PixelFormatEnumToMasks\n        (target_format, &bpp, &Rmask, &Gmask, &Bmask, &Amask) || bpp < 15) {\n        return SDL_SetError(\"Unsupported YUV destination format\");\n    }\n\n    swdata->target_format = target_format;\n    r_2_pix_alloc = &swdata->rgb_2_pix[0 * 768];\n    g_2_pix_alloc = &swdata->rgb_2_pix[1 * 768];\n    b_2_pix_alloc = &swdata->rgb_2_pix[2 * 768];\n\n    /*\n     * Set up entries 0-255 in rgb-to-pixel value tables.\n     */\n    for (i = 0; i < 256; ++i) {\n        r_2_pix_alloc[i + 256] = i >> (8 - number_of_bits_set(Rmask));\n        r_2_pix_alloc[i + 256] <<= free_bits_at_bottom(Rmask);\n        r_2_pix_alloc[i + 256] |= Amask;\n        g_2_pix_alloc[i + 256] = i >> (8 - number_of_bits_set(Gmask));\n        g_2_pix_alloc[i + 256] <<= free_bits_at_bottom(Gmask);\n        g_2_pix_alloc[i + 256] |= Amask;\n        b_2_pix_alloc[i + 256] = i >> (8 - number_of_bits_set(Bmask));\n        b_2_pix_alloc[i + 256] <<= free_bits_at_bottom(Bmask);\n        b_2_pix_alloc[i + 256] |= Amask;\n    }\n\n    /*\n     * If we have 16-bit output depth, then we double the value\n     * in the top word. This means that we can write out both\n     * pixels in the pixel doubling mode with one op. It is\n     * harmless in the normal case as storing a 32-bit value\n     * through a short pointer will lose the top bits anyway.\n     */\n    if (SDL_BYTESPERPIXEL(target_format) == 2) {\n        for (i = 0; i < 256; ++i) {\n            r_2_pix_alloc[i + 256] |= (r_2_pix_alloc[i + 256]) << 16;\n            g_2_pix_alloc[i + 256] |= (g_2_pix_alloc[i + 256]) << 16;\n            b_2_pix_alloc[i + 256] |= (b_2_pix_alloc[i + 256]) << 16;\n        }\n    }\n\n    /*\n     * Spread out the values we have to the rest of the array so that\n     * we do not need to check for overflow.\n     */\n    for (i = 0; i < 256; ++i) {\n        r_2_pix_alloc[i] = r_2_pix_alloc[256];\n        r_2_pix_alloc[i + 512] = r_2_pix_alloc[511];\n        g_2_pix_alloc[i] = g_2_pix_alloc[256];\n        g_2_pix_alloc[i + 512] = g_2_pix_alloc[511];\n        b_2_pix_alloc[i] = b_2_pix_alloc[256];\n        b_2_pix_alloc[i + 512] = b_2_pix_alloc[511];\n    }\n\n    /* You have chosen wisely... */\n    switch (swdata->format) {\n    case SDL_PIXELFORMAT_YV12:\n    case SDL_PIXELFORMAT_IYUV:\n        if (SDL_BYTESPERPIXEL(target_format) == 2) {\n#if (__GNUC__ > 2) && defined(__i386__) && __OPTIMIZE__ && SDL_ASSEMBLY_ROUTINES\n            /* inline assembly functions */\n            if (SDL_HasMMX() && (Rmask == 0xF800) &&\n                (Gmask == 0x07E0) && (Bmask == 0x001F)\n                && (swdata->w & 15) == 0) {\n/* printf(\"Using MMX 16-bit 565 dither\\n\"); */\n                swdata->Display1X = Color565DitherYV12MMX1X;\n            } else {\n/* printf(\"Using C 16-bit dither\\n\"); */\n                swdata->Display1X = Color16DitherYV12Mod1X;\n            }\n#else\n            swdata->Display1X = Color16DitherYV12Mod1X;\n#endif\n            swdata->Display2X = Color16DitherYV12Mod2X;\n        }\n        if (SDL_BYTESPERPIXEL(target_format) == 3) {\n            swdata->Display1X = Color24DitherYV12Mod1X;\n            swdata->Display2X = Color24DitherYV12Mod2X;\n        }\n        if (SDL_BYTESPERPIXEL(target_format) == 4) {\n#if (__GNUC__ > 2) && defined(__i386__) && __OPTIMIZE__ && SDL_ASSEMBLY_ROUTINES\n            /* inline assembly functions */\n            if (SDL_HasMMX() && (Rmask == 0x00FF0000) &&\n                (Gmask == 0x0000FF00) &&\n                (Bmask == 0x000000FF) && (swdata->w & 15) == 0) {\n/* printf(\"Using MMX 32-bit dither\\n\"); */\n                swdata->Display1X = ColorRGBDitherYV12MMX1X;\n            } else {\n/* printf(\"Using C 32-bit dither\\n\"); */\n                swdata->Display1X = Color32DitherYV12Mod1X;\n            }\n#else\n            swdata->Display1X = Color32DitherYV12Mod1X;\n#endif\n            swdata->Display2X = Color32DitherYV12Mod2X;\n        }\n        break;\n    case SDL_PIXELFORMAT_YUY2:\n    case SDL_PIXELFORMAT_UYVY:\n    case SDL_PIXELFORMAT_YVYU:\n        if (SDL_BYTESPERPIXEL(target_format) == 2) {\n            swdata->Display1X = Color16DitherYUY2Mod1X;\n            swdata->Display2X = Color16DitherYUY2Mod2X;\n        }\n        if (SDL_BYTESPERPIXEL(target_format) == 3) {\n            swdata->Display1X = Color24DitherYUY2Mod1X;\n            swdata->Display2X = Color24DitherYUY2Mod2X;\n        }\n        if (SDL_BYTESPERPIXEL(target_format) == 4) {\n            swdata->Display1X = Color32DitherYUY2Mod1X;\n            swdata->Display2X = Color32DitherYUY2Mod2X;\n        }\n        break;\n    default:\n        /* We should never get here (caught above) */\n        break;\n    }\n\n    SDL_FreeSurface(swdata->display);\n    swdata->display = NULL;\n    return 0;\n}\n\nSDL_SW_YUVTexture *\nSDL_SW_CreateYUVTexture(Uint32 format, int w, int h)\n{\n    SDL_SW_YUVTexture *swdata;\n    int *Cr_r_tab;\n    int *Cr_g_tab;\n    int *Cb_g_tab;\n    int *Cb_b_tab;\n    int i;\n    int CR, CB;\n\n    switch (format) {\n    case SDL_PIXELFORMAT_YV12:\n    case SDL_PIXELFORMAT_IYUV:\n    case SDL_PIXELFORMAT_YUY2:\n    case SDL_PIXELFORMAT_UYVY:\n    case SDL_PIXELFORMAT_YVYU:\n        break;\n    default:\n        SDL_SetError(\"Unsupported YUV format\");\n        return NULL;\n    }\n\n    swdata = (SDL_SW_YUVTexture *) SDL_calloc(1, sizeof(*swdata));\n    if (!swdata) {\n        SDL_OutOfMemory();\n        return NULL;\n    }\n\n    swdata->format = format;\n    swdata->target_format = SDL_PIXELFORMAT_UNKNOWN;\n    swdata->w = w;\n    swdata->h = h;\n    swdata->pixels = (Uint8 *) SDL_malloc(w * h * 2);\n    swdata->colortab = (int *) SDL_malloc(4 * 256 * sizeof(int));\n    swdata->rgb_2_pix = (Uint32 *) SDL_malloc(3 * 768 * sizeof(Uint32));\n    if (!swdata->pixels || !swdata->colortab || !swdata->rgb_2_pix) {\n        SDL_SW_DestroyYUVTexture(swdata);\n        SDL_OutOfMemory();\n        return NULL;\n    }\n\n    /* Generate the tables for the display surface */\n    Cr_r_tab = &swdata->colortab[0 * 256];\n    Cr_g_tab = &swdata->colortab[1 * 256];\n    Cb_g_tab = &swdata->colortab[2 * 256];\n    Cb_b_tab = &swdata->colortab[3 * 256];\n    for (i = 0; i < 256; i++) {\n        /* Gamma correction (luminescence table) and chroma correction\n           would be done here.  See the Berkeley mpeg_play sources.\n         */\n        CB = CR = (i - 128);\n        Cr_r_tab[i] = (int) ((0.419 / 0.299) * CR);\n        Cr_g_tab[i] = (int) (-(0.299 / 0.419) * CR);\n        Cb_g_tab[i] = (int) (-(0.114 / 0.331) * CB);\n        Cb_b_tab[i] = (int) ((0.587 / 0.331) * CB);\n    }\n\n    /* Find the pitch and offset values for the overlay */\n    switch (format) {\n    case SDL_PIXELFORMAT_YV12:\n    case SDL_PIXELFORMAT_IYUV:\n        swdata->pitches[0] = w;\n        swdata->pitches[1] = swdata->pitches[0] / 2;\n        swdata->pitches[2] = swdata->pitches[0] / 2;\n        swdata->planes[0] = swdata->pixels;\n        swdata->planes[1] = swdata->planes[0] + swdata->pitches[0] * h;\n        swdata->planes[2] = swdata->planes[1] + swdata->pitches[1] * h / 2;\n        break;\n    case SDL_PIXELFORMAT_YUY2:\n    case SDL_PIXELFORMAT_UYVY:\n    case SDL_PIXELFORMAT_YVYU:\n        swdata->pitches[0] = w * 2;\n        swdata->planes[0] = swdata->pixels;\n        break;\n    default:\n        SDL_assert(0 && \"We should never get here (caught above)\");\n        break;\n    }\n\n    /* We're all done.. */\n    return (swdata);\n}\n\nint\nSDL_SW_QueryYUVTexturePixels(SDL_SW_YUVTexture * swdata, void **pixels,\n                             int *pitch)\n{\n    *pixels = swdata->planes[0];\n    *pitch = swdata->pitches[0];\n    return 0;\n}\n\nint\nSDL_SW_UpdateYUVTexture(SDL_SW_YUVTexture * swdata, const SDL_Rect * rect,\n                        const void *pixels, int pitch)\n{\n    switch (swdata->format) {\n    case SDL_PIXELFORMAT_YV12:\n    case SDL_PIXELFORMAT_IYUV:\n        if (rect->x == 0 && rect->y == 0 &&\n            rect->w == swdata->w && rect->h == swdata->h) {\n                SDL_memcpy(swdata->pixels, pixels,\n                           (swdata->h * swdata->w) + (swdata->h * swdata->w) / 2);\n        } else {\n            Uint8 *src, *dst;\n            int row;\n            size_t length;\n\n            /* Copy the Y plane */\n            src = (Uint8 *) pixels;\n            dst = swdata->pixels + rect->y * swdata->w + rect->x;\n            length = rect->w;\n            for (row = 0; row < rect->h; ++row) {\n                SDL_memcpy(dst, src, length);\n                src += pitch;\n                dst += swdata->w;\n            }\n\n            /* Copy the next plane */\n            src = (Uint8 *) pixels + rect->h * pitch;\n            dst = swdata->pixels + swdata->h * swdata->w;\n            dst += rect->y/2 * swdata->w/2 + rect->x/2;\n            length = rect->w / 2;\n            for (row = 0; row < rect->h/2; ++row) {\n                SDL_memcpy(dst, src, length);\n                src += pitch/2;\n                dst += swdata->w/2;\n            }\n\n            /* Copy the next plane */\n            src = (Uint8 *) pixels + rect->h * pitch + (rect->h * pitch) / 4;\n            dst = swdata->pixels + swdata->h * swdata->w +\n                  (swdata->h * swdata->w) / 4;\n            dst += rect->y/2 * swdata->w/2 + rect->x/2;\n            length = rect->w / 2;\n            for (row = 0; row < rect->h/2; ++row) {\n                SDL_memcpy(dst, src, length);\n                src += pitch/2;\n                dst += swdata->w/2;\n            }\n        }\n        break;\n    case SDL_PIXELFORMAT_YUY2:\n    case SDL_PIXELFORMAT_UYVY:\n    case SDL_PIXELFORMAT_YVYU:\n        {\n            Uint8 *src, *dst;\n            int row;\n            size_t length;\n\n            src = (Uint8 *) pixels;\n            dst =\n                swdata->planes[0] + rect->y * swdata->pitches[0] +\n                rect->x * 2;\n            length = rect->w * 2;\n            for (row = 0; row < rect->h; ++row) {\n                SDL_memcpy(dst, src, length);\n                src += pitch;\n                dst += swdata->pitches[0];\n            }\n        }\n        break;\n    }\n    return 0;\n}\n\nint\nSDL_SW_UpdateYUVTexturePlanar(SDL_SW_YUVTexture * swdata, const SDL_Rect * rect,\n                              const Uint8 *Yplane, int Ypitch,\n                              const Uint8 *Uplane, int Upitch,\n                              const Uint8 *Vplane, int Vpitch)\n{\n    const Uint8 *src;\n    Uint8 *dst;\n    int row;\n    size_t length;\n\n    /* Copy the Y plane */\n    src = Yplane;\n    dst = swdata->pixels + rect->y * swdata->w + rect->x;\n    length = rect->w;\n    for (row = 0; row < rect->h; ++row) {\n        SDL_memcpy(dst, src, length);\n        src += Ypitch;\n        dst += swdata->w;\n    }\n\n    /* Copy the U plane */\n    src = Uplane;\n    if (swdata->format == SDL_PIXELFORMAT_IYUV) {\n        dst = swdata->pixels + swdata->h * swdata->w;\n    } else {\n        dst = swdata->pixels + swdata->h * swdata->w +\n              (swdata->h * swdata->w) / 4;\n    }\n    dst += rect->y/2 * swdata->w/2 + rect->x/2;\n    length = rect->w / 2;\n    for (row = 0; row < rect->h/2; ++row) {\n        SDL_memcpy(dst, src, length);\n        src += Upitch;\n        dst += swdata->w/2;\n    }\n\n    /* Copy the V plane */\n    src = Vplane;\n    if (swdata->format == SDL_PIXELFORMAT_YV12) {\n        dst = swdata->pixels + swdata->h * swdata->w;\n    } else {\n        dst = swdata->pixels + swdata->h * swdata->w +\n              (swdata->h * swdata->w) / 4;\n    }\n    dst += rect->y/2 * swdata->w/2 + rect->x/2;\n    length = rect->w / 2;\n    for (row = 0; row < rect->h/2; ++row) {\n        SDL_memcpy(dst, src, length);\n        src += Vpitch;\n        dst += swdata->w/2;\n    }\n    return 0;\n}\n\nint\nSDL_SW_LockYUVTexture(SDL_SW_YUVTexture * swdata, const SDL_Rect * rect,\n                      void **pixels, int *pitch)\n{\n    switch (swdata->format) {\n    case SDL_PIXELFORMAT_YV12:\n    case SDL_PIXELFORMAT_IYUV:\n        if (rect\n            && (rect->x != 0 || rect->y != 0 || rect->w != swdata->w\n                || rect->h != swdata->h)) {\n            return SDL_SetError\n                (\"YV12 and IYUV textures only support full surface locks\");\n        }\n        break;\n    }\n\n    if (rect) {\n        *pixels = swdata->planes[0] + rect->y * swdata->pitches[0] + rect->x * 2;\n    } else {\n        *pixels = swdata->planes[0];\n    }\n    *pitch = swdata->pitches[0];\n    return 0;\n}\n\nvoid\nSDL_SW_UnlockYUVTexture(SDL_SW_YUVTexture * swdata)\n{\n}\n\nint\nSDL_SW_CopyYUVToRGB(SDL_SW_YUVTexture * swdata, const SDL_Rect * srcrect,\n                    Uint32 target_format, int w, int h, void *pixels,\n                    int pitch)\n{\n    const int targetbpp = SDL_BYTESPERPIXEL(target_format);\n    int stretch;\n    int scale_2x;\n    Uint8 *lum, *Cr, *Cb;\n    int mod;\n\n    if (targetbpp == 0) {\n        return SDL_SetError(\"Invalid target pixel format\");\n    }\n\n    /* Make sure we're set up to display in the desired format */\n    if (target_format != swdata->target_format) {\n        if (SDL_SW_SetupYUVDisplay(swdata, target_format) < 0) {\n            return -1;\n        }\n    }\n\n    stretch = 0;\n    scale_2x = 0;\n    if (srcrect->x || srcrect->y || srcrect->w < swdata->w\n        || srcrect->h < swdata->h) {\n        /* The source rectangle has been clipped.\n           Using a scratch surface is easier than adding clipped\n           source support to all the blitters, plus that would\n           slow them down in the general unclipped case.\n         */\n        stretch = 1;\n    } else if ((srcrect->w != w) || (srcrect->h != h)) {\n        if ((w == 2 * srcrect->w) && (h == 2 * srcrect->h)) {\n            scale_2x = 1;\n        } else {\n            stretch = 1;\n        }\n    }\n    if (stretch) {\n        int bpp;\n        Uint32 Rmask, Gmask, Bmask, Amask;\n\n        if (swdata->display) {\n            swdata->display->w = w;\n            swdata->display->h = h;\n            swdata->display->pixels = pixels;\n            swdata->display->pitch = pitch;\n        } else {\n            /* This must have succeeded in SDL_SW_SetupYUVDisplay() earlier */\n            SDL_PixelFormatEnumToMasks(target_format, &bpp, &Rmask, &Gmask,\n                                       &Bmask, &Amask);\n            swdata->display =\n                SDL_CreateRGBSurfaceFrom(pixels, w, h, bpp, pitch, Rmask,\n                                         Gmask, Bmask, Amask);\n            if (!swdata->display) {\n                return (-1);\n            }\n        }\n        if (!swdata->stretch) {\n            /* This must have succeeded in SDL_SW_SetupYUVDisplay() earlier */\n            SDL_PixelFormatEnumToMasks(target_format, &bpp, &Rmask, &Gmask,\n                                       &Bmask, &Amask);\n            swdata->stretch =\n                SDL_CreateRGBSurface(0, swdata->w, swdata->h, bpp, Rmask,\n                                     Gmask, Bmask, Amask);\n            if (!swdata->stretch) {\n                return (-1);\n            }\n        }\n        pixels = swdata->stretch->pixels;\n        pitch = swdata->stretch->pitch;\n    }\n    switch (swdata->format) {\n    case SDL_PIXELFORMAT_YV12:\n        lum = swdata->planes[0];\n        Cr = swdata->planes[1];\n        Cb = swdata->planes[2];\n        break;\n    case SDL_PIXELFORMAT_IYUV:\n        lum = swdata->planes[0];\n        Cr = swdata->planes[2];\n        Cb = swdata->planes[1];\n        break;\n    case SDL_PIXELFORMAT_YUY2:\n        lum = swdata->planes[0];\n        Cr = lum + 3;\n        Cb = lum + 1;\n        break;\n    case SDL_PIXELFORMAT_UYVY:\n        lum = swdata->planes[0] + 1;\n        Cr = lum + 1;\n        Cb = lum - 1;\n        break;\n    case SDL_PIXELFORMAT_YVYU:\n        lum = swdata->planes[0];\n        Cr = lum + 1;\n        Cb = lum + 3;\n        break;\n    default:\n        return SDL_SetError(\"Unsupported YUV format in copy\");\n    }\n    mod = (pitch / targetbpp);\n\n    if (scale_2x) {\n        mod -= (swdata->w * 2);\n        swdata->Display2X(swdata->colortab, swdata->rgb_2_pix,\n                          lum, Cr, Cb, pixels, swdata->h, swdata->w, mod);\n    } else {\n        mod -= swdata->w;\n        swdata->Display1X(swdata->colortab, swdata->rgb_2_pix,\n                          lum, Cr, Cb, pixels, swdata->h, swdata->w, mod);\n    }\n    if (stretch) {\n        SDL_Rect rect = *srcrect;\n        SDL_SoftStretch(swdata->stretch, &rect, swdata->display, NULL);\n    }\n    return 0;\n}\n\nvoid\nSDL_SW_DestroyYUVTexture(SDL_SW_YUVTexture * swdata)\n{\n    if (swdata) {\n        SDL_free(swdata->pixels);\n        SDL_free(swdata->colortab);\n        SDL_free(swdata->rgb_2_pix);\n        SDL_FreeSurface(swdata->stretch);\n        SDL_FreeSurface(swdata->display);\n        SDL_free(swdata);\n    }\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../../SDL_internal.h\"\n\n#if SDL_VIDEO_RENDER_OGL_ES2 && !SDL_RENDER_DISABLED\n\n#include \"SDL_hints.h\"\n#include \"SDL_opengles2.h\"\n#include \"../SDL_sysrender.h\"\n#include \"../../video/SDL_blit.h\"\n#include \"SDL_shaders_gles2.h\"\n\n/* !!! FIXME: Emscripten makes these into WebGL calls, and WebGL doesn't offer\n   !!! FIXME:  client-side arrays (without an Emscripten compatibility hack,\n   !!! FIXME:  at least), but the current VBO code here is dramatically\n   !!! FIXME:  slower on actual iOS devices, even though the iOS Simulator\n   !!! FIXME:  is okay. Some time after 2.0.4 ships, we should revisit this,\n   !!! FIXME:  fix the performance bottleneck, and make everything use VBOs.\n*/\n#ifdef __EMSCRIPTEN__\n#define SDL_GLES2_USE_VBOS 1\n#else\n#define SDL_GLES2_USE_VBOS 0\n#endif\n\n/* To prevent unnecessary window recreation,\n * these should match the defaults selected in SDL_GL_ResetAttributes \n */\n#define RENDERER_CONTEXT_MAJOR 2\n#define RENDERER_CONTEXT_MINOR 0\n\n/* Used to re-create the window with OpenGL ES capability */\nextern int SDL_RecreateWindow(SDL_Window * window, Uint32 flags);\n\n/*************************************************************************************************\n * Bootstrap data                                                                                *\n *************************************************************************************************/\n\nstatic SDL_Renderer *GLES2_CreateRenderer(SDL_Window *window, Uint32 flags);\n\nSDL_RenderDriver GLES2_RenderDriver = {\n    GLES2_CreateRenderer,\n    {\n        \"opengles2\",\n        (SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC | SDL_RENDERER_TARGETTEXTURE),\n        4,\n        {\n        SDL_PIXELFORMAT_ARGB8888,\n        SDL_PIXELFORMAT_ABGR8888,\n        SDL_PIXELFORMAT_RGB888,\n        SDL_PIXELFORMAT_BGR888\n        },\n        0,\n        0\n    }\n};\n\n/*************************************************************************************************\n * Context structures                                                                            *\n *************************************************************************************************/\n\ntypedef struct GLES2_FBOList GLES2_FBOList;\n\nstruct GLES2_FBOList\n{\n   Uint32 w, h;\n   GLuint FBO;\n   GLES2_FBOList *next;\n};\n\ntypedef struct GLES2_TextureData\n{\n    GLenum texture;\n    GLenum texture_type;\n    GLenum pixel_format;\n    GLenum pixel_type;\n    void *pixel_data;\n    int pitch;\n    /* YUV texture support */\n    SDL_bool yuv;\n    SDL_bool nv12;\n    GLenum texture_v;\n    GLenum texture_u;\n    GLES2_FBOList *fbo;\n} GLES2_TextureData;\n\ntypedef struct GLES2_ShaderCacheEntry\n{\n    GLuint id;\n    GLES2_ShaderType type;\n    const GLES2_ShaderInstance *instance;\n    int references;\n    Uint8 modulation_r, modulation_g, modulation_b, modulation_a;\n    struct GLES2_ShaderCacheEntry *prev;\n    struct GLES2_ShaderCacheEntry *next;\n} GLES2_ShaderCacheEntry;\n\ntypedef struct GLES2_ShaderCache\n{\n    int count;\n    GLES2_ShaderCacheEntry *head;\n} GLES2_ShaderCache;\n\ntypedef struct GLES2_ProgramCacheEntry\n{\n    GLuint id;\n    SDL_BlendMode blend_mode;\n    GLES2_ShaderCacheEntry *vertex_shader;\n    GLES2_ShaderCacheEntry *fragment_shader;\n    GLuint uniform_locations[16];\n    Uint8 color_r, color_g, color_b, color_a;\n    Uint8 modulation_r, modulation_g, modulation_b, modulation_a;\n    GLfloat projection[4][4];\n    struct GLES2_ProgramCacheEntry *prev;\n    struct GLES2_ProgramCacheEntry *next;\n} GLES2_ProgramCacheEntry;\n\ntypedef struct GLES2_ProgramCache\n{\n    int count;\n    GLES2_ProgramCacheEntry *head;\n    GLES2_ProgramCacheEntry *tail;\n} GLES2_ProgramCache;\n\ntypedef enum\n{\n    GLES2_ATTRIBUTE_POSITION = 0,\n    GLES2_ATTRIBUTE_TEXCOORD = 1,\n    GLES2_ATTRIBUTE_ANGLE = 2,\n    GLES2_ATTRIBUTE_CENTER = 3,\n} GLES2_Attribute;\n\ntypedef enum\n{\n    GLES2_UNIFORM_PROJECTION,\n    GLES2_UNIFORM_TEXTURE,\n    GLES2_UNIFORM_MODULATION,\n    GLES2_UNIFORM_COLOR,\n    GLES2_UNIFORM_TEXTURE_U,\n    GLES2_UNIFORM_TEXTURE_V\n} GLES2_Uniform;\n\ntypedef enum\n{\n    GLES2_IMAGESOURCE_SOLID,\n    GLES2_IMAGESOURCE_TEXTURE_ABGR,\n    GLES2_IMAGESOURCE_TEXTURE_ARGB,\n    GLES2_IMAGESOURCE_TEXTURE_RGB,\n    GLES2_IMAGESOURCE_TEXTURE_BGR,\n    GLES2_IMAGESOURCE_TEXTURE_YUV,\n    GLES2_IMAGESOURCE_TEXTURE_NV12,\n    GLES2_IMAGESOURCE_TEXTURE_NV21\n} GLES2_ImageSource;\n\ntypedef struct GLES2_DriverContext\n{\n    SDL_GLContext *context;\n\n    SDL_bool debug_enabled;\n\n    struct {\n        int blendMode;\n        SDL_bool tex_coords;\n    } current;\n\n#define SDL_PROC(ret,func,params) ret (APIENTRY *func) params;\n#include \"SDL_gles2funcs.h\"\n#undef SDL_PROC\n    GLES2_FBOList *framebuffers;\n    GLuint window_framebuffer;\n\n    int shader_format_count;\n    GLenum *shader_formats;\n    GLES2_ShaderCache shader_cache;\n    GLES2_ProgramCache program_cache;\n    GLES2_ProgramCacheEntry *current_program;\n    Uint8 clear_r, clear_g, clear_b, clear_a;\n\n#if SDL_GLES2_USE_VBOS\n    GLuint vertex_buffers[4];\n    GLsizeiptr vertex_buffer_size[4];\n#endif\n} GLES2_DriverContext;\n\n#define GLES2_MAX_CACHED_PROGRAMS 8\n\n\nSDL_FORCE_INLINE const char*\nGL_TranslateError (GLenum error)\n{\n#define GL_ERROR_TRANSLATE(e) case e: return #e;\n    switch (error) {\n    GL_ERROR_TRANSLATE(GL_INVALID_ENUM)\n    GL_ERROR_TRANSLATE(GL_INVALID_VALUE)\n    GL_ERROR_TRANSLATE(GL_INVALID_OPERATION)\n    GL_ERROR_TRANSLATE(GL_OUT_OF_MEMORY)\n    GL_ERROR_TRANSLATE(GL_NO_ERROR)\n    default:\n        return \"UNKNOWN\";\n}\n#undef GL_ERROR_TRANSLATE\n}\n\nSDL_FORCE_INLINE void\nGL_ClearErrors(SDL_Renderer *renderer)\n{\n    GLES2_DriverContext *data = (GLES2_DriverContext *) renderer->driverdata;\n\n    if (!data->debug_enabled)\n    {\n        return;\n    }\n    while (data->glGetError() != GL_NO_ERROR) {\n        continue;\n    }\n}\n\nSDL_FORCE_INLINE int\nGL_CheckAllErrors (const char *prefix, SDL_Renderer *renderer, const char *file, int line, const char *function)\n{\n    GLES2_DriverContext *data = (GLES2_DriverContext *) renderer->driverdata;\n    int ret = 0;\n\n    if (!data->debug_enabled)\n    {\n        return 0;\n    }\n    /* check gl errors (can return multiple errors) */\n    for (;;) {\n        GLenum error = data->glGetError();\n        if (error != GL_NO_ERROR) {\n            if (prefix == NULL || prefix[0] == '\\0') {\n                prefix = \"generic\";\n            }\n            SDL_SetError(\"%s: %s (%d): %s %s (0x%X)\", prefix, file, line, function, GL_TranslateError(error), error);\n            ret = -1;\n        } else {\n            break;\n        }\n    }\n    return ret;\n}\n\n#if 0\n#define GL_CheckError(prefix, renderer)\n#elif defined(_MSC_VER)\n#define GL_CheckError(prefix, renderer) GL_CheckAllErrors(prefix, renderer, __FILE__, __LINE__, __FUNCTION__)\n#else\n#define GL_CheckError(prefix, renderer) GL_CheckAllErrors(prefix, renderer, __FILE__, __LINE__, __PRETTY_FUNCTION__)\n#endif\n\n\n/*************************************************************************************************\n * Renderer state APIs                                                                           *\n *************************************************************************************************/\n\nstatic int GLES2_ActivateRenderer(SDL_Renderer *renderer);\nstatic void GLES2_WindowEvent(SDL_Renderer * renderer,\n                              const SDL_WindowEvent *event);\nstatic int GLES2_UpdateViewport(SDL_Renderer * renderer);\nstatic void GLES2_DestroyRenderer(SDL_Renderer *renderer);\nstatic int GLES2_SetOrthographicProjection(SDL_Renderer *renderer);\n\n\nstatic SDL_GLContext SDL_CurrentContext = NULL;\n\nstatic int GLES2_LoadFunctions(GLES2_DriverContext * data)\n{\n#if SDL_VIDEO_DRIVER_UIKIT\n#define __SDL_NOGETPROCADDR__\n#elif SDL_VIDEO_DRIVER_ANDROID\n#define __SDL_NOGETPROCADDR__\n#elif SDL_VIDEO_DRIVER_PANDORA\n#define __SDL_NOGETPROCADDR__\n#endif\n\n#if defined __SDL_NOGETPROCADDR__\n#define SDL_PROC(ret,func,params) data->func=func;\n#else\n#define SDL_PROC(ret,func,params) \\\n    do { \\\n        data->func = SDL_GL_GetProcAddress(#func); \\\n        if ( ! data->func ) { \\\n            return SDL_SetError(\"Couldn't load GLES2 function %s: %s\\n\", #func, SDL_GetError()); \\\n        } \\\n    } while ( 0 );\n#endif /* _SDL_NOGETPROCADDR_ */\n\n#include \"SDL_gles2funcs.h\"\n#undef SDL_PROC\n    return 0;\n}\n\nGLES2_FBOList *\nGLES2_GetFBO(GLES2_DriverContext *data, Uint32 w, Uint32 h)\n{\n   GLES2_FBOList *result = data->framebuffers;\n   while ((result) && ((result->w != w) || (result->h != h)) )\n   {\n       result = result->next;\n   }\n   if (result == NULL)\n   {\n       result = SDL_malloc(sizeof(GLES2_FBOList));\n       result->w = w;\n       result->h = h;\n       data->glGenFramebuffers(1, &result->FBO);\n       result->next = data->framebuffers;\n       data->framebuffers = result;\n   }\n   return result;\n}\n\nstatic int\nGLES2_ActivateRenderer(SDL_Renderer * renderer)\n{\n    GLES2_DriverContext *data = (GLES2_DriverContext *)renderer->driverdata;\n\n    if (SDL_CurrentContext != data->context) {\n        /* Null out the current program to ensure we set it again */\n        data->current_program = NULL;\n\n        if (SDL_GL_MakeCurrent(renderer->window, data->context) < 0) {\n            return -1;\n        }\n        SDL_CurrentContext = data->context;\n\n        GLES2_UpdateViewport(renderer);\n    }\n\n    GL_ClearErrors(renderer);\n\n    return 0;\n}\n\nstatic void\nGLES2_WindowEvent(SDL_Renderer * renderer, const SDL_WindowEvent *event)\n{\n    GLES2_DriverContext *data = (GLES2_DriverContext *)renderer->driverdata;\n\n    if (event->event == SDL_WINDOWEVENT_SIZE_CHANGED ||\n        event->event == SDL_WINDOWEVENT_SHOWN ||\n        event->event == SDL_WINDOWEVENT_HIDDEN) {\n        /* Rebind the context to the window area */\n        SDL_CurrentContext = NULL;\n    }\n\n    if (event->event == SDL_WINDOWEVENT_MINIMIZED) {\n        /* According to Apple documentation, we need to finish drawing NOW! */\n        data->glFinish();\n    }\n}\n\nstatic int\nGLES2_UpdateViewport(SDL_Renderer * renderer)\n{\n    GLES2_DriverContext *data = (GLES2_DriverContext *)renderer->driverdata;\n\n    if (SDL_CurrentContext != data->context) {\n        /* We'll update the viewport after we rebind the context */\n        return 0;\n    }\n\n    data->glViewport(renderer->viewport.x, renderer->viewport.y,\n               renderer->viewport.w, renderer->viewport.h);\n\n    if (data->current_program) {\n        GLES2_SetOrthographicProjection(renderer);\n    }\n    return GL_CheckError(\"\", renderer);\n}\n\nstatic int\nGLES2_UpdateClipRect(SDL_Renderer * renderer)\n{\n    GLES2_DriverContext *data = (GLES2_DriverContext *)renderer->driverdata;\n\n    if (SDL_CurrentContext != data->context) {\n        /* We'll update the clip rect after we rebind the context */\n        return 0;\n    }\n\n    if (renderer->clipping_enabled) {\n        const SDL_Rect *rect = &renderer->clip_rect;\n        data->glEnable(GL_SCISSOR_TEST);\n        data->glScissor(rect->x, renderer->viewport.h - rect->y - rect->h, rect->w, rect->h);\n    } else {\n        data->glDisable(GL_SCISSOR_TEST);\n    }\n    return 0;\n}\n\nstatic void\nGLES2_DestroyRenderer(SDL_Renderer *renderer)\n{\n    GLES2_DriverContext *data = (GLES2_DriverContext *)renderer->driverdata;\n\n    /* Deallocate everything */\n    if (data) {\n        GLES2_ActivateRenderer(renderer);\n\n        {\n            GLES2_ShaderCacheEntry *entry;\n            GLES2_ShaderCacheEntry *next;\n            entry = data->shader_cache.head;\n            while (entry)\n            {\n                data->glDeleteShader(entry->id);\n                next = entry->next;\n                SDL_free(entry);\n                entry = next;\n            }\n        }\n        {\n            GLES2_ProgramCacheEntry *entry;\n            GLES2_ProgramCacheEntry *next;\n            entry = data->program_cache.head;\n            while (entry) {\n                data->glDeleteProgram(entry->id);\n                next = entry->next;\n                SDL_free(entry);\n                entry = next;\n            }\n        }\n        if (data->context) {\n            while (data->framebuffers) {\n                GLES2_FBOList *nextnode = data->framebuffers->next;\n                data->glDeleteFramebuffers(1, &data->framebuffers->FBO);\n                GL_CheckError(\"\", renderer);\n                SDL_free(data->framebuffers);\n                data->framebuffers = nextnode;\n            }\n            SDL_GL_DeleteContext(data->context);\n        }\n        SDL_free(data->shader_formats);\n        SDL_free(data);\n    }\n    SDL_free(renderer);\n}\n\n/*************************************************************************************************\n * Texture APIs                                                                                  *\n *************************************************************************************************/\n\nstatic int GLES2_CreateTexture(SDL_Renderer *renderer, SDL_Texture *texture);\nstatic int GLES2_UpdateTexture(SDL_Renderer *renderer, SDL_Texture *texture, const SDL_Rect *rect,\n                               const void *pixels, int pitch);\nstatic int GLES2_UpdateTextureYUV(SDL_Renderer * renderer, SDL_Texture * texture,\n                               const SDL_Rect * rect,\n                               const Uint8 *Yplane, int Ypitch,\n                               const Uint8 *Uplane, int Upitch,\n                               const Uint8 *Vplane, int Vpitch);\nstatic int GLES2_LockTexture(SDL_Renderer *renderer, SDL_Texture *texture, const SDL_Rect *rect,\n                             void **pixels, int *pitch);\nstatic void GLES2_UnlockTexture(SDL_Renderer *renderer, SDL_Texture *texture);\nstatic int GLES2_SetRenderTarget(SDL_Renderer * renderer, SDL_Texture * texture);\nstatic void GLES2_DestroyTexture(SDL_Renderer *renderer, SDL_Texture *texture);\n\nstatic GLenum\nGetScaleQuality(void)\n{\n    const char *hint = SDL_GetHint(SDL_HINT_RENDER_SCALE_QUALITY);\n\n    if (!hint || *hint == '0' || SDL_strcasecmp(hint, \"nearest\") == 0) {\n        return GL_NEAREST;\n    } else {\n        return GL_LINEAR;\n    }\n}\n\nstatic int\nGLES2_CreateTexture(SDL_Renderer *renderer, SDL_Texture *texture)\n{\n    GLES2_DriverContext *renderdata = (GLES2_DriverContext *)renderer->driverdata;\n    GLES2_TextureData *data;\n    GLenum format;\n    GLenum type;\n    GLenum scaleMode;\n\n    GLES2_ActivateRenderer(renderer);\n\n    /* Determine the corresponding GLES texture format params */\n    switch (texture->format)\n    {\n    case SDL_PIXELFORMAT_ARGB8888:\n    case SDL_PIXELFORMAT_ABGR8888:\n    case SDL_PIXELFORMAT_RGB888:\n    case SDL_PIXELFORMAT_BGR888:\n        format = GL_RGBA;\n        type = GL_UNSIGNED_BYTE;\n        break;\n    case SDL_PIXELFORMAT_IYUV:\n    case SDL_PIXELFORMAT_YV12:\n    case SDL_PIXELFORMAT_NV12:\n    case SDL_PIXELFORMAT_NV21:\n        format = GL_LUMINANCE;\n        type = GL_UNSIGNED_BYTE;\n        break;\n    default:\n        return SDL_SetError(\"Texture format not supported\");\n    }\n\n    /* Allocate a texture struct */\n    data = (GLES2_TextureData *)SDL_calloc(1, sizeof(GLES2_TextureData));\n    if (!data) {\n        return SDL_OutOfMemory();\n    }\n    data->texture = 0;\n    data->texture_type = GL_TEXTURE_2D;\n    data->pixel_format = format;\n    data->pixel_type = type;\n    data->yuv = ((texture->format == SDL_PIXELFORMAT_IYUV) || (texture->format == SDL_PIXELFORMAT_YV12));\n    data->nv12 = ((texture->format == SDL_PIXELFORMAT_NV12) || (texture->format == SDL_PIXELFORMAT_NV21));\n    data->texture_u = 0;\n    data->texture_v = 0;\n    scaleMode = GetScaleQuality();\n\n    /* Allocate a blob for image renderdata */\n    if (texture->access == SDL_TEXTUREACCESS_STREAMING) {\n        size_t size;\n        data->pitch = texture->w * SDL_BYTESPERPIXEL(texture->format);\n        size = texture->h * data->pitch;\n        if (data->yuv) {\n            /* Need to add size for the U and V planes */\n            size += (2 * (texture->h * data->pitch) / 4);\n        }\n        if (data->nv12) {\n            /* Need to add size for the U/V plane */\n            size += ((texture->h * data->pitch) / 2);\n        }\n        data->pixel_data = SDL_calloc(1, size);\n        if (!data->pixel_data) {\n            SDL_free(data);\n            return SDL_OutOfMemory();\n        }\n    }\n\n    /* Allocate the texture */\n    GL_CheckError(\"\", renderer);\n\n    if (data->yuv) {\n        renderdata->glGenTextures(1, &data->texture_v);\n        if (GL_CheckError(\"glGenTexures()\", renderer) < 0) {\n            return -1;\n        }\n        renderdata->glActiveTexture(GL_TEXTURE2);\n        renderdata->glBindTexture(data->texture_type, data->texture_v);\n        renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_MIN_FILTER, scaleMode);\n        renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_MAG_FILTER, scaleMode);\n        renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n        renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n        renderdata->glTexImage2D(data->texture_type, 0, format, texture->w / 2, texture->h / 2, 0, format, type, NULL);\n\n        renderdata->glGenTextures(1, &data->texture_u);\n        if (GL_CheckError(\"glGenTexures()\", renderer) < 0) {\n            return -1;\n        }\n        renderdata->glActiveTexture(GL_TEXTURE1);\n        renderdata->glBindTexture(data->texture_type, data->texture_u);\n        renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_MIN_FILTER, scaleMode);\n        renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_MAG_FILTER, scaleMode);\n        renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n        renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n        renderdata->glTexImage2D(data->texture_type, 0, format, texture->w / 2, texture->h / 2, 0, format, type, NULL);\n        if (GL_CheckError(\"glTexImage2D()\", renderer) < 0) {\n            return -1;\n        }\n    }\n\n    if (data->nv12) {\n        renderdata->glGenTextures(1, &data->texture_u);\n        if (GL_CheckError(\"glGenTexures()\", renderer) < 0) {\n            return -1;\n        }\n        renderdata->glActiveTexture(GL_TEXTURE1);\n        renderdata->glBindTexture(data->texture_type, data->texture_u);\n        renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_MIN_FILTER, scaleMode);\n        renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_MAG_FILTER, scaleMode);\n        renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n        renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n        renderdata->glTexImage2D(data->texture_type, 0, GL_LUMINANCE_ALPHA, texture->w / 2, texture->h / 2, 0, GL_LUMINANCE_ALPHA, GL_UNSIGNED_BYTE, NULL);\n        if (GL_CheckError(\"glTexImage2D()\", renderer) < 0) {\n            return -1;\n        }\n    }\n\n    renderdata->glGenTextures(1, &data->texture);\n    if (GL_CheckError(\"glGenTexures()\", renderer) < 0) {\n        return -1;\n    }\n    texture->driverdata = data;\n    renderdata->glActiveTexture(GL_TEXTURE0);\n    renderdata->glBindTexture(data->texture_type, data->texture);\n    renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_MIN_FILTER, scaleMode);\n    renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_MAG_FILTER, scaleMode);\n    renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n    renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n    renderdata->glTexImage2D(data->texture_type, 0, format, texture->w, texture->h, 0, format, type, NULL);\n    if (GL_CheckError(\"glTexImage2D()\", renderer) < 0) {\n        return -1;\n    }\n\n    if (texture->access == SDL_TEXTUREACCESS_TARGET) {\n       data->fbo = GLES2_GetFBO(renderer->driverdata, texture->w, texture->h);\n    } else {\n       data->fbo = NULL;\n    }\n\n    return GL_CheckError(\"\", renderer);\n}\n\nstatic int\nGLES2_TexSubImage2D(GLES2_DriverContext *data, GLenum target, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels, GLint pitch, GLint bpp)\n{\n    Uint8 *blob = NULL;\n    Uint8 *src;\n    int src_pitch;\n    int y;\n\n    /* Reformat the texture data into a tightly packed array */\n    src_pitch = width * bpp;\n    src = (Uint8 *)pixels;\n    if (pitch != src_pitch) {\n        blob = (Uint8 *)SDL_malloc(src_pitch * height);\n        if (!blob) {\n            return SDL_OutOfMemory();\n        }\n        src = blob;\n        for (y = 0; y < height; ++y)\n        {\n            SDL_memcpy(src, pixels, src_pitch);\n            src += src_pitch;\n            pixels = (Uint8 *)pixels + pitch;\n        }\n        src = blob;\n    }\n\n    data->glTexSubImage2D(target, 0, xoffset, yoffset, width, height, format, type, src);\n    if (blob) {\n        SDL_free(blob);\n    }\n    return 0;\n}\n\nstatic int\nGLES2_UpdateTexture(SDL_Renderer *renderer, SDL_Texture *texture, const SDL_Rect *rect,\n                    const void *pixels, int pitch)\n{\n    GLES2_DriverContext *data = (GLES2_DriverContext *)renderer->driverdata;\n    GLES2_TextureData *tdata = (GLES2_TextureData *)texture->driverdata;\n\n    GLES2_ActivateRenderer(renderer);\n\n    /* Bail out if we're supposed to update an empty rectangle */\n    if (rect->w <= 0 || rect->h <= 0)\n        return 0;\n\n    /* Create a texture subimage with the supplied data */\n    data->glBindTexture(tdata->texture_type, tdata->texture);\n    GLES2_TexSubImage2D(data, tdata->texture_type,\n                    rect->x,\n                    rect->y,\n                    rect->w,\n                    rect->h,\n                    tdata->pixel_format,\n                    tdata->pixel_type,\n                    pixels, pitch, SDL_BYTESPERPIXEL(texture->format));\n\n    if (tdata->yuv) {\n        /* Skip to the correct offset into the next texture */\n        pixels = (const void*)((const Uint8*)pixels + rect->h * pitch);\n        if (texture->format == SDL_PIXELFORMAT_YV12) {\n            data->glBindTexture(tdata->texture_type, tdata->texture_v);\n        } else {\n            data->glBindTexture(tdata->texture_type, tdata->texture_u);\n        }\n        GLES2_TexSubImage2D(data, tdata->texture_type,\n                rect->x / 2,\n                rect->y / 2,\n                rect->w / 2,\n                rect->h / 2,\n                tdata->pixel_format,\n                tdata->pixel_type,\n                pixels, pitch / 2, 1);\n\n        /* Skip to the correct offset into the next texture */\n        pixels = (const void*)((const Uint8*)pixels + (rect->h * pitch)/4);\n        if (texture->format == SDL_PIXELFORMAT_YV12) {\n            data->glBindTexture(tdata->texture_type, tdata->texture_u);\n        } else {\n            data->glBindTexture(tdata->texture_type, tdata->texture_v);\n        }\n        GLES2_TexSubImage2D(data, tdata->texture_type,\n                rect->x / 2,\n                rect->y / 2,\n                rect->w / 2,\n                rect->h / 2,\n                tdata->pixel_format,\n                tdata->pixel_type,\n                pixels, pitch / 2, 1);\n    }\n\n    if (tdata->nv12) {\n        /* Skip to the correct offset into the next texture */\n        pixels = (const void*)((const Uint8*)pixels + rect->h * pitch);\n        data->glBindTexture(tdata->texture_type, tdata->texture_u);\n        GLES2_TexSubImage2D(data, tdata->texture_type,\n                rect->x / 2,\n                rect->y / 2,\n                rect->w / 2,\n                rect->h / 2,\n                GL_LUMINANCE_ALPHA,\n                GL_UNSIGNED_BYTE,\n                pixels, pitch, 2);\n    }\n\n    return GL_CheckError(\"glTexSubImage2D()\", renderer);\n}\n\nstatic int\nGLES2_UpdateTextureYUV(SDL_Renderer * renderer, SDL_Texture * texture,\n                    const SDL_Rect * rect,\n                    const Uint8 *Yplane, int Ypitch,\n                    const Uint8 *Uplane, int Upitch,\n                    const Uint8 *Vplane, int Vpitch)\n{\n    GLES2_DriverContext *data = (GLES2_DriverContext *)renderer->driverdata;\n    GLES2_TextureData *tdata = (GLES2_TextureData *)texture->driverdata;\n\n    GLES2_ActivateRenderer(renderer);\n\n    /* Bail out if we're supposed to update an empty rectangle */\n    if (rect->w <= 0 || rect->h <= 0)\n        return 0;\n\n    data->glBindTexture(tdata->texture_type, tdata->texture_v);\n    GLES2_TexSubImage2D(data, tdata->texture_type,\n                    rect->x / 2,\n                    rect->y / 2,\n                    rect->w / 2,\n                    rect->h / 2,\n                    tdata->pixel_format,\n                    tdata->pixel_type,\n                    Vplane, Vpitch, 1);\n\n    data->glBindTexture(tdata->texture_type, tdata->texture_u);\n    GLES2_TexSubImage2D(data, tdata->texture_type,\n                    rect->x / 2,\n                    rect->y / 2,\n                    rect->w / 2,\n                    rect->h / 2,\n                    tdata->pixel_format,\n                    tdata->pixel_type,\n                    Uplane, Upitch, 1);\n\n    data->glBindTexture(tdata->texture_type, tdata->texture);\n    GLES2_TexSubImage2D(data, tdata->texture_type,\n                    rect->x,\n                    rect->y,\n                    rect->w,\n                    rect->h,\n                    tdata->pixel_format,\n                    tdata->pixel_type,\n                    Yplane, Ypitch, 1);\n\n    return GL_CheckError(\"glTexSubImage2D()\", renderer);\n}\n\nstatic int\nGLES2_LockTexture(SDL_Renderer *renderer, SDL_Texture *texture, const SDL_Rect *rect,\n                  void **pixels, int *pitch)\n{\n    GLES2_TextureData *tdata = (GLES2_TextureData *)texture->driverdata;\n\n    /* Retrieve the buffer/pitch for the specified region */\n    *pixels = (Uint8 *)tdata->pixel_data +\n              (tdata->pitch * rect->y) +\n              (rect->x * SDL_BYTESPERPIXEL(texture->format));\n    *pitch = tdata->pitch;\n\n    return 0;\n}\n\nstatic void\nGLES2_UnlockTexture(SDL_Renderer *renderer, SDL_Texture *texture)\n{\n    GLES2_TextureData *tdata = (GLES2_TextureData *)texture->driverdata;\n    SDL_Rect rect;\n\n    /* We do whole texture updates, at least for now */\n    rect.x = 0;\n    rect.y = 0;\n    rect.w = texture->w;\n    rect.h = texture->h;\n    GLES2_UpdateTexture(renderer, texture, &rect, tdata->pixel_data, tdata->pitch);\n}\n\nstatic int\nGLES2_SetRenderTarget(SDL_Renderer * renderer, SDL_Texture * texture)\n{\n    GLES2_DriverContext *data = (GLES2_DriverContext *) renderer->driverdata;\n    GLES2_TextureData *texturedata = NULL;\n    GLenum status;\n\n    if (texture == NULL) {\n        data->glBindFramebuffer(GL_FRAMEBUFFER, data->window_framebuffer);\n    } else {\n        texturedata = (GLES2_TextureData *) texture->driverdata;\n        data->glBindFramebuffer(GL_FRAMEBUFFER, texturedata->fbo->FBO);\n        /* TODO: check if texture pixel format allows this operation */\n        data->glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, texturedata->texture_type, texturedata->texture, 0);\n        /* Check FBO status */\n        status = data->glCheckFramebufferStatus(GL_FRAMEBUFFER);\n        if (status != GL_FRAMEBUFFER_COMPLETE) {\n            return SDL_SetError(\"glFramebufferTexture2D() failed\");\n        }\n    }\n    return 0;\n}\n\nstatic void\nGLES2_DestroyTexture(SDL_Renderer *renderer, SDL_Texture *texture)\n{\n    GLES2_DriverContext *data = (GLES2_DriverContext *)renderer->driverdata;\n    GLES2_TextureData *tdata = (GLES2_TextureData *)texture->driverdata;\n\n    GLES2_ActivateRenderer(renderer);\n\n    /* Destroy the texture */\n    if (tdata)\n    {\n        data->glDeleteTextures(1, &tdata->texture);\n        if (tdata->texture_v) {\n            data->glDeleteTextures(1, &tdata->texture_v);\n        }\n        if (tdata->texture_u) {\n            data->glDeleteTextures(1, &tdata->texture_u);\n        }\n        SDL_free(tdata->pixel_data);\n        SDL_free(tdata);\n        texture->driverdata = NULL;\n    }\n}\n\n/*************************************************************************************************\n * Shader management functions                                                                   *\n *************************************************************************************************/\n\nstatic GLES2_ShaderCacheEntry *GLES2_CacheShader(SDL_Renderer *renderer, GLES2_ShaderType type,\n                                                 SDL_BlendMode blendMode);\nstatic void GLES2_EvictShader(SDL_Renderer *renderer, GLES2_ShaderCacheEntry *entry);\nstatic GLES2_ProgramCacheEntry *GLES2_CacheProgram(SDL_Renderer *renderer,\n                                                   GLES2_ShaderCacheEntry *vertex,\n                                                   GLES2_ShaderCacheEntry *fragment,\n                                                   SDL_BlendMode blendMode);\nstatic int GLES2_SelectProgram(SDL_Renderer *renderer, GLES2_ImageSource source,\n                               SDL_BlendMode blendMode);\n\nstatic GLES2_ProgramCacheEntry *\nGLES2_CacheProgram(SDL_Renderer *renderer, GLES2_ShaderCacheEntry *vertex,\n                   GLES2_ShaderCacheEntry *fragment, SDL_BlendMode blendMode)\n{\n    GLES2_DriverContext *data = (GLES2_DriverContext *)renderer->driverdata;\n    GLES2_ProgramCacheEntry *entry;\n    GLES2_ShaderCacheEntry *shaderEntry;\n    GLint linkSuccessful;\n\n    /* Check if we've already cached this program */\n    entry = data->program_cache.head;\n    while (entry)\n    {\n        if (entry->vertex_shader == vertex && entry->fragment_shader == fragment)\n            break;\n        entry = entry->next;\n    }\n    if (entry)\n    {\n        if (data->program_cache.head != entry)\n        {\n            if (entry->next)\n                entry->next->prev = entry->prev;\n            if (entry->prev)\n                entry->prev->next = entry->next;\n            entry->prev = NULL;\n            entry->next = data->program_cache.head;\n            data->program_cache.head->prev = entry;\n            data->program_cache.head = entry;\n        }\n        return entry;\n    }\n\n    /* Create a program cache entry */\n    entry = (GLES2_ProgramCacheEntry *)SDL_calloc(1, sizeof(GLES2_ProgramCacheEntry));\n    if (!entry)\n    {\n        SDL_OutOfMemory();\n        return NULL;\n    }\n    entry->vertex_shader = vertex;\n    entry->fragment_shader = fragment;\n    entry->blend_mode = blendMode;\n\n    /* Create the program and link it */\n    entry->id = data->glCreateProgram();\n    data->glAttachShader(entry->id, vertex->id);\n    data->glAttachShader(entry->id, fragment->id);\n    data->glBindAttribLocation(entry->id, GLES2_ATTRIBUTE_POSITION, \"a_position\");\n    data->glBindAttribLocation(entry->id, GLES2_ATTRIBUTE_TEXCOORD, \"a_texCoord\");\n    data->glBindAttribLocation(entry->id, GLES2_ATTRIBUTE_ANGLE, \"a_angle\");\n    data->glBindAttribLocation(entry->id, GLES2_ATTRIBUTE_CENTER, \"a_center\");\n    data->glLinkProgram(entry->id);\n    data->glGetProgramiv(entry->id, GL_LINK_STATUS, &linkSuccessful);\n    if (!linkSuccessful)\n    {\n        data->glDeleteProgram(entry->id);\n        SDL_free(entry);\n        SDL_SetError(\"Failed to link shader program\");\n        return NULL;\n    }\n\n    /* Predetermine locations of uniform variables */\n    entry->uniform_locations[GLES2_UNIFORM_PROJECTION] =\n        data->glGetUniformLocation(entry->id, \"u_projection\");\n    entry->uniform_locations[GLES2_UNIFORM_TEXTURE_V] =\n        data->glGetUniformLocation(entry->id, \"u_texture_v\");\n    entry->uniform_locations[GLES2_UNIFORM_TEXTURE_U] =\n        data->glGetUniformLocation(entry->id, \"u_texture_u\");\n    entry->uniform_locations[GLES2_UNIFORM_TEXTURE] =\n        data->glGetUniformLocation(entry->id, \"u_texture\");\n    entry->uniform_locations[GLES2_UNIFORM_MODULATION] =\n        data->glGetUniformLocation(entry->id, \"u_modulation\");\n    entry->uniform_locations[GLES2_UNIFORM_COLOR] =\n        data->glGetUniformLocation(entry->id, \"u_color\");\n\n    entry->modulation_r = entry->modulation_g = entry->modulation_b = entry->modulation_a = 255;\n    entry->color_r = entry->color_g = entry->color_b = entry->color_a = 255;\n\n    data->glUseProgram(entry->id);\n    data->glUniform1i(entry->uniform_locations[GLES2_UNIFORM_TEXTURE_V], 2);  /* always texture unit 2. */\n    data->glUniform1i(entry->uniform_locations[GLES2_UNIFORM_TEXTURE_U], 1);  /* always texture unit 1. */\n    data->glUniform1i(entry->uniform_locations[GLES2_UNIFORM_TEXTURE], 0);  /* always texture unit 0. */\n    data->glUniformMatrix4fv(entry->uniform_locations[GLES2_UNIFORM_PROJECTION], 1, GL_FALSE, (GLfloat *)entry->projection);\n    data->glUniform4f(entry->uniform_locations[GLES2_UNIFORM_MODULATION], 1.0f, 1.0f, 1.0f, 1.0f);\n    data->glUniform4f(entry->uniform_locations[GLES2_UNIFORM_COLOR], 1.0f, 1.0f, 1.0f, 1.0f);\n\n    /* Cache the linked program */\n    if (data->program_cache.head)\n    {\n        entry->next = data->program_cache.head;\n        data->program_cache.head->prev = entry;\n    }\n    else\n    {\n        data->program_cache.tail = entry;\n    }\n    data->program_cache.head = entry;\n    ++data->program_cache.count;\n\n    /* Increment the refcount of the shaders we're using */\n    ++vertex->references;\n    ++fragment->references;\n\n    /* Evict the last entry from the cache if we exceed the limit */\n    if (data->program_cache.count > GLES2_MAX_CACHED_PROGRAMS)\n    {\n        shaderEntry = data->program_cache.tail->vertex_shader;\n        if (--shaderEntry->references <= 0)\n            GLES2_EvictShader(renderer, shaderEntry);\n        shaderEntry = data->program_cache.tail->fragment_shader;\n        if (--shaderEntry->references <= 0)\n            GLES2_EvictShader(renderer, shaderEntry);\n        data->glDeleteProgram(data->program_cache.tail->id);\n        data->program_cache.tail = data->program_cache.tail->prev;\n        SDL_free(data->program_cache.tail->next);\n        data->program_cache.tail->next = NULL;\n        --data->program_cache.count;\n    }\n    return entry;\n}\n\nstatic GLES2_ShaderCacheEntry *\nGLES2_CacheShader(SDL_Renderer *renderer, GLES2_ShaderType type, SDL_BlendMode blendMode)\n{\n    GLES2_DriverContext *data = (GLES2_DriverContext *)renderer->driverdata;\n    const GLES2_Shader *shader;\n    const GLES2_ShaderInstance *instance = NULL;\n    GLES2_ShaderCacheEntry *entry = NULL;\n    GLint compileSuccessful = GL_FALSE;\n    int i, j;\n\n    /* Find the corresponding shader */\n    shader = GLES2_GetShader(type, blendMode);\n    if (!shader)\n    {\n        SDL_SetError(\"No shader matching the requested characteristics was found\");\n        return NULL;\n    }\n\n    /* Find a matching shader instance that's supported on this hardware */\n    for (i = 0; i < shader->instance_count && !instance; ++i)\n    {\n        for (j = 0; j < data->shader_format_count && !instance; ++j)\n        {\n            if (!shader->instances)\n                continue;\n            if (!shader->instances[i])\n                continue;\n            if (shader->instances[i]->format != data->shader_formats[j])\n                continue;\n            instance = shader->instances[i];\n        }\n    }\n    if (!instance)\n    {\n        SDL_SetError(\"The specified shader cannot be loaded on the current platform\");\n        return NULL;\n    }\n\n    /* Check if we've already cached this shader */\n    entry = data->shader_cache.head;\n    while (entry)\n    {\n        if (entry->instance == instance)\n            break;\n        entry = entry->next;\n    }\n    if (entry)\n        return entry;\n\n    /* Create a shader cache entry */\n    entry = (GLES2_ShaderCacheEntry *)SDL_calloc(1, sizeof(GLES2_ShaderCacheEntry));\n    if (!entry)\n    {\n        SDL_OutOfMemory();\n        return NULL;\n    }\n    entry->type = type;\n    entry->instance = instance;\n\n    /* Compile or load the selected shader instance */\n    entry->id = data->glCreateShader(instance->type);\n    if (instance->format == (GLenum)-1)\n    {\n        data->glShaderSource(entry->id, 1, (const char **)&instance->data, NULL);\n        data->glCompileShader(entry->id);\n        data->glGetShaderiv(entry->id, GL_COMPILE_STATUS, &compileSuccessful);\n    }\n    else\n    {\n        data->glShaderBinary(1, &entry->id, instance->format, instance->data, instance->length);\n        compileSuccessful = GL_TRUE;\n    }\n    if (!compileSuccessful)\n    {\n        char *info = NULL;\n        int length = 0;\n\n        data->glGetShaderiv(entry->id, GL_INFO_LOG_LENGTH, &length);\n        if (length > 0) {\n            info = SDL_stack_alloc(char, length);\n            if (info) {\n                data->glGetShaderInfoLog(entry->id, length, &length, info);\n            }\n        }\n        if (info) {\n            SDL_SetError(\"Failed to load the shader: %s\", info);\n            SDL_stack_free(info);\n        } else {\n            SDL_SetError(\"Failed to load the shader\");\n        }\n        data->glDeleteShader(entry->id);\n        SDL_free(entry);\n        return NULL;\n    }\n\n    /* Link the shader entry in at the front of the cache */\n    if (data->shader_cache.head)\n    {\n        entry->next = data->shader_cache.head;\n        data->shader_cache.head->prev = entry;\n    }\n    data->shader_cache.head = entry;\n    ++data->shader_cache.count;\n    return entry;\n}\n\nstatic void\nGLES2_EvictShader(SDL_Renderer *renderer, GLES2_ShaderCacheEntry *entry)\n{\n    GLES2_DriverContext *data = (GLES2_DriverContext *)renderer->driverdata;\n\n    /* Unlink the shader from the cache */\n    if (entry->next)\n        entry->next->prev = entry->prev;\n    if (entry->prev)\n        entry->prev->next = entry->next;\n    if (data->shader_cache.head == entry)\n        data->shader_cache.head = entry->next;\n    --data->shader_cache.count;\n\n    /* Deallocate the shader */\n    data->glDeleteShader(entry->id);\n    SDL_free(entry);\n}\n\nstatic int\nGLES2_SelectProgram(SDL_Renderer *renderer, GLES2_ImageSource source, SDL_BlendMode blendMode)\n{\n    GLES2_DriverContext *data = (GLES2_DriverContext *)renderer->driverdata;\n    GLES2_ShaderCacheEntry *vertex = NULL;\n    GLES2_ShaderCacheEntry *fragment = NULL;\n    GLES2_ShaderType vtype, ftype;\n    GLES2_ProgramCacheEntry *program;\n\n    /* Select an appropriate shader pair for the specified modes */\n    vtype = GLES2_SHADER_VERTEX_DEFAULT;\n    switch (source)\n    {\n    case GLES2_IMAGESOURCE_SOLID:\n        ftype = GLES2_SHADER_FRAGMENT_SOLID_SRC;\n        break;\n    case GLES2_IMAGESOURCE_TEXTURE_ABGR:\n        ftype = GLES2_SHADER_FRAGMENT_TEXTURE_ABGR_SRC;\n        break;\n    case GLES2_IMAGESOURCE_TEXTURE_ARGB:\n        ftype = GLES2_SHADER_FRAGMENT_TEXTURE_ARGB_SRC;\n        break;\n    case GLES2_IMAGESOURCE_TEXTURE_RGB:\n        ftype = GLES2_SHADER_FRAGMENT_TEXTURE_RGB_SRC;\n        break;\n    case GLES2_IMAGESOURCE_TEXTURE_BGR:\n        ftype = GLES2_SHADER_FRAGMENT_TEXTURE_BGR_SRC;\n        break;\n    case GLES2_IMAGESOURCE_TEXTURE_YUV:\n        ftype = GLES2_SHADER_FRAGMENT_TEXTURE_YUV_SRC;\n        break;\n    case GLES2_IMAGESOURCE_TEXTURE_NV12:\n        ftype = GLES2_SHADER_FRAGMENT_TEXTURE_NV12_SRC;\n        break;\n    case GLES2_IMAGESOURCE_TEXTURE_NV21:\n        ftype = GLES2_SHADER_FRAGMENT_TEXTURE_NV21_SRC;\n        break;\n    default:\n        goto fault;\n    }\n\n    /* Load the requested shaders */\n    vertex = GLES2_CacheShader(renderer, vtype, blendMode);\n    if (!vertex)\n        goto fault;\n    fragment = GLES2_CacheShader(renderer, ftype, blendMode);\n    if (!fragment)\n        goto fault;\n\n    /* Check if we need to change programs at all */\n    if (data->current_program &&\n        data->current_program->vertex_shader == vertex &&\n        data->current_program->fragment_shader == fragment)\n        return 0;\n\n    /* Generate a matching program */\n    program = GLES2_CacheProgram(renderer, vertex, fragment, blendMode);\n    if (!program)\n        goto fault;\n\n    /* Select that program in OpenGL */\n    data->glUseProgram(program->id);\n\n    /* Set the current program */\n    data->current_program = program;\n\n    /* Activate an orthographic projection */\n    if (GLES2_SetOrthographicProjection(renderer) < 0)\n        goto fault;\n\n    /* Clean up and return */\n    return 0;\nfault:\n    if (vertex && vertex->references <= 0)\n        GLES2_EvictShader(renderer, vertex);\n    if (fragment && fragment->references <= 0)\n        GLES2_EvictShader(renderer, fragment);\n    data->current_program = NULL;\n    return -1;\n}\n\nstatic int\nGLES2_SetOrthographicProjection(SDL_Renderer *renderer)\n{\n    GLES2_DriverContext *data = (GLES2_DriverContext *)renderer->driverdata;\n    GLfloat projection[4][4];\n\n    if (!renderer->viewport.w || !renderer->viewport.h) {\n        return 0;\n    }\n\n    /* Prepare an orthographic projection */\n    projection[0][0] = 2.0f / renderer->viewport.w;\n    projection[0][1] = 0.0f;\n    projection[0][2] = 0.0f;\n    projection[0][3] = 0.0f;\n    projection[1][0] = 0.0f;\n    if (renderer->target) {\n        projection[1][1] = 2.0f / renderer->viewport.h;\n    } else {\n        projection[1][1] = -2.0f / renderer->viewport.h;\n    }\n    projection[1][2] = 0.0f;\n    projection[1][3] = 0.0f;\n    projection[2][0] = 0.0f;\n    projection[2][1] = 0.0f;\n    projection[2][2] = 0.0f;\n    projection[2][3] = 0.0f;\n    projection[3][0] = -1.0f;\n    if (renderer->target) {\n        projection[3][1] = -1.0f;\n    } else {\n        projection[3][1] = 1.0f;\n    }\n    projection[3][2] = 0.0f;\n    projection[3][3] = 1.0f;\n\n    /* Set the projection matrix */\n    if (SDL_memcmp(data->current_program->projection, projection, sizeof (projection)) != 0) {\n        const GLuint locProjection = data->current_program->uniform_locations[GLES2_UNIFORM_PROJECTION];\n        data->glUniformMatrix4fv(locProjection, 1, GL_FALSE, (GLfloat *)projection);\n        SDL_memcpy(data->current_program->projection, projection, sizeof (projection));\n    }\n\n    return 0;\n}\n\n/*************************************************************************************************\n * Rendering functions                                                                           *\n *************************************************************************************************/\n\nstatic const float inv255f = 1.0f / 255.0f;\n\nstatic int GLES2_RenderClear(SDL_Renderer *renderer);\nstatic int GLES2_RenderDrawPoints(SDL_Renderer *renderer, const SDL_FPoint *points, int count);\nstatic int GLES2_RenderDrawLines(SDL_Renderer *renderer, const SDL_FPoint *points, int count);\nstatic int GLES2_RenderFillRects(SDL_Renderer *renderer, const SDL_FRect *rects, int count);\nstatic int GLES2_RenderCopy(SDL_Renderer *renderer, SDL_Texture *texture, const SDL_Rect *srcrect,\n                            const SDL_FRect *dstrect);\nstatic int GLES2_RenderCopyEx(SDL_Renderer * renderer, SDL_Texture * texture,\n                         const SDL_Rect * srcrect, const SDL_FRect * dstrect,\n                         const double angle, const SDL_FPoint *center, const SDL_RendererFlip flip);\nstatic int GLES2_RenderReadPixels(SDL_Renderer * renderer, const SDL_Rect * rect,\n                    Uint32 pixel_format, void * pixels, int pitch);\nstatic void GLES2_RenderPresent(SDL_Renderer *renderer);\n\nstatic SDL_bool\nCompareColors(Uint8 r1, Uint8 g1, Uint8 b1, Uint8 a1,\n              Uint8 r2, Uint8 g2, Uint8 b2, Uint8 a2)\n{\n    Uint32 Pixel1, Pixel2;\n    RGBA8888_FROM_RGBA(Pixel1, r1, g1, b1, a1);\n    RGBA8888_FROM_RGBA(Pixel2, r2, g2, b2, a2);\n    return (Pixel1 == Pixel2);\n}\n\nstatic int\nGLES2_RenderClear(SDL_Renderer * renderer)\n{\n    Uint8 r, g, b, a;\n\n    GLES2_DriverContext *data = (GLES2_DriverContext *)renderer->driverdata;\n\n    GLES2_ActivateRenderer(renderer);\n\n    if (!CompareColors(data->clear_r, data->clear_g, data->clear_b, data->clear_a,\n                        renderer->r, renderer->g, renderer->b, renderer->a)) {\n\n       /* Select the color to clear with */\n       g = renderer->g;\n       a = renderer->a;\n   \n       if (renderer->target &&\n            (renderer->target->format == SDL_PIXELFORMAT_ARGB8888 ||\n             renderer->target->format == SDL_PIXELFORMAT_RGB888)) {\n           r = renderer->b;\n           b = renderer->r;\n        } else {\n           r = renderer->r;\n           b = renderer->b;\n        }\n\n        data->glClearColor((GLfloat) r * inv255f,\n                     (GLfloat) g * inv255f,\n                     (GLfloat) b * inv255f,\n                     (GLfloat) a * inv255f);\n        data->clear_r = renderer->r;\n        data->clear_g = renderer->g;\n        data->clear_b = renderer->b;\n        data->clear_a = renderer->a;\n    }\n\n    data->glClear(GL_COLOR_BUFFER_BIT);\n\n    return 0;\n}\n\nstatic void\nGLES2_SetBlendMode(GLES2_DriverContext *data, int blendMode)\n{\n    if (blendMode != data->current.blendMode) {\n        switch (blendMode) {\n        default:\n        case SDL_BLENDMODE_NONE:\n            data->glDisable(GL_BLEND);\n            break;\n        case SDL_BLENDMODE_BLEND:\n            data->glEnable(GL_BLEND);\n            data->glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);\n            break;\n        case SDL_BLENDMODE_ADD:\n            data->glEnable(GL_BLEND);\n            data->glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE, GL_ZERO, GL_ONE);\n            break;\n        case SDL_BLENDMODE_MOD:\n            data->glEnable(GL_BLEND);\n            data->glBlendFuncSeparate(GL_ZERO, GL_SRC_COLOR, GL_ZERO, GL_ONE);\n            break;\n        }\n        data->current.blendMode = blendMode;\n    }\n}\n\nstatic void\nGLES2_SetTexCoords(GLES2_DriverContext * data, SDL_bool enabled)\n{\n    if (enabled != data->current.tex_coords) {\n        if (enabled) {\n            data->glEnableVertexAttribArray(GLES2_ATTRIBUTE_TEXCOORD);\n        } else {\n            data->glDisableVertexAttribArray(GLES2_ATTRIBUTE_TEXCOORD);\n        }\n        data->current.tex_coords = enabled;\n    }\n}\n\nstatic int\nGLES2_SetDrawingState(SDL_Renderer * renderer)\n{\n    GLES2_DriverContext *data = (GLES2_DriverContext *)renderer->driverdata;\n    const int blendMode = renderer->blendMode;\n    GLES2_ProgramCacheEntry *program;\n    Uint8 r, g, b, a;\n\n    GLES2_ActivateRenderer(renderer);\n\n    GLES2_SetBlendMode(data, blendMode);\n\n    GLES2_SetTexCoords(data, SDL_FALSE);\n\n    /* Activate an appropriate shader and set the projection matrix */\n    if (GLES2_SelectProgram(renderer, GLES2_IMAGESOURCE_SOLID, blendMode) < 0) {\n        return -1;\n    }\n\n    /* Select the color to draw with */\n    g = renderer->g;\n    a = renderer->a;\n\n    if (renderer->target &&\n         (renderer->target->format == SDL_PIXELFORMAT_ARGB8888 ||\n         renderer->target->format == SDL_PIXELFORMAT_RGB888)) {\n        r = renderer->b;\n        b = renderer->r;\n     } else {\n        r = renderer->r;\n        b = renderer->b;\n     }\n\n    program = data->current_program;\n    if (!CompareColors(program->color_r, program->color_g, program->color_b, program->color_a, r, g, b, a)) {\n        /* Select the color to draw with */\n        data->glUniform4f(program->uniform_locations[GLES2_UNIFORM_COLOR], r * inv255f, g * inv255f, b * inv255f, a * inv255f);\n        program->color_r = r;\n        program->color_g = g;\n        program->color_b = b;\n        program->color_a = a;\n    }\n\n    return 0;\n}\n\nstatic int\nGLES2_UpdateVertexBuffer(SDL_Renderer *renderer, GLES2_Attribute attr,\n                         const void *vertexData, size_t dataSizeInBytes)\n{\n    GLES2_DriverContext *data = (GLES2_DriverContext *)renderer->driverdata;\n\n#if !SDL_GLES2_USE_VBOS\n    data->glVertexAttribPointer(attr, attr == GLES2_ATTRIBUTE_ANGLE ? 1 : 2, GL_FLOAT, GL_FALSE, 0, vertexData);\n#else\n    if (!data->vertex_buffers[attr])\n        data->glGenBuffers(1, &data->vertex_buffers[attr]);\n\n    data->glBindBuffer(GL_ARRAY_BUFFER, data->vertex_buffers[attr]);\n\n    if (data->vertex_buffer_size[attr] < dataSizeInBytes) {\n        data->glBufferData(GL_ARRAY_BUFFER, dataSizeInBytes, vertexData, GL_STREAM_DRAW);\n        data->vertex_buffer_size[attr] = dataSizeInBytes;\n    } else {\n        data->glBufferSubData(GL_ARRAY_BUFFER, 0, dataSizeInBytes, vertexData);\n    }\n\n    data->glVertexAttribPointer(attr, attr == GLES2_ATTRIBUTE_ANGLE ? 1 : 2, GL_FLOAT, GL_FALSE, 0, 0);\n#endif\n\n    return 0;\n}\n\nstatic int\nGLES2_RenderDrawPoints(SDL_Renderer *renderer, const SDL_FPoint *points, int count)\n{\n    GLES2_DriverContext *data = (GLES2_DriverContext *)renderer->driverdata;\n    GLfloat *vertices;\n    int idx;\n\n    if (GLES2_SetDrawingState(renderer) < 0) {\n        return -1;\n    }\n\n    /* Emit the specified vertices as points */\n    vertices = SDL_stack_alloc(GLfloat, count * 2);\n    for (idx = 0; idx < count; ++idx) {\n        GLfloat x = points[idx].x + 0.5f;\n        GLfloat y = points[idx].y + 0.5f;\n\n        vertices[idx * 2] = x;\n        vertices[(idx * 2) + 1] = y;\n    }\n    /*data->glVertexAttribPointer(GLES2_ATTRIBUTE_POSITION, 2, GL_FLOAT, GL_FALSE, 0, vertices);*/\n    GLES2_UpdateVertexBuffer(renderer, GLES2_ATTRIBUTE_POSITION, vertices, count * 2 * sizeof(GLfloat));\n    data->glDrawArrays(GL_POINTS, 0, count);\n    SDL_stack_free(vertices);\n    return 0;\n}\n\nstatic int\nGLES2_RenderDrawLines(SDL_Renderer *renderer, const SDL_FPoint *points, int count)\n{\n    GLES2_DriverContext *data = (GLES2_DriverContext *)renderer->driverdata;\n    GLfloat *vertices;\n    int idx;\n\n    if (GLES2_SetDrawingState(renderer) < 0) {\n        return -1;\n    }\n\n    /* Emit a line strip including the specified vertices */\n    vertices = SDL_stack_alloc(GLfloat, count * 2);\n    for (idx = 0; idx < count; ++idx) {\n        GLfloat x = points[idx].x + 0.5f;\n        GLfloat y = points[idx].y + 0.5f;\n\n        vertices[idx * 2] = x;\n        vertices[(idx * 2) + 1] = y;\n    }\n    /*data->glVertexAttribPointer(GLES2_ATTRIBUTE_POSITION, 2, GL_FLOAT, GL_FALSE, 0, vertices);*/\n    GLES2_UpdateVertexBuffer(renderer, GLES2_ATTRIBUTE_POSITION, vertices, count * 2 * sizeof(GLfloat));\n    data->glDrawArrays(GL_LINE_STRIP, 0, count);\n\n    /* We need to close the endpoint of the line */\n    if (count == 2 ||\n        points[0].x != points[count-1].x || points[0].y != points[count-1].y) {\n        data->glDrawArrays(GL_POINTS, count-1, 1);\n    }\n    SDL_stack_free(vertices);\n\n    return GL_CheckError(\"\", renderer);\n}\n\nstatic int\nGLES2_RenderFillRects(SDL_Renderer *renderer, const SDL_FRect *rects, int count)\n{\n    GLES2_DriverContext *data = (GLES2_DriverContext *)renderer->driverdata;\n    GLfloat vertices[8];\n    int idx;\n\n    if (GLES2_SetDrawingState(renderer) < 0) {\n        return -1;\n    }\n\n    /* Emit a line loop for each rectangle */\n    for (idx = 0; idx < count; ++idx) {\n        const SDL_FRect *rect = &rects[idx];\n\n        GLfloat xMin = rect->x;\n        GLfloat xMax = (rect->x + rect->w);\n        GLfloat yMin = rect->y;\n        GLfloat yMax = (rect->y + rect->h);\n\n        vertices[0] = xMin;\n        vertices[1] = yMin;\n        vertices[2] = xMax;\n        vertices[3] = yMin;\n        vertices[4] = xMin;\n        vertices[5] = yMax;\n        vertices[6] = xMax;\n        vertices[7] = yMax;\n        /*data->glVertexAttribPointer(GLES2_ATTRIBUTE_POSITION, 2, GL_FLOAT, GL_FALSE, 0, vertices);*/\n        GLES2_UpdateVertexBuffer(renderer, GLES2_ATTRIBUTE_POSITION, vertices, 8 * sizeof(GLfloat));\n        data->glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);\n    }\n    return GL_CheckError(\"\", renderer);\n}\n\nstatic int\nGLES2_SetupCopy(SDL_Renderer *renderer, SDL_Texture *texture)\n{\n    GLES2_DriverContext *data = (GLES2_DriverContext *)renderer->driverdata;\n    GLES2_TextureData *tdata = (GLES2_TextureData *)texture->driverdata;\n    GLES2_ImageSource sourceType = GLES2_IMAGESOURCE_TEXTURE_ABGR;\n    SDL_BlendMode blendMode;\n    GLES2_ProgramCacheEntry *program;\n    Uint8 r, g, b, a;\n\n    /* Activate an appropriate shader and set the projection matrix */\n    blendMode = texture->blendMode;\n    if (renderer->target) {\n        /* Check if we need to do color mapping between the source and render target textures */\n        if (renderer->target->format != texture->format) {\n            switch (texture->format)\n            {\n            case SDL_PIXELFORMAT_ARGB8888:\n                switch (renderer->target->format)\n                {\n                    case SDL_PIXELFORMAT_ABGR8888:\n                    case SDL_PIXELFORMAT_BGR888:\n                        sourceType = GLES2_IMAGESOURCE_TEXTURE_ARGB;\n                        break;\n                    case SDL_PIXELFORMAT_RGB888:\n                        sourceType = GLES2_IMAGESOURCE_TEXTURE_ABGR;\n                        break;\n                }\n                break;\n            case SDL_PIXELFORMAT_ABGR8888:\n                switch (renderer->target->format)\n                {\n                    case SDL_PIXELFORMAT_ARGB8888:\n                    case SDL_PIXELFORMAT_RGB888:\n                        sourceType = GLES2_IMAGESOURCE_TEXTURE_ARGB;\n                        break;\n                    case SDL_PIXELFORMAT_BGR888:\n                        sourceType = GLES2_IMAGESOURCE_TEXTURE_ABGR;\n                        break;\n                }\n                break;\n            case SDL_PIXELFORMAT_RGB888:\n                switch (renderer->target->format)\n                {\n                    case SDL_PIXELFORMAT_ABGR8888:\n                        sourceType = GLES2_IMAGESOURCE_TEXTURE_ARGB;\n                        break;\n                    case SDL_PIXELFORMAT_ARGB8888:\n                        sourceType = GLES2_IMAGESOURCE_TEXTURE_BGR;\n                        break;\n                    case SDL_PIXELFORMAT_BGR888:\n                        sourceType = GLES2_IMAGESOURCE_TEXTURE_ARGB;\n                        break;\n                }\n                break;\n            case SDL_PIXELFORMAT_BGR888:\n                switch (renderer->target->format)\n                {\n                    case SDL_PIXELFORMAT_ABGR8888:\n                        sourceType = GLES2_IMAGESOURCE_TEXTURE_BGR;\n                        break;\n                    case SDL_PIXELFORMAT_ARGB8888:\n                        sourceType = GLES2_IMAGESOURCE_TEXTURE_RGB;\n                        break;\n                    case SDL_PIXELFORMAT_RGB888:\n                        sourceType = GLES2_IMAGESOURCE_TEXTURE_ARGB;\n                        break;\n                }\n                break;\n            case SDL_PIXELFORMAT_IYUV:\n            case SDL_PIXELFORMAT_YV12:\n                sourceType = GLES2_IMAGESOURCE_TEXTURE_YUV;\n                break;\n            case SDL_PIXELFORMAT_NV12:\n                sourceType = GLES2_IMAGESOURCE_TEXTURE_NV12;\n                break;\n            case SDL_PIXELFORMAT_NV21:\n                sourceType = GLES2_IMAGESOURCE_TEXTURE_NV21;\n                break;\n            default:\n                return SDL_SetError(\"Unsupported texture format\");\n            }\n        }\n        else sourceType = GLES2_IMAGESOURCE_TEXTURE_ABGR;   /* Texture formats match, use the non color mapping shader (even if the formats are not ABGR) */\n    } else {\n        switch (texture->format)\n        {\n            case SDL_PIXELFORMAT_ARGB8888:\n                sourceType = GLES2_IMAGESOURCE_TEXTURE_ARGB;\n                break;\n            case SDL_PIXELFORMAT_ABGR8888:\n                sourceType = GLES2_IMAGESOURCE_TEXTURE_ABGR;\n                break;\n            case SDL_PIXELFORMAT_RGB888:\n                sourceType = GLES2_IMAGESOURCE_TEXTURE_RGB;\n                break;\n            case SDL_PIXELFORMAT_BGR888:\n                sourceType = GLES2_IMAGESOURCE_TEXTURE_BGR;\n                break;\n            case SDL_PIXELFORMAT_IYUV:\n            case SDL_PIXELFORMAT_YV12:\n                sourceType = GLES2_IMAGESOURCE_TEXTURE_YUV;\n                break;\n            case SDL_PIXELFORMAT_NV12:\n                sourceType = GLES2_IMAGESOURCE_TEXTURE_NV12;\n                break;\n            case SDL_PIXELFORMAT_NV21:\n                sourceType = GLES2_IMAGESOURCE_TEXTURE_NV21;\n                break;\n            default:\n                return SDL_SetError(\"Unsupported texture format\");\n        }\n    }\n\n    if (GLES2_SelectProgram(renderer, sourceType, blendMode) < 0) {\n        return -1;\n    }\n\n    /* Select the target texture */\n    if (tdata->yuv) {\n        data->glActiveTexture(GL_TEXTURE2);\n        data->glBindTexture(tdata->texture_type, tdata->texture_v);\n\n        data->glActiveTexture(GL_TEXTURE1);\n        data->glBindTexture(tdata->texture_type, tdata->texture_u);\n\n        data->glActiveTexture(GL_TEXTURE0);\n    }\n    if (tdata->nv12) {\n        data->glActiveTexture(GL_TEXTURE1);\n        data->glBindTexture(tdata->texture_type, tdata->texture_u);\n\n        data->glActiveTexture(GL_TEXTURE0);\n    }\n    data->glBindTexture(tdata->texture_type, tdata->texture);\n\n    /* Configure color modulation */\n    g = texture->g;\n    a = texture->a;\n\n    if (renderer->target &&\n        (renderer->target->format == SDL_PIXELFORMAT_ARGB8888 ||\n         renderer->target->format == SDL_PIXELFORMAT_RGB888)) {\n        r = texture->b;\n        b = texture->r;\n    } else {\n        r = texture->r;\n        b = texture->b;\n    }\n\n    program = data->current_program;\n\n    if (!CompareColors(program->modulation_r, program->modulation_g, program->modulation_b, program->modulation_a, r, g, b, a)) {\n        data->glUniform4f(program->uniform_locations[GLES2_UNIFORM_MODULATION], r * inv255f, g * inv255f, b * inv255f, a * inv255f);\n        program->modulation_r = r;\n        program->modulation_g = g;\n        program->modulation_b = b;\n        program->modulation_a = a;\n    }\n\n    /* Configure texture blending */\n    GLES2_SetBlendMode(data, blendMode);\n\n    GLES2_SetTexCoords(data, SDL_TRUE);\n    return 0;\n}\n\nstatic int\nGLES2_RenderCopy(SDL_Renderer *renderer, SDL_Texture *texture, const SDL_Rect *srcrect,\n                 const SDL_FRect *dstrect)\n{\n    GLES2_DriverContext *data = (GLES2_DriverContext *)renderer->driverdata;\n    GLfloat vertices[8];\n    GLfloat texCoords[8];\n\n    GLES2_ActivateRenderer(renderer);\n\n    if (GLES2_SetupCopy(renderer, texture) < 0) {\n        return -1;\n    }\n\n    /* Emit the textured quad */\n    vertices[0] = dstrect->x;\n    vertices[1] = dstrect->y;\n    vertices[2] = (dstrect->x + dstrect->w);\n    vertices[3] = dstrect->y;\n    vertices[4] = dstrect->x;\n    vertices[5] = (dstrect->y + dstrect->h);\n    vertices[6] = (dstrect->x + dstrect->w);\n    vertices[7] = (dstrect->y + dstrect->h);\n    /*data->glVertexAttribPointer(GLES2_ATTRIBUTE_POSITION, 2, GL_FLOAT, GL_FALSE, 0, vertices);*/\n    GLES2_UpdateVertexBuffer(renderer, GLES2_ATTRIBUTE_POSITION, vertices, 8 * sizeof(GLfloat));\n    texCoords[0] = srcrect->x / (GLfloat)texture->w;\n    texCoords[1] = srcrect->y / (GLfloat)texture->h;\n    texCoords[2] = (srcrect->x + srcrect->w) / (GLfloat)texture->w;\n    texCoords[3] = srcrect->y / (GLfloat)texture->h;\n    texCoords[4] = srcrect->x / (GLfloat)texture->w;\n    texCoords[5] = (srcrect->y + srcrect->h) / (GLfloat)texture->h;\n    texCoords[6] = (srcrect->x + srcrect->w) / (GLfloat)texture->w;\n    texCoords[7] = (srcrect->y + srcrect->h) / (GLfloat)texture->h;\n    /*data->glVertexAttribPointer(GLES2_ATTRIBUTE_TEXCOORD, 2, GL_FLOAT, GL_FALSE, 0, texCoords);*/\n    GLES2_UpdateVertexBuffer(renderer, GLES2_ATTRIBUTE_TEXCOORD, texCoords, 8 * sizeof(GLfloat));\n    data->glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);\n\n    return GL_CheckError(\"\", renderer);\n}\n\nstatic int\nGLES2_RenderCopyEx(SDL_Renderer *renderer, SDL_Texture *texture, const SDL_Rect *srcrect,\n                 const SDL_FRect *dstrect, const double angle, const SDL_FPoint *center, const SDL_RendererFlip flip)\n{\n    GLES2_DriverContext *data = (GLES2_DriverContext *)renderer->driverdata;\n    GLfloat vertices[8];\n    GLfloat texCoords[8];\n    GLfloat translate[8];\n    GLfloat fAngle[4];\n    GLfloat tmp;\n\n    GLES2_ActivateRenderer(renderer);\n\n    if (GLES2_SetupCopy(renderer, texture) < 0) {\n        return -1;\n    }\n\n    data->glEnableVertexAttribArray(GLES2_ATTRIBUTE_CENTER);\n    data->glEnableVertexAttribArray(GLES2_ATTRIBUTE_ANGLE);\n    fAngle[0] = fAngle[1] = fAngle[2] = fAngle[3] = (GLfloat)(360.0f - angle);\n    /* Calculate the center of rotation */\n    translate[0] = translate[2] = translate[4] = translate[6] = (center->x + dstrect->x);\n    translate[1] = translate[3] = translate[5] = translate[7] = (center->y + dstrect->y);\n\n    /* Emit the textured quad */\n    vertices[0] = dstrect->x;\n    vertices[1] = dstrect->y;\n    vertices[2] = (dstrect->x + dstrect->w);\n    vertices[3] = dstrect->y;\n    vertices[4] = dstrect->x;\n    vertices[5] = (dstrect->y + dstrect->h);\n    vertices[6] = (dstrect->x + dstrect->w);\n    vertices[7] = (dstrect->y + dstrect->h);\n    if (flip & SDL_FLIP_HORIZONTAL) {\n        tmp = vertices[0];\n        vertices[0] = vertices[4] = vertices[2];\n        vertices[2] = vertices[6] = tmp;\n    }\n    if (flip & SDL_FLIP_VERTICAL) {\n        tmp = vertices[1];\n        vertices[1] = vertices[3] = vertices[5];\n        vertices[5] = vertices[7] = tmp;\n    }\n\n    /*data->glVertexAttribPointer(GLES2_ATTRIBUTE_ANGLE, 1, GL_FLOAT, GL_FALSE, 0, &fAngle);\n    data->glVertexAttribPointer(GLES2_ATTRIBUTE_CENTER, 2, GL_FLOAT, GL_FALSE, 0, translate);\n    data->glVertexAttribPointer(GLES2_ATTRIBUTE_POSITION, 2, GL_FLOAT, GL_FALSE, 0, vertices);*/\n\n    GLES2_UpdateVertexBuffer(renderer, GLES2_ATTRIBUTE_ANGLE, fAngle, 4 * sizeof(GLfloat));\n    GLES2_UpdateVertexBuffer(renderer, GLES2_ATTRIBUTE_CENTER, translate, 8 * sizeof(GLfloat));\n    GLES2_UpdateVertexBuffer(renderer, GLES2_ATTRIBUTE_POSITION, vertices, 8 * sizeof(GLfloat));\n\n    texCoords[0] = srcrect->x / (GLfloat)texture->w;\n    texCoords[1] = srcrect->y / (GLfloat)texture->h;\n    texCoords[2] = (srcrect->x + srcrect->w) / (GLfloat)texture->w;\n    texCoords[3] = srcrect->y / (GLfloat)texture->h;\n    texCoords[4] = srcrect->x / (GLfloat)texture->w;\n    texCoords[5] = (srcrect->y + srcrect->h) / (GLfloat)texture->h;\n    texCoords[6] = (srcrect->x + srcrect->w) / (GLfloat)texture->w;\n    texCoords[7] = (srcrect->y + srcrect->h) / (GLfloat)texture->h;\n    /*data->glVertexAttribPointer(GLES2_ATTRIBUTE_TEXCOORD, 2, GL_FLOAT, GL_FALSE, 0, texCoords);*/\n    GLES2_UpdateVertexBuffer(renderer, GLES2_ATTRIBUTE_TEXCOORD, texCoords, 8 * sizeof(GLfloat));\n    data->glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);\n    data->glDisableVertexAttribArray(GLES2_ATTRIBUTE_CENTER);\n    data->glDisableVertexAttribArray(GLES2_ATTRIBUTE_ANGLE);\n\n    return GL_CheckError(\"\", renderer);\n}\n\nstatic int\nGLES2_RenderReadPixels(SDL_Renderer * renderer, const SDL_Rect * rect,\n                    Uint32 pixel_format, void * pixels, int pitch)\n{\n    GLES2_DriverContext *data = (GLES2_DriverContext *)renderer->driverdata;\n    Uint32 temp_format = SDL_PIXELFORMAT_ABGR8888;\n    void *temp_pixels;\n    int temp_pitch;\n    Uint8 *src, *dst, *tmp;\n    int w, h, length, rows;\n    int status;\n\n    GLES2_ActivateRenderer(renderer);\n\n    temp_pitch = rect->w * SDL_BYTESPERPIXEL(temp_format);\n    temp_pixels = SDL_malloc(rect->h * temp_pitch);\n    if (!temp_pixels) {\n        return SDL_OutOfMemory();\n    }\n\n    SDL_GetRendererOutputSize(renderer, &w, &h);\n\n    data->glReadPixels(rect->x, (h-rect->y)-rect->h, rect->w, rect->h,\n                       GL_RGBA, GL_UNSIGNED_BYTE, temp_pixels);\n    if (GL_CheckError(\"glReadPixels()\", renderer) < 0) {\n        return -1;\n    }\n\n    /* Flip the rows to be top-down */\n    length = rect->w * SDL_BYTESPERPIXEL(temp_format);\n    src = (Uint8*)temp_pixels + (rect->h-1)*temp_pitch;\n    dst = (Uint8*)temp_pixels;\n    tmp = SDL_stack_alloc(Uint8, length);\n    rows = rect->h / 2;\n    while (rows--) {\n        SDL_memcpy(tmp, dst, length);\n        SDL_memcpy(dst, src, length);\n        SDL_memcpy(src, tmp, length);\n        dst += temp_pitch;\n        src -= temp_pitch;\n    }\n    SDL_stack_free(tmp);\n\n    status = SDL_ConvertPixels(rect->w, rect->h,\n                               temp_format, temp_pixels, temp_pitch,\n                               pixel_format, pixels, pitch);\n    SDL_free(temp_pixels);\n\n    return status;\n}\n\nstatic void\nGLES2_RenderPresent(SDL_Renderer *renderer)\n{\n    GLES2_ActivateRenderer(renderer);\n\n    /* Tell the video driver to swap buffers */\n    SDL_GL_SwapWindow(renderer->window);\n}\n\n\n/*************************************************************************************************\n * Bind/unbinding of textures\n *************************************************************************************************/\nstatic int GLES2_BindTexture (SDL_Renderer * renderer, SDL_Texture *texture, float *texw, float *texh);\nstatic int GLES2_UnbindTexture (SDL_Renderer * renderer, SDL_Texture *texture);\n\nstatic int GLES2_BindTexture (SDL_Renderer * renderer, SDL_Texture *texture, float *texw, float *texh)\n{\n    GLES2_DriverContext *data = (GLES2_DriverContext *)renderer->driverdata;\n    GLES2_TextureData *texturedata = (GLES2_TextureData *)texture->driverdata;\n    GLES2_ActivateRenderer(renderer);\n\n    data->glBindTexture(texturedata->texture_type, texturedata->texture);\n\n    if(texw) *texw = 1.0;\n    if(texh) *texh = 1.0;\n\n    return 0;\n}\n\nstatic int GLES2_UnbindTexture (SDL_Renderer * renderer, SDL_Texture *texture)\n{\n    GLES2_DriverContext *data = (GLES2_DriverContext *)renderer->driverdata;\n    GLES2_TextureData *texturedata = (GLES2_TextureData *)texture->driverdata;\n    GLES2_ActivateRenderer(renderer);\n\n    data->glBindTexture(texturedata->texture_type, 0);\n\n    return 0;\n}\n\n\n/*************************************************************************************************\n * Renderer instantiation                                                                        *\n *************************************************************************************************/\n\n#define GL_NVIDIA_PLATFORM_BINARY_NV 0x890B\n\nstatic void\nGLES2_ResetState(SDL_Renderer *renderer)\n{\n    GLES2_DriverContext *data = (GLES2_DriverContext *) renderer->driverdata;\n\n    if (SDL_CurrentContext == data->context) {\n        GLES2_UpdateViewport(renderer);\n    } else {\n        GLES2_ActivateRenderer(renderer);\n    }\n\n    data->current.blendMode = -1;\n    data->current.tex_coords = SDL_FALSE;\n\n    data->glActiveTexture(GL_TEXTURE0);\n    data->glPixelStorei(GL_PACK_ALIGNMENT, 1);\n    data->glPixelStorei(GL_UNPACK_ALIGNMENT, 1);\n\n    data->glClearColor((GLfloat) data->clear_r * inv255f,\n                        (GLfloat) data->clear_g * inv255f,\n                        (GLfloat) data->clear_b * inv255f,\n                        (GLfloat) data->clear_a * inv255f);\n\n    data->glEnableVertexAttribArray(GLES2_ATTRIBUTE_POSITION);\n    data->glDisableVertexAttribArray(GLES2_ATTRIBUTE_TEXCOORD);\n\n    GL_CheckError(\"\", renderer);\n}\n\nstatic SDL_Renderer *\nGLES2_CreateRenderer(SDL_Window *window, Uint32 flags)\n{\n    SDL_Renderer *renderer;\n    GLES2_DriverContext *data;\n    GLint nFormats;\n#ifndef ZUNE_HD\n    GLboolean hasCompiler;\n#endif\n    Uint32 window_flags;\n    GLint window_framebuffer;\n    GLint value;\n    int profile_mask, major, minor;\n    SDL_bool changed_window = SDL_FALSE;\n\n    SDL_GL_GetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, &profile_mask);\n    SDL_GL_GetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, &major);\n    SDL_GL_GetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, &minor);\n\n    window_flags = SDL_GetWindowFlags(window);\n    if (!(window_flags & SDL_WINDOW_OPENGL) ||\n        profile_mask != SDL_GL_CONTEXT_PROFILE_ES || major != RENDERER_CONTEXT_MAJOR || minor != RENDERER_CONTEXT_MINOR) {\n\n        changed_window = SDL_TRUE;\n        SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_ES);\n        SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, RENDERER_CONTEXT_MAJOR);\n        SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, RENDERER_CONTEXT_MINOR);\n\n        if (SDL_RecreateWindow(window, window_flags | SDL_WINDOW_OPENGL) < 0) {\n            goto error;\n        }\n    }\n\n    /* Create the renderer struct */\n    renderer = (SDL_Renderer *)SDL_calloc(1, sizeof(SDL_Renderer));\n    if (!renderer) {\n        SDL_OutOfMemory();\n        goto error;\n    }\n\n    data = (GLES2_DriverContext *)SDL_calloc(1, sizeof(GLES2_DriverContext));\n    if (!data) {\n        GLES2_DestroyRenderer(renderer);\n        SDL_OutOfMemory();\n        goto error;\n    }\n    renderer->info = GLES2_RenderDriver.info;\n    renderer->info.flags = (SDL_RENDERER_ACCELERATED | SDL_RENDERER_TARGETTEXTURE);\n    renderer->driverdata = data;\n    renderer->window = window;\n\n    /* Create an OpenGL ES 2.0 context */\n    data->context = SDL_GL_CreateContext(window);\n    if (!data->context) {\n        GLES2_DestroyRenderer(renderer);\n        goto error;\n    }\n    if (SDL_GL_MakeCurrent(window, data->context) < 0) {\n        GLES2_DestroyRenderer(renderer);\n        goto error;\n    }\n\n    if (GLES2_LoadFunctions(data) < 0) {\n        GLES2_DestroyRenderer(renderer);\n        goto error;\n    }\n\n#if __WINRT__\n    /* DLudwig, 2013-11-29: ANGLE for WinRT doesn't seem to work unless VSync\n     * is turned on.  Not doing so will freeze the screen's contents to that\n     * of the first drawn frame.\n     */\n    flags |= SDL_RENDERER_PRESENTVSYNC;\n#endif\n\n    if (flags & SDL_RENDERER_PRESENTVSYNC) {\n        SDL_GL_SetSwapInterval(1);\n    } else {\n        SDL_GL_SetSwapInterval(0);\n    }\n    if (SDL_GL_GetSwapInterval() > 0) {\n        renderer->info.flags |= SDL_RENDERER_PRESENTVSYNC;\n    }\n\n    /* Check for debug output support */\n    if (SDL_GL_GetAttribute(SDL_GL_CONTEXT_FLAGS, &value) == 0 &&\n        (value & SDL_GL_CONTEXT_DEBUG_FLAG)) {\n        data->debug_enabled = SDL_TRUE;\n    }\n\n    value = 0;\n    data->glGetIntegerv(GL_MAX_TEXTURE_SIZE, &value);\n    renderer->info.max_texture_width = value;\n    value = 0;\n    data->glGetIntegerv(GL_MAX_TEXTURE_SIZE, &value);\n    renderer->info.max_texture_height = value;\n\n    /* Determine supported shader formats */\n    /* HACK: glGetInteger is broken on the Zune HD's compositor, so we just hardcode this */\n#ifdef ZUNE_HD\n    nFormats = 1;\n#else /* !ZUNE_HD */\n    data->glGetIntegerv(GL_NUM_SHADER_BINARY_FORMATS, &nFormats);\n    data->glGetBooleanv(GL_SHADER_COMPILER, &hasCompiler);\n    if (hasCompiler)\n        ++nFormats;\n#endif /* ZUNE_HD */\n    data->shader_formats = (GLenum *)SDL_calloc(nFormats, sizeof(GLenum));\n    if (!data->shader_formats)\n    {\n        GLES2_DestroyRenderer(renderer);\n        SDL_OutOfMemory();\n        goto error;\n    }\n    data->shader_format_count = nFormats;\n#ifdef ZUNE_HD\n    data->shader_formats[0] = GL_NVIDIA_PLATFORM_BINARY_NV;\n#else /* !ZUNE_HD */\n    data->glGetIntegerv(GL_SHADER_BINARY_FORMATS, (GLint *)data->shader_formats);\n    if (hasCompiler)\n        data->shader_formats[nFormats - 1] = (GLenum)-1;\n#endif /* ZUNE_HD */\n\n    data->framebuffers = NULL;\n    data->glGetIntegerv(GL_FRAMEBUFFER_BINDING, &window_framebuffer);\n    data->window_framebuffer = (GLuint)window_framebuffer;\n\n    /* Populate the function pointers for the module */\n    renderer->WindowEvent         = &GLES2_WindowEvent;\n    renderer->CreateTexture       = &GLES2_CreateTexture;\n    renderer->UpdateTexture       = &GLES2_UpdateTexture;\n    renderer->UpdateTextureYUV    = &GLES2_UpdateTextureYUV;\n    renderer->LockTexture         = &GLES2_LockTexture;\n    renderer->UnlockTexture       = &GLES2_UnlockTexture;\n    renderer->SetRenderTarget     = &GLES2_SetRenderTarget;\n    renderer->UpdateViewport      = &GLES2_UpdateViewport;\n    renderer->UpdateClipRect      = &GLES2_UpdateClipRect;\n    renderer->RenderClear         = &GLES2_RenderClear;\n    renderer->RenderDrawPoints    = &GLES2_RenderDrawPoints;\n    renderer->RenderDrawLines     = &GLES2_RenderDrawLines;\n    renderer->RenderFillRects     = &GLES2_RenderFillRects;\n    renderer->RenderCopy          = &GLES2_RenderCopy;\n    renderer->RenderCopyEx        = &GLES2_RenderCopyEx;\n    renderer->RenderReadPixels    = &GLES2_RenderReadPixels;\n    renderer->RenderPresent       = &GLES2_RenderPresent;\n    renderer->DestroyTexture      = &GLES2_DestroyTexture;\n    renderer->DestroyRenderer     = &GLES2_DestroyRenderer;\n    renderer->GL_BindTexture      = &GLES2_BindTexture;\n    renderer->GL_UnbindTexture    = &GLES2_UnbindTexture;\n\n    renderer->info.texture_formats[renderer->info.num_texture_formats++] = SDL_PIXELFORMAT_YV12;\n    renderer->info.texture_formats[renderer->info.num_texture_formats++] = SDL_PIXELFORMAT_IYUV;\n    renderer->info.texture_formats[renderer->info.num_texture_formats++] = SDL_PIXELFORMAT_NV12;\n    renderer->info.texture_formats[renderer->info.num_texture_formats++] = SDL_PIXELFORMAT_NV21;\n\n    GLES2_ResetState(renderer);\n\n    return renderer;\n\nerror:\n    if (changed_window) {\n        /* Uh oh, better try to put it back... */\n        SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, profile_mask);\n        SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, major);\n        SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, minor);\n        SDL_RecreateWindow(window, window_flags);\n    }\n    return NULL;\n}\n\n#endif /* SDL_VIDEO_RENDER_OGL_ES2 && !SDL_RENDER_DISABLED */\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n\nSDL_PROC(void, glActiveTexture, (GLenum))\nSDL_PROC(void, glAttachShader, (GLuint, GLuint))\nSDL_PROC(void, glBindAttribLocation, (GLuint, GLuint, const char *))\nSDL_PROC(void, glBindTexture, (GLenum, GLuint))\nSDL_PROC(void, glBlendFuncSeparate, (GLenum, GLenum, GLenum, GLenum))\nSDL_PROC(void, glClear, (GLbitfield))\nSDL_PROC(void, glClearColor, (GLclampf, GLclampf, GLclampf, GLclampf))\nSDL_PROC(void, glCompileShader, (GLuint))\nSDL_PROC(GLuint, glCreateProgram, (void))\nSDL_PROC(GLuint, glCreateShader, (GLenum))\nSDL_PROC(void, glDeleteProgram, (GLuint))\nSDL_PROC(void, glDeleteShader, (GLuint))\nSDL_PROC(void, glDeleteTextures, (GLsizei, const GLuint *))\nSDL_PROC(void, glDisable, (GLenum))\nSDL_PROC(void, glDisableVertexAttribArray, (GLuint))\nSDL_PROC(void, glDrawArrays, (GLenum, GLint, GLsizei))\nSDL_PROC(void, glEnable, (GLenum))\nSDL_PROC(void, glEnableVertexAttribArray, (GLuint))\nSDL_PROC(void, glFinish, (void))\nSDL_PROC(void, glGenFramebuffers, (GLsizei, GLuint *))\nSDL_PROC(void, glGenTextures, (GLsizei, GLuint *))\nSDL_PROC(void, glGetBooleanv, (GLenum, GLboolean *))\nSDL_PROC(const GLubyte *, glGetString, (GLenum))\nSDL_PROC(GLenum, glGetError, (void))\nSDL_PROC(void, glGetIntegerv, (GLenum, GLint *))\nSDL_PROC(void, glGetProgramiv, (GLuint, GLenum, GLint *))\nSDL_PROC(void, glGetShaderInfoLog, (GLuint, GLsizei, GLsizei *, char *))\nSDL_PROC(void, glGetShaderiv, (GLuint, GLenum, GLint *))\nSDL_PROC(GLint, glGetUniformLocation, (GLuint, const char *))\nSDL_PROC(void, glLinkProgram, (GLuint))\nSDL_PROC(void, glPixelStorei, (GLenum, GLint))\nSDL_PROC(void, glReadPixels, (GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, GLvoid*))\nSDL_PROC(void, glScissor, (GLint, GLint, GLsizei, GLsizei))\nSDL_PROC(void, glShaderBinary, (GLsizei, const GLuint *, GLenum, const void *, GLsizei))\nSDL_PROC(void, glShaderSource, (GLuint, GLsizei, const GLchar* const*, const GLint *))\nSDL_PROC(void, glTexImage2D, (GLenum, GLint, GLint, GLsizei, GLsizei, GLint, GLenum, GLenum, const void *))\nSDL_PROC(void, glTexParameteri, (GLenum, GLenum, GLint))\nSDL_PROC(void, glTexSubImage2D, (GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *))\nSDL_PROC(void, glUniform1i, (GLint, GLint))\nSDL_PROC(void, glUniform4f, (GLint, GLfloat, GLfloat, GLfloat, GLfloat))\nSDL_PROC(void, glUniformMatrix4fv, (GLint, GLsizei, GLboolean, const GLfloat *))\nSDL_PROC(void, glUseProgram, (GLuint))\nSDL_PROC(void, glVertexAttribPointer, (GLuint, GLint, GLenum, GLboolean, GLsizei, const void *))\nSDL_PROC(void, glViewport, (GLint, GLint, GLsizei, GLsizei))\nSDL_PROC(void, glBindFramebuffer, (GLenum, GLuint))\nSDL_PROC(void, glFramebufferTexture2D, (GLenum, GLenum, GLenum, GLuint, GLint))\nSDL_PROC(GLenum, glCheckFramebufferStatus, (GLenum))\nSDL_PROC(void, glDeleteFramebuffers, (GLsizei, const GLuint *))\nSDL_PROC(GLint, glGetAttribLocation, (GLuint, const GLchar *))\nSDL_PROC(void, glGetProgramInfoLog, (GLuint, GLsizei, GLsizei*, GLchar*))\nSDL_PROC(void, glGenBuffers, (GLsizei, GLuint *))\nSDL_PROC(void, glBindBuffer, (GLenum, GLuint))\nSDL_PROC(void, glBufferData, (GLenum, GLsizeiptr, const GLvoid *, GLenum))\nSDL_PROC(void, glBufferSubData, (GLenum, GLintptr, GLsizeiptr, const GLvoid *))\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../../SDL_internal.h\"\n\n#if SDL_VIDEO_RENDER_OGL_ES2 && !SDL_RENDER_DISABLED\n\n#include \"SDL_video.h\"\n#include \"SDL_opengles2.h\"\n#include \"SDL_shaders_gles2.h\"\n#include \"SDL_stdinc.h\"\n\n/*************************************************************************************************\n * Vertex/fragment shader source                                                                 *\n *************************************************************************************************/\n\nstatic const Uint8 GLES2_VertexSrc_Default_[] = \" \\\n    uniform mat4 u_projection; \\\n    attribute vec2 a_position; \\\n    attribute vec2 a_texCoord; \\\n    attribute float a_angle; \\\n    attribute vec2 a_center; \\\n    varying vec2 v_texCoord; \\\n    \\\n    void main() \\\n    { \\\n        float angle = radians(a_angle); \\\n        float c = cos(angle); \\\n        float s = sin(angle); \\\n        mat2 rotationMatrix = mat2(c, -s, s, c); \\\n        vec2 position = rotationMatrix * (a_position - a_center) + a_center; \\\n        v_texCoord = a_texCoord; \\\n        gl_Position = u_projection * vec4(position, 0.0, 1.0);\\\n        gl_PointSize = 1.0; \\\n    } \\\n\";\n\nstatic const Uint8 GLES2_FragmentSrc_SolidSrc_[] = \" \\\n    precision mediump float; \\\n    uniform vec4 u_color; \\\n    \\\n    void main() \\\n    { \\\n        gl_FragColor = u_color; \\\n    } \\\n\";\n\nstatic const Uint8 GLES2_FragmentSrc_TextureABGRSrc_[] = \" \\\n    precision mediump float; \\\n    uniform sampler2D u_texture; \\\n    uniform vec4 u_modulation; \\\n    varying vec2 v_texCoord; \\\n    \\\n    void main() \\\n    { \\\n        gl_FragColor = texture2D(u_texture, v_texCoord); \\\n        gl_FragColor *= u_modulation; \\\n    } \\\n\";\n\n/* ARGB to ABGR conversion */\nstatic const Uint8 GLES2_FragmentSrc_TextureARGBSrc_[] = \" \\\n    precision mediump float; \\\n    uniform sampler2D u_texture; \\\n    uniform vec4 u_modulation; \\\n    varying vec2 v_texCoord; \\\n    \\\n    void main() \\\n    { \\\n        vec4 abgr = texture2D(u_texture, v_texCoord); \\\n        gl_FragColor = abgr; \\\n        gl_FragColor.r = abgr.b; \\\n        gl_FragColor.b = abgr.r; \\\n        gl_FragColor *= u_modulation; \\\n    } \\\n\";\n\n/* RGB to ABGR conversion */\nstatic const Uint8 GLES2_FragmentSrc_TextureRGBSrc_[] = \" \\\n    precision mediump float; \\\n    uniform sampler2D u_texture; \\\n    uniform vec4 u_modulation; \\\n    varying vec2 v_texCoord; \\\n    \\\n    void main() \\\n    { \\\n        vec4 abgr = texture2D(u_texture, v_texCoord); \\\n        gl_FragColor = abgr; \\\n        gl_FragColor.r = abgr.b; \\\n        gl_FragColor.b = abgr.r; \\\n        gl_FragColor.a = 1.0; \\\n        gl_FragColor *= u_modulation; \\\n    } \\\n\";\n\n/* BGR to ABGR conversion */\nstatic const Uint8 GLES2_FragmentSrc_TextureBGRSrc_[] = \" \\\n    precision mediump float; \\\n    uniform sampler2D u_texture; \\\n    uniform vec4 u_modulation; \\\n    varying vec2 v_texCoord; \\\n    \\\n    void main() \\\n    { \\\n        vec4 abgr = texture2D(u_texture, v_texCoord); \\\n        gl_FragColor = abgr; \\\n        gl_FragColor.a = 1.0; \\\n        gl_FragColor *= u_modulation; \\\n    } \\\n\";\n\n/* YUV to ABGR conversion */\nstatic const Uint8 GLES2_FragmentSrc_TextureYUVSrc_[] = \" \\\n    precision mediump float; \\\n    uniform sampler2D u_texture; \\\n    uniform sampler2D u_texture_u; \\\n    uniform sampler2D u_texture_v; \\\n    uniform vec4 u_modulation; \\\n    varying vec2 v_texCoord; \\\n    \\\n    void main() \\\n    { \\\n        mediump vec3 yuv; \\\n        lowp vec3 rgb; \\\n        yuv.x = texture2D(u_texture,   v_texCoord).r; \\\n        yuv.y = texture2D(u_texture_u, v_texCoord).r - 0.5; \\\n        yuv.z = texture2D(u_texture_v, v_texCoord).r - 0.5; \\\n        rgb = mat3( 1,        1,       1, \\\n                    0,       -0.39465, 2.03211, \\\n                    1.13983, -0.58060, 0) * yuv; \\\n        gl_FragColor = vec4(rgb, 1); \\\n        gl_FragColor *= u_modulation; \\\n    } \\\n\";\n\n/* NV12 to ABGR conversion */\nstatic const Uint8 GLES2_FragmentSrc_TextureNV12Src_[] = \" \\\n    precision mediump float; \\\n    uniform sampler2D u_texture; \\\n    uniform sampler2D u_texture_u; \\\n    uniform vec4 u_modulation; \\\n    varying vec2 v_texCoord; \\\n    \\\n    void main() \\\n    { \\\n        mediump vec3 yuv; \\\n        lowp vec3 rgb; \\\n        yuv.x = texture2D(u_texture,   v_texCoord).r; \\\n        yuv.yz = texture2D(u_texture_u, v_texCoord).ra - 0.5; \\\n        rgb = mat3( 1,        1,       1, \\\n                    0,       -0.39465, 2.03211, \\\n                    1.13983, -0.58060, 0) * yuv; \\\n        gl_FragColor = vec4(rgb, 1); \\\n        gl_FragColor *= u_modulation; \\\n    } \\\n\";\n\n/* NV21 to ABGR conversion */\nstatic const Uint8 GLES2_FragmentSrc_TextureNV21Src_[] = \" \\\n    precision mediump float; \\\n    uniform sampler2D u_texture; \\\n    uniform sampler2D u_texture_u; \\\n    uniform vec4 u_modulation; \\\n    varying vec2 v_texCoord; \\\n    \\\n    void main() \\\n    { \\\n        mediump vec3 yuv; \\\n        lowp vec3 rgb; \\\n        yuv.x = texture2D(u_texture,   v_texCoord).r; \\\n        yuv.yz = texture2D(u_texture_u, v_texCoord).ar - 0.5; \\\n        rgb = mat3( 1,        1,       1, \\\n                    0,       -0.39465, 2.03211, \\\n                    1.13983, -0.58060, 0) * yuv; \\\n        gl_FragColor = vec4(rgb, 1); \\\n        gl_FragColor *= u_modulation; \\\n    } \\\n\";\n\nstatic const GLES2_ShaderInstance GLES2_VertexSrc_Default = {\n    GL_VERTEX_SHADER,\n    GLES2_SOURCE_SHADER,\n    sizeof(GLES2_VertexSrc_Default_),\n    GLES2_VertexSrc_Default_\n};\n\nstatic const GLES2_ShaderInstance GLES2_FragmentSrc_SolidSrc = {\n    GL_FRAGMENT_SHADER,\n    GLES2_SOURCE_SHADER,\n    sizeof(GLES2_FragmentSrc_SolidSrc_),\n    GLES2_FragmentSrc_SolidSrc_\n};\n\nstatic const GLES2_ShaderInstance GLES2_FragmentSrc_TextureABGRSrc = {\n    GL_FRAGMENT_SHADER,\n    GLES2_SOURCE_SHADER,\n    sizeof(GLES2_FragmentSrc_TextureABGRSrc_),\n    GLES2_FragmentSrc_TextureABGRSrc_\n};\n\nstatic const GLES2_ShaderInstance GLES2_FragmentSrc_TextureARGBSrc = {\n    GL_FRAGMENT_SHADER,\n    GLES2_SOURCE_SHADER,\n    sizeof(GLES2_FragmentSrc_TextureARGBSrc_),\n    GLES2_FragmentSrc_TextureARGBSrc_\n};\n\nstatic const GLES2_ShaderInstance GLES2_FragmentSrc_TextureRGBSrc = {\n    GL_FRAGMENT_SHADER,\n    GLES2_SOURCE_SHADER,\n    sizeof(GLES2_FragmentSrc_TextureRGBSrc_),\n    GLES2_FragmentSrc_TextureRGBSrc_\n};\n\nstatic const GLES2_ShaderInstance GLES2_FragmentSrc_TextureBGRSrc = {\n    GL_FRAGMENT_SHADER,\n    GLES2_SOURCE_SHADER,\n    sizeof(GLES2_FragmentSrc_TextureBGRSrc_),\n    GLES2_FragmentSrc_TextureBGRSrc_\n};\n\nstatic const GLES2_ShaderInstance GLES2_FragmentSrc_TextureYUVSrc = {\n    GL_FRAGMENT_SHADER,\n    GLES2_SOURCE_SHADER,\n    sizeof(GLES2_FragmentSrc_TextureYUVSrc_),\n    GLES2_FragmentSrc_TextureYUVSrc_\n};\n\nstatic const GLES2_ShaderInstance GLES2_FragmentSrc_TextureNV12Src = {\n    GL_FRAGMENT_SHADER,\n    GLES2_SOURCE_SHADER,\n    sizeof(GLES2_FragmentSrc_TextureNV12Src_),\n    GLES2_FragmentSrc_TextureNV12Src_\n};\n\nstatic const GLES2_ShaderInstance GLES2_FragmentSrc_TextureNV21Src = {\n    GL_FRAGMENT_SHADER,\n    GLES2_SOURCE_SHADER,\n    sizeof(GLES2_FragmentSrc_TextureNV21Src_),\n    GLES2_FragmentSrc_TextureNV21Src_\n};\n\n\n/*************************************************************************************************\n * Vertex/fragment shader binaries (NVIDIA Tegra 1/2)                                            *\n *************************************************************************************************/\n\n#if GLES2_INCLUDE_NVIDIA_SHADERS\n\n#define GL_NVIDIA_PLATFORM_BINARY_NV 0x890B\n\nstatic const Uint8 GLES2_VertexTegra_Default_[] = {\n    243, 193, 1, 142, 31, 109, 131, 38, 6, 0, 1, 0, 5, 0, 0, 0, 17, 0, 0, 0, 1, 0, 0, 0, 73, 0,\n    0, 0, 46, 0, 0, 0, 48, 0, 0, 0, 2, 0, 0, 0, 85, 0, 0, 0, 2, 0, 0, 0, 24, 0, 0, 0, 3, 0, 0, 0,\n    91, 0, 0, 0, 1, 0, 0, 0, 16, 0, 0, 0, 5, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 95, 0, 0, 0, 1, 0, 0, 0, 28, 0, 0, 0,\n    13, 0, 0, 0, 102, 0, 0, 0, 2, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 16, 0, 0, 0, 104, 0, 0, 0, 1, 0, 0, 0, 32, 0, 0, 0, 17, 0, 0, 0, 112, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 18, 0, 0, 0, 112, 0, 0, 0, 80, 0, 0, 0, 80, 0, 0, 0, 19, 0, 0, 0, 132, 0,\n    0, 0, 104, 0, 0, 0, 104, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 109, 97, 110, 70, 73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 97,\n    95, 112, 111, 115, 105, 116, 105, 111, 110, 0, 97, 95, 116, 101, 120, 67, 111, 111, 114, 100,\n    0, 118, 95, 116, 101, 120, 67, 111, 111, 114, 100, 0, 117, 95, 112, 114, 111, 106, 101, 99,\n    116, 105, 111, 110, 0, 0, 0, 0, 0, 0, 0, 82, 139, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 80, 139, 0,\n    0, 1, 0, 0, 0, 22, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 33, 0, 0, 0, 92, 139, 0, 0,\n    1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 240, 0, 0, 0, 0, 0, 0, 1, 0,\n    0, 0, 64, 0, 0, 0, 80, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 193, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 128, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 66, 24, 0, 6, 34, 108, 28,\n    0, 0, 42, 16, 128, 0, 195, 192, 6, 129, 252, 255, 65, 96, 108, 28, 0, 0, 0, 0, 0, 1, 195, 192,\n    6, 1, 252, 255, 33, 96, 108, 156, 31, 64, 8, 1, 64, 0, 131, 192, 6, 1, 156, 159, 65, 96, 108,\n    28, 0, 0, 85, 32, 0, 1, 195, 192, 6, 1, 252, 255, 33, 96, 108, 156, 31, 64, 0, 64, 64, 0, 131,\n    192, 134, 1, 152, 31, 65, 96, 108, 156, 31, 64, 127, 48, 0, 1, 195, 192, 6, 129, 129, 255, 33,\n    96\n};\n\nstatic const Uint8 GLES2_FragmentTegra_None_SolidSrc_[] = {\n    155, 191, 159, 1, 47, 109, 131, 38, 6, 0, 1, 0, 5, 0, 0, 0, 17, 0, 0, 0, 1, 0, 0, 0, 73, 0,\n    0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 2, 0, 0, 0, 75, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 75,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 75, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0,\n    75, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 75, 0, 0, 0, 1, 0, 0, 0, 28, 0, 0, 0, 13, 0,\n    0, 0, 82, 0, 0, 0, 2, 0, 0, 0, 8, 0, 0, 0, 14, 0, 0, 0, 84, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    22, 0, 0, 0, 84, 0, 0, 0, 8, 0, 0, 0, 32, 0, 0, 0, 23, 0, 0, 0, 92, 0, 0, 0, 1, 0, 0, 0, 4,\n    0, 0, 0, 15, 0, 0, 0, 93, 0, 0, 0, 1, 0, 0, 0, 80, 0, 0, 0, 17, 0, 0, 0, 113, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 18, 0, 0, 0, 113, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 113, 0, 0,\n    0, 108, 0, 0, 0, 108, 0, 0, 0, 20, 0, 0, 0, 113, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0,\n    0, 113, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 109, 97, 110, 70, 73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 117, 95, 99, 111, 108, 111, 114, 0, 0, 0, 0, 0, 82, 139, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 241, 0, 0, 0, 240, 0, 0,\n    0, 240, 0, 0, 0, 240, 0, 0, 0, 240, 0, 0, 0, 240, 0, 0, 0, 240, 0, 0, 0, 240, 0, 0, 0, 0, 0,\n    0, 0, 0, 1, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 21, 32, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 20, 0, 0, 0, 16, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 65, 82, 50, 48, 45, 66, 73, 78, 1,\n    0, 0, 0, 1, 0, 0, 0, 1, 0, 65, 37, 0, 0, 0, 0, 1, 0, 0, 21, 0, 0, 0, 0, 1, 0, 1, 38, 0, 0, 0,\n    0, 1, 0, 1, 39, 0, 0, 0, 0, 1, 0, 1, 40, 1, 0, 0, 0, 8, 0, 4, 40, 0, 40, 0, 0, 0, 242, 65, 63,\n    192, 200, 0, 0, 0, 242, 65, 63, 128, 168, 0, 0, 0, 242, 65, 63, 64, 72, 0, 0, 0, 242, 65, 63,\n    1, 0, 6, 40, 0, 0, 0, 0, 1, 0, 1, 41, 5, 0, 2, 0\n};\n\nstatic const Uint8 GLES2_FragmentTegra_Alpha_SolidSrc_[] = {\n    169, 153, 195, 28, 47, 109, 131, 38, 6, 0, 1, 0, 5, 0, 0, 0, 17, 0, 0, 0, 1, 0, 0, 0, 73, 0,\n    0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 2, 0, 0, 0, 75, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 75,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 75, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0,\n    75, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 75, 0, 0, 0, 1, 0, 0, 0, 28, 0, 0, 0, 13, 0,\n    0, 0, 82, 0, 0, 0, 2, 0, 0, 0, 8, 0, 0, 0, 14, 0, 0, 0, 84, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    22, 0, 0, 0, 84, 0, 0, 0, 8, 0, 0, 0, 32, 0, 0, 0, 23, 0, 0, 0, 92, 0, 0, 0, 1, 0, 0, 0, 4,\n    0, 0, 0, 15, 0, 0, 0, 93, 0, 0, 0, 1, 0, 0, 0, 80, 0, 0, 0, 17, 0, 0, 0, 113, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 18, 0, 0, 0, 113, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 113, 0, 0,\n    0, 220, 0, 0, 0, 220, 0, 0, 0, 20, 0, 0, 0, 113, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0,\n    0, 113, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 109, 97, 110, 70, 73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 117, 95, 99, 111, 108, 111, 114, 0, 0, 0, 0, 0, 82, 139, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 48, 0, 0, 0, 0, 0, 0, 118, 118, 17, 241, 0, 0, 0, 240, 0,\n    0, 0, 240, 0, 0, 0, 240, 0, 0, 0, 240, 0, 0, 0, 240, 0, 0, 0, 240, 0, 0, 0, 240, 0, 0, 0, 0,\n    0, 0, 0, 0, 1, 0, 0, 0, 7, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 0, 21, 32, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 16, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 65, 82, 50, 48, 45, 66, 73, 78,\n    1, 0, 0, 0, 3, 0, 0, 0, 3, 0, 65, 37, 8, 0, 129, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 21, 0,\n    0, 0, 0, 3, 0, 1, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 1, 39, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 3, 0, 1, 40, 1, 0, 0, 0, 5, 0, 0, 0, 9, 0, 0, 0, 24, 0, 4, 40, 232, 231, 15,\n    0, 0, 242, 65, 62, 194, 72, 1, 0, 0, 250, 65, 63, 194, 40, 1, 0, 0, 250, 65, 63, 192, 168, 1,\n    0, 0, 242, 1, 64, 192, 168, 1, 0, 0, 242, 1, 68, 168, 32, 0, 0, 0, 50, 64, 0, 192, 168, 15,\n    0, 0, 242, 1, 66, 168, 64, 0, 16, 0, 242, 65, 1, 232, 231, 15, 0, 0, 242, 65, 62, 168, 160,\n    0, 0, 0, 50, 64, 2, 104, 192, 0, 0, 36, 48, 66, 4, 232, 231, 15, 0, 0, 242, 65, 62, 3, 0, 6,\n    40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 1, 41, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 2, 0\n};\n\nstatic const Uint8 GLES2_FragmentTegra_Additive_SolidSrc_[] = {\n    59, 71, 42, 17, 47, 109, 131, 38, 6, 0, 1, 0, 5, 0, 0, 0, 17, 0, 0, 0, 1, 0, 0, 0, 73, 0, 0,\n    0, 8, 0, 0, 0, 8, 0, 0, 0, 2, 0, 0, 0, 75, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 75,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 75, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0,\n    75, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 75, 0, 0, 0, 1, 0, 0, 0, 28, 0, 0, 0, 13, 0,\n    0, 0, 82, 0, 0, 0, 2, 0, 0, 0, 8, 0, 0, 0, 14, 0, 0, 0, 84, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    22, 0, 0, 0, 84, 0, 0, 0, 8, 0, 0, 0, 32, 0, 0, 0, 23, 0, 0, 0, 92, 0, 0, 0, 1, 0, 0, 0, 4,\n    0, 0, 0, 15, 0, 0, 0, 93, 0, 0, 0, 1, 0, 0, 0, 80, 0, 0, 0, 17, 0, 0, 0, 113, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 18, 0, 0, 0, 113, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 113, 0, 0,\n    0, 108, 0, 0, 0, 108, 0, 0, 0, 20, 0, 0, 0, 113, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0,\n    0, 113, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 109, 97, 110, 70, 73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 117, 95, 99, 111, 108, 111, 114, 0, 0, 0, 0, 0, 82, 139, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 48, 0, 0, 0, 0, 0, 0, 22, 22, 17, 241, 0, 0, 0, 240, 0,\n    0, 0, 240, 0, 0, 0, 240, 0, 0, 0, 240, 0, 0, 0, 240, 0, 0, 0, 240, 0, 0, 0, 240, 0, 0, 0, 0,\n    0, 0, 0, 0, 1, 0, 0, 0, 7, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 21, 32, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 16, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 65, 82, 50, 48, 45, 66, 73, 78,\n    1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 65, 37, 8, 0, 129, 0, 1, 0, 0, 21, 0, 0, 0, 0, 1, 0, 1, 38, 0,\n    0, 0, 0, 1, 0, 1, 39, 0, 0, 0, 0, 1, 0, 1, 40, 1, 0, 0, 0, 8, 0, 4, 40, 192, 200, 0, 0, 0, 26,\n    0, 70, 192, 40, 0, 0, 0, 2, 0, 64, 192, 72, 0, 0, 0, 10, 0, 66, 192, 168, 0, 0, 0, 18, 0, 68,\n    1, 0, 6, 40, 0, 0, 0, 0, 1, 0, 1, 41, 5, 0, 2, 0\n};\n\nstatic const Uint8 GLES2_FragmentTegra_Modulated_SolidSrc_[] = {\n    37, 191, 49, 17, 47, 109, 131, 38, 6, 0, 1, 0, 5, 0, 0, 0, 17, 0, 0, 0, 1, 0, 0, 0, 73, 0, 0,\n    0, 8, 0, 0, 0, 8, 0, 0, 0, 2, 0, 0, 0, 75, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 75,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 75, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0,\n    75, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 75, 0, 0, 0, 1, 0, 0, 0, 28, 0, 0, 0, 13, 0,\n    0, 0, 82, 0, 0, 0, 2, 0, 0, 0, 8, 0, 0, 0, 14, 0, 0, 0, 84, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    22, 0, 0, 0, 84, 0, 0, 0, 8, 0, 0, 0, 32, 0, 0, 0, 23, 0, 0, 0, 92, 0, 0, 0, 1, 0, 0, 0, 4,\n    0, 0, 0, 15, 0, 0, 0, 93, 0, 0, 0, 1, 0, 0, 0, 80, 0, 0, 0, 17, 0, 0, 0, 113, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 18, 0, 0, 0, 113, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 113, 0, 0,\n    0, 108, 0, 0, 0, 108, 0, 0, 0, 20, 0, 0, 0, 113, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0,\n    0, 113, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 109, 97, 110, 70, 73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 117, 95, 99, 111, 108, 111, 114, 0, 0, 0, 0, 0, 82, 139, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 48, 0, 0, 0, 0, 0, 0, 32, 32, 17, 241, 0, 0, 0, 240, 0,\n    0, 0, 240, 0, 0, 0, 240, 0, 0, 0, 240, 0, 0, 0, 240, 0, 0, 0, 240, 0, 0, 0, 240, 0, 0, 0, 0,\n    0, 0, 0, 0, 1, 0, 0, 0, 7, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 21, 32, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 16, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 65, 82, 50, 48, 45, 66, 73, 78,\n    1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 65, 37, 8, 0, 129, 0, 1, 0, 0, 21, 0, 0, 0, 0, 1, 0, 1, 38, 0,\n    0, 0, 0, 1, 0, 1, 39, 0, 0, 0, 0, 1, 0, 1, 40, 1, 0, 0, 0, 8, 0, 4, 40, 104, 192, 0, 0, 0, 242,\n    1, 70, 8, 32, 0, 0, 0, 242, 1, 64, 40, 64, 0, 0, 0, 242, 1, 66, 72, 160, 0, 0, 0, 242, 1, 68,\n    1, 0, 6, 40, 0, 0, 0, 0, 1, 0, 1, 41, 5, 0, 2, 0\n};\n\nstatic const Uint8 GLES2_FragmentTegra_None_TextureSrc_[] = {\n    220, 217, 41, 211, 47, 109, 131, 38, 6, 0, 1, 0, 5, 0, 0, 0, 17, 0, 0, 0, 1, 0, 0, 0, 73, 0,\n    0, 0, 34, 0, 0, 0, 36, 0, 0, 0, 2, 0, 0, 0, 82, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,\n    82, 0, 0, 0, 1, 0, 0, 0, 20, 0, 0, 0, 6, 0, 0, 0, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0,\n    0, 0, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 87, 0, 0, 0, 2, 0, 0, 0, 56, 0, 0, 0,\n    13, 0, 0, 0, 101, 0, 0, 0, 4, 0, 0, 0, 16, 0, 0, 0, 14, 0, 0, 0, 105, 0, 0, 0, 1, 0, 0, 0, 4,\n    0, 0, 0, 22, 0, 0, 0, 106, 0, 0, 0, 8, 0, 0, 0, 32, 0, 0, 0, 23, 0, 0, 0, 114, 0, 0, 0, 1, 0,\n    0, 0, 4, 0, 0, 0, 15, 0, 0, 0, 115, 0, 0, 0, 1, 0, 0, 0, 80, 0, 0, 0, 17, 0, 0, 0, 135, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 0, 0, 135, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 135,\n    0, 0, 0, 120, 0, 0, 0, 120, 0, 0, 0, 20, 0, 0, 0, 135, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21,\n    0, 0, 0, 135, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 109, 97, 110, 70, 73, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 118, 95, 116, 101, 120, 67, 111, 111, 114, 100, 0, 117, 95, 109, 111, 100, 117, 108,\n    97, 116, 105, 111, 110, 0, 117, 95, 116, 101, 120, 116, 117, 114, 101, 0, 0, 0, 0, 0, 0, 0,\n    2, 0, 0, 0, 0, 0, 0, 0, 220, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 82, 139, 0, 0, 1, 0, 0, 0, 1,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 94, 139, 0, 0, 1, 0, 0, 0, 1, 0, 0,\n    0, 2, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 5, 48, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 1, 0, 0, 0, 241, 0, 0, 0, 240, 0, 0, 0, 240, 0, 0, 0, 240, 0, 0, 0, 240, 0, 0, 0, 240,\n    0, 0, 0, 240, 0, 0, 0, 240, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0,\n    0, 0, 1, 0, 0, 0, 21, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 16, 0, 0, 0, 16, 0, 0,\n    0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 65, 82, 50, 48, 45, 66, 73, 78, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 65, 37, 0, 0, 0, 0, 1, 0,\n    0, 21, 0, 0, 0, 0, 1, 0, 1, 38, 1, 0, 0, 0, 2, 0, 4, 38, 186, 81, 78, 16, 2, 1, 0, 0, 1, 0,\n    1, 39, 0, 4, 0, 0, 1, 0, 1, 40, 1, 0, 0, 0, 8, 0, 4, 40, 104, 192, 0, 0, 0, 242, 1, 70, 8, 32,\n    0, 0, 0, 242, 1, 64, 40, 64, 0, 0, 0, 242, 1, 66, 72, 160, 0, 0, 0, 242, 1, 68, 1, 0, 6, 40,\n    0, 0, 0, 0, 1, 0, 1, 41, 5, 0, 2, 0\n};\n\nstatic const Uint8 GLES2_FragmentTegra_Alpha_TextureSrc_[] = {\n    71, 202, 114, 229, 47, 109, 131, 38, 6, 0, 1, 0, 5, 0, 0, 0, 17, 0, 0, 0, 1, 0, 0, 0, 73, 0,\n    0, 0, 34, 0, 0, 0, 36, 0, 0, 0, 2, 0, 0, 0, 82, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,\n    82, 0, 0, 0, 1, 0, 0, 0, 20, 0, 0, 0, 6, 0, 0, 0, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0,\n    0, 0, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 87, 0, 0, 0, 2, 0, 0, 0, 56, 0, 0, 0,\n    13, 0, 0, 0, 101, 0, 0, 0, 4, 0, 0, 0, 16, 0, 0, 0, 14, 0, 0, 0, 105, 0, 0, 0, 1, 0, 0, 0, 4,\n    0, 0, 0, 22, 0, 0, 0, 106, 0, 0, 0, 8, 0, 0, 0, 32, 0, 0, 0, 23, 0, 0, 0, 114, 0, 0, 0, 1, 0,\n    0, 0, 4, 0, 0, 0, 15, 0, 0, 0, 115, 0, 0, 0, 1, 0, 0, 0, 80, 0, 0, 0, 17, 0, 0, 0, 135, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 0, 0, 135, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 135,\n    0, 0, 0, 176, 0, 0, 0, 176, 0, 0, 0, 20, 0, 0, 0, 135, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21,\n    0, 0, 0, 135, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 109, 97, 110, 70, 73, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 118, 95, 116, 101, 120, 67, 111, 111, 114, 100, 0, 117, 95, 109, 111, 100, 117, 108,\n    97, 116, 105, 111, 110, 0, 117, 95, 116, 101, 120, 116, 117, 114, 101, 0, 0, 0, 0, 0, 0, 0,\n    2, 0, 0, 0, 0, 0, 0, 0, 220, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 82, 139, 0, 0, 1, 0, 0, 0, 1,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 94, 139, 0, 0, 1, 0, 0, 0, 1, 0, 0,\n    0, 2, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 5, 48, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 1, 118, 118, 17, 241, 0, 0, 0, 240, 0, 0, 0, 240, 0, 0, 0, 240, 0, 0, 0, 240, 0, 0, 0,\n    240, 0, 0, 0, 240, 0, 0, 0, 240, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 7, 0, 0, 0, 2, 0, 0, 0,\n    1, 0, 0, 0, 2, 0, 0, 0, 21, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 16, 0, 0, 0, 16,\n    0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 65, 82, 50, 48, 45, 66, 73, 78, 1, 0, 0, 0, 2, 0, 0, 0, 2, 0, 65, 37, 0, 0, 0, 0,\n    8, 0, 129, 0, 1, 0, 0, 21, 0, 0, 0, 0, 2, 0, 1, 38, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 4, 38, 186,\n    81, 78, 16, 2, 1, 0, 0, 2, 0, 1, 39, 0, 4, 0, 0, 0, 0, 0, 0, 2, 0, 1, 40, 1, 0, 0, 0, 5, 0,\n    0, 0, 16, 0, 4, 40, 40, 160, 1, 0, 0, 242, 1, 66, 8, 192, 1, 0, 0, 242, 1, 64, 104, 32, 1, 0,\n    0, 242, 1, 70, 72, 64, 1, 0, 0, 242, 1, 68, 154, 192, 0, 0, 37, 34, 64, 3, 8, 32, 0, 0, 5, 58,\n    208, 4, 40, 64, 0, 0, 5, 50, 208, 4, 72, 160, 0, 0, 37, 42, 208, 4, 2, 0, 6, 40, 0, 0, 0, 0,\n    0, 0, 0, 0, 2, 0, 1, 41, 0, 0, 0, 0, 5, 0, 2, 0\n};\n\nstatic const Uint8 GLES2_FragmentTegra_Additive_TextureSrc_[] = {\n    161, 234, 193, 234, 47, 109, 131, 38, 6, 0, 1, 0, 5, 0, 0, 0, 17, 0, 0, 0, 1, 0, 0, 0, 73, 0,\n    0, 0, 34, 0, 0, 0, 36, 0, 0, 0, 2, 0, 0, 0, 82, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,\n    82, 0, 0, 0, 1, 0, 0, 0, 20, 0, 0, 0, 6, 0, 0, 0, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0,\n    0, 0, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 87, 0, 0, 0, 2, 0, 0, 0, 56, 0, 0, 0,\n    13, 0, 0, 0, 101, 0, 0, 0, 4, 0, 0, 0, 16, 0, 0, 0, 14, 0, 0, 0, 105, 0, 0, 0, 1, 0, 0, 0, 4,\n    0, 0, 0, 22, 0, 0, 0, 106, 0, 0, 0, 8, 0, 0, 0, 32, 0, 0, 0, 23, 0, 0, 0, 114, 0, 0, 0, 1, 0,\n    0, 0, 4, 0, 0, 0, 15, 0, 0, 0, 115, 0, 0, 0, 1, 0, 0, 0, 80, 0, 0, 0, 17, 0, 0, 0, 135, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 0, 0, 135, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 135,\n    0, 0, 0, 176, 0, 0, 0, 176, 0, 0, 0, 20, 0, 0, 0, 135, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21,\n    0, 0, 0, 135, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 109, 97, 110, 70, 73, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 118, 95, 116, 101, 120, 67, 111, 111, 114, 100, 0, 117, 95, 109, 111, 100, 117, 108,\n    97, 116, 105, 111, 110, 0, 117, 95, 116, 101, 120, 116, 117, 114, 101, 0, 0, 0, 0, 0, 0, 0,\n    2, 0, 0, 0, 0, 0, 0, 0, 220, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 82, 139, 0, 0, 1, 0, 0, 0, 1,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 94, 139, 0, 0, 1, 0, 0, 0, 1, 0, 0,\n    0, 2, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 5, 48, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 1, 22, 22, 17, 241, 0, 0, 0, 240, 0, 0, 0, 240, 0, 0, 0, 240, 0, 0, 0, 240, 0, 0, 0, 240,\n    0, 0, 0, 240, 0, 0, 0, 240, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 7, 0, 0, 0, 2, 0, 0, 0, 1, 0,\n    0, 0, 2, 0, 0, 0, 21, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 16, 0, 0, 0, 16, 0, 0,\n    0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 65, 82, 50, 48, 45, 66, 73, 78, 1, 0, 0, 0, 2, 0, 0, 0, 2, 0, 65, 37, 0, 0, 0, 0, 8, 0,\n    129, 0, 1, 0, 0, 21, 0, 0, 0, 0, 2, 0, 1, 38, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 4, 38, 186, 81,\n    78, 16, 2, 1, 0, 0, 2, 0, 1, 39, 0, 4, 0, 0, 0, 0, 0, 0, 2, 0, 1, 40, 1, 0, 0, 0, 5, 0, 0, 0,\n    16, 0, 4, 40, 40, 160, 1, 0, 0, 242, 1, 66, 104, 32, 1, 0, 0, 242, 1, 70, 8, 192, 1, 0, 0, 242,\n    1, 64, 72, 64, 1, 0, 0, 242, 1, 68, 136, 192, 0, 0, 0, 26, 64, 4, 136, 32, 0, 0, 0, 2, 64, 7,\n    136, 64, 0, 0, 0, 10, 64, 6, 136, 160, 0, 0, 0, 18, 64, 5, 2, 0, 6, 40, 0, 0, 0, 0, 0, 0, 0,\n    0, 2, 0, 1, 41, 0, 0, 0, 0, 5, 0, 2, 0\n};\n\nstatic const Uint8 GLES2_FragmentTegra_Modulated_TextureSrc_[] = {\n    75, 132, 201, 227, 47, 109, 131, 38, 6, 0, 1, 0, 5, 0, 0, 0, 17, 0, 0, 0, 1, 0, 0, 0, 73, 0,\n    0, 0, 34, 0, 0, 0, 36, 0, 0, 0, 2, 0, 0, 0, 82, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,\n    82, 0, 0, 0, 1, 0, 0, 0, 20, 0, 0, 0, 6, 0, 0, 0, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0,\n    0, 0, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 87, 0, 0, 0, 2, 0, 0, 0, 56, 0, 0, 0,\n    13, 0, 0, 0, 101, 0, 0, 0, 4, 0, 0, 0, 16, 0, 0, 0, 14, 0, 0, 0, 105, 0, 0, 0, 1, 0, 0, 0, 4,\n    0, 0, 0, 22, 0, 0, 0, 106, 0, 0, 0, 8, 0, 0, 0, 32, 0, 0, 0, 23, 0, 0, 0, 114, 0, 0, 0, 1, 0,\n    0, 0, 4, 0, 0, 0, 15, 0, 0, 0, 115, 0, 0, 0, 1, 0, 0, 0, 80, 0, 0, 0, 17, 0, 0, 0, 135, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 0, 0, 135, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 135,\n    0, 0, 0, 176, 0, 0, 0, 176, 0, 0, 0, 20, 0, 0, 0, 135, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21,\n    0, 0, 0, 135, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 109, 97, 110, 70, 73, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 118, 95, 116, 101, 120, 67, 111, 111, 114, 100, 0, 117, 95, 109, 111, 100, 117, 108,\n    97, 116, 105, 111, 110, 0, 117, 95, 116, 101, 120, 116, 117, 114, 101, 0, 0, 0, 0, 0, 0, 0,\n    2, 0, 0, 0, 0, 0, 0, 0, 220, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 82, 139, 0, 0, 1, 0, 0, 0, 1,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 94, 139, 0, 0, 1, 0, 0, 0, 1, 0, 0,\n    0, 2, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 5, 48, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 1, 32, 32, 17, 241, 0, 0, 0, 240, 0, 0, 0, 240, 0, 0, 0, 240, 0, 0, 0, 240, 0, 0, 0, 240,\n    0, 0, 0, 240, 0, 0, 0, 240, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 7, 0, 0, 0, 2, 0, 0, 0, 1, 0,\n    0, 0, 2, 0, 0, 0, 21, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 16, 0, 0, 0, 16, 0, 0,\n    0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 65, 82, 50, 48, 45, 66, 73, 78, 1, 0, 0, 0, 2, 0, 0, 0, 2, 0, 65, 37, 0, 0, 0, 0, 8, 0,\n    129, 0, 1, 0, 0, 21, 0, 0, 0, 0, 2, 0, 1, 38, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 4, 38, 186, 81,\n    78, 16, 2, 1, 0, 0, 2, 0, 1, 39, 0, 4, 0, 0, 0, 0, 0, 0, 2, 0, 1, 40, 1, 0, 0, 0, 5, 0, 0, 0,\n    16, 0, 4, 40, 40, 160, 1, 0, 0, 242, 1, 66, 8, 192, 1, 0, 0, 242, 1, 64, 104, 32, 1, 0, 0, 242,\n    1, 70, 72, 64, 1, 0, 0, 242, 1, 68, 104, 192, 0, 0, 0, 242, 65, 4, 232, 32, 0, 0, 0, 242, 65,\n    0, 40, 64, 0, 0, 0, 242, 65, 6, 72, 160, 0, 0, 0, 242, 65, 5, 2, 0, 6, 40, 0, 0, 0, 0, 0, 0,\n    0, 0, 2, 0, 1, 41, 0, 0, 0, 0, 5, 0, 2, 0\n};\n\nstatic const GLES2_ShaderInstance GLES2_VertexTegra_Default = {\n    GL_VERTEX_SHADER,\n    GL_NVIDIA_PLATFORM_BINARY_NV,\n    sizeof(GLES2_VertexTegra_Default_),\n    GLES2_VertexTegra_Default_\n};\n\nstatic const GLES2_ShaderInstance GLES2_FragmentTegra_None_SolidSrc = {\n    GL_FRAGMENT_SHADER,\n    GL_NVIDIA_PLATFORM_BINARY_NV,\n    sizeof(GLES2_FragmentTegra_None_SolidSrc_),\n    GLES2_FragmentTegra_None_SolidSrc_\n};\n\nstatic const GLES2_ShaderInstance GLES2_FragmentTegra_Alpha_SolidSrc = {\n    GL_FRAGMENT_SHADER,\n    GL_NVIDIA_PLATFORM_BINARY_NV,\n    sizeof(GLES2_FragmentTegra_Alpha_SolidSrc_),\n    GLES2_FragmentTegra_Alpha_SolidSrc_\n};\n\nstatic const GLES2_ShaderInstance GLES2_FragmentTegra_Additive_SolidSrc = {\n    GL_FRAGMENT_SHADER,\n    GL_NVIDIA_PLATFORM_BINARY_NV,\n    sizeof(GLES2_FragmentTegra_Additive_SolidSrc_),\n    GLES2_FragmentTegra_Additive_SolidSrc_\n};\n\nstatic const GLES2_ShaderInstance GLES2_FragmentTegra_Modulated_SolidSrc = {\n    GL_FRAGMENT_SHADER,\n    GL_NVIDIA_PLATFORM_BINARY_NV,\n    sizeof(GLES2_FragmentTegra_Modulated_SolidSrc_),\n    GLES2_FragmentTegra_Modulated_SolidSrc_\n};\n\nstatic const GLES2_ShaderInstance GLES2_FragmentTegra_None_TextureSrc = {\n    GL_FRAGMENT_SHADER,\n    GL_NVIDIA_PLATFORM_BINARY_NV,\n    sizeof(GLES2_FragmentTegra_None_TextureSrc_),\n    GLES2_FragmentTegra_None_TextureSrc_\n};\n\nstatic const GLES2_ShaderInstance GLES2_FragmentTegra_Alpha_TextureSrc = {\n    GL_FRAGMENT_SHADER,\n    GL_NVIDIA_PLATFORM_BINARY_NV,\n    sizeof(GLES2_FragmentTegra_Alpha_TextureSrc_),\n    GLES2_FragmentTegra_Alpha_TextureSrc_\n};\n\nstatic const GLES2_ShaderInstance GLES2_FragmentTegra_Additive_TextureSrc = {\n    GL_FRAGMENT_SHADER,\n    GL_NVIDIA_PLATFORM_BINARY_NV,\n    sizeof(GLES2_FragmentTegra_Additive_TextureSrc_),\n    GLES2_FragmentTegra_Additive_TextureSrc_\n};\n\nstatic const GLES2_ShaderInstance GLES2_FragmentTegra_Modulated_TextureSrc = {\n    GL_FRAGMENT_SHADER,\n    GL_NVIDIA_PLATFORM_BINARY_NV,\n    sizeof(GLES2_FragmentTegra_Modulated_TextureSrc_),\n    GLES2_FragmentTegra_Modulated_TextureSrc_\n};\n\n#endif /* GLES2_INCLUDE_NVIDIA_SHADERS */\n\n/*************************************************************************************************\n * Vertex/fragment shader definitions                                                            *\n *************************************************************************************************/\n\nstatic GLES2_Shader GLES2_VertexShader_Default = {\n#if GLES2_INCLUDE_NVIDIA_SHADERS\n    2,\n#else\n    1,\n#endif\n    {\n#if GLES2_INCLUDE_NVIDIA_SHADERS\n        &GLES2_VertexTegra_Default,\n#endif\n        &GLES2_VertexSrc_Default\n    }\n};\n\nstatic GLES2_Shader GLES2_FragmentShader_None_SolidSrc = {\n#if GLES2_INCLUDE_NVIDIA_SHADERS\n    2,\n#else\n    1,\n#endif\n    {\n#if GLES2_INCLUDE_NVIDIA_SHADERS\n        &GLES2_FragmentTegra_None_SolidSrc,\n#endif\n        &GLES2_FragmentSrc_SolidSrc\n    }\n};\n\nstatic GLES2_Shader GLES2_FragmentShader_Alpha_SolidSrc = {\n#if GLES2_INCLUDE_NVIDIA_SHADERS\n    2,\n#else\n    1,\n#endif\n    {\n#if GLES2_INCLUDE_NVIDIA_SHADERS\n        &GLES2_FragmentTegra_Alpha_SolidSrc,\n#endif\n        &GLES2_FragmentSrc_SolidSrc\n    }\n};\n\nstatic GLES2_Shader GLES2_FragmentShader_Additive_SolidSrc = {\n#if GLES2_INCLUDE_NVIDIA_SHADERS\n    2,\n#else\n    1,\n#endif\n    {\n#if GLES2_INCLUDE_NVIDIA_SHADERS\n        &GLES2_FragmentTegra_Additive_SolidSrc,\n#endif\n        &GLES2_FragmentSrc_SolidSrc\n    }\n};\n\nstatic GLES2_Shader GLES2_FragmentShader_Modulated_SolidSrc = {\n#if GLES2_INCLUDE_NVIDIA_SHADERS\n    2,\n#else\n    1,\n#endif\n    {\n#if GLES2_INCLUDE_NVIDIA_SHADERS\n        &GLES2_FragmentTegra_Modulated_SolidSrc,\n#endif\n        &GLES2_FragmentSrc_SolidSrc\n    }\n};\n\nstatic GLES2_Shader GLES2_FragmentShader_None_TextureABGRSrc = {\n#if GLES2_INCLUDE_NVIDIA_SHADERS\n    2,\n#else\n    1,\n#endif\n    {\n#if GLES2_INCLUDE_NVIDIA_SHADERS\n        &GLES2_FragmentTegra_None_TextureSrc,\n#endif\n        &GLES2_FragmentSrc_TextureABGRSrc\n    }\n};\n\nstatic GLES2_Shader GLES2_FragmentShader_Alpha_TextureABGRSrc = {\n#if GLES2_INCLUDE_NVIDIA_SHADERS\n    2,\n#else\n    1,\n#endif\n    {\n#if GLES2_INCLUDE_NVIDIA_SHADERS\n        &GLES2_FragmentTegra_Alpha_TextureSrc,\n#endif\n        &GLES2_FragmentSrc_TextureABGRSrc\n    }\n};\n\nstatic GLES2_Shader GLES2_FragmentShader_Additive_TextureABGRSrc = {\n#if GLES2_INCLUDE_NVIDIA_SHADERS\n    2,\n#else\n    1,\n#endif\n    {\n#if GLES2_INCLUDE_NVIDIA_SHADERS\n        &GLES2_FragmentTegra_Additive_TextureSrc,\n#endif\n        &GLES2_FragmentSrc_TextureABGRSrc\n    }\n};\n\nstatic GLES2_Shader GLES2_FragmentShader_Modulated_TextureABGRSrc = {\n#if GLES2_INCLUDE_NVIDIA_SHADERS\n    2,\n#else\n    1,\n#endif\n    {\n#if GLES2_INCLUDE_NVIDIA_SHADERS\n        &GLES2_FragmentTegra_Modulated_TextureSrc,\n#endif\n        &GLES2_FragmentSrc_TextureABGRSrc\n    }\n};\n\nstatic GLES2_Shader GLES2_FragmentShader_None_TextureARGBSrc = {\n    1,\n    {\n        &GLES2_FragmentSrc_TextureARGBSrc\n    }\n};\n\nstatic GLES2_Shader GLES2_FragmentShader_Alpha_TextureARGBSrc = {\n    1,\n    {\n        &GLES2_FragmentSrc_TextureARGBSrc\n    }\n};\n\nstatic GLES2_Shader GLES2_FragmentShader_Additive_TextureARGBSrc = {\n    1,\n    {\n        &GLES2_FragmentSrc_TextureARGBSrc\n    }\n};\n\nstatic GLES2_Shader GLES2_FragmentShader_Modulated_TextureARGBSrc = {\n    1,\n    {\n        &GLES2_FragmentSrc_TextureARGBSrc\n    }\n};\n\nstatic GLES2_Shader GLES2_FragmentShader_None_TextureRGBSrc = {\n    1,\n    {\n        &GLES2_FragmentSrc_TextureRGBSrc\n    }\n};\n\nstatic GLES2_Shader GLES2_FragmentShader_Alpha_TextureRGBSrc = {\n    1,\n    {\n        &GLES2_FragmentSrc_TextureRGBSrc\n    }\n};\n\nstatic GLES2_Shader GLES2_FragmentShader_Additive_TextureRGBSrc = {\n    1,\n    {\n        &GLES2_FragmentSrc_TextureRGBSrc\n    }\n};\n\nstatic GLES2_Shader GLES2_FragmentShader_Modulated_TextureRGBSrc = {\n    1,\n    {\n        &GLES2_FragmentSrc_TextureRGBSrc\n    }\n};\n\nstatic GLES2_Shader GLES2_FragmentShader_None_TextureBGRSrc = {\n    1,\n    {\n        &GLES2_FragmentSrc_TextureBGRSrc\n    }\n};\n\nstatic GLES2_Shader GLES2_FragmentShader_Alpha_TextureBGRSrc = {\n    1,\n    {\n        &GLES2_FragmentSrc_TextureBGRSrc\n    }\n};\n\nstatic GLES2_Shader GLES2_FragmentShader_Additive_TextureBGRSrc = {\n    1,\n    {\n        &GLES2_FragmentSrc_TextureBGRSrc\n    }\n};\n\nstatic GLES2_Shader GLES2_FragmentShader_Modulated_TextureBGRSrc = {\n    1,\n    {\n        &GLES2_FragmentSrc_TextureBGRSrc\n    }\n};\n\nstatic GLES2_Shader GLES2_FragmentShader_TextureYUVSrc = {\n    1,\n    {\n        &GLES2_FragmentSrc_TextureYUVSrc\n    }\n};\n\nstatic GLES2_Shader GLES2_FragmentShader_TextureNV12Src = {\n    1,\n    {\n        &GLES2_FragmentSrc_TextureNV12Src\n    }\n};\n\nstatic GLES2_Shader GLES2_FragmentShader_TextureNV21Src = {\n    1,\n    {\n        &GLES2_FragmentSrc_TextureNV21Src\n    }\n};\n\n\n/*************************************************************************************************\n * Shader selector                                                                               *\n *************************************************************************************************/\n\nconst GLES2_Shader *GLES2_GetShader(GLES2_ShaderType type, SDL_BlendMode blendMode)\n{\n    switch (type)\n    {\n    case GLES2_SHADER_VERTEX_DEFAULT:\n        return &GLES2_VertexShader_Default;\n    case GLES2_SHADER_FRAGMENT_SOLID_SRC:\n    switch (blendMode)\n    {\n    case SDL_BLENDMODE_NONE:\n        return &GLES2_FragmentShader_None_SolidSrc;\n    case SDL_BLENDMODE_BLEND:\n        return &GLES2_FragmentShader_Alpha_SolidSrc;\n    case SDL_BLENDMODE_ADD:\n        return &GLES2_FragmentShader_Additive_SolidSrc;\n    case SDL_BLENDMODE_MOD:\n        return &GLES2_FragmentShader_Modulated_SolidSrc;\n    default:\n        return NULL;\n    }\n    case GLES2_SHADER_FRAGMENT_TEXTURE_ABGR_SRC:\n        switch (blendMode)\n    {\n        case SDL_BLENDMODE_NONE:\n            return &GLES2_FragmentShader_None_TextureABGRSrc;\n        case SDL_BLENDMODE_BLEND:\n            return &GLES2_FragmentShader_Alpha_TextureABGRSrc;\n        case SDL_BLENDMODE_ADD:\n            return &GLES2_FragmentShader_Additive_TextureABGRSrc;\n        case SDL_BLENDMODE_MOD:\n            return &GLES2_FragmentShader_Modulated_TextureABGRSrc;\n        default:\n            return NULL;\n    }\n    case GLES2_SHADER_FRAGMENT_TEXTURE_ARGB_SRC:\n        switch (blendMode)\n    {\n        case SDL_BLENDMODE_NONE:\n            return &GLES2_FragmentShader_None_TextureARGBSrc;\n        case SDL_BLENDMODE_BLEND:\n            return &GLES2_FragmentShader_Alpha_TextureARGBSrc;\n        case SDL_BLENDMODE_ADD:\n            return &GLES2_FragmentShader_Additive_TextureARGBSrc;\n        case SDL_BLENDMODE_MOD:\n            return &GLES2_FragmentShader_Modulated_TextureARGBSrc;\n        default:\n            return NULL;\n    }\n\n    case GLES2_SHADER_FRAGMENT_TEXTURE_RGB_SRC:\n        switch (blendMode)\n    {\n        case SDL_BLENDMODE_NONE:\n            return &GLES2_FragmentShader_None_TextureRGBSrc;\n        case SDL_BLENDMODE_BLEND:\n            return &GLES2_FragmentShader_Alpha_TextureRGBSrc;\n        case SDL_BLENDMODE_ADD:\n            return &GLES2_FragmentShader_Additive_TextureRGBSrc;\n        case SDL_BLENDMODE_MOD:\n            return &GLES2_FragmentShader_Modulated_TextureRGBSrc;\n        default:\n            return NULL;\n    }\n\n    case GLES2_SHADER_FRAGMENT_TEXTURE_BGR_SRC:\n        switch (blendMode)\n    {\n        case SDL_BLENDMODE_NONE:\n            return &GLES2_FragmentShader_None_TextureBGRSrc;\n        case SDL_BLENDMODE_BLEND:\n            return &GLES2_FragmentShader_Alpha_TextureBGRSrc;\n        case SDL_BLENDMODE_ADD:\n            return &GLES2_FragmentShader_Additive_TextureBGRSrc;\n        case SDL_BLENDMODE_MOD:\n            return &GLES2_FragmentShader_Modulated_TextureBGRSrc;\n        default:\n            return NULL;\n    }\n    \n    case GLES2_SHADER_FRAGMENT_TEXTURE_YUV_SRC:\n    {\n        return &GLES2_FragmentShader_TextureYUVSrc;\n    }\n\n    case GLES2_SHADER_FRAGMENT_TEXTURE_NV12_SRC:\n    {\n        return &GLES2_FragmentShader_TextureNV12Src;\n    }\n\n    case GLES2_SHADER_FRAGMENT_TEXTURE_NV21_SRC:\n    {\n        return &GLES2_FragmentShader_TextureNV21Src;\n    }\n\n    default:\n        return NULL;\n    }\n}\n\n#endif /* SDL_VIDEO_RENDER_OGL_ES2 && !SDL_RENDER_DISABLED */\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../../SDL_internal.h\"\n\n#if !SDL_RENDER_DISABLED\n\n#include \"../SDL_sysrender.h\"\n#include \"SDL_render_sw_c.h\"\n#include \"SDL_hints.h\"\n\n#include \"SDL_draw.h\"\n#include \"SDL_blendfillrect.h\"\n#include \"SDL_blendline.h\"\n#include \"SDL_blendpoint.h\"\n#include \"SDL_drawline.h\"\n#include \"SDL_drawpoint.h\"\n#include \"SDL_rotate.h\"\n\n/* SDL surface based renderer implementation */\n\nstatic SDL_Renderer *SW_CreateRenderer(SDL_Window * window, Uint32 flags);\nstatic void SW_WindowEvent(SDL_Renderer * renderer,\n                           const SDL_WindowEvent *event);\nstatic int SW_GetOutputSize(SDL_Renderer * renderer, int *w, int *h);\nstatic int SW_CreateTexture(SDL_Renderer * renderer, SDL_Texture * texture);\nstatic int SW_SetTextureColorMod(SDL_Renderer * renderer,\n                                 SDL_Texture * texture);\nstatic int SW_SetTextureAlphaMod(SDL_Renderer * renderer,\n                                 SDL_Texture * texture);\nstatic int SW_SetTextureBlendMode(SDL_Renderer * renderer,\n                                  SDL_Texture * texture);\nstatic int SW_UpdateTexture(SDL_Renderer * renderer, SDL_Texture * texture,\n                            const SDL_Rect * rect, const void *pixels,\n                            int pitch);\nstatic int SW_LockTexture(SDL_Renderer * renderer, SDL_Texture * texture,\n                          const SDL_Rect * rect, void **pixels, int *pitch);\nstatic void SW_UnlockTexture(SDL_Renderer * renderer, SDL_Texture * texture);\nstatic int SW_SetRenderTarget(SDL_Renderer * renderer, SDL_Texture * texture);\nstatic int SW_UpdateViewport(SDL_Renderer * renderer);\nstatic int SW_UpdateClipRect(SDL_Renderer * renderer);\nstatic int SW_RenderClear(SDL_Renderer * renderer);\nstatic int SW_RenderDrawPoints(SDL_Renderer * renderer,\n                               const SDL_FPoint * points, int count);\nstatic int SW_RenderDrawLines(SDL_Renderer * renderer,\n                              const SDL_FPoint * points, int count);\nstatic int SW_RenderFillRects(SDL_Renderer * renderer,\n                              const SDL_FRect * rects, int count);\nstatic int SW_RenderCopy(SDL_Renderer * renderer, SDL_Texture * texture,\n                         const SDL_Rect * srcrect, const SDL_FRect * dstrect);\nstatic int SW_RenderCopyEx(SDL_Renderer * renderer, SDL_Texture * texture,\n                          const SDL_Rect * srcrect, const SDL_FRect * dstrect,\n                          const double angle, const SDL_FPoint * center, const SDL_RendererFlip flip);\nstatic int SW_RenderReadPixels(SDL_Renderer * renderer, const SDL_Rect * rect,\n                               Uint32 format, void * pixels, int pitch);\nstatic void SW_RenderPresent(SDL_Renderer * renderer);\nstatic void SW_DestroyTexture(SDL_Renderer * renderer, SDL_Texture * texture);\nstatic void SW_DestroyRenderer(SDL_Renderer * renderer);\n\n\nSDL_RenderDriver SW_RenderDriver = {\n    SW_CreateRenderer,\n    {\n     \"software\",\n     SDL_RENDERER_SOFTWARE | SDL_RENDERER_TARGETTEXTURE,\n     8,\n     {\n      SDL_PIXELFORMAT_ARGB8888,\n      SDL_PIXELFORMAT_ABGR8888,\n      SDL_PIXELFORMAT_RGBA8888,\n      SDL_PIXELFORMAT_BGRA8888,\n      SDL_PIXELFORMAT_RGB888,\n      SDL_PIXELFORMAT_BGR888,\n      SDL_PIXELFORMAT_RGB565,\n      SDL_PIXELFORMAT_RGB555\n     },\n     0,\n     0}\n};\n\ntypedef struct\n{\n    SDL_Surface *surface;\n    SDL_Surface *window;\n} SW_RenderData;\n\n\nstatic SDL_Surface *\nSW_ActivateRenderer(SDL_Renderer * renderer)\n{\n    SW_RenderData *data = (SW_RenderData *) renderer->driverdata;\n\n    if (!data->surface) {\n        data->surface = data->window;\n    }\n    if (!data->surface) {\n        SDL_Surface *surface = SDL_GetWindowSurface(renderer->window);\n        if (surface) {\n            data->surface = data->window = surface;\n\n            SW_UpdateViewport(renderer);\n            SW_UpdateClipRect(renderer);\n        }\n    }\n    return data->surface;\n}\n\nSDL_Renderer *\nSW_CreateRendererForSurface(SDL_Surface * surface)\n{\n    SDL_Renderer *renderer;\n    SW_RenderData *data;\n\n    if (!surface) {\n        SDL_SetError(\"Can't create renderer for NULL surface\");\n        return NULL;\n    }\n\n    renderer = (SDL_Renderer *) SDL_calloc(1, sizeof(*renderer));\n    if (!renderer) {\n        SDL_OutOfMemory();\n        return NULL;\n    }\n\n    data = (SW_RenderData *) SDL_calloc(1, sizeof(*data));\n    if (!data) {\n        SW_DestroyRenderer(renderer);\n        SDL_OutOfMemory();\n        return NULL;\n    }\n    data->surface = surface;\n    data->window = surface;\n\n    renderer->WindowEvent = SW_WindowEvent;\n    renderer->GetOutputSize = SW_GetOutputSize;\n    renderer->CreateTexture = SW_CreateTexture;\n    renderer->SetTextureColorMod = SW_SetTextureColorMod;\n    renderer->SetTextureAlphaMod = SW_SetTextureAlphaMod;\n    renderer->SetTextureBlendMode = SW_SetTextureBlendMode;\n    renderer->UpdateTexture = SW_UpdateTexture;\n    renderer->LockTexture = SW_LockTexture;\n    renderer->UnlockTexture = SW_UnlockTexture;\n    renderer->SetRenderTarget = SW_SetRenderTarget;\n    renderer->UpdateViewport = SW_UpdateViewport;\n    renderer->UpdateClipRect = SW_UpdateClipRect;\n    renderer->RenderClear = SW_RenderClear;\n    renderer->RenderDrawPoints = SW_RenderDrawPoints;\n    renderer->RenderDrawLines = SW_RenderDrawLines;\n    renderer->RenderFillRects = SW_RenderFillRects;\n    renderer->RenderCopy = SW_RenderCopy;\n    renderer->RenderCopyEx = SW_RenderCopyEx;\n    renderer->RenderReadPixels = SW_RenderReadPixels;\n    renderer->RenderPresent = SW_RenderPresent;\n    renderer->DestroyTexture = SW_DestroyTexture;\n    renderer->DestroyRenderer = SW_DestroyRenderer;\n    renderer->info = SW_RenderDriver.info;\n    renderer->driverdata = data;\n\n    SW_ActivateRenderer(renderer);\n\n    return renderer;\n}\n\nSDL_Renderer *\nSW_CreateRenderer(SDL_Window * window, Uint32 flags)\n{\n    SDL_Surface *surface;\n\n    surface = SDL_GetWindowSurface(window);\n    if (!surface) {\n        return NULL;\n    }\n    return SW_CreateRendererForSurface(surface);\n}\n\nstatic void\nSW_WindowEvent(SDL_Renderer * renderer, const SDL_WindowEvent *event)\n{\n    SW_RenderData *data = (SW_RenderData *) renderer->driverdata;\n\n    if (event->event == SDL_WINDOWEVENT_SIZE_CHANGED) {\n        data->surface = NULL;\n        data->window = NULL;\n    }\n}\n\nstatic int\nSW_GetOutputSize(SDL_Renderer * renderer, int *w, int *h)\n{\n    SDL_Surface *surface = SW_ActivateRenderer(renderer);\n\n    if (surface) {\n        if (w) {\n            *w = surface->w;\n        }\n        if (h) {\n            *h = surface->h;\n        }\n        return 0;\n    } else {\n        SDL_SetError(\"Software renderer doesn't have an output surface\");\n        return -1;\n    }\n}\n\nstatic int\nSW_CreateTexture(SDL_Renderer * renderer, SDL_Texture * texture)\n{\n    int bpp;\n    Uint32 Rmask, Gmask, Bmask, Amask;\n\n    if (!SDL_PixelFormatEnumToMasks\n        (texture->format, &bpp, &Rmask, &Gmask, &Bmask, &Amask)) {\n        return SDL_SetError(\"Unknown texture format\");\n    }\n\n    texture->driverdata =\n        SDL_CreateRGBSurface(0, texture->w, texture->h, bpp, Rmask, Gmask,\n                             Bmask, Amask);\n    SDL_SetSurfaceColorMod(texture->driverdata, texture->r, texture->g,\n                           texture->b);\n    SDL_SetSurfaceAlphaMod(texture->driverdata, texture->a);\n    SDL_SetSurfaceBlendMode(texture->driverdata, texture->blendMode);\n\n    if (texture->access == SDL_TEXTUREACCESS_STATIC) {\n        SDL_SetSurfaceRLE(texture->driverdata, 1);\n    }\n\n    if (!texture->driverdata) {\n        return -1;\n    }\n    return 0;\n}\n\nstatic int\nSW_SetTextureColorMod(SDL_Renderer * renderer, SDL_Texture * texture)\n{\n    SDL_Surface *surface = (SDL_Surface *) texture->driverdata;\n    return SDL_SetSurfaceColorMod(surface, texture->r, texture->g,\n                                  texture->b);\n}\n\nstatic int\nSW_SetTextureAlphaMod(SDL_Renderer * renderer, SDL_Texture * texture)\n{\n    SDL_Surface *surface = (SDL_Surface *) texture->driverdata;\n    return SDL_SetSurfaceAlphaMod(surface, texture->a);\n}\n\nstatic int\nSW_SetTextureBlendMode(SDL_Renderer * renderer, SDL_Texture * texture)\n{\n    SDL_Surface *surface = (SDL_Surface *) texture->driverdata;\n    return SDL_SetSurfaceBlendMode(surface, texture->blendMode);\n}\n\nstatic int\nSW_UpdateTexture(SDL_Renderer * renderer, SDL_Texture * texture,\n                 const SDL_Rect * rect, const void *pixels, int pitch)\n{\n    SDL_Surface *surface = (SDL_Surface *) texture->driverdata;\n    Uint8 *src, *dst;\n    int row;\n    size_t length;\n\n    if(SDL_MUSTLOCK(surface))\n        SDL_LockSurface(surface);\n    src = (Uint8 *) pixels;\n    dst = (Uint8 *) surface->pixels +\n                        rect->y * surface->pitch +\n                        rect->x * surface->format->BytesPerPixel;\n    length = rect->w * surface->format->BytesPerPixel;\n    for (row = 0; row < rect->h; ++row) {\n        SDL_memcpy(dst, src, length);\n        src += pitch;\n        dst += surface->pitch;\n    }\n    if(SDL_MUSTLOCK(surface))\n        SDL_UnlockSurface(surface);\n    return 0;\n}\n\nstatic int\nSW_LockTexture(SDL_Renderer * renderer, SDL_Texture * texture,\n               const SDL_Rect * rect, void **pixels, int *pitch)\n{\n    SDL_Surface *surface = (SDL_Surface *) texture->driverdata;\n\n    *pixels =\n        (void *) ((Uint8 *) surface->pixels + rect->y * surface->pitch +\n                  rect->x * surface->format->BytesPerPixel);\n    *pitch = surface->pitch;\n    return 0;\n}\n\nstatic void\nSW_UnlockTexture(SDL_Renderer * renderer, SDL_Texture * texture)\n{\n}\n\nstatic int\nSW_SetRenderTarget(SDL_Renderer * renderer, SDL_Texture * texture)\n{\n    SW_RenderData *data = (SW_RenderData *) renderer->driverdata;\n\n    if (texture ) {\n        data->surface = (SDL_Surface *) texture->driverdata;\n    } else {\n        data->surface = data->window;\n    }\n    return 0;\n}\n\nstatic int\nSW_UpdateViewport(SDL_Renderer * renderer)\n{\n    SW_RenderData *data = (SW_RenderData *) renderer->driverdata;\n    SDL_Surface *surface = data->surface;\n\n    if (!surface) {\n        /* We'll update the viewport after we recreate the surface */\n        return 0;\n    }\n\n    SDL_SetClipRect(data->surface, &renderer->viewport);\n    return 0;\n}\n\nstatic int\nSW_UpdateClipRect(SDL_Renderer * renderer)\n{\n    SW_RenderData *data = (SW_RenderData *) renderer->driverdata;\n    SDL_Surface *surface = data->surface;\n    if (surface) {\n        if (renderer->clipping_enabled) {\n            SDL_SetClipRect(surface, &renderer->clip_rect);\n        } else {\n            SDL_SetClipRect(surface, NULL);\n        }\n    }\n    return 0;\n}\n\nstatic int\nSW_RenderClear(SDL_Renderer * renderer)\n{\n    SDL_Surface *surface = SW_ActivateRenderer(renderer);\n    Uint32 color;\n    SDL_Rect clip_rect;\n\n    if (!surface) {\n        return -1;\n    }\n\n    color = SDL_MapRGBA(surface->format,\n                        renderer->r, renderer->g, renderer->b, renderer->a);\n\n    /* By definition the clear ignores the clip rect */\n    clip_rect = surface->clip_rect;\n    SDL_SetClipRect(surface, NULL);\n    SDL_FillRect(surface, NULL, color);\n    SDL_SetClipRect(surface, &clip_rect);\n    return 0;\n}\n\nstatic int\nSW_RenderDrawPoints(SDL_Renderer * renderer, const SDL_FPoint * points,\n                    int count)\n{\n    SDL_Surface *surface = SW_ActivateRenderer(renderer);\n    SDL_Point *final_points;\n    int i, status;\n\n    if (!surface) {\n        return -1;\n    }\n\n    final_points = SDL_stack_alloc(SDL_Point, count);\n    if (!final_points) {\n        return SDL_OutOfMemory();\n    }\n    if (renderer->viewport.x || renderer->viewport.y) {\n        int x = renderer->viewport.x;\n        int y = renderer->viewport.y;\n\n        for (i = 0; i < count; ++i) {\n            final_points[i].x = (int)(x + points[i].x);\n            final_points[i].y = (int)(y + points[i].y);\n        }\n    } else {\n        for (i = 0; i < count; ++i) {\n            final_points[i].x = (int)points[i].x;\n            final_points[i].y = (int)points[i].y;\n        }\n    }\n\n    /* Draw the points! */\n    if (renderer->blendMode == SDL_BLENDMODE_NONE) {\n        Uint32 color = SDL_MapRGBA(surface->format,\n                                   renderer->r, renderer->g, renderer->b,\n                                   renderer->a);\n\n        status = SDL_DrawPoints(surface, final_points, count, color);\n    } else {\n        status = SDL_BlendPoints(surface, final_points, count,\n                                renderer->blendMode,\n                                renderer->r, renderer->g, renderer->b,\n                                renderer->a);\n    }\n    SDL_stack_free(final_points);\n\n    return status;\n}\n\nstatic int\nSW_RenderDrawLines(SDL_Renderer * renderer, const SDL_FPoint * points,\n                   int count)\n{\n    SDL_Surface *surface = SW_ActivateRenderer(renderer);\n    SDL_Point *final_points;\n    int i, status;\n\n    if (!surface) {\n        return -1;\n    }\n\n    final_points = SDL_stack_alloc(SDL_Point, count);\n    if (!final_points) {\n        return SDL_OutOfMemory();\n    }\n    if (renderer->viewport.x || renderer->viewport.y) {\n        int x = renderer->viewport.x;\n        int y = renderer->viewport.y;\n\n        for (i = 0; i < count; ++i) {\n            final_points[i].x = (int)(x + points[i].x);\n            final_points[i].y = (int)(y + points[i].y);\n        }\n    } else {\n        for (i = 0; i < count; ++i) {\n            final_points[i].x = (int)points[i].x;\n            final_points[i].y = (int)points[i].y;\n        }\n    }\n\n    /* Draw the lines! */\n    if (renderer->blendMode == SDL_BLENDMODE_NONE) {\n        Uint32 color = SDL_MapRGBA(surface->format,\n                                   renderer->r, renderer->g, renderer->b,\n                                   renderer->a);\n\n        status = SDL_DrawLines(surface, final_points, count, color);\n    } else {\n        status = SDL_BlendLines(surface, final_points, count,\n                                renderer->blendMode,\n                                renderer->r, renderer->g, renderer->b,\n                                renderer->a);\n    }\n    SDL_stack_free(final_points);\n\n    return status;\n}\n\nstatic int\nSW_RenderFillRects(SDL_Renderer * renderer, const SDL_FRect * rects, int count)\n{\n    SDL_Surface *surface = SW_ActivateRenderer(renderer);\n    SDL_Rect *final_rects;\n    int i, status;\n\n    if (!surface) {\n        return -1;\n    }\n\n    final_rects = SDL_stack_alloc(SDL_Rect, count);\n    if (!final_rects) {\n        return SDL_OutOfMemory();\n    }\n    if (renderer->viewport.x || renderer->viewport.y) {\n        int x = renderer->viewport.x;\n        int y = renderer->viewport.y;\n\n        for (i = 0; i < count; ++i) {\n            final_rects[i].x = (int)(x + rects[i].x);\n            final_rects[i].y = (int)(y + rects[i].y);\n            final_rects[i].w = SDL_max((int)rects[i].w, 1);\n            final_rects[i].h = SDL_max((int)rects[i].h, 1);\n        }\n    } else {\n        for (i = 0; i < count; ++i) {\n            final_rects[i].x = (int)rects[i].x;\n            final_rects[i].y = (int)rects[i].y;\n            final_rects[i].w = SDL_max((int)rects[i].w, 1);\n            final_rects[i].h = SDL_max((int)rects[i].h, 1);\n        }\n    }\n\n    if (renderer->blendMode == SDL_BLENDMODE_NONE) {\n        Uint32 color = SDL_MapRGBA(surface->format,\n                                   renderer->r, renderer->g, renderer->b,\n                                   renderer->a);\n        status = SDL_FillRects(surface, final_rects, count, color);\n    } else {\n        status = SDL_BlendFillRects(surface, final_rects, count,\n                                    renderer->blendMode,\n                                    renderer->r, renderer->g, renderer->b,\n                                    renderer->a);\n    }\n    SDL_stack_free(final_rects);\n\n    return status;\n}\n\nstatic int\nSW_RenderCopy(SDL_Renderer * renderer, SDL_Texture * texture,\n              const SDL_Rect * srcrect, const SDL_FRect * dstrect)\n{\n    SDL_Surface *surface = SW_ActivateRenderer(renderer);\n    SDL_Surface *src = (SDL_Surface *) texture->driverdata;\n    SDL_Rect final_rect;\n\n    if (!surface) {\n        return -1;\n    }\n\n    if (renderer->viewport.x || renderer->viewport.y) {\n        final_rect.x = (int)(renderer->viewport.x + dstrect->x);\n        final_rect.y = (int)(renderer->viewport.y + dstrect->y);\n    } else {\n        final_rect.x = (int)dstrect->x;\n        final_rect.y = (int)dstrect->y;\n    }\n    final_rect.w = (int)dstrect->w;\n    final_rect.h = (int)dstrect->h;\n\n    if ( srcrect->w == final_rect.w && srcrect->h == final_rect.h ) {\n        return SDL_BlitSurface(src, srcrect, surface, &final_rect);\n    } else {\n        return SDL_BlitScaled(src, srcrect, surface, &final_rect);\n    }\n}\n\nstatic int\nGetScaleQuality(void)\n{\n    const char *hint = SDL_GetHint(SDL_HINT_RENDER_SCALE_QUALITY);\n\n    if (!hint || *hint == '0' || SDL_strcasecmp(hint, \"nearest\") == 0) {\n        return 0;\n    } else {\n        return 1;\n    }\n}\n\nstatic int\nSW_RenderCopyEx(SDL_Renderer * renderer, SDL_Texture * texture,\n                const SDL_Rect * srcrect, const SDL_FRect * dstrect,\n                const double angle, const SDL_FPoint * center, const SDL_RendererFlip flip)\n{\n    SDL_Surface *surface = SW_ActivateRenderer(renderer);\n    SDL_Surface *src = (SDL_Surface *) texture->driverdata;\n    SDL_Rect final_rect, tmp_rect;\n    SDL_Surface *surface_rotated, *surface_scaled;\n    Uint32 colorkey;\n    int retval, dstwidth, dstheight, abscenterx, abscentery;\n    double cangle, sangle, px, py, p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y;\n\n    if (!surface) {\n        return -1;\n    }\n\n    if (renderer->viewport.x || renderer->viewport.y) {\n        final_rect.x = (int)(renderer->viewport.x + dstrect->x);\n        final_rect.y = (int)(renderer->viewport.y + dstrect->y);\n    } else {\n        final_rect.x = (int)dstrect->x;\n        final_rect.y = (int)dstrect->y;\n    }\n    final_rect.w = (int)dstrect->w;\n    final_rect.h = (int)dstrect->h;\n\n    surface_scaled = SDL_CreateRGBSurface(SDL_SWSURFACE, final_rect.w, final_rect.h, src->format->BitsPerPixel,\n                                          src->format->Rmask, src->format->Gmask,\n                                          src->format->Bmask, src->format->Amask );\n    if (surface_scaled) {\n        SDL_GetColorKey(src, &colorkey);\n        SDL_SetColorKey(surface_scaled, SDL_TRUE, colorkey);\n        tmp_rect = final_rect;\n        tmp_rect.x = 0;\n        tmp_rect.y = 0;\n\n        retval = SDL_BlitScaled(src, srcrect, surface_scaled, &tmp_rect);\n        if (!retval) {\n            SDLgfx_rotozoomSurfaceSizeTrig(tmp_rect.w, tmp_rect.h, -angle, &dstwidth, &dstheight, &cangle, &sangle);\n            surface_rotated = SDLgfx_rotateSurface(surface_scaled, -angle, dstwidth/2, dstheight/2, GetScaleQuality(), flip & SDL_FLIP_HORIZONTAL, flip & SDL_FLIP_VERTICAL, dstwidth, dstheight, cangle, sangle);\n            if(surface_rotated) {\n                /* Find out where the new origin is by rotating the four final_rect points around the center and then taking the extremes */\n                abscenterx = final_rect.x + (int)center->x;\n                abscentery = final_rect.y + (int)center->y;\n                /* Compensate the angle inversion to match the behaviour of the other backends */\n                sangle = -sangle;\n\n                /* Top Left */\n                px = final_rect.x - abscenterx;\n                py = final_rect.y - abscentery;\n                p1x = px * cangle - py * sangle + abscenterx;\n                p1y = px * sangle + py * cangle + abscentery;\n\n                /* Top Right */\n                px = final_rect.x + final_rect.w - abscenterx;\n                py = final_rect.y - abscentery;\n                p2x = px * cangle - py * sangle + abscenterx;\n                p2y = px * sangle + py * cangle + abscentery;\n\n                /* Bottom Left */\n                px = final_rect.x - abscenterx;\n                py = final_rect.y + final_rect.h - abscentery;\n                p3x = px * cangle - py * sangle + abscenterx;\n                p3y = px * sangle + py * cangle + abscentery;\n\n                /* Bottom Right */\n                px = final_rect.x + final_rect.w - abscenterx;\n                py = final_rect.y + final_rect.h - abscentery;\n                p4x = px * cangle - py * sangle + abscenterx;\n                p4y = px * sangle + py * cangle + abscentery;\n\n                tmp_rect.x = (int)MIN(MIN(p1x, p2x), MIN(p3x, p4x));\n                tmp_rect.y = (int)MIN(MIN(p1y, p2y), MIN(p3y, p4y));\n                tmp_rect.w = dstwidth;\n                tmp_rect.h = dstheight;\n\n                retval = SDL_BlitSurface(surface_rotated, NULL, surface, &tmp_rect);\n                SDL_FreeSurface(surface_scaled);\n                SDL_FreeSurface(surface_rotated);\n                return retval;\n            }\n        }\n        return retval;\n    }\n\n    return -1;\n}\n\nstatic int\nSW_RenderReadPixels(SDL_Renderer * renderer, const SDL_Rect * rect,\n                    Uint32 format, void * pixels, int pitch)\n{\n    SDL_Surface *surface = SW_ActivateRenderer(renderer);\n    Uint32 src_format;\n    void *src_pixels;\n    SDL_Rect final_rect;\n\n    if (!surface) {\n        return -1;\n    }\n\n    if (renderer->viewport.x || renderer->viewport.y) {\n        final_rect.x = renderer->viewport.x + rect->x;\n        final_rect.y = renderer->viewport.y + rect->y;\n        final_rect.w = rect->w;\n        final_rect.h = rect->h;\n        rect = &final_rect;\n    }\n\n    if (rect->x < 0 || rect->x+rect->w > surface->w ||\n        rect->y < 0 || rect->y+rect->h > surface->h) {\n        return SDL_SetError(\"Tried to read outside of surface bounds\");\n    }\n\n    src_format = surface->format->format;\n    src_pixels = (void*)((Uint8 *) surface->pixels +\n                    rect->y * surface->pitch +\n                    rect->x * surface->format->BytesPerPixel);\n\n    return SDL_ConvertPixels(rect->w, rect->h,\n                             src_format, src_pixels, surface->pitch,\n                             format, pixels, pitch);\n}\n\nstatic void\nSW_RenderPresent(SDL_Renderer * renderer)\n{\n    SDL_Window *window = renderer->window;\n\n    if (window) {\n        SDL_UpdateWindowSurface(window);\n    }\n}\n\nstatic void\nSW_DestroyTexture(SDL_Renderer * renderer, SDL_Texture * texture)\n{\n    SDL_Surface *surface = (SDL_Surface *) texture->driverdata;\n\n    SDL_FreeSurface(surface);\n}\n\nstatic void\nSW_DestroyRenderer(SDL_Renderer * renderer)\n{\n    SW_RenderData *data = (SW_RenderData *) renderer->driverdata;\n\n    SDL_free(data);\n    SDL_free(renderer);\n}\n\n#endif /* !SDL_RENDER_DISABLED */\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n\nSDL_rotate.c: rotates 32bit or 8bit surfaces\n\nShamelessly stolen from SDL_gfx by Andreas Schiffler. Original copyright follows:\n\nCopyright (C) 2001-2011  Andreas Schiffler\n\nThis software is provided 'as-is', without any express or implied\nwarranty. In no event will the authors be held liable for any damages\narising from the use of this software.\n\nPermission is granted to anyone to use this software for any purpose,\nincluding commercial applications, and to alter it and redistribute it\nfreely, subject to the following restrictions:\n\n   1. The origin of this software must not be misrepresented; you must not\n   claim that you wrote the original software. If you use this software\n   in a product, an acknowledgment in the product documentation would be\n   appreciated but is not required.\n\n   2. Altered source versions must be plainly marked as such, and must not be\n   misrepresented as being the original software.\n\n   3. This notice may not be removed or altered from any source\n   distribution.\n\nAndreas Schiffler -- aschiffler at ferzkopp dot net\n\n*/\n#include \"../../SDL_internal.h\"\n\n#if defined(__WIN32__)\n#include \"../../core/windows/SDL_windows.h\"\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"SDL.h\"\n#include \"SDL_rotate.h\"\n\n/* ---- Internally used structures */\n\n/* !\n\\brief A 32 bit RGBA pixel.\n*/\ntypedef struct tColorRGBA {\n    Uint8 r;\n    Uint8 g;\n    Uint8 b;\n    Uint8 a;\n} tColorRGBA;\n\n/* !\n\\brief A 8bit Y/palette pixel.\n*/\ntypedef struct tColorY {\n    Uint8 y;\n} tColorY;\n\n/* !\n\\brief Returns maximum of two numbers a and b.\n*/\n#define MAX(a,b)    (((a) > (b)) ? (a) : (b))\n\n/* !\n\\brief Number of guard rows added to destination surfaces.\n\nThis is a simple but effective workaround for observed issues.\nThese rows allocate extra memory and are then hidden from the surface.\nRows are added to the end of destination surfaces when they are allocated.\nThis catches any potential overflows which seem to happen with\njust the right src image dimensions and scale/rotation and can lead\nto a situation where the program can segfault.\n*/\n#define GUARD_ROWS (2)\n\n/* !\n\\brief Lower limit of absolute zoom factor or rotation degrees.\n*/\n#define VALUE_LIMIT 0.001\n\n/* !\n\\brief Returns colorkey info for a surface\n*/\nstatic Uint32\n_colorkey(SDL_Surface *src)\n{\n    Uint32 key = 0;\n    SDL_GetColorKey(src, &key);\n    return key;\n}\n\n\n/* !\n\\brief Internal target surface sizing function for rotations with trig result return.\n\n\\param width The source surface width.\n\\param height The source surface height.\n\\param angle The angle to rotate in degrees.\n\\param dstwidth The calculated width of the destination surface.\n\\param dstheight The calculated height of the destination surface.\n\\param cangle The sine of the angle\n\\param sangle The cosine of the angle\n\n*/\nvoid\nSDLgfx_rotozoomSurfaceSizeTrig(int width, int height, double angle,\n                               int *dstwidth, int *dstheight,\n                               double *cangle, double *sangle)\n{\n    double x, y, cx, cy, sx, sy;\n    double radangle;\n    int dstwidthhalf, dstheighthalf;\n\n    /*\n    * Determine destination width and height by rotating a centered source box\n    */\n    radangle = angle * (M_PI / 180.0);\n    *sangle = SDL_sin(radangle);\n    *cangle = SDL_cos(radangle);\n    x = (double)(width / 2);\n    y = (double)(height / 2);\n    cx = *cangle * x;\n    cy = *cangle * y;\n    sx = *sangle * x;\n    sy = *sangle * y;\n\n    dstwidthhalf = MAX((int)\n        SDL_ceil(MAX(MAX(MAX(SDL_fabs(cx + sy), SDL_fabs(cx - sy)), SDL_fabs(-cx + sy)), SDL_fabs(-cx - sy))), 1);\n    dstheighthalf = MAX((int)\n        SDL_ceil(MAX(MAX(MAX(SDL_fabs(sx + cy), SDL_fabs(sx - cy)), SDL_fabs(-sx + cy)), SDL_fabs(-sx - cy))), 1);\n    *dstwidth = 2 * dstwidthhalf;\n    *dstheight = 2 * dstheighthalf;\n}\n\n\n/* !\n\\brief Internal 32 bit rotozoomer with optional anti-aliasing.\n\nRotates and zooms 32 bit RGBA/ABGR 'src' surface to 'dst' surface based on the control\nparameters by scanning the destination surface and applying optionally anti-aliasing\nby bilinear interpolation.\nAssumes src and dst surfaces are of 32 bit depth.\nAssumes dst surface was allocated with the correct dimensions.\n\n\\param src Source surface.\n\\param dst Destination surface.\n\\param cx Horizontal center coordinate.\n\\param cy Vertical center coordinate.\n\\param isin Integer version of sine of angle.\n\\param icos Integer version of cosine of angle.\n\\param flipx Flag indicating horizontal mirroring should be applied.\n\\param flipy Flag indicating vertical mirroring should be applied.\n\\param smooth Flag indicating anti-aliasing should be used.\n*/\nstatic void\n_transformSurfaceRGBA(SDL_Surface * src, SDL_Surface * dst, int cx, int cy, int isin, int icos, int flipx, int flipy, int smooth)\n{\n    int x, y, t1, t2, dx, dy, xd, yd, sdx, sdy, ax, ay, ex, ey, sw, sh;\n    tColorRGBA c00, c01, c10, c11, cswap;\n    tColorRGBA *pc, *sp;\n    int gap;\n\n    /*\n    * Variable setup\n    */\n    xd = ((src->w - dst->w) << 15);\n    yd = ((src->h - dst->h) << 15);\n    ax = (cx << 16) - (icos * cx);\n    ay = (cy << 16) - (isin * cx);\n    sw = src->w - 1;\n    sh = src->h - 1;\n    pc = (tColorRGBA*) dst->pixels;\n    gap = dst->pitch - dst->w * 4;\n\n    /*\n    * Switch between interpolating and non-interpolating code\n    */\n    if (smooth) {\n        for (y = 0; y < dst->h; y++) {\n            dy = cy - y;\n            sdx = (ax + (isin * dy)) + xd;\n            sdy = (ay - (icos * dy)) + yd;\n            for (x = 0; x < dst->w; x++) {\n                dx = (sdx >> 16);\n                dy = (sdy >> 16);\n                if (flipx) dx = sw - dx;\n                if (flipy) dy = sh - dy;\n                if ((dx > -1) && (dy > -1) && (dx < (src->w-1)) && (dy < (src->h-1))) {\n                    sp = (tColorRGBA *)src->pixels;\n                    sp += ((src->pitch/4) * dy);\n                    sp += dx;\n                    c00 = *sp;\n                    sp += 1;\n                    c01 = *sp;\n                    sp += (src->pitch/4);\n                    c11 = *sp;\n                    sp -= 1;\n                    c10 = *sp;\n                    if (flipx) {\n                        cswap = c00; c00=c01; c01=cswap;\n                        cswap = c10; c10=c11; c11=cswap;\n                    }\n                    if (flipy) {\n                        cswap = c00; c00=c10; c10=cswap;\n                        cswap = c01; c01=c11; c11=cswap;\n                    }\n                    /*\n                    * Interpolate colors\n                    */\n                    ex = (sdx & 0xffff);\n                    ey = (sdy & 0xffff);\n                    t1 = ((((c01.r - c00.r) * ex) >> 16) + c00.r) & 0xff;\n                    t2 = ((((c11.r - c10.r) * ex) >> 16) + c10.r) & 0xff;\n                    pc->r = (((t2 - t1) * ey) >> 16) + t1;\n                    t1 = ((((c01.g - c00.g) * ex) >> 16) + c00.g) & 0xff;\n                    t2 = ((((c11.g - c10.g) * ex) >> 16) + c10.g) & 0xff;\n                    pc->g = (((t2 - t1) * ey) >> 16) + t1;\n                    t1 = ((((c01.b - c00.b) * ex) >> 16) + c00.b) & 0xff;\n                    t2 = ((((c11.b - c10.b) * ex) >> 16) + c10.b) & 0xff;\n                    pc->b = (((t2 - t1) * ey) >> 16) + t1;\n                    t1 = ((((c01.a - c00.a) * ex) >> 16) + c00.a) & 0xff;\n                    t2 = ((((c11.a - c10.a) * ex) >> 16) + c10.a) & 0xff;\n                    pc->a = (((t2 - t1) * ey) >> 16) + t1;\n                }\n                sdx += icos;\n                sdy += isin;\n                pc++;\n            }\n            pc = (tColorRGBA *) ((Uint8 *) pc + gap);\n        }\n    } else {\n        for (y = 0; y < dst->h; y++) {\n            dy = cy - y;\n            sdx = (ax + (isin * dy)) + xd;\n            sdy = (ay - (icos * dy)) + yd;\n            for (x = 0; x < dst->w; x++) {\n                dx = (short) (sdx >> 16);\n                dy = (short) (sdy >> 16);\n                if (flipx) dx = (src->w-1)-dx;\n                if (flipy) dy = (src->h-1)-dy;\n                if ((dx >= 0) && (dy >= 0) && (dx < src->w) && (dy < src->h)) {\n                    sp = (tColorRGBA *) ((Uint8 *) src->pixels + src->pitch * dy);\n                    sp += dx;\n                    *pc = *sp;\n                }\n                sdx += icos;\n                sdy += isin;\n                pc++;\n            }\n            pc = (tColorRGBA *) ((Uint8 *) pc + gap);\n        }\n    }\n}\n\n/* !\n\n\\brief Rotates and zooms 8 bit palette/Y 'src' surface to 'dst' surface without smoothing.\n\nRotates and zooms 8 bit RGBA/ABGR 'src' surface to 'dst' surface based on the control\nparameters by scanning the destination surface.\nAssumes src and dst surfaces are of 8 bit depth.\nAssumes dst surface was allocated with the correct dimensions.\n\n\\param src Source surface.\n\\param dst Destination surface.\n\\param cx Horizontal center coordinate.\n\\param cy Vertical center coordinate.\n\\param isin Integer version of sine of angle.\n\\param icos Integer version of cosine of angle.\n\\param flipx Flag indicating horizontal mirroring should be applied.\n\\param flipy Flag indicating vertical mirroring should be applied.\n*/\nstatic void\ntransformSurfaceY(SDL_Surface * src, SDL_Surface * dst, int cx, int cy, int isin, int icos, int flipx, int flipy)\n{\n    int x, y, dx, dy, xd, yd, sdx, sdy, ax, ay;\n    tColorY *pc, *sp;\n    int gap;\n\n    /*\n    * Variable setup\n    */\n    xd = ((src->w - dst->w) << 15);\n    yd = ((src->h - dst->h) << 15);\n    ax = (cx << 16) - (icos * cx);\n    ay = (cy << 16) - (isin * cx);\n    pc = (tColorY*) dst->pixels;\n    gap = dst->pitch - dst->w;\n    /*\n    * Clear surface to colorkey\n    */\n    SDL_memset(pc, (int)(_colorkey(src) & 0xff), dst->pitch * dst->h);\n    /*\n    * Iterate through destination surface\n    */\n    for (y = 0; y < dst->h; y++) {\n        dy = cy - y;\n        sdx = (ax + (isin * dy)) + xd;\n        sdy = (ay - (icos * dy)) + yd;\n        for (x = 0; x < dst->w; x++) {\n            dx = (short) (sdx >> 16);\n            dy = (short) (sdy >> 16);\n            if (flipx) dx = (src->w-1)-dx;\n            if (flipy) dy = (src->h-1)-dy;\n            if ((dx >= 0) && (dy >= 0) && (dx < src->w) && (dy < src->h)) {\n                sp = (tColorY *) (src->pixels);\n                sp += (src->pitch * dy + dx);\n                *pc = *sp;\n            }\n            sdx += icos;\n            sdy += isin;\n            pc++;\n        }\n        pc += gap;\n    }\n}\n\n\n/* !\n\\brief Rotates and zooms a surface with different horizontal and vertival scaling factors and optional anti-aliasing.\n\nRotates a 32bit or 8bit 'src' surface to newly created 'dst' surface.\n'angle' is the rotation in degrees, 'centerx' and 'centery' the rotation center. If 'smooth' is set\nthen the destination 32bit surface is anti-aliased. If the surface is not 8bit\nor 32bit RGBA/ABGR it will be converted into a 32bit RGBA format on the fly.\n\n\\param src The surface to rotozoom.\n\\param angle The angle to rotate in degrees.\n\\param centerx The horizontal coordinate of the center of rotation\n\\param zoomy The vertical coordinate of the center of rotation\n\\param smooth Antialiasing flag; set to SMOOTHING_ON to enable.\n\\param flipx Set to 1 to flip the image horizontally\n\\param flipy Set to 1 to flip the image vertically\n\\param dstwidth The destination surface width\n\\param dstheight The destination surface height\n\\param cangle The angle cosine\n\\param sangle The angle sine\n\\return The new rotated surface.\n\n*/\n\nSDL_Surface *\nSDLgfx_rotateSurface(SDL_Surface * src, double angle, int centerx, int centery, int smooth, int flipx, int flipy, int dstwidth, int dstheight, double cangle, double sangle)\n{\n    SDL_Surface *rz_src;\n    SDL_Surface *rz_dst;\n    int is32bit;\n    int i, src_converted;\n    Uint8 r,g,b;\n    Uint32 colorkey = 0;\n    int colorKeyAvailable = 0;\n    double sangleinv, cangleinv;\n\n    /*\n    * Sanity check\n    */\n    if (src == NULL)\n        return (NULL);\n\n    if (src->flags & SDL_TRUE/* SDL_SRCCOLORKEY */)\n    {\n        colorkey = _colorkey(src);\n        SDL_GetRGB(colorkey, src->format, &r, &g, &b);\n        colorKeyAvailable = 1;\n    }\n    /*\n    * Determine if source surface is 32bit or 8bit\n    */\n    is32bit = (src->format->BitsPerPixel == 32);\n    if ((is32bit) || (src->format->BitsPerPixel == 8)) {\n        /*\n        * Use source surface 'as is'\n        */\n        rz_src = src;\n        src_converted = 0;\n    } else {\n        /*\n        * New source surface is 32bit with a defined RGBA ordering\n        */\n        rz_src =\n            SDL_CreateRGBSurface(SDL_SWSURFACE, src->w, src->h, 32,\n#if SDL_BYTEORDER == SDL_LIL_ENDIAN\n            0x000000ff, 0x0000ff00, 0x00ff0000, 0xff000000\n#else\n            0xff000000,  0x00ff0000, 0x0000ff00, 0x000000ff\n#endif\n            );\n        if(colorKeyAvailable)\n            SDL_SetColorKey(src, 0, 0);\n\n        SDL_BlitSurface(src, NULL, rz_src, NULL);\n\n        if(colorKeyAvailable)\n            SDL_SetColorKey(src, SDL_TRUE /* SDL_SRCCOLORKEY */, colorkey);\n        src_converted = 1;\n        is32bit = 1;\n    }\n\n\n    /* Determine target size */\n    /* _rotozoomSurfaceSizeTrig(rz_src->w, rz_src->h, angle, &dstwidth, &dstheight, &cangle, &sangle); */\n\n    /*\n    * Calculate target factors from sin/cos and zoom\n    */\n    sangleinv = sangle*65536.0;\n    cangleinv = cangle*65536.0;\n\n    /*\n    * Alloc space to completely contain the rotated surface\n    */\n    rz_dst = NULL;\n    if (is32bit) {\n        /*\n        * Target surface is 32bit with source RGBA/ABGR ordering\n        */\n        rz_dst =\n            SDL_CreateRGBSurface(SDL_SWSURFACE, dstwidth, dstheight + GUARD_ROWS, 32,\n            rz_src->format->Rmask, rz_src->format->Gmask,\n            rz_src->format->Bmask, rz_src->format->Amask);\n    } else {\n        /*\n        * Target surface is 8bit\n        */\n        rz_dst = SDL_CreateRGBSurface(SDL_SWSURFACE, dstwidth, dstheight + GUARD_ROWS, 8, 0, 0, 0, 0);\n    }\n\n    /* Check target */\n    if (rz_dst == NULL)\n        return NULL;\n\n    /* Adjust for guard rows */\n    rz_dst->h = dstheight;\n\n    if (colorKeyAvailable == 1){\n        colorkey = SDL_MapRGB(rz_dst->format, r, g, b);\n\n        SDL_FillRect(rz_dst, NULL, colorkey );\n    }\n\n    /*\n    * Lock source surface\n    */\n    if (SDL_MUSTLOCK(rz_src)) {\n        SDL_LockSurface(rz_src);\n    }\n\n    /*\n    * Check which kind of surface we have\n    */\n    if (is32bit) {\n        /*\n        * Call the 32bit transformation routine to do the rotation (using alpha)\n        */\n        _transformSurfaceRGBA(rz_src, rz_dst, centerx, centery,\n            (int) (sangleinv), (int) (cangleinv),\n            flipx, flipy,\n            smooth);\n        /*\n        * Turn on source-alpha support\n        */\n        /* SDL_SetAlpha(rz_dst, SDL_SRCALPHA, 255); */\n        SDL_SetColorKey(rz_dst, /* SDL_SRCCOLORKEY */ SDL_TRUE | SDL_RLEACCEL, _colorkey(rz_src));\n    } else {\n        /*\n        * Copy palette and colorkey info\n        */\n        for (i = 0; i < rz_src->format->palette->ncolors; i++) {\n            rz_dst->format->palette->colors[i] = rz_src->format->palette->colors[i];\n        }\n        rz_dst->format->palette->ncolors = rz_src->format->palette->ncolors;\n        /*\n        * Call the 8bit transformation routine to do the rotation\n        */\n        transformSurfaceY(rz_src, rz_dst, centerx, centery,\n            (int) (sangleinv), (int) (cangleinv),\n            flipx, flipy);\n        SDL_SetColorKey(rz_dst, /* SDL_SRCCOLORKEY */ SDL_TRUE | SDL_RLEACCEL, _colorkey(rz_src));\n    }\n    /*\n    * Unlock source surface\n    */\n    if (SDL_MUSTLOCK(rz_src)) {\n        SDL_UnlockSurface(rz_src);\n    }\n\n    /*\n    * Cleanup temp surface\n    */\n    if (src_converted) {\n        SDL_FreeSurface(rz_src);\n    }\n\n    /*\n    * Return destination surface\n    */\n    return (rz_dst);\n}\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n\n#if defined(__clang_analyzer__) && !defined(SDL_DISABLE_ANALYZE_MACROS)\n#define SDL_DISABLE_ANALYZE_MACROS 1\n#endif\n\n#include \"../SDL_internal.h\"\n\n/* This file contains portable memory management functions for SDL */\n\n#include \"SDL_stdinc.h\"\n\n#if defined(HAVE_MALLOC)\n\nvoid *SDL_malloc(size_t size)\n{\n    return malloc(size);\n}\n\nvoid *SDL_calloc(size_t nmemb, size_t size)\n{\n    return calloc(nmemb, size);\n}\n\nvoid *SDL_realloc(void *ptr, size_t size)\n{\n    return realloc(ptr, size);\n}\n\nvoid SDL_free(void *ptr)\n{\n    free(ptr);\n}\n\n#else  /* the rest of this is a LOT of tapdancing to implement malloc. :) */\n\n#define LACKS_SYS_TYPES_H\n#define LACKS_STDIO_H\n#define LACKS_STRINGS_H\n#define LACKS_STRING_H\n#define LACKS_STDLIB_H\n#define ABORT\n#define USE_LOCKS 1\n\n/*\n  This is a version (aka dlmalloc) of malloc/free/realloc written by\n  Doug Lea and released to the public domain, as explained at\n  http://creativecommons.org/licenses/publicdomain.  Send questions,\n  comments, complaints, performance data, etc to dl@cs.oswego.edu\n\n* Version 2.8.3 Thu Sep 22 11:16:15 2005  Doug Lea  (dl at gee)\n\n   Note: There may be an updated version of this malloc obtainable at\n           ftp://gee.cs.oswego.edu/pub/misc/malloc.c\n         Check before installing!\n\n* Quickstart\n\n  This library is all in one file to simplify the most common usage:\n  ftp it, compile it (-O3), and link it into another program. All of\n  the compile-time options default to reasonable values for use on\n  most platforms.  You might later want to step through various\n  compile-time and dynamic tuning options.\n\n  For convenience, an include file for code using this malloc is at:\n     ftp://gee.cs.oswego.edu/pub/misc/malloc-2.8.3.h\n  You don't really need this .h file unless you call functions not\n  defined in your system include files.  The .h file contains only the\n  excerpts from this file needed for using this malloc on ANSI C/C++\n  systems, so long as you haven't changed compile-time options about\n  naming and tuning parameters.  If you do, then you can create your\n  own malloc.h that does include all settings by cutting at the point\n  indicated below. Note that you may already by default be using a C\n  library containing a malloc that is based on some version of this\n  malloc (for example in linux). You might still want to use the one\n  in this file to customize settings or to avoid overheads associated\n  with library versions.\n\n* Vital statistics:\n\n  Supported pointer/size_t representation:       4 or 8 bytes\n       size_t MUST be an unsigned type of the same width as\n       pointers. (If you are using an ancient system that declares\n       size_t as a signed type, or need it to be a different width\n       than pointers, you can use a previous release of this malloc\n       (e.g. 2.7.2) supporting these.)\n\n  Alignment:                                     8 bytes (default)\n       This suffices for nearly all current machines and C compilers.\n       However, you can define MALLOC_ALIGNMENT to be wider than this\n       if necessary (up to 128bytes), at the expense of using more space.\n\n  Minimum overhead per allocated chunk:   4 or  8 bytes (if 4byte sizes)\n                                          8 or 16 bytes (if 8byte sizes)\n       Each malloced chunk has a hidden word of overhead holding size\n       and status information, and additional cross-check word\n       if FOOTERS is defined.\n\n  Minimum allocated size: 4-byte ptrs:  16 bytes    (including overhead)\n                          8-byte ptrs:  32 bytes    (including overhead)\n\n       Even a request for zero bytes (i.e., malloc(0)) returns a\n       pointer to something of the minimum allocatable size.\n       The maximum overhead wastage (i.e., number of extra bytes\n       allocated than were requested in malloc) is less than or equal\n       to the minimum size, except for requests >= mmap_threshold that\n       are serviced via mmap(), where the worst case wastage is about\n       32 bytes plus the remainder from a system page (the minimal\n       mmap unit); typically 4096 or 8192 bytes.\n\n  Security: static-safe; optionally more or less\n       The \"security\" of malloc refers to the ability of malicious\n       code to accentuate the effects of errors (for example, freeing\n       space that is not currently malloc'ed or overwriting past the\n       ends of chunks) in code that calls malloc.  This malloc\n       guarantees not to modify any memory locations below the base of\n       heap, i.e., static variables, even in the presence of usage\n       errors.  The routines additionally detect most improper frees\n       and reallocs.  All this holds as long as the static bookkeeping\n       for malloc itself is not corrupted by some other means.  This\n       is only one aspect of security -- these checks do not, and\n       cannot, detect all possible programming errors.\n\n       If FOOTERS is defined nonzero, then each allocated chunk\n       carries an additional check word to verify that it was malloced\n       from its space.  These check words are the same within each\n       execution of a program using malloc, but differ across\n       executions, so externally crafted fake chunks cannot be\n       freed. This improves security by rejecting frees/reallocs that\n       could corrupt heap memory, in addition to the checks preventing\n       writes to statics that are always on.  This may further improve\n       security at the expense of time and space overhead.  (Note that\n       FOOTERS may also be worth using with MSPACES.)\n\n       By default detected errors cause the program to abort (calling\n       \"abort()\"). You can override this to instead proceed past\n       errors by defining PROCEED_ON_ERROR.  In this case, a bad free\n       has no effect, and a malloc that encounters a bad address\n       caused by user overwrites will ignore the bad address by\n       dropping pointers and indices to all known memory. This may\n       be appropriate for programs that should continue if at all\n       possible in the face of programming errors, although they may\n       run out of memory because dropped memory is never reclaimed.\n\n       If you don't like either of these options, you can define\n       CORRUPTION_ERROR_ACTION and USAGE_ERROR_ACTION to do anything\n       else. And if if you are sure that your program using malloc has\n       no errors or vulnerabilities, you can define INSECURE to 1,\n       which might (or might not) provide a small performance improvement.\n\n  Thread-safety: NOT thread-safe unless USE_LOCKS defined\n       When USE_LOCKS is defined, each public call to malloc, free,\n       etc is surrounded with either a pthread mutex or a win32\n       spinlock (depending on WIN32). This is not especially fast, and\n       can be a major bottleneck.  It is designed only to provide\n       minimal protection in concurrent environments, and to provide a\n       basis for extensions.  If you are using malloc in a concurrent\n       program, consider instead using ptmalloc, which is derived from\n       a version of this malloc. (See http://www.malloc.de).\n\n  System requirements: Any combination of MORECORE and/or MMAP/MUNMAP\n       This malloc can use unix sbrk or any emulation (invoked using\n       the CALL_MORECORE macro) and/or mmap/munmap or any emulation\n       (invoked using CALL_MMAP/CALL_MUNMAP) to get and release system\n       memory.  On most unix systems, it tends to work best if both\n       MORECORE and MMAP are enabled.  On Win32, it uses emulations\n       based on VirtualAlloc. It also uses common C library functions\n       like memset.\n\n  Compliance: I believe it is compliant with the Single Unix Specification\n       (See http://www.unix.org). Also SVID/XPG, ANSI C, and probably\n       others as well.\n\n* Overview of algorithms\n\n  This is not the fastest, most space-conserving, most portable, or\n  most tunable malloc ever written. However it is among the fastest\n  while also being among the most space-conserving, portable and\n  tunable.  Consistent balance across these factors results in a good\n  general-purpose allocator for malloc-intensive programs.\n\n  In most ways, this malloc is a best-fit allocator. Generally, it\n  chooses the best-fitting existing chunk for a request, with ties\n  broken in approximately least-recently-used order. (This strategy\n  normally maintains low fragmentation.) However, for requests less\n  than 256bytes, it deviates from best-fit when there is not an\n  exactly fitting available chunk by preferring to use space adjacent\n  to that used for the previous small request, as well as by breaking\n  ties in approximately most-recently-used order. (These enhance\n  locality of series of small allocations.)  And for very large requests\n  (>= 256Kb by default), it relies on system memory mapping\n  facilities, if supported.  (This helps avoid carrying around and\n  possibly fragmenting memory used only for large chunks.)\n\n  All operations (except malloc_stats and mallinfo) have execution\n  times that are bounded by a constant factor of the number of bits in\n  a size_t, not counting any clearing in calloc or copying in realloc,\n  or actions surrounding MORECORE and MMAP that have times\n  proportional to the number of non-contiguous regions returned by\n  system allocation routines, which is often just 1.\n\n  The implementation is not very modular and seriously overuses\n  macros. Perhaps someday all C compilers will do as good a job\n  inlining modular code as can now be done by brute-force expansion,\n  but now, enough of them seem not to.\n\n  Some compilers issue a lot of warnings about code that is\n  dead/unreachable only on some platforms, and also about intentional\n  uses of negation on unsigned types. All known cases of each can be\n  ignored.\n\n  For a longer but out of date high-level description, see\n     http://gee.cs.oswego.edu/dl/html/malloc.html\n\n* MSPACES\n  If MSPACES is defined, then in addition to malloc, free, etc.,\n  this file also defines mspace_malloc, mspace_free, etc. These\n  are versions of malloc routines that take an \"mspace\" argument\n  obtained using create_mspace, to control all internal bookkeeping.\n  If ONLY_MSPACES is defined, only these versions are compiled.\n  So if you would like to use this allocator for only some allocations,\n  and your system malloc for others, you can compile with\n  ONLY_MSPACES and then do something like...\n    static mspace mymspace = create_mspace(0,0); // for example\n    #define mymalloc(bytes)  mspace_malloc(mymspace, bytes)\n\n  (Note: If you only need one instance of an mspace, you can instead\n  use \"USE_DL_PREFIX\" to relabel the global malloc.)\n\n  You can similarly create thread-local allocators by storing\n  mspaces as thread-locals. For example:\n    static __thread mspace tlms = 0;\n    void*  tlmalloc(size_t bytes) {\n      if (tlms == 0) tlms = create_mspace(0, 0);\n      return mspace_malloc(tlms, bytes);\n    }\n    void  tlfree(void* mem) { mspace_free(tlms, mem); }\n\n  Unless FOOTERS is defined, each mspace is completely independent.\n  You cannot allocate from one and free to another (although\n  conformance is only weakly checked, so usage errors are not always\n  caught). If FOOTERS is defined, then each chunk carries around a tag\n  indicating its originating mspace, and frees are directed to their\n  originating spaces.\n\n -------------------------  Compile-time options ---------------------------\n\nBe careful in setting #define values for numerical constants of type\nsize_t. On some systems, literal values are not automatically extended\nto size_t precision unless they are explicitly casted.\n\nWIN32                    default: defined if _WIN32 defined\n  Defining WIN32 sets up defaults for MS environment and compilers.\n  Otherwise defaults are for unix.\n\nMALLOC_ALIGNMENT         default: (size_t)8\n  Controls the minimum alignment for malloc'ed chunks.  It must be a\n  power of two and at least 8, even on machines for which smaller\n  alignments would suffice. It may be defined as larger than this\n  though. Note however that code and data structures are optimized for\n  the case of 8-byte alignment.\n\nMSPACES                  default: 0 (false)\n  If true, compile in support for independent allocation spaces.\n  This is only supported if HAVE_MMAP is true.\n\nONLY_MSPACES             default: 0 (false)\n  If true, only compile in mspace versions, not regular versions.\n\nUSE_LOCKS                default: 0 (false)\n  Causes each call to each public routine to be surrounded with\n  pthread or WIN32 mutex lock/unlock. (If set true, this can be\n  overridden on a per-mspace basis for mspace versions.)\n\nFOOTERS                  default: 0\n  If true, provide extra checking and dispatching by placing\n  information in the footers of allocated chunks. This adds\n  space and time overhead.\n\nINSECURE                 default: 0\n  If true, omit checks for usage errors and heap space overwrites.\n\nUSE_DL_PREFIX            default: NOT defined\n  Causes compiler to prefix all public routines with the string 'dl'.\n  This can be useful when you only want to use this malloc in one part\n  of a program, using your regular system malloc elsewhere.\n\nABORT                    default: defined as abort()\n  Defines how to abort on failed checks.  On most systems, a failed\n  check cannot die with an \"assert\" or even print an informative\n  message, because the underlying print routines in turn call malloc,\n  which will fail again.  Generally, the best policy is to simply call\n  abort(). It's not very useful to do more than this because many\n  errors due to overwriting will show up as address faults (null, odd\n  addresses etc) rather than malloc-triggered checks, so will also\n  abort.  Also, most compilers know that abort() does not return, so\n  can better optimize code conditionally calling it.\n\nPROCEED_ON_ERROR           default: defined as 0 (false)\n  Controls whether detected bad addresses cause them to bypassed\n  rather than aborting. If set, detected bad arguments to free and\n  realloc are ignored. And all bookkeeping information is zeroed out\n  upon a detected overwrite of freed heap space, thus losing the\n  ability to ever return it from malloc again, but enabling the\n  application to proceed. If PROCEED_ON_ERROR is defined, the\n  static variable malloc_corruption_error_count is compiled in\n  and can be examined to see if errors have occurred. This option\n  generates slower code than the default abort policy.\n\nDEBUG                    default: NOT defined\n  The DEBUG setting is mainly intended for people trying to modify\n  this code or diagnose problems when porting to new platforms.\n  However, it may also be able to better isolate user errors than just\n  using runtime checks.  The assertions in the check routines spell\n  out in more detail the assumptions and invariants underlying the\n  algorithms.  The checking is fairly extensive, and will slow down\n  execution noticeably. Calling malloc_stats or mallinfo with DEBUG\n  set will attempt to check every non-mmapped allocated and free chunk\n  in the course of computing the summaries.\n\nABORT_ON_ASSERT_FAILURE   default: defined as 1 (true)\n  Debugging assertion failures can be nearly impossible if your\n  version of the assert macro causes malloc to be called, which will\n  lead to a cascade of further failures, blowing the runtime stack.\n  ABORT_ON_ASSERT_FAILURE cause assertions failures to call abort(),\n  which will usually make debugging easier.\n\nMALLOC_FAILURE_ACTION     default: sets errno to ENOMEM, or no-op on win32\n  The action to take before \"return 0\" when malloc fails to be able to\n  return memory because there is none available.\n\nHAVE_MORECORE             default: 1 (true) unless win32 or ONLY_MSPACES\n  True if this system supports sbrk or an emulation of it.\n\nMORECORE                  default: sbrk\n  The name of the sbrk-style system routine to call to obtain more\n  memory.  See below for guidance on writing custom MORECORE\n  functions. The type of the argument to sbrk/MORECORE varies across\n  systems.  It cannot be size_t, because it supports negative\n  arguments, so it is normally the signed type of the same width as\n  size_t (sometimes declared as \"intptr_t\").  It doesn't much matter\n  though. Internally, we only call it with arguments less than half\n  the max value of a size_t, which should work across all reasonable\n  possibilities, although sometimes generating compiler warnings.  See\n  near the end of this file for guidelines for creating a custom\n  version of MORECORE.\n\nMORECORE_CONTIGUOUS       default: 1 (true)\n  If true, take advantage of fact that consecutive calls to MORECORE\n  with positive arguments always return contiguous increasing\n  addresses.  This is true of unix sbrk. It does not hurt too much to\n  set it true anyway, since malloc copes with non-contiguities.\n  Setting it false when definitely non-contiguous saves time\n  and possibly wasted space it would take to discover this though.\n\nMORECORE_CANNOT_TRIM      default: NOT defined\n  True if MORECORE cannot release space back to the system when given\n  negative arguments. This is generally necessary only if you are\n  using a hand-crafted MORECORE function that cannot handle negative\n  arguments.\n\nHAVE_MMAP                 default: 1 (true)\n  True if this system supports mmap or an emulation of it.  If so, and\n  HAVE_MORECORE is not true, MMAP is used for all system\n  allocation. If set and HAVE_MORECORE is true as well, MMAP is\n  primarily used to directly allocate very large blocks. It is also\n  used as a backup strategy in cases where MORECORE fails to provide\n  space from system. Note: A single call to MUNMAP is assumed to be\n  able to unmap memory that may have be allocated using multiple calls\n  to MMAP, so long as they are adjacent.\n\nHAVE_MREMAP               default: 1 on linux, else 0\n  If true realloc() uses mremap() to re-allocate large blocks and\n  extend or shrink allocation spaces.\n\nMMAP_CLEARS               default: 1 on unix\n  True if mmap clears memory so calloc doesn't need to. This is true\n  for standard unix mmap using /dev/zero.\n\nUSE_BUILTIN_FFS            default: 0 (i.e., not used)\n  Causes malloc to use the builtin ffs() function to compute indices.\n  Some compilers may recognize and intrinsify ffs to be faster than the\n  supplied C version. Also, the case of x86 using gcc is special-cased\n  to an asm instruction, so is already as fast as it can be, and so\n  this setting has no effect. (On most x86s, the asm version is only\n  slightly faster than the C version.)\n\nmalloc_getpagesize         default: derive from system includes, or 4096.\n  The system page size. To the extent possible, this malloc manages\n  memory from the system in page-size units.  This may be (and\n  usually is) a function rather than a constant. This is ignored\n  if WIN32, where page size is determined using getSystemInfo during\n  initialization.\n\nUSE_DEV_RANDOM             default: 0 (i.e., not used)\n  Causes malloc to use /dev/random to initialize secure magic seed for\n  stamping footers. Otherwise, the current time is used.\n\nNO_MALLINFO                default: 0\n  If defined, don't compile \"mallinfo\". This can be a simple way\n  of dealing with mismatches between system declarations and\n  those in this file.\n\nMALLINFO_FIELD_TYPE        default: size_t\n  The type of the fields in the mallinfo struct. This was originally\n  defined as \"int\" in SVID etc, but is more usefully defined as\n  size_t. The value is used only if  HAVE_USR_INCLUDE_MALLOC_H is not set\n\nREALLOC_ZERO_BYTES_FREES    default: not defined\n  This should be set if a call to realloc with zero bytes should\n  be the same as a call to free. Some people think it should. Otherwise,\n  since this malloc returns a unique pointer for malloc(0), so does\n  realloc(p, 0).\n\nLACKS_UNISTD_H, LACKS_FCNTL_H, LACKS_SYS_PARAM_H, LACKS_SYS_MMAN_H\nLACKS_STRINGS_H, LACKS_STRING_H, LACKS_SYS_TYPES_H,  LACKS_ERRNO_H\nLACKS_STDLIB_H                default: NOT defined unless on WIN32\n  Define these if your system does not have these header files.\n  You might need to manually insert some of the declarations they provide.\n\nDEFAULT_GRANULARITY        default: page size if MORECORE_CONTIGUOUS,\n                                system_info.dwAllocationGranularity in WIN32,\n                                otherwise 64K.\n      Also settable using mallopt(M_GRANULARITY, x)\n  The unit for allocating and deallocating memory from the system.  On\n  most systems with contiguous MORECORE, there is no reason to\n  make this more than a page. However, systems with MMAP tend to\n  either require or encourage larger granularities.  You can increase\n  this value to prevent system allocation functions to be called so\n  often, especially if they are slow.  The value must be at least one\n  page and must be a power of two.  Setting to 0 causes initialization\n  to either page size or win32 region size.  (Note: In previous\n  versions of malloc, the equivalent of this option was called\n  \"TOP_PAD\")\n\nDEFAULT_TRIM_THRESHOLD    default: 2MB\n      Also settable using mallopt(M_TRIM_THRESHOLD, x)\n  The maximum amount of unused top-most memory to keep before\n  releasing via malloc_trim in free().  Automatic trimming is mainly\n  useful in long-lived programs using contiguous MORECORE.  Because\n  trimming via sbrk can be slow on some systems, and can sometimes be\n  wasteful (in cases where programs immediately afterward allocate\n  more large chunks) the value should be high enough so that your\n  overall system performance would improve by releasing this much\n  memory.  As a rough guide, you might set to a value close to the\n  average size of a process (program) running on your system.\n  Releasing this much memory would allow such a process to run in\n  memory.  Generally, it is worth tuning trim thresholds when a\n  program undergoes phases where several large chunks are allocated\n  and released in ways that can reuse each other's storage, perhaps\n  mixed with phases where there are no such chunks at all. The trim\n  value must be greater than page size to have any useful effect.  To\n  disable trimming completely, you can set to MAX_SIZE_T. Note that the trick\n  some people use of mallocing a huge space and then freeing it at\n  program startup, in an attempt to reserve system memory, doesn't\n  have the intended effect under automatic trimming, since that memory\n  will immediately be returned to the system.\n\nDEFAULT_MMAP_THRESHOLD       default: 256K\n      Also settable using mallopt(M_MMAP_THRESHOLD, x)\n  The request size threshold for using MMAP to directly service a\n  request. Requests of at least this size that cannot be allocated\n  using already-existing space will be serviced via mmap.  (If enough\n  normal freed space already exists it is used instead.)  Using mmap\n  segregates relatively large chunks of memory so that they can be\n  individually obtained and released from the host system. A request\n  serviced through mmap is never reused by any other request (at least\n  not directly; the system may just so happen to remap successive\n  requests to the same locations).  Segregating space in this way has\n  the benefits that: Mmapped space can always be individually released\n  back to the system, which helps keep the system level memory demands\n  of a long-lived program low.  Also, mapped memory doesn't become\n  `locked' between other chunks, as can happen with normally allocated\n  chunks, which means that even trimming via malloc_trim would not\n  release them.  However, it has the disadvantage that the space\n  cannot be reclaimed, consolidated, and then used to service later\n  requests, as happens with normal chunks.  The advantages of mmap\n  nearly always outweigh disadvantages for \"large\" chunks, but the\n  value of \"large\" may vary across systems.  The default is an\n  empirically derived value that works well in most systems. You can\n  disable mmap by setting to MAX_SIZE_T.\n\n*/\n\n#ifndef WIN32\n#ifdef _WIN32\n#define WIN32 1\n#endif /* _WIN32 */\n#endif /* WIN32 */\n#ifdef WIN32\n#define WIN32_LEAN_AND_MEAN\n#include <windows.h>\n#define HAVE_MMAP 1\n#define HAVE_MORECORE 0\n#define LACKS_UNISTD_H\n#define LACKS_SYS_PARAM_H\n#define LACKS_SYS_MMAN_H\n#define LACKS_STRING_H\n#define LACKS_STRINGS_H\n#define LACKS_SYS_TYPES_H\n#define LACKS_ERRNO_H\n#define LACKS_FCNTL_H\n#define MALLOC_FAILURE_ACTION\n#define MMAP_CLEARS 0           /* WINCE and some others apparently don't clear */\n#endif /* WIN32 */\n\n#if defined(DARWIN) || defined(_DARWIN)\n/* Mac OSX docs advise not to use sbrk; it seems better to use mmap */\n#ifndef HAVE_MORECORE\n#define HAVE_MORECORE 0\n#define HAVE_MMAP 1\n#endif /* HAVE_MORECORE */\n#endif /* DARWIN */\n\n#ifndef LACKS_SYS_TYPES_H\n#include <sys/types.h>          /* For size_t */\n#endif /* LACKS_SYS_TYPES_H */\n\n/* The maximum possible size_t value has all bits set */\n#define MAX_SIZE_T           (~(size_t)0)\n\n#ifndef ONLY_MSPACES\n#define ONLY_MSPACES 0\n#endif /* ONLY_MSPACES */\n#ifndef MSPACES\n#if ONLY_MSPACES\n#define MSPACES 1\n#else /* ONLY_MSPACES */\n#define MSPACES 0\n#endif /* ONLY_MSPACES */\n#endif /* MSPACES */\n#ifndef MALLOC_ALIGNMENT\n#define MALLOC_ALIGNMENT ((size_t)8U)\n#endif /* MALLOC_ALIGNMENT */\n#ifndef FOOTERS\n#define FOOTERS 0\n#endif /* FOOTERS */\n#ifndef ABORT\n#define ABORT  abort()\n#endif /* ABORT */\n#ifndef ABORT_ON_ASSERT_FAILURE\n#define ABORT_ON_ASSERT_FAILURE 1\n#endif /* ABORT_ON_ASSERT_FAILURE */\n#ifndef PROCEED_ON_ERROR\n#define PROCEED_ON_ERROR 0\n#endif /* PROCEED_ON_ERROR */\n#ifndef USE_LOCKS\n#define USE_LOCKS 0\n#endif /* USE_LOCKS */\n#ifndef INSECURE\n#define INSECURE 0\n#endif /* INSECURE */\n#ifndef HAVE_MMAP\n#define HAVE_MMAP 1\n#endif /* HAVE_MMAP */\n#ifndef MMAP_CLEARS\n#define MMAP_CLEARS 1\n#endif /* MMAP_CLEARS */\n#ifndef HAVE_MREMAP\n#ifdef linux\n#define HAVE_MREMAP 1\n#else /* linux */\n#define HAVE_MREMAP 0\n#endif /* linux */\n#endif /* HAVE_MREMAP */\n#ifndef MALLOC_FAILURE_ACTION\n#define MALLOC_FAILURE_ACTION  errno = ENOMEM;\n#endif /* MALLOC_FAILURE_ACTION */\n#ifndef HAVE_MORECORE\n#if ONLY_MSPACES\n#define HAVE_MORECORE 0\n#else /* ONLY_MSPACES */\n#define HAVE_MORECORE 1\n#endif /* ONLY_MSPACES */\n#endif /* HAVE_MORECORE */\n#if !HAVE_MORECORE\n#define MORECORE_CONTIGUOUS 0\n#else /* !HAVE_MORECORE */\n#ifndef MORECORE\n#define MORECORE sbrk\n#endif /* MORECORE */\n#ifndef MORECORE_CONTIGUOUS\n#define MORECORE_CONTIGUOUS 1\n#endif /* MORECORE_CONTIGUOUS */\n#endif /* HAVE_MORECORE */\n#ifndef DEFAULT_GRANULARITY\n#if MORECORE_CONTIGUOUS\n#define DEFAULT_GRANULARITY (0) /* 0 means to compute in init_mparams */\n#else /* MORECORE_CONTIGUOUS */\n#define DEFAULT_GRANULARITY ((size_t)64U * (size_t)1024U)\n#endif /* MORECORE_CONTIGUOUS */\n#endif /* DEFAULT_GRANULARITY */\n#ifndef DEFAULT_TRIM_THRESHOLD\n#ifndef MORECORE_CANNOT_TRIM\n#define DEFAULT_TRIM_THRESHOLD ((size_t)2U * (size_t)1024U * (size_t)1024U)\n#else /* MORECORE_CANNOT_TRIM */\n#define DEFAULT_TRIM_THRESHOLD MAX_SIZE_T\n#endif /* MORECORE_CANNOT_TRIM */\n#endif /* DEFAULT_TRIM_THRESHOLD */\n#ifndef DEFAULT_MMAP_THRESHOLD\n#if HAVE_MMAP\n#define DEFAULT_MMAP_THRESHOLD ((size_t)256U * (size_t)1024U)\n#else /* HAVE_MMAP */\n#define DEFAULT_MMAP_THRESHOLD MAX_SIZE_T\n#endif /* HAVE_MMAP */\n#endif /* DEFAULT_MMAP_THRESHOLD */\n#ifndef USE_BUILTIN_FFS\n#define USE_BUILTIN_FFS 0\n#endif /* USE_BUILTIN_FFS */\n#ifndef USE_DEV_RANDOM\n#define USE_DEV_RANDOM 0\n#endif /* USE_DEV_RANDOM */\n#ifndef NO_MALLINFO\n#define NO_MALLINFO 0\n#endif /* NO_MALLINFO */\n#ifndef MALLINFO_FIELD_TYPE\n#define MALLINFO_FIELD_TYPE size_t\n#endif /* MALLINFO_FIELD_TYPE */\n\n#define memset  SDL_memset\n#define memcpy  SDL_memcpy\n#define malloc  SDL_malloc\n#define calloc  SDL_calloc\n#define realloc SDL_realloc\n#define free    SDL_free\n\n/*\n  mallopt tuning options.  SVID/XPG defines four standard parameter\n  numbers for mallopt, normally defined in malloc.h.  None of these\n  are used in this malloc, so setting them has no effect. But this\n  malloc does support the following options.\n*/\n\n#define M_TRIM_THRESHOLD     (-1)\n#define M_GRANULARITY        (-2)\n#define M_MMAP_THRESHOLD     (-3)\n\n/* ------------------------ Mallinfo declarations ------------------------ */\n\n#if !NO_MALLINFO\n/*\n  This version of malloc supports the standard SVID/XPG mallinfo\n  routine that returns a struct containing usage properties and\n  statistics. It should work on any system that has a\n  /usr/include/malloc.h defining struct mallinfo.  The main\n  declaration needed is the mallinfo struct that is returned (by-copy)\n  by mallinfo().  The malloinfo struct contains a bunch of fields that\n  are not even meaningful in this version of malloc.  These fields are\n  are instead filled by mallinfo() with other numbers that might be of\n  interest.\n\n  HAVE_USR_INCLUDE_MALLOC_H should be set if you have a\n  /usr/include/malloc.h file that includes a declaration of struct\n  mallinfo.  If so, it is included; else a compliant version is\n  declared below.  These must be precisely the same for mallinfo() to\n  work.  The original SVID version of this struct, defined on most\n  systems with mallinfo, declares all fields as ints. But some others\n  define as unsigned long. If your system defines the fields using a\n  type of different width than listed here, you MUST #include your\n  system version and #define HAVE_USR_INCLUDE_MALLOC_H.\n*/\n\n/* #define HAVE_USR_INCLUDE_MALLOC_H */\n\n#ifdef HAVE_USR_INCLUDE_MALLOC_H\n#include \"/usr/include/malloc.h\"\n#else /* HAVE_USR_INCLUDE_MALLOC_H */\n\nstruct mallinfo\n{\n    MALLINFO_FIELD_TYPE arena;  /* non-mmapped space allocated from system */\n    MALLINFO_FIELD_TYPE ordblks;        /* number of free chunks */\n    MALLINFO_FIELD_TYPE smblks; /* always 0 */\n    MALLINFO_FIELD_TYPE hblks;  /* always 0 */\n    MALLINFO_FIELD_TYPE hblkhd; /* space in mmapped regions */\n    MALLINFO_FIELD_TYPE usmblks;        /* maximum total allocated space */\n    MALLINFO_FIELD_TYPE fsmblks;        /* always 0 */\n    MALLINFO_FIELD_TYPE uordblks;       /* total allocated space */\n    MALLINFO_FIELD_TYPE fordblks;       /* total free space */\n    MALLINFO_FIELD_TYPE keepcost;       /* releasable (via malloc_trim) space */\n};\n\n#endif /* HAVE_USR_INCLUDE_MALLOC_H */\n#endif /* NO_MALLINFO */\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif                          /* __cplusplus */\n\n#if !ONLY_MSPACES\n\n/* ------------------- Declarations of public routines ------------------- */\n\n#ifndef USE_DL_PREFIX\n#define dlcalloc               calloc\n#define dlfree                 free\n#define dlmalloc               malloc\n#define dlmemalign             memalign\n#define dlrealloc              realloc\n#define dlvalloc               valloc\n#define dlpvalloc              pvalloc\n#define dlmallinfo             mallinfo\n#define dlmallopt              mallopt\n#define dlmalloc_trim          malloc_trim\n#define dlmalloc_stats         malloc_stats\n#define dlmalloc_usable_size   malloc_usable_size\n#define dlmalloc_footprint     malloc_footprint\n#define dlmalloc_max_footprint malloc_max_footprint\n#define dlindependent_calloc   independent_calloc\n#define dlindependent_comalloc independent_comalloc\n#endif                          /* USE_DL_PREFIX */\n\n\n/*\n  malloc(size_t n)\n  Returns a pointer to a newly allocated chunk of at least n bytes, or\n  null if no space is available, in which case errno is set to ENOMEM\n  on ANSI C systems.\n\n  If n is zero, malloc returns a minimum-sized chunk. (The minimum\n  size is 16 bytes on most 32bit systems, and 32 bytes on 64bit\n  systems.)  Note that size_t is an unsigned type, so calls with\n  arguments that would be negative if signed are interpreted as\n  requests for huge amounts of space, which will often fail. The\n  maximum supported value of n differs across systems, but is in all\n  cases less than the maximum representable value of a size_t.\n*/\n    void *dlmalloc(size_t);\n\n/*\n  free(void* p)\n  Releases the chunk of memory pointed to by p, that had been previously\n  allocated using malloc or a related routine such as realloc.\n  It has no effect if p is null. If p was not malloced or already\n  freed, free(p) will by default cause the current program to abort.\n*/\n    void dlfree(void *);\n\n/*\n  calloc(size_t n_elements, size_t element_size);\n  Returns a pointer to n_elements * element_size bytes, with all locations\n  set to zero.\n*/\n    void *dlcalloc(size_t, size_t);\n\n/*\n  realloc(void* p, size_t n)\n  Returns a pointer to a chunk of size n that contains the same data\n  as does chunk p up to the minimum of (n, p's size) bytes, or null\n  if no space is available.\n\n  The returned pointer may or may not be the same as p. The algorithm\n  prefers extending p in most cases when possible, otherwise it\n  employs the equivalent of a malloc-copy-free sequence.\n\n  If p is null, realloc is equivalent to malloc.\n\n  If space is not available, realloc returns null, errno is set (if on\n  ANSI) and p is NOT freed.\n\n  if n is for fewer bytes than already held by p, the newly unused\n  space is lopped off and freed if possible.  realloc with a size\n  argument of zero (re)allocates a minimum-sized chunk.\n\n  The old unix realloc convention of allowing the last-free'd chunk\n  to be used as an argument to realloc is not supported.\n*/\n\n    void *dlrealloc(void *, size_t);\n\n/*\n  memalign(size_t alignment, size_t n);\n  Returns a pointer to a newly allocated chunk of n bytes, aligned\n  in accord with the alignment argument.\n\n  The alignment argument should be a power of two. If the argument is\n  not a power of two, the nearest greater power is used.\n  8-byte alignment is guaranteed by normal malloc calls, so don't\n  bother calling memalign with an argument of 8 or less.\n\n  Overreliance on memalign is a sure way to fragment space.\n*/\n    void *dlmemalign(size_t, size_t);\n\n/*\n  valloc(size_t n);\n  Equivalent to memalign(pagesize, n), where pagesize is the page\n  size of the system. If the pagesize is unknown, 4096 is used.\n*/\n    void *dlvalloc(size_t);\n\n/*\n  mallopt(int parameter_number, int parameter_value)\n  Sets tunable parameters The format is to provide a\n  (parameter-number, parameter-value) pair.  mallopt then sets the\n  corresponding parameter to the argument value if it can (i.e., so\n  long as the value is meaningful), and returns 1 if successful else\n  0.  SVID/XPG/ANSI defines four standard param numbers for mallopt,\n  normally defined in malloc.h.  None of these are use in this malloc,\n  so setting them has no effect. But this malloc also supports other\n  options in mallopt. See below for details.  Briefly, supported\n  parameters are as follows (listed defaults are for \"typical\"\n  configurations).\n\n  Symbol            param #  default    allowed param values\n  M_TRIM_THRESHOLD     -1   2*1024*1024   any   (MAX_SIZE_T disables)\n  M_GRANULARITY        -2     page size   any power of 2 >= page size\n  M_MMAP_THRESHOLD     -3      256*1024   any   (or 0 if no MMAP support)\n*/\n    int dlmallopt(int, int);\n\n/*\n  malloc_footprint();\n  Returns the number of bytes obtained from the system.  The total\n  number of bytes allocated by malloc, realloc etc., is less than this\n  value. Unlike mallinfo, this function returns only a precomputed\n  result, so can be called frequently to monitor memory consumption.\n  Even if locks are otherwise defined, this function does not use them,\n  so results might not be up to date.\n*/\n    size_t dlmalloc_footprint(void);\n\n/*\n  malloc_max_footprint();\n  Returns the maximum number of bytes obtained from the system. This\n  value will be greater than current footprint if deallocated space\n  has been reclaimed by the system. The peak number of bytes allocated\n  by malloc, realloc etc., is less than this value. Unlike mallinfo,\n  this function returns only a precomputed result, so can be called\n  frequently to monitor memory consumption.  Even if locks are\n  otherwise defined, this function does not use them, so results might\n  not be up to date.\n*/\n    size_t dlmalloc_max_footprint(void);\n\n#if !NO_MALLINFO\n/*\n  mallinfo()\n  Returns (by copy) a struct containing various summary statistics:\n\n  arena:     current total non-mmapped bytes allocated from system\n  ordblks:   the number of free chunks\n  smblks:    always zero.\n  hblks:     current number of mmapped regions\n  hblkhd:    total bytes held in mmapped regions\n  usmblks:   the maximum total allocated space. This will be greater\n                than current total if trimming has occurred.\n  fsmblks:   always zero\n  uordblks:  current total allocated space (normal or mmapped)\n  fordblks:  total free space\n  keepcost:  the maximum number of bytes that could ideally be released\n               back to system via malloc_trim. (\"ideally\" means that\n               it ignores page restrictions etc.)\n\n  Because these fields are ints, but internal bookkeeping may\n  be kept as longs, the reported values may wrap around zero and\n  thus be inaccurate.\n*/\n    struct mallinfo dlmallinfo(void);\n#endif                          /* NO_MALLINFO */\n\n/*\n  independent_calloc(size_t n_elements, size_t element_size, void* chunks[]);\n\n  independent_calloc is similar to calloc, but instead of returning a\n  single cleared space, it returns an array of pointers to n_elements\n  independent elements that can hold contents of size elem_size, each\n  of which starts out cleared, and can be independently freed,\n  realloc'ed etc. The elements are guaranteed to be adjacently\n  allocated (this is not guaranteed to occur with multiple callocs or\n  mallocs), which may also improve cache locality in some\n  applications.\n\n  The \"chunks\" argument is optional (i.e., may be null, which is\n  probably the most typical usage). If it is null, the returned array\n  is itself dynamically allocated and should also be freed when it is\n  no longer needed. Otherwise, the chunks array must be of at least\n  n_elements in length. It is filled in with the pointers to the\n  chunks.\n\n  In either case, independent_calloc returns this pointer array, or\n  null if the allocation failed.  If n_elements is zero and \"chunks\"\n  is null, it returns a chunk representing an array with zero elements\n  (which should be freed if not wanted).\n\n  Each element must be individually freed when it is no longer\n  needed. If you'd like to instead be able to free all at once, you\n  should instead use regular calloc and assign pointers into this\n  space to represent elements.  (In this case though, you cannot\n  independently free elements.)\n\n  independent_calloc simplifies and speeds up implementations of many\n  kinds of pools.  It may also be useful when constructing large data\n  structures that initially have a fixed number of fixed-sized nodes,\n  but the number is not known at compile time, and some of the nodes\n  may later need to be freed. For example:\n\n  struct Node { int item; struct Node* next; };\n\n  struct Node* build_list() {\n    struct Node** pool;\n    int n = read_number_of_nodes_needed();\n    if (n <= 0) return 0;\n    pool = (struct Node**)(independent_calloc(n, sizeof(struct Node), 0);\n    if (pool == 0) die();\n    // organize into a linked list...\n    struct Node* first = pool[0];\n    for (i = 0; i < n-1; ++i)\n      pool[i]->next = pool[i+1];\n    free(pool);     // Can now free the array (or not, if it is needed later)\n    return first;\n  }\n*/\n    void **dlindependent_calloc(size_t, size_t, void **);\n\n/*\n  independent_comalloc(size_t n_elements, size_t sizes[], void* chunks[]);\n\n  independent_comalloc allocates, all at once, a set of n_elements\n  chunks with sizes indicated in the \"sizes\" array.    It returns\n  an array of pointers to these elements, each of which can be\n  independently freed, realloc'ed etc. The elements are guaranteed to\n  be adjacently allocated (this is not guaranteed to occur with\n  multiple callocs or mallocs), which may also improve cache locality\n  in some applications.\n\n  The \"chunks\" argument is optional (i.e., may be null). If it is null\n  the returned array is itself dynamically allocated and should also\n  be freed when it is no longer needed. Otherwise, the chunks array\n  must be of at least n_elements in length. It is filled in with the\n  pointers to the chunks.\n\n  In either case, independent_comalloc returns this pointer array, or\n  null if the allocation failed.  If n_elements is zero and chunks is\n  null, it returns a chunk representing an array with zero elements\n  (which should be freed if not wanted).\n\n  Each element must be individually freed when it is no longer\n  needed. If you'd like to instead be able to free all at once, you\n  should instead use a single regular malloc, and assign pointers at\n  particular offsets in the aggregate space. (In this case though, you\n  cannot independently free elements.)\n\n  independent_comallac differs from independent_calloc in that each\n  element may have a different size, and also that it does not\n  automatically clear elements.\n\n  independent_comalloc can be used to speed up allocation in cases\n  where several structs or objects must always be allocated at the\n  same time.  For example:\n\n  struct Head { ... }\n  struct Foot { ... }\n\n  void send_message(char* msg) {\n    int msglen = strlen(msg);\n    size_t sizes[3] = { sizeof(struct Head), msglen, sizeof(struct Foot) };\n    void* chunks[3];\n    if (independent_comalloc(3, sizes, chunks) == 0)\n      die();\n    struct Head* head = (struct Head*)(chunks[0]);\n    char*        body = (char*)(chunks[1]);\n    struct Foot* foot = (struct Foot*)(chunks[2]);\n    // ...\n  }\n\n  In general though, independent_comalloc is worth using only for\n  larger values of n_elements. For small values, you probably won't\n  detect enough difference from series of malloc calls to bother.\n\n  Overuse of independent_comalloc can increase overall memory usage,\n  since it cannot reuse existing noncontiguous small chunks that\n  might be available for some of the elements.\n*/\n    void **dlindependent_comalloc(size_t, size_t *, void **);\n\n\n/*\n  pvalloc(size_t n);\n  Equivalent to valloc(minimum-page-that-holds(n)), that is,\n  round up n to nearest pagesize.\n */\n    void *dlpvalloc(size_t);\n\n/*\n  malloc_trim(size_t pad);\n\n  If possible, gives memory back to the system (via negative arguments\n  to sbrk) if there is unused memory at the `high' end of the malloc\n  pool or in unused MMAP segments. You can call this after freeing\n  large blocks of memory to potentially reduce the system-level memory\n  requirements of a program. However, it cannot guarantee to reduce\n  memory. Under some allocation patterns, some large free blocks of\n  memory will be locked between two used chunks, so they cannot be\n  given back to the system.\n\n  The `pad' argument to malloc_trim represents the amount of free\n  trailing space to leave untrimmed. If this argument is zero, only\n  the minimum amount of memory to maintain internal data structures\n  will be left. Non-zero arguments can be supplied to maintain enough\n  trailing space to service future expected allocations without having\n  to re-obtain memory from the system.\n\n  Malloc_trim returns 1 if it actually released any memory, else 0.\n*/\n    int dlmalloc_trim(size_t);\n\n/*\n  malloc_usable_size(void* p);\n\n  Returns the number of bytes you can actually use in\n  an allocated chunk, which may be more than you requested (although\n  often not) due to alignment and minimum size constraints.\n  You can use this many bytes without worrying about\n  overwriting other allocated objects. This is not a particularly great\n  programming practice. malloc_usable_size can be more useful in\n  debugging and assertions, for example:\n\n  p = malloc(n);\n  assert(malloc_usable_size(p) >= 256);\n*/\n    size_t dlmalloc_usable_size(void *);\n\n/*\n  malloc_stats();\n  Prints on stderr the amount of space obtained from the system (both\n  via sbrk and mmap), the maximum amount (which may be more than\n  current if malloc_trim and/or munmap got called), and the current\n  number of bytes allocated via malloc (or realloc, etc) but not yet\n  freed. Note that this is the number of bytes allocated, not the\n  number requested. It will be larger than the number requested\n  because of alignment and bookkeeping overhead. Because it includes\n  alignment wastage as being in use, this figure may be greater than\n  zero even when no user-level chunks are allocated.\n\n  The reported current and maximum system memory can be inaccurate if\n  a program makes other calls to system memory allocation functions\n  (normally sbrk) outside of malloc.\n\n  malloc_stats prints only the most commonly interesting statistics.\n  More information can be obtained by calling mallinfo.\n*/\n    void dlmalloc_stats(void);\n\n#endif                          /* ONLY_MSPACES */\n\n#if MSPACES\n\n/*\n  mspace is an opaque type representing an independent\n  region of space that supports mspace_malloc, etc.\n*/\n    typedef void *mspace;\n\n/*\n  create_mspace creates and returns a new independent space with the\n  given initial capacity, or, if 0, the default granularity size.  It\n  returns null if there is no system memory available to create the\n  space.  If argument locked is non-zero, the space uses a separate\n  lock to control access. The capacity of the space will grow\n  dynamically as needed to service mspace_malloc requests.  You can\n  control the sizes of incremental increases of this space by\n  compiling with a different DEFAULT_GRANULARITY or dynamically\n  setting with mallopt(M_GRANULARITY, value).\n*/\n    mspace create_mspace(size_t capacity, int locked);\n\n/*\n  destroy_mspace destroys the given space, and attempts to return all\n  of its memory back to the system, returning the total number of\n  bytes freed. After destruction, the results of access to all memory\n  used by the space become undefined.\n*/\n    size_t destroy_mspace(mspace msp);\n\n/*\n  create_mspace_with_base uses the memory supplied as the initial base\n  of a new mspace. Part (less than 128*sizeof(size_t) bytes) of this\n  space is used for bookkeeping, so the capacity must be at least this\n  large. (Otherwise 0 is returned.) When this initial space is\n  exhausted, additional memory will be obtained from the system.\n  Destroying this space will deallocate all additionally allocated\n  space (if possible) but not the initial base.\n*/\n    mspace create_mspace_with_base(void *base, size_t capacity, int locked);\n\n/*\n  mspace_malloc behaves as malloc, but operates within\n  the given space.\n*/\n    void *mspace_malloc(mspace msp, size_t bytes);\n\n/*\n  mspace_free behaves as free, but operates within\n  the given space.\n\n  If compiled with FOOTERS==1, mspace_free is not actually needed.\n  free may be called instead of mspace_free because freed chunks from\n  any space are handled by their originating spaces.\n*/\n    void mspace_free(mspace msp, void *mem);\n\n/*\n  mspace_realloc behaves as realloc, but operates within\n  the given space.\n\n  If compiled with FOOTERS==1, mspace_realloc is not actually\n  needed.  realloc may be called instead of mspace_realloc because\n  realloced chunks from any space are handled by their originating\n  spaces.\n*/\n    void *mspace_realloc(mspace msp, void *mem, size_t newsize);\n\n/*\n  mspace_calloc behaves as calloc, but operates within\n  the given space.\n*/\n    void *mspace_calloc(mspace msp, size_t n_elements, size_t elem_size);\n\n/*\n  mspace_memalign behaves as memalign, but operates within\n  the given space.\n*/\n    void *mspace_memalign(mspace msp, size_t alignment, size_t bytes);\n\n/*\n  mspace_independent_calloc behaves as independent_calloc, but\n  operates within the given space.\n*/\n    void **mspace_independent_calloc(mspace msp, size_t n_elements,\n                                     size_t elem_size, void *chunks[]);\n\n/*\n  mspace_independent_comalloc behaves as independent_comalloc, but\n  operates within the given space.\n*/\n    void **mspace_independent_comalloc(mspace msp, size_t n_elements,\n                                       size_t sizes[], void *chunks[]);\n\n/*\n  mspace_footprint() returns the number of bytes obtained from the\n  system for this space.\n*/\n    size_t mspace_footprint(mspace msp);\n\n/*\n  mspace_max_footprint() returns the peak number of bytes obtained from the\n  system for this space.\n*/\n    size_t mspace_max_footprint(mspace msp);\n\n\n#if !NO_MALLINFO\n/*\n  mspace_mallinfo behaves as mallinfo, but reports properties of\n  the given space.\n*/\n    struct mallinfo mspace_mallinfo(mspace msp);\n#endif                          /* NO_MALLINFO */\n\n/*\n  mspace_malloc_stats behaves as malloc_stats, but reports\n  properties of the given space.\n*/\n    void mspace_malloc_stats(mspace msp);\n\n/*\n  mspace_trim behaves as malloc_trim, but\n  operates within the given space.\n*/\n    int mspace_trim(mspace msp, size_t pad);\n\n/*\n  An alias for mallopt.\n*/\n    int mspace_mallopt(int, int);\n\n#endif                          /* MSPACES */\n\n#ifdef __cplusplus\n};                              /* end of extern \"C\" */\n#endif /* __cplusplus */\n\n/*\n  ========================================================================\n  To make a fully customizable malloc.h header file, cut everything\n  above this line, put into file malloc.h, edit to suit, and #include it\n  on the next line, as well as in programs that use this malloc.\n  ========================================================================\n*/\n\n/* #include \"malloc.h\" */\n\n/*------------------------------ internal #includes ---------------------- */\n\n#ifdef _MSC_VER\n#pragma warning( disable : 4146 )       /* no \"unsigned\" warnings */\n#endif /* _MSC_VER */\n\n#ifndef LACKS_STDIO_H\n#include <stdio.h>              /* for printing in malloc_stats */\n#endif\n\n#ifndef LACKS_ERRNO_H\n#include <errno.h>              /* for MALLOC_FAILURE_ACTION */\n#endif /* LACKS_ERRNO_H */\n#if FOOTERS\n#include <time.h>               /* for magic initialization */\n#endif /* FOOTERS */\n#ifndef LACKS_STDLIB_H\n#include <stdlib.h>             /* for abort() */\n#endif /* LACKS_STDLIB_H */\n#ifdef DEBUG\n#if ABORT_ON_ASSERT_FAILURE\n#define assert(x) if(!(x)) ABORT\n#else /* ABORT_ON_ASSERT_FAILURE */\n#include <assert.h>\n#endif /* ABORT_ON_ASSERT_FAILURE */\n#else /* DEBUG */\n#define assert(x)\n#endif /* DEBUG */\n#ifndef LACKS_STRING_H\n#include <string.h>             /* for memset etc */\n#endif /* LACKS_STRING_H */\n#if USE_BUILTIN_FFS\n#ifndef LACKS_STRINGS_H\n#include <strings.h>            /* for ffs */\n#endif /* LACKS_STRINGS_H */\n#endif /* USE_BUILTIN_FFS */\n#if HAVE_MMAP\n#ifndef LACKS_SYS_MMAN_H\n#include <sys/mman.h>           /* for mmap */\n#endif /* LACKS_SYS_MMAN_H */\n#ifndef LACKS_FCNTL_H\n#include <fcntl.h>\n#endif /* LACKS_FCNTL_H */\n#endif /* HAVE_MMAP */\n#if HAVE_MORECORE\n#ifndef LACKS_UNISTD_H\n#include <unistd.h>             /* for sbrk */\n#else /* LACKS_UNISTD_H */\n#if !defined(__FreeBSD__) && !defined(__OpenBSD__) && !defined(__NetBSD__)\nextern void *sbrk(ptrdiff_t);\n#endif /* FreeBSD etc */\n#endif /* LACKS_UNISTD_H */\n#endif /* HAVE_MMAP */\n\n#ifndef WIN32\n#ifndef malloc_getpagesize\n#  ifdef _SC_PAGESIZE           /* some SVR4 systems omit an underscore */\n#    ifndef _SC_PAGE_SIZE\n#      define _SC_PAGE_SIZE _SC_PAGESIZE\n#    endif\n#  endif\n#  ifdef _SC_PAGE_SIZE\n#    define malloc_getpagesize sysconf(_SC_PAGE_SIZE)\n#  else\n#    if defined(BSD) || defined(DGUX) || defined(HAVE_GETPAGESIZE)\nextern size_t getpagesize();\n#      define malloc_getpagesize getpagesize()\n#    else\n#      ifdef WIN32              /* use supplied emulation of getpagesize */\n#        define malloc_getpagesize getpagesize()\n#      else\n#        ifndef LACKS_SYS_PARAM_H\n#          include <sys/param.h>\n#        endif\n#        ifdef EXEC_PAGESIZE\n#          define malloc_getpagesize EXEC_PAGESIZE\n#        else\n#          ifdef NBPG\n#            ifndef CLSIZE\n#              define malloc_getpagesize NBPG\n#            else\n#              define malloc_getpagesize (NBPG * CLSIZE)\n#            endif\n#          else\n#            ifdef NBPC\n#              define malloc_getpagesize NBPC\n#            else\n#              ifdef PAGESIZE\n#                define malloc_getpagesize PAGESIZE\n#              else /* just guess */\n#                define malloc_getpagesize ((size_t)4096U)\n#              endif\n#            endif\n#          endif\n#        endif\n#      endif\n#    endif\n#  endif\n#endif\n#endif\n\n/* ------------------- size_t and alignment properties -------------------- */\n\n/* The byte and bit size of a size_t */\n#define SIZE_T_SIZE         (sizeof(size_t))\n#define SIZE_T_BITSIZE      (sizeof(size_t) << 3)\n\n/* Some constants coerced to size_t */\n/* Annoying but necessary to avoid errors on some plaftorms */\n#define SIZE_T_ZERO         ((size_t)0)\n#define SIZE_T_ONE          ((size_t)1)\n#define SIZE_T_TWO          ((size_t)2)\n#define TWO_SIZE_T_SIZES    (SIZE_T_SIZE<<1)\n#define FOUR_SIZE_T_SIZES   (SIZE_T_SIZE<<2)\n#define SIX_SIZE_T_SIZES    (FOUR_SIZE_T_SIZES+TWO_SIZE_T_SIZES)\n#define HALF_MAX_SIZE_T     (MAX_SIZE_T / 2U)\n\n/* The bit mask value corresponding to MALLOC_ALIGNMENT */\n#define CHUNK_ALIGN_MASK    (MALLOC_ALIGNMENT - SIZE_T_ONE)\n\n/* True if address a has acceptable alignment */\n#define is_aligned(A)       (((size_t)((A)) & (CHUNK_ALIGN_MASK)) == 0)\n\n/* the number of bytes to offset an address to align it */\n#define align_offset(A)\\\n ((((size_t)(A) & CHUNK_ALIGN_MASK) == 0)? 0 :\\\n  ((MALLOC_ALIGNMENT - ((size_t)(A) & CHUNK_ALIGN_MASK)) & CHUNK_ALIGN_MASK))\n\n/* -------------------------- MMAP preliminaries ------------------------- */\n\n/*\n   If HAVE_MORECORE or HAVE_MMAP are false, we just define calls and\n   checks to fail so compiler optimizer can delete code rather than\n   using so many \"#if\"s.\n*/\n\n\n/* MORECORE and MMAP must return MFAIL on failure */\n#define MFAIL                ((void*)(MAX_SIZE_T))\n#define CMFAIL               ((char*)(MFAIL))   /* defined for convenience */\n\n#if !HAVE_MMAP\n#define IS_MMAPPED_BIT       (SIZE_T_ZERO)\n#define USE_MMAP_BIT         (SIZE_T_ZERO)\n#define CALL_MMAP(s)         MFAIL\n#define CALL_MUNMAP(a, s)    (-1)\n#define DIRECT_MMAP(s)       MFAIL\n\n#else /* HAVE_MMAP */\n#define IS_MMAPPED_BIT       (SIZE_T_ONE)\n#define USE_MMAP_BIT         (SIZE_T_ONE)\n\n#ifndef WIN32\n#define CALL_MUNMAP(a, s)    munmap((a), (s))\n#define MMAP_PROT            (PROT_READ|PROT_WRITE)\n#if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)\n#define MAP_ANONYMOUS        MAP_ANON\n#endif /* MAP_ANON */\n#ifdef MAP_ANONYMOUS\n#define MMAP_FLAGS           (MAP_PRIVATE|MAP_ANONYMOUS)\n#define CALL_MMAP(s)         mmap(0, (s), MMAP_PROT, MMAP_FLAGS, -1, 0)\n#else /* MAP_ANONYMOUS */\n/*\n   Nearly all versions of mmap support MAP_ANONYMOUS, so the following\n   is unlikely to be needed, but is supplied just in case.\n*/\n#define MMAP_FLAGS           (MAP_PRIVATE)\nstatic int dev_zero_fd = -1;    /* Cached file descriptor for /dev/zero. */\n#define CALL_MMAP(s) ((dev_zero_fd < 0) ? \\\n           (dev_zero_fd = open(\"/dev/zero\", O_RDWR), \\\n            mmap(0, (s), MMAP_PROT, MMAP_FLAGS, dev_zero_fd, 0)) : \\\n            mmap(0, (s), MMAP_PROT, MMAP_FLAGS, dev_zero_fd, 0))\n#endif /* MAP_ANONYMOUS */\n\n#define DIRECT_MMAP(s)       CALL_MMAP(s)\n#else /* WIN32 */\n\n/* Win32 MMAP via VirtualAlloc */\nstatic void *\nwin32mmap(size_t size)\n{\n    void *ptr =\n        VirtualAlloc(0, size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);\n    return (ptr != 0) ? ptr : MFAIL;\n}\n\n/* For direct MMAP, use MEM_TOP_DOWN to minimize interference */\nstatic void *\nwin32direct_mmap(size_t size)\n{\n    void *ptr = VirtualAlloc(0, size, MEM_RESERVE | MEM_COMMIT | MEM_TOP_DOWN,\n                             PAGE_READWRITE);\n    return (ptr != 0) ? ptr : MFAIL;\n}\n\n/* This function supports releasing coalesed segments */\nstatic int\nwin32munmap(void *ptr, size_t size)\n{\n    MEMORY_BASIC_INFORMATION minfo;\n    char *cptr = ptr;\n    while (size) {\n        if (VirtualQuery(cptr, &minfo, sizeof(minfo)) == 0)\n            return -1;\n        if (minfo.BaseAddress != cptr || minfo.AllocationBase != cptr ||\n            minfo.State != MEM_COMMIT || minfo.RegionSize > size)\n            return -1;\n        if (VirtualFree(cptr, 0, MEM_RELEASE) == 0)\n            return -1;\n        cptr += minfo.RegionSize;\n        size -= minfo.RegionSize;\n    }\n    return 0;\n}\n\n#define CALL_MMAP(s)         win32mmap(s)\n#define CALL_MUNMAP(a, s)    win32munmap((a), (s))\n#define DIRECT_MMAP(s)       win32direct_mmap(s)\n#endif /* WIN32 */\n#endif /* HAVE_MMAP */\n\n#if HAVE_MMAP && HAVE_MREMAP\n#define CALL_MREMAP(addr, osz, nsz, mv) mremap((addr), (osz), (nsz), (mv))\n#else /* HAVE_MMAP && HAVE_MREMAP */\n#define CALL_MREMAP(addr, osz, nsz, mv) MFAIL\n#endif /* HAVE_MMAP && HAVE_MREMAP */\n\n#if HAVE_MORECORE\n#define CALL_MORECORE(S)     MORECORE(S)\n#else /* HAVE_MORECORE */\n#define CALL_MORECORE(S)     MFAIL\n#endif /* HAVE_MORECORE */\n\n/* mstate bit set if continguous morecore disabled or failed */\n#define USE_NONCONTIGUOUS_BIT (4U)\n\n/* segment bit set in create_mspace_with_base */\n#define EXTERN_BIT            (8U)\n\n\n/* --------------------------- Lock preliminaries ------------------------ */\n\n#if USE_LOCKS\n\n/*\n  When locks are defined, there are up to two global locks:\n\n  * If HAVE_MORECORE, morecore_mutex protects sequences of calls to\n    MORECORE.  In many cases sys_alloc requires two calls, that should\n    not be interleaved with calls by other threads.  This does not\n    protect against direct calls to MORECORE by other threads not\n    using this lock, so there is still code to cope the best we can on\n    interference.\n\n  * magic_init_mutex ensures that mparams.magic and other\n    unique mparams values are initialized only once.\n*/\n\n#ifndef WIN32\n/* By default use posix locks */\n#include <pthread.h>\n#define MLOCK_T pthread_mutex_t\n#define INITIAL_LOCK(l)      pthread_mutex_init(l, NULL)\n#define ACQUIRE_LOCK(l)      pthread_mutex_lock(l)\n#define RELEASE_LOCK(l)      pthread_mutex_unlock(l)\n\n#if HAVE_MORECORE\nstatic MLOCK_T morecore_mutex = PTHREAD_MUTEX_INITIALIZER;\n#endif /* HAVE_MORECORE */\n\nstatic MLOCK_T magic_init_mutex = PTHREAD_MUTEX_INITIALIZER;\n\n#else /* WIN32 */\n/*\n   Because lock-protected regions have bounded times, and there\n   are no recursive lock calls, we can use simple spinlocks.\n*/\n\n#define MLOCK_T long\nstatic int\nwin32_acquire_lock(MLOCK_T * sl)\n{\n    for (;;) {\n#ifdef InterlockedCompareExchangePointer\n        if (!InterlockedCompareExchange(sl, 1, 0))\n            return 0;\n#else /* Use older void* version */\n        if (!InterlockedCompareExchange((void **) sl, (void *) 1, (void *) 0))\n            return 0;\n#endif /* InterlockedCompareExchangePointer */\n        Sleep(0);\n    }\n}\n\nstatic void\nwin32_release_lock(MLOCK_T * sl)\n{\n    InterlockedExchange(sl, 0);\n}\n\n#define INITIAL_LOCK(l)      *(l)=0\n#define ACQUIRE_LOCK(l)      win32_acquire_lock(l)\n#define RELEASE_LOCK(l)      win32_release_lock(l)\n#if HAVE_MORECORE\nstatic MLOCK_T morecore_mutex;\n#endif /* HAVE_MORECORE */\nstatic MLOCK_T magic_init_mutex;\n#endif /* WIN32 */\n\n#define USE_LOCK_BIT               (2U)\n#else /* USE_LOCKS */\n#define USE_LOCK_BIT               (0U)\n#define INITIAL_LOCK(l)\n#endif /* USE_LOCKS */\n\n#if USE_LOCKS && HAVE_MORECORE\n#define ACQUIRE_MORECORE_LOCK()    ACQUIRE_LOCK(&morecore_mutex);\n#define RELEASE_MORECORE_LOCK()    RELEASE_LOCK(&morecore_mutex);\n#else /* USE_LOCKS && HAVE_MORECORE */\n#define ACQUIRE_MORECORE_LOCK()\n#define RELEASE_MORECORE_LOCK()\n#endif /* USE_LOCKS && HAVE_MORECORE */\n\n#if USE_LOCKS\n#define ACQUIRE_MAGIC_INIT_LOCK()  ACQUIRE_LOCK(&magic_init_mutex);\n#define RELEASE_MAGIC_INIT_LOCK()  RELEASE_LOCK(&magic_init_mutex);\n#else /* USE_LOCKS */\n#define ACQUIRE_MAGIC_INIT_LOCK()\n#define RELEASE_MAGIC_INIT_LOCK()\n#endif /* USE_LOCKS */\n\n\n/* -----------------------  Chunk representations ------------------------ */\n\n/*\n  (The following includes lightly edited explanations by Colin Plumb.)\n\n  The malloc_chunk declaration below is misleading (but accurate and\n  necessary).  It declares a \"view\" into memory allowing access to\n  necessary fields at known offsets from a given base.\n\n  Chunks of memory are maintained using a `boundary tag' method as\n  originally described by Knuth.  (See the paper by Paul Wilson\n  ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a survey of such\n  techniques.)  Sizes of free chunks are stored both in the front of\n  each chunk and at the end.  This makes consolidating fragmented\n  chunks into bigger chunks fast.  The head fields also hold bits\n  representing whether chunks are free or in use.\n\n  Here are some pictures to make it clearer.  They are \"exploded\" to\n  show that the state of a chunk can be thought of as extending from\n  the high 31 bits of the head field of its header through the\n  prev_foot and PINUSE_BIT bit of the following chunk header.\n\n  A chunk that's in use looks like:\n\n   chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n           | Size of previous chunk (if P = 1)                             |\n           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|\n         | Size of this chunk                                         1| +-+\n   mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         |                                                               |\n         +-                                                             -+\n         |                                                               |\n         +-                                                             -+\n         |                                                               :\n         +-      size - sizeof(size_t) available payload bytes          -+\n         :                                                               |\n chunk-> +-                                                             -+\n         |                                                               |\n         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |1|\n       | Size of next chunk (may or may not be in use)               | +-+\n mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n    And if it's free, it looks like this:\n\n   chunk-> +-                                                             -+\n           | User payload (must be in use, or we would have merged!)       |\n           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|\n         | Size of this chunk                                         0| +-+\n   mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         | Next pointer                                                  |\n         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         | Prev pointer                                                  |\n         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         |                                                               :\n         +-      size - sizeof(struct chunk) unused bytes               -+\n         :                                                               |\n chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         | Size of this chunk                                            |\n         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0|\n       | Size of next chunk (must be in use, or we would have merged)| +-+\n mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |                                                               :\n       +- User payload                                                -+\n       :                                                               |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                                                                     |0|\n                                                                     +-+\n  Note that since we always merge adjacent free chunks, the chunks\n  adjacent to a free chunk must be in use.\n\n  Given a pointer to a chunk (which can be derived trivially from the\n  payload pointer) we can, in O(1) time, find out whether the adjacent\n  chunks are free, and if so, unlink them from the lists that they\n  are on and merge them with the current chunk.\n\n  Chunks always begin on even word boundaries, so the mem portion\n  (which is returned to the user) is also on an even word boundary, and\n  thus at least double-word aligned.\n\n  The P (PINUSE_BIT) bit, stored in the unused low-order bit of the\n  chunk size (which is always a multiple of two words), is an in-use\n  bit for the *previous* chunk.  If that bit is *clear*, then the\n  word before the current chunk size contains the previous chunk\n  size, and can be used to find the front of the previous chunk.\n  The very first chunk allocated always has this bit set, preventing\n  access to non-existent (or non-owned) memory. If pinuse is set for\n  any given chunk, then you CANNOT determine the size of the\n  previous chunk, and might even get a memory addressing fault when\n  trying to do so.\n\n  The C (CINUSE_BIT) bit, stored in the unused second-lowest bit of\n  the chunk size redundantly records whether the current chunk is\n  inuse. This redundancy enables usage checks within free and realloc,\n  and reduces indirection when freeing and consolidating chunks.\n\n  Each freshly allocated chunk must have both cinuse and pinuse set.\n  That is, each allocated chunk borders either a previously allocated\n  and still in-use chunk, or the base of its memory arena. This is\n  ensured by making all allocations from the the `lowest' part of any\n  found chunk.  Further, no free chunk physically borders another one,\n  so each free chunk is known to be preceded and followed by either\n  inuse chunks or the ends of memory.\n\n  Note that the `foot' of the current chunk is actually represented\n  as the prev_foot of the NEXT chunk. This makes it easier to\n  deal with alignments etc but can be very confusing when trying\n  to extend or adapt this code.\n\n  The exceptions to all this are\n\n     1. The special chunk `top' is the top-most available chunk (i.e.,\n        the one bordering the end of available memory). It is treated\n        specially.  Top is never included in any bin, is used only if\n        no other chunk is available, and is released back to the\n        system if it is very large (see M_TRIM_THRESHOLD).  In effect,\n        the top chunk is treated as larger (and thus less well\n        fitting) than any other available chunk.  The top chunk\n        doesn't update its trailing size field since there is no next\n        contiguous chunk that would have to index off it. However,\n        space is still allocated for it (TOP_FOOT_SIZE) to enable\n        separation or merging when space is extended.\n\n     3. Chunks allocated via mmap, which have the lowest-order bit\n        (IS_MMAPPED_BIT) set in their prev_foot fields, and do not set\n        PINUSE_BIT in their head fields.  Because they are allocated\n        one-by-one, each must carry its own prev_foot field, which is\n        also used to hold the offset this chunk has within its mmapped\n        region, which is needed to preserve alignment. Each mmapped\n        chunk is trailed by the first two fields of a fake next-chunk\n        for sake of usage checks.\n\n*/\n\nstruct malloc_chunk\n{\n    size_t prev_foot;           /* Size of previous chunk (if free).  */\n    size_t head;                /* Size and inuse bits. */\n    struct malloc_chunk *fd;    /* double links -- used only if free. */\n    struct malloc_chunk *bk;\n};\n\ntypedef struct malloc_chunk mchunk;\ntypedef struct malloc_chunk *mchunkptr;\ntypedef struct malloc_chunk *sbinptr;   /* The type of bins of chunks */\ntypedef size_t bindex_t;        /* Described below */\ntypedef unsigned int binmap_t;  /* Described below */\ntypedef unsigned int flag_t;    /* The type of various bit flag sets */\n\n/* ------------------- Chunks sizes and alignments ----------------------- */\n\n#define MCHUNK_SIZE         (sizeof(mchunk))\n\n#if FOOTERS\n#define CHUNK_OVERHEAD      (TWO_SIZE_T_SIZES)\n#else /* FOOTERS */\n#define CHUNK_OVERHEAD      (SIZE_T_SIZE)\n#endif /* FOOTERS */\n\n/* MMapped chunks need a second word of overhead ... */\n#define MMAP_CHUNK_OVERHEAD (TWO_SIZE_T_SIZES)\n/* ... and additional padding for fake next-chunk at foot */\n#define MMAP_FOOT_PAD       (FOUR_SIZE_T_SIZES)\n\n/* The smallest size we can malloc is an aligned minimal chunk */\n#define MIN_CHUNK_SIZE\\\n  ((MCHUNK_SIZE + CHUNK_ALIGN_MASK) & ~CHUNK_ALIGN_MASK)\n\n/* conversion from malloc headers to user pointers, and back */\n#define chunk2mem(p)        ((void*)((char*)(p)       + TWO_SIZE_T_SIZES))\n#define mem2chunk(mem)      ((mchunkptr)((char*)(mem) - TWO_SIZE_T_SIZES))\n/* chunk associated with aligned address A */\n#define align_as_chunk(A)   (mchunkptr)((A) + align_offset(chunk2mem(A)))\n\n/* Bounds on request (not chunk) sizes. */\n#define MAX_REQUEST         ((-MIN_CHUNK_SIZE) << 2)\n#define MIN_REQUEST         (MIN_CHUNK_SIZE - CHUNK_OVERHEAD - SIZE_T_ONE)\n\n/* pad request bytes into a usable size */\n#define pad_request(req) \\\n   (((req) + CHUNK_OVERHEAD + CHUNK_ALIGN_MASK) & ~CHUNK_ALIGN_MASK)\n\n/* pad request, checking for minimum (but not maximum) */\n#define request2size(req) \\\n  (((req) < MIN_REQUEST)? MIN_CHUNK_SIZE : pad_request(req))\n\n\n/* ------------------ Operations on head and foot fields ----------------- */\n\n/*\n  The head field of a chunk is or'ed with PINUSE_BIT when previous\n  adjacent chunk in use, and or'ed with CINUSE_BIT if this chunk is in\n  use. If the chunk was obtained with mmap, the prev_foot field has\n  IS_MMAPPED_BIT set, otherwise holding the offset of the base of the\n  mmapped region to the base of the chunk.\n*/\n\n#define PINUSE_BIT          (SIZE_T_ONE)\n#define CINUSE_BIT          (SIZE_T_TWO)\n#define INUSE_BITS          (PINUSE_BIT|CINUSE_BIT)\n\n/* Head value for fenceposts */\n#define FENCEPOST_HEAD      (INUSE_BITS|SIZE_T_SIZE)\n\n/* extraction of fields from head words */\n#define cinuse(p)           ((p)->head & CINUSE_BIT)\n#define pinuse(p)           ((p)->head & PINUSE_BIT)\n#define chunksize(p)        ((p)->head & ~(INUSE_BITS))\n\n#define clear_pinuse(p)     ((p)->head &= ~PINUSE_BIT)\n#define clear_cinuse(p)     ((p)->head &= ~CINUSE_BIT)\n\n/* Treat space at ptr +/- offset as a chunk */\n#define chunk_plus_offset(p, s)  ((mchunkptr)(((char*)(p)) + (s)))\n#define chunk_minus_offset(p, s) ((mchunkptr)(((char*)(p)) - (s)))\n\n/* Ptr to next or previous physical malloc_chunk. */\n#define next_chunk(p) ((mchunkptr)( ((char*)(p)) + ((p)->head & ~INUSE_BITS)))\n#define prev_chunk(p) ((mchunkptr)( ((char*)(p)) - ((p)->prev_foot) ))\n\n/* extract next chunk's pinuse bit */\n#define next_pinuse(p)  ((next_chunk(p)->head) & PINUSE_BIT)\n\n/* Get/set size at footer */\n#define get_foot(p, s)  (((mchunkptr)((char*)(p) + (s)))->prev_foot)\n#define set_foot(p, s)  (((mchunkptr)((char*)(p) + (s)))->prev_foot = (s))\n\n/* Set size, pinuse bit, and foot */\n#define set_size_and_pinuse_of_free_chunk(p, s)\\\n  ((p)->head = (s|PINUSE_BIT), set_foot(p, s))\n\n/* Set size, pinuse bit, foot, and clear next pinuse */\n#define set_free_with_pinuse(p, s, n)\\\n  (clear_pinuse(n), set_size_and_pinuse_of_free_chunk(p, s))\n\n#define is_mmapped(p)\\\n  (!((p)->head & PINUSE_BIT) && ((p)->prev_foot & IS_MMAPPED_BIT))\n\n/* Get the internal overhead associated with chunk p */\n#define overhead_for(p)\\\n (is_mmapped(p)? MMAP_CHUNK_OVERHEAD : CHUNK_OVERHEAD)\n\n/* Return true if malloced space is not necessarily cleared */\n#if MMAP_CLEARS\n#define calloc_must_clear(p) (!is_mmapped(p))\n#else /* MMAP_CLEARS */\n#define calloc_must_clear(p) (1)\n#endif /* MMAP_CLEARS */\n\n/* ---------------------- Overlaid data structures ----------------------- */\n\n/*\n  When chunks are not in use, they are treated as nodes of either\n  lists or trees.\n\n  \"Small\"  chunks are stored in circular doubly-linked lists, and look\n  like this:\n\n    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             Size of previous chunk                            |\n            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    `head:' |             Size of chunk, in bytes                         |P|\n      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             Forward pointer to next chunk in list             |\n            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             Back pointer to previous chunk in list            |\n            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             Unused space (may be 0 bytes long)                .\n            .                                                               .\n            .                                                               |\nnextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    `foot:' |             Size of chunk, in bytes                           |\n            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n  Larger chunks are kept in a form of bitwise digital trees (aka\n  tries) keyed on chunksizes.  Because malloc_tree_chunks are only for\n  free chunks greater than 256 bytes, their size doesn't impose any\n  constraints on user chunk sizes.  Each node looks like:\n\n    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             Size of previous chunk                            |\n            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    `head:' |             Size of chunk, in bytes                         |P|\n      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             Forward pointer to next chunk of same size        |\n            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             Back pointer to previous chunk of same size       |\n            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             Pointer to left child (child[0])                  |\n            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             Pointer to right child (child[1])                 |\n            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             Pointer to parent                                 |\n            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             bin index of this chunk                           |\n            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             Unused space                                      .\n            .                                                               |\nnextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    `foot:' |             Size of chunk, in bytes                           |\n            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n  Each tree holding treenodes is a tree of unique chunk sizes.  Chunks\n  of the same size are arranged in a circularly-linked list, with only\n  the oldest chunk (the next to be used, in our FIFO ordering)\n  actually in the tree.  (Tree members are distinguished by a non-null\n  parent pointer.)  If a chunk with the same size an an existing node\n  is inserted, it is linked off the existing node using pointers that\n  work in the same way as fd/bk pointers of small chunks.\n\n  Each tree contains a power of 2 sized range of chunk sizes (the\n  smallest is 0x100 <= x < 0x180), which is is divided in half at each\n  tree level, with the chunks in the smaller half of the range (0x100\n  <= x < 0x140 for the top nose) in the left subtree and the larger\n  half (0x140 <= x < 0x180) in the right subtree.  This is, of course,\n  done by inspecting individual bits.\n\n  Using these rules, each node's left subtree contains all smaller\n  sizes than its right subtree.  However, the node at the root of each\n  subtree has no particular ordering relationship to either.  (The\n  dividing line between the subtree sizes is based on trie relation.)\n  If we remove the last chunk of a given size from the interior of the\n  tree, we need to replace it with a leaf node.  The tree ordering\n  rules permit a node to be replaced by any leaf below it.\n\n  The smallest chunk in a tree (a common operation in a best-fit\n  allocator) can be found by walking a path to the leftmost leaf in\n  the tree.  Unlike a usual binary tree, where we follow left child\n  pointers until we reach a null, here we follow the right child\n  pointer any time the left one is null, until we reach a leaf with\n  both child pointers null. The smallest chunk in the tree will be\n  somewhere along that path.\n\n  The worst case number of steps to add, find, or remove a node is\n  bounded by the number of bits differentiating chunks within\n  bins. Under current bin calculations, this ranges from 6 up to 21\n  (for 32 bit sizes) or up to 53 (for 64 bit sizes). The typical case\n  is of course much better.\n*/\n\nstruct malloc_tree_chunk\n{\n    /* The first four fields must be compatible with malloc_chunk */\n    size_t prev_foot;\n    size_t head;\n    struct malloc_tree_chunk *fd;\n    struct malloc_tree_chunk *bk;\n\n    struct malloc_tree_chunk *child[2];\n    struct malloc_tree_chunk *parent;\n    bindex_t index;\n};\n\ntypedef struct malloc_tree_chunk tchunk;\ntypedef struct malloc_tree_chunk *tchunkptr;\ntypedef struct malloc_tree_chunk *tbinptr;      /* The type of bins of trees */\n\n/* A little helper macro for trees */\n#define leftmost_child(t) ((t)->child[0] != 0? (t)->child[0] : (t)->child[1])\n\n/* ----------------------------- Segments -------------------------------- */\n\n/*\n  Each malloc space may include non-contiguous segments, held in a\n  list headed by an embedded malloc_segment record representing the\n  top-most space. Segments also include flags holding properties of\n  the space. Large chunks that are directly allocated by mmap are not\n  included in this list. They are instead independently created and\n  destroyed without otherwise keeping track of them.\n\n  Segment management mainly comes into play for spaces allocated by\n  MMAP.  Any call to MMAP might or might not return memory that is\n  adjacent to an existing segment.  MORECORE normally contiguously\n  extends the current space, so this space is almost always adjacent,\n  which is simpler and faster to deal with. (This is why MORECORE is\n  used preferentially to MMAP when both are available -- see\n  sys_alloc.)  When allocating using MMAP, we don't use any of the\n  hinting mechanisms (inconsistently) supported in various\n  implementations of unix mmap, or distinguish reserving from\n  committing memory. Instead, we just ask for space, and exploit\n  contiguity when we get it.  It is probably possible to do\n  better than this on some systems, but no general scheme seems\n  to be significantly better.\n\n  Management entails a simpler variant of the consolidation scheme\n  used for chunks to reduce fragmentation -- new adjacent memory is\n  normally prepended or appended to an existing segment. However,\n  there are limitations compared to chunk consolidation that mostly\n  reflect the fact that segment processing is relatively infrequent\n  (occurring only when getting memory from system) and that we\n  don't expect to have huge numbers of segments:\n\n  * Segments are not indexed, so traversal requires linear scans.  (It\n    would be possible to index these, but is not worth the extra\n    overhead and complexity for most programs on most platforms.)\n  * New segments are only appended to old ones when holding top-most\n    memory; if they cannot be prepended to others, they are held in\n    different segments.\n\n  Except for the top-most segment of an mstate, each segment record\n  is kept at the tail of its segment. Segments are added by pushing\n  segment records onto the list headed by &mstate.seg for the\n  containing mstate.\n\n  Segment flags control allocation/merge/deallocation policies:\n  * If EXTERN_BIT set, then we did not allocate this segment,\n    and so should not try to deallocate or merge with others.\n    (This currently holds only for the initial segment passed\n    into create_mspace_with_base.)\n  * If IS_MMAPPED_BIT set, the segment may be merged with\n    other surrounding mmapped segments and trimmed/de-allocated\n    using munmap.\n  * If neither bit is set, then the segment was obtained using\n    MORECORE so can be merged with surrounding MORECORE'd segments\n    and deallocated/trimmed using MORECORE with negative arguments.\n*/\n\nstruct malloc_segment\n{\n    char *base;                 /* base address */\n    size_t size;                /* allocated size */\n    struct malloc_segment *next;        /* ptr to next segment */\n    flag_t sflags;              /* mmap and extern flag */\n};\n\n#define is_mmapped_segment(S)  ((S)->sflags & IS_MMAPPED_BIT)\n#define is_extern_segment(S)   ((S)->sflags & EXTERN_BIT)\n\ntypedef struct malloc_segment msegment;\ntypedef struct malloc_segment *msegmentptr;\n\n/* ---------------------------- malloc_state ----------------------------- */\n\n/*\n   A malloc_state holds all of the bookkeeping for a space.\n   The main fields are:\n\n  Top\n    The topmost chunk of the currently active segment. Its size is\n    cached in topsize.  The actual size of topmost space is\n    topsize+TOP_FOOT_SIZE, which includes space reserved for adding\n    fenceposts and segment records if necessary when getting more\n    space from the system.  The size at which to autotrim top is\n    cached from mparams in trim_check, except that it is disabled if\n    an autotrim fails.\n\n  Designated victim (dv)\n    This is the preferred chunk for servicing small requests that\n    don't have exact fits.  It is normally the chunk split off most\n    recently to service another small request.  Its size is cached in\n    dvsize. The link fields of this chunk are not maintained since it\n    is not kept in a bin.\n\n  SmallBins\n    An array of bin headers for free chunks.  These bins hold chunks\n    with sizes less than MIN_LARGE_SIZE bytes. Each bin contains\n    chunks of all the same size, spaced 8 bytes apart.  To simplify\n    use in double-linked lists, each bin header acts as a malloc_chunk\n    pointing to the real first node, if it exists (else pointing to\n    itself).  This avoids special-casing for headers.  But to avoid\n    waste, we allocate only the fd/bk pointers of bins, and then use\n    repositioning tricks to treat these as the fields of a chunk.\n\n  TreeBins\n    Treebins are pointers to the roots of trees holding a range of\n    sizes. There are 2 equally spaced treebins for each power of two\n    from TREE_SHIFT to TREE_SHIFT+16. The last bin holds anything\n    larger.\n\n  Bin maps\n    There is one bit map for small bins (\"smallmap\") and one for\n    treebins (\"treemap).  Each bin sets its bit when non-empty, and\n    clears the bit when empty.  Bit operations are then used to avoid\n    bin-by-bin searching -- nearly all \"search\" is done without ever\n    looking at bins that won't be selected.  The bit maps\n    conservatively use 32 bits per map word, even if on 64bit system.\n    For a good description of some of the bit-based techniques used\n    here, see Henry S. Warren Jr's book \"Hacker's Delight\" (and\n    supplement at http://hackersdelight.org/). Many of these are\n    intended to reduce the branchiness of paths through malloc etc, as\n    well as to reduce the number of memory locations read or written.\n\n  Segments\n    A list of segments headed by an embedded malloc_segment record\n    representing the initial space.\n\n  Address check support\n    The least_addr field is the least address ever obtained from\n    MORECORE or MMAP. Attempted frees and reallocs of any address less\n    than this are trapped (unless INSECURE is defined).\n\n  Magic tag\n    A cross-check field that should always hold same value as mparams.magic.\n\n  Flags\n    Bits recording whether to use MMAP, locks, or contiguous MORECORE\n\n  Statistics\n    Each space keeps track of current and maximum system memory\n    obtained via MORECORE or MMAP.\n\n  Locking\n    If USE_LOCKS is defined, the \"mutex\" lock is acquired and released\n    around every public call using this mspace.\n*/\n\n/* Bin types, widths and sizes */\n#define NSMALLBINS        (32U)\n#define NTREEBINS         (32U)\n#define SMALLBIN_SHIFT    (3U)\n#define SMALLBIN_WIDTH    (SIZE_T_ONE << SMALLBIN_SHIFT)\n#define TREEBIN_SHIFT     (8U)\n#define MIN_LARGE_SIZE    (SIZE_T_ONE << TREEBIN_SHIFT)\n#define MAX_SMALL_SIZE    (MIN_LARGE_SIZE - SIZE_T_ONE)\n#define MAX_SMALL_REQUEST (MAX_SMALL_SIZE - CHUNK_ALIGN_MASK - CHUNK_OVERHEAD)\n\nstruct malloc_state\n{\n    binmap_t smallmap;\n    binmap_t treemap;\n    size_t dvsize;\n    size_t topsize;\n    char *least_addr;\n    mchunkptr dv;\n    mchunkptr top;\n    size_t trim_check;\n    size_t magic;\n    mchunkptr smallbins[(NSMALLBINS + 1) * 2];\n    tbinptr treebins[NTREEBINS];\n    size_t footprint;\n    size_t max_footprint;\n    flag_t mflags;\n#if USE_LOCKS\n    MLOCK_T mutex;              /* locate lock among fields that rarely change */\n#endif                          /* USE_LOCKS */\n    msegment seg;\n};\n\ntypedef struct malloc_state *mstate;\n\n/* ------------- Global malloc_state and malloc_params ------------------- */\n\n/*\n  malloc_params holds global properties, including those that can be\n  dynamically set using mallopt. There is a single instance, mparams,\n  initialized in init_mparams.\n*/\n\nstruct malloc_params\n{\n    size_t magic;\n    size_t page_size;\n    size_t granularity;\n    size_t mmap_threshold;\n    size_t trim_threshold;\n    flag_t default_mflags;\n};\n\nstatic struct malloc_params mparams;\n\n/* The global malloc_state used for all non-\"mspace\" calls */\nstatic struct malloc_state _gm_;\n#define gm                 (&_gm_)\n#define is_global(M)       ((M) == &_gm_)\n#define is_initialized(M)  ((M)->top != 0)\n\n/* -------------------------- system alloc setup ------------------------- */\n\n/* Operations on mflags */\n\n#define use_lock(M)           ((M)->mflags &   USE_LOCK_BIT)\n#define enable_lock(M)        ((M)->mflags |=  USE_LOCK_BIT)\n#define disable_lock(M)       ((M)->mflags &= ~USE_LOCK_BIT)\n\n#define use_mmap(M)           ((M)->mflags &   USE_MMAP_BIT)\n#define enable_mmap(M)        ((M)->mflags |=  USE_MMAP_BIT)\n#define disable_mmap(M)       ((M)->mflags &= ~USE_MMAP_BIT)\n\n#define use_noncontiguous(M)  ((M)->mflags &   USE_NONCONTIGUOUS_BIT)\n#define disable_contiguous(M) ((M)->mflags |=  USE_NONCONTIGUOUS_BIT)\n\n#define set_lock(M,L)\\\n ((M)->mflags = (L)?\\\n  ((M)->mflags | USE_LOCK_BIT) :\\\n  ((M)->mflags & ~USE_LOCK_BIT))\n\n/* page-align a size */\n#define page_align(S)\\\n (((S) + (mparams.page_size)) & ~(mparams.page_size - SIZE_T_ONE))\n\n/* granularity-align a size */\n#define granularity_align(S)\\\n  (((S) + (mparams.granularity)) & ~(mparams.granularity - SIZE_T_ONE))\n\n#define is_page_aligned(S)\\\n   (((size_t)(S) & (mparams.page_size - SIZE_T_ONE)) == 0)\n#define is_granularity_aligned(S)\\\n   (((size_t)(S) & (mparams.granularity - SIZE_T_ONE)) == 0)\n\n/*  True if segment S holds address A */\n#define segment_holds(S, A)\\\n  ((char*)(A) >= S->base && (char*)(A) < S->base + S->size)\n\n/* Return segment holding given address */\nstatic msegmentptr\nsegment_holding(mstate m, char *addr)\n{\n    msegmentptr sp = &m->seg;\n    for (;;) {\n        if (addr >= sp->base && addr < sp->base + sp->size)\n            return sp;\n        if ((sp = sp->next) == 0)\n            return 0;\n    }\n}\n\n/* Return true if segment contains a segment link */\nstatic int\nhas_segment_link(mstate m, msegmentptr ss)\n{\n    msegmentptr sp = &m->seg;\n    for (;;) {\n        if ((char *) sp >= ss->base && (char *) sp < ss->base + ss->size)\n            return 1;\n        if ((sp = sp->next) == 0)\n            return 0;\n    }\n}\n\n#ifndef MORECORE_CANNOT_TRIM\n#define should_trim(M,s)  ((s) > (M)->trim_check)\n#else /* MORECORE_CANNOT_TRIM */\n#define should_trim(M,s)  (0)\n#endif /* MORECORE_CANNOT_TRIM */\n\n/*\n  TOP_FOOT_SIZE is padding at the end of a segment, including space\n  that may be needed to place segment records and fenceposts when new\n  noncontiguous segments are added.\n*/\n#define TOP_FOOT_SIZE\\\n  (align_offset(chunk2mem(0))+pad_request(sizeof(struct malloc_segment))+MIN_CHUNK_SIZE)\n\n\n/* -------------------------------  Hooks -------------------------------- */\n\n/*\n  PREACTION should be defined to return 0 on success, and nonzero on\n  failure. If you are not using locking, you can redefine these to do\n  anything you like.\n*/\n\n#if USE_LOCKS\n\n/* Ensure locks are initialized */\n#define GLOBALLY_INITIALIZE() (mparams.page_size == 0 && init_mparams())\n\n#define PREACTION(M)  ((GLOBALLY_INITIALIZE() || use_lock(M))? ACQUIRE_LOCK(&(M)->mutex) : 0)\n#define POSTACTION(M) { if (use_lock(M)) RELEASE_LOCK(&(M)->mutex); }\n#else /* USE_LOCKS */\n\n#ifndef PREACTION\n#define PREACTION(M) (0)\n#endif /* PREACTION */\n\n#ifndef POSTACTION\n#define POSTACTION(M)\n#endif /* POSTACTION */\n\n#endif /* USE_LOCKS */\n\n/*\n  CORRUPTION_ERROR_ACTION is triggered upon detected bad addresses.\n  USAGE_ERROR_ACTION is triggered on detected bad frees and\n  reallocs. The argument p is an address that might have triggered the\n  fault. It is ignored by the two predefined actions, but might be\n  useful in custom actions that try to help diagnose errors.\n*/\n\n#if PROCEED_ON_ERROR\n\n/* A count of the number of corruption errors causing resets */\nint malloc_corruption_error_count;\n\n/* default corruption action */\nstatic void reset_on_error(mstate m);\n\n#define CORRUPTION_ERROR_ACTION(m)  reset_on_error(m)\n#define USAGE_ERROR_ACTION(m, p)\n\n#else /* PROCEED_ON_ERROR */\n\n#ifndef CORRUPTION_ERROR_ACTION\n#define CORRUPTION_ERROR_ACTION(m) ABORT\n#endif /* CORRUPTION_ERROR_ACTION */\n\n#ifndef USAGE_ERROR_ACTION\n#define USAGE_ERROR_ACTION(m,p) ABORT\n#endif /* USAGE_ERROR_ACTION */\n\n#endif /* PROCEED_ON_ERROR */\n\n/* -------------------------- Debugging setup ---------------------------- */\n\n#if ! DEBUG\n\n#define check_free_chunk(M,P)\n#define check_inuse_chunk(M,P)\n#define check_malloced_chunk(M,P,N)\n#define check_mmapped_chunk(M,P)\n#define check_malloc_state(M)\n#define check_top_chunk(M,P)\n\n#else /* DEBUG */\n#define check_free_chunk(M,P)       do_check_free_chunk(M,P)\n#define check_inuse_chunk(M,P)      do_check_inuse_chunk(M,P)\n#define check_top_chunk(M,P)        do_check_top_chunk(M,P)\n#define check_malloced_chunk(M,P,N) do_check_malloced_chunk(M,P,N)\n#define check_mmapped_chunk(M,P)    do_check_mmapped_chunk(M,P)\n#define check_malloc_state(M)       do_check_malloc_state(M)\n\nstatic void do_check_any_chunk(mstate m, mchunkptr p);\nstatic void do_check_top_chunk(mstate m, mchunkptr p);\nstatic void do_check_mmapped_chunk(mstate m, mchunkptr p);\nstatic void do_check_inuse_chunk(mstate m, mchunkptr p);\nstatic void do_check_free_chunk(mstate m, mchunkptr p);\nstatic void do_check_malloced_chunk(mstate m, void *mem, size_t s);\nstatic void do_check_tree(mstate m, tchunkptr t);\nstatic void do_check_treebin(mstate m, bindex_t i);\nstatic void do_check_smallbin(mstate m, bindex_t i);\nstatic void do_check_malloc_state(mstate m);\nstatic int bin_find(mstate m, mchunkptr x);\nstatic size_t traverse_and_check(mstate m);\n#endif /* DEBUG */\n\n/* ---------------------------- Indexing Bins ---------------------------- */\n\n#define is_small(s)         (((s) >> SMALLBIN_SHIFT) < NSMALLBINS)\n#define small_index(s)      ((s)  >> SMALLBIN_SHIFT)\n#define small_index2size(i) ((i)  << SMALLBIN_SHIFT)\n#define MIN_SMALL_INDEX     (small_index(MIN_CHUNK_SIZE))\n\n/* addressing by index. See above about smallbin repositioning */\n#define smallbin_at(M, i)   ((sbinptr)((char*)&((M)->smallbins[(i)<<1])))\n#define treebin_at(M,i)     (&((M)->treebins[i]))\n\n/* assign tree index for size S to variable I */\n#if defined(__GNUC__) && defined(i386)\n#define compute_tree_index(S, I)\\\n{\\\n  size_t X = S >> TREEBIN_SHIFT;\\\n  if (X == 0)\\\n    I = 0;\\\n  else if (X > 0xFFFF)\\\n    I = NTREEBINS-1;\\\n  else {\\\n    unsigned int K;\\\n    __asm__(\"bsrl %1,%0\\n\\t\" : \"=r\" (K) : \"rm\"  (X));\\\n    I =  (bindex_t)((K << 1) + ((S >> (K + (TREEBIN_SHIFT-1)) & 1)));\\\n  }\\\n}\n#else /* GNUC */\n#define compute_tree_index(S, I)\\\n{\\\n  size_t X = S >> TREEBIN_SHIFT;\\\n  if (X == 0)\\\n    I = 0;\\\n  else if (X > 0xFFFF)\\\n    I = NTREEBINS-1;\\\n  else {\\\n    unsigned int Y = (unsigned int)X;\\\n    unsigned int N = ((Y - 0x100) >> 16) & 8;\\\n    unsigned int K = (((Y <<= N) - 0x1000) >> 16) & 4;\\\n    N += K;\\\n    N += K = (((Y <<= K) - 0x4000) >> 16) & 2;\\\n    K = 14 - N + ((Y <<= K) >> 15);\\\n    I = (K << 1) + ((S >> (K + (TREEBIN_SHIFT-1)) & 1));\\\n  }\\\n}\n#endif /* GNUC */\n\n/* Bit representing maximum resolved size in a treebin at i */\n#define bit_for_tree_index(i) \\\n   (i == NTREEBINS-1)? (SIZE_T_BITSIZE-1) : (((i) >> 1) + TREEBIN_SHIFT - 2)\n\n/* Shift placing maximum resolved bit in a treebin at i as sign bit */\n#define leftshift_for_tree_index(i) \\\n   ((i == NTREEBINS-1)? 0 : \\\n    ((SIZE_T_BITSIZE-SIZE_T_ONE) - (((i) >> 1) + TREEBIN_SHIFT - 2)))\n\n/* The size of the smallest chunk held in bin with index i */\n#define minsize_for_tree_index(i) \\\n   ((SIZE_T_ONE << (((i) >> 1) + TREEBIN_SHIFT)) |  \\\n   (((size_t)((i) & SIZE_T_ONE)) << (((i) >> 1) + TREEBIN_SHIFT - 1)))\n\n\n/* ------------------------ Operations on bin maps ----------------------- */\n\n/* bit corresponding to given index */\n#define idx2bit(i)              ((binmap_t)(1) << (i))\n\n/* Mark/Clear bits with given index */\n#define mark_smallmap(M,i)      ((M)->smallmap |=  idx2bit(i))\n#define clear_smallmap(M,i)     ((M)->smallmap &= ~idx2bit(i))\n#define smallmap_is_marked(M,i) ((M)->smallmap &   idx2bit(i))\n\n#define mark_treemap(M,i)       ((M)->treemap  |=  idx2bit(i))\n#define clear_treemap(M,i)      ((M)->treemap  &= ~idx2bit(i))\n#define treemap_is_marked(M,i)  ((M)->treemap  &   idx2bit(i))\n\n/* index corresponding to given bit */\n\n#if defined(__GNUC__) && defined(i386)\n#define compute_bit2idx(X, I)\\\n{\\\n  unsigned int J;\\\n  __asm__(\"bsfl %1,%0\\n\\t\" : \"=r\" (J) : \"rm\" (X));\\\n  I = (bindex_t)J;\\\n}\n\n#else /* GNUC */\n#if  USE_BUILTIN_FFS\n#define compute_bit2idx(X, I) I = ffs(X)-1\n\n#else /* USE_BUILTIN_FFS */\n#define compute_bit2idx(X, I)\\\n{\\\n  unsigned int Y = X - 1;\\\n  unsigned int K = Y >> (16-4) & 16;\\\n  unsigned int N = K;        Y >>= K;\\\n  N += K = Y >> (8-3) &  8;  Y >>= K;\\\n  N += K = Y >> (4-2) &  4;  Y >>= K;\\\n  N += K = Y >> (2-1) &  2;  Y >>= K;\\\n  N += K = Y >> (1-0) &  1;  Y >>= K;\\\n  I = (bindex_t)(N + Y);\\\n}\n#endif /* USE_BUILTIN_FFS */\n#endif /* GNUC */\n\n/* isolate the least set bit of a bitmap */\n#define least_bit(x)         ((x) & -(x))\n\n/* mask with all bits to left of least bit of x on */\n#define left_bits(x)         ((x<<1) | -(x<<1))\n\n/* mask with all bits to left of or equal to least bit of x on */\n#define same_or_left_bits(x) ((x) | -(x))\n\n\n/* ----------------------- Runtime Check Support ------------------------- */\n\n/*\n  For security, the main invariant is that malloc/free/etc never\n  writes to a static address other than malloc_state, unless static\n  malloc_state itself has been corrupted, which cannot occur via\n  malloc (because of these checks). In essence this means that we\n  believe all pointers, sizes, maps etc held in malloc_state, but\n  check all of those linked or offsetted from other embedded data\n  structures.  These checks are interspersed with main code in a way\n  that tends to minimize their run-time cost.\n\n  When FOOTERS is defined, in addition to range checking, we also\n  verify footer fields of inuse chunks, which can be used guarantee\n  that the mstate controlling malloc/free is intact.  This is a\n  streamlined version of the approach described by William Robertson\n  et al in \"Run-time Detection of Heap-based Overflows\" LISA'03\n  http://www.usenix.org/events/lisa03/tech/robertson.html The footer\n  of an inuse chunk holds the xor of its mstate and a random seed,\n  that is checked upon calls to free() and realloc().  This is\n  (probablistically) unguessable from outside the program, but can be\n  computed by any code successfully malloc'ing any chunk, so does not\n  itself provide protection against code that has already broken\n  security through some other means.  Unlike Robertson et al, we\n  always dynamically check addresses of all offset chunks (previous,\n  next, etc). This turns out to be cheaper than relying on hashes.\n*/\n\n#if !INSECURE\n/* Check if address a is at least as high as any from MORECORE or MMAP */\n#define ok_address(M, a) ((char*)(a) >= (M)->least_addr)\n/* Check if address of next chunk n is higher than base chunk p */\n#define ok_next(p, n)    ((char*)(p) < (char*)(n))\n/* Check if p has its cinuse bit on */\n#define ok_cinuse(p)     cinuse(p)\n/* Check if p has its pinuse bit on */\n#define ok_pinuse(p)     pinuse(p)\n\n#else /* !INSECURE */\n#define ok_address(M, a) (1)\n#define ok_next(b, n)    (1)\n#define ok_cinuse(p)     (1)\n#define ok_pinuse(p)     (1)\n#endif /* !INSECURE */\n\n#if (FOOTERS && !INSECURE)\n/* Check if (alleged) mstate m has expected magic field */\n#define ok_magic(M)      ((M)->magic == mparams.magic)\n#else /* (FOOTERS && !INSECURE) */\n#define ok_magic(M)      (1)\n#endif /* (FOOTERS && !INSECURE) */\n\n\n/* In gcc, use __builtin_expect to minimize impact of checks */\n#if !INSECURE\n#if defined(__GNUC__) && __GNUC__ >= 3\n#define RTCHECK(e)  __builtin_expect(e, 1)\n#else /* GNUC */\n#define RTCHECK(e)  (e)\n#endif /* GNUC */\n#else /* !INSECURE */\n#define RTCHECK(e)  (1)\n#endif /* !INSECURE */\n\n/* macros to set up inuse chunks with or without footers */\n\n#if !FOOTERS\n\n#define mark_inuse_foot(M,p,s)\n\n/* Set cinuse bit and pinuse bit of next chunk */\n#define set_inuse(M,p,s)\\\n  ((p)->head = (((p)->head & PINUSE_BIT)|s|CINUSE_BIT),\\\n  ((mchunkptr)(((char*)(p)) + (s)))->head |= PINUSE_BIT)\n\n/* Set cinuse and pinuse of this chunk and pinuse of next chunk */\n#define set_inuse_and_pinuse(M,p,s)\\\n  ((p)->head = (s|PINUSE_BIT|CINUSE_BIT),\\\n  ((mchunkptr)(((char*)(p)) + (s)))->head |= PINUSE_BIT)\n\n/* Set size, cinuse and pinuse bit of this chunk */\n#define set_size_and_pinuse_of_inuse_chunk(M, p, s)\\\n  ((p)->head = (s|PINUSE_BIT|CINUSE_BIT))\n\n#else /* FOOTERS */\n\n/* Set foot of inuse chunk to be xor of mstate and seed */\n#define mark_inuse_foot(M,p,s)\\\n  (((mchunkptr)((char*)(p) + (s)))->prev_foot = ((size_t)(M) ^ mparams.magic))\n\n#define get_mstate_for(p)\\\n  ((mstate)(((mchunkptr)((char*)(p) +\\\n    (chunksize(p))))->prev_foot ^ mparams.magic))\n\n#define set_inuse(M,p,s)\\\n  ((p)->head = (((p)->head & PINUSE_BIT)|s|CINUSE_BIT),\\\n  (((mchunkptr)(((char*)(p)) + (s)))->head |= PINUSE_BIT), \\\n  mark_inuse_foot(M,p,s))\n\n#define set_inuse_and_pinuse(M,p,s)\\\n  ((p)->head = (s|PINUSE_BIT|CINUSE_BIT),\\\n  (((mchunkptr)(((char*)(p)) + (s)))->head |= PINUSE_BIT),\\\n mark_inuse_foot(M,p,s))\n\n#define set_size_and_pinuse_of_inuse_chunk(M, p, s)\\\n  ((p)->head = (s|PINUSE_BIT|CINUSE_BIT),\\\n  mark_inuse_foot(M, p, s))\n\n#endif /* !FOOTERS */\n\n/* ---------------------------- setting mparams -------------------------- */\n\n/* Initialize mparams */\nstatic int\ninit_mparams(void)\n{\n    if (mparams.page_size == 0) {\n        size_t s;\n\n        mparams.mmap_threshold = DEFAULT_MMAP_THRESHOLD;\n        mparams.trim_threshold = DEFAULT_TRIM_THRESHOLD;\n#if MORECORE_CONTIGUOUS\n        mparams.default_mflags = USE_LOCK_BIT | USE_MMAP_BIT;\n#else /* MORECORE_CONTIGUOUS */\n        mparams.default_mflags =\n            USE_LOCK_BIT | USE_MMAP_BIT | USE_NONCONTIGUOUS_BIT;\n#endif /* MORECORE_CONTIGUOUS */\n\n#if (FOOTERS && !INSECURE)\n        {\n#if USE_DEV_RANDOM\n            int fd;\n            unsigned char buf[sizeof(size_t)];\n            /* Try to use /dev/urandom, else fall back on using time */\n            if ((fd = open(\"/dev/urandom\", O_RDONLY)) >= 0 &&\n                read(fd, buf, sizeof(buf)) == sizeof(buf)) {\n                s = *((size_t *) buf);\n                close(fd);\n            } else\n#endif /* USE_DEV_RANDOM */\n                s = (size_t) (time(0) ^ (size_t) 0x55555555U);\n\n            s |= (size_t) 8U;   /* ensure nonzero */\n            s &= ~(size_t) 7U;  /* improve chances of fault for bad values */\n\n        }\n#else /* (FOOTERS && !INSECURE) */\n        s = (size_t) 0x58585858U;\n#endif /* (FOOTERS && !INSECURE) */\n        ACQUIRE_MAGIC_INIT_LOCK();\n        if (mparams.magic == 0) {\n            mparams.magic = s;\n            /* Set up lock for main malloc area */\n            INITIAL_LOCK(&gm->mutex);\n            gm->mflags = mparams.default_mflags;\n        }\n        RELEASE_MAGIC_INIT_LOCK();\n\n#ifndef WIN32\n        mparams.page_size = malloc_getpagesize;\n        mparams.granularity = ((DEFAULT_GRANULARITY != 0) ?\n                               DEFAULT_GRANULARITY : mparams.page_size);\n#else /* WIN32 */\n        {\n            SYSTEM_INFO system_info;\n            GetSystemInfo(&system_info);\n            mparams.page_size = system_info.dwPageSize;\n            mparams.granularity = system_info.dwAllocationGranularity;\n        }\n#endif /* WIN32 */\n\n        /* Sanity-check configuration:\n           size_t must be unsigned and as wide as pointer type.\n           ints must be at least 4 bytes.\n           alignment must be at least 8.\n           Alignment, min chunk size, and page size must all be powers of 2.\n         */\n        if ((sizeof(size_t) != sizeof(char *)) ||\n            (MAX_SIZE_T < MIN_CHUNK_SIZE) ||\n            (sizeof(int) < 4) ||\n            (MALLOC_ALIGNMENT < (size_t) 8U) ||\n            ((MALLOC_ALIGNMENT & (MALLOC_ALIGNMENT - SIZE_T_ONE)) != 0) ||\n            ((MCHUNK_SIZE & (MCHUNK_SIZE - SIZE_T_ONE)) != 0) ||\n            ((mparams.granularity & (mparams.granularity - SIZE_T_ONE)) != 0)\n            || ((mparams.page_size & (mparams.page_size - SIZE_T_ONE)) != 0))\n            ABORT;\n    }\n    return 0;\n}\n\n/* support for mallopt */\nstatic int\nchange_mparam(int param_number, int value)\n{\n    size_t val = (size_t) value;\n    init_mparams();\n    switch (param_number) {\n    case M_TRIM_THRESHOLD:\n        mparams.trim_threshold = val;\n        return 1;\n    case M_GRANULARITY:\n        if (val >= mparams.page_size && ((val & (val - 1)) == 0)) {\n            mparams.granularity = val;\n            return 1;\n        } else\n            return 0;\n    case M_MMAP_THRESHOLD:\n        mparams.mmap_threshold = val;\n        return 1;\n    default:\n        return 0;\n    }\n}\n\n#if DEBUG\n/* ------------------------- Debugging Support --------------------------- */\n\n/* Check properties of any chunk, whether free, inuse, mmapped etc  */\nstatic void\ndo_check_any_chunk(mstate m, mchunkptr p)\n{\n    assert((is_aligned(chunk2mem(p))) || (p->head == FENCEPOST_HEAD));\n    assert(ok_address(m, p));\n}\n\n/* Check properties of top chunk */\nstatic void\ndo_check_top_chunk(mstate m, mchunkptr p)\n{\n    msegmentptr sp = segment_holding(m, (char *) p);\n    size_t sz = chunksize(p);\n    assert(sp != 0);\n    assert((is_aligned(chunk2mem(p))) || (p->head == FENCEPOST_HEAD));\n    assert(ok_address(m, p));\n    assert(sz == m->topsize);\n    assert(sz > 0);\n    assert(sz == ((sp->base + sp->size) - (char *) p) - TOP_FOOT_SIZE);\n    assert(pinuse(p));\n    assert(!next_pinuse(p));\n}\n\n/* Check properties of (inuse) mmapped chunks */\nstatic void\ndo_check_mmapped_chunk(mstate m, mchunkptr p)\n{\n    size_t sz = chunksize(p);\n    size_t len = (sz + (p->prev_foot & ~IS_MMAPPED_BIT) + MMAP_FOOT_PAD);\n    assert(is_mmapped(p));\n    assert(use_mmap(m));\n    assert((is_aligned(chunk2mem(p))) || (p->head == FENCEPOST_HEAD));\n    assert(ok_address(m, p));\n    assert(!is_small(sz));\n    assert((len & (mparams.page_size - SIZE_T_ONE)) == 0);\n    assert(chunk_plus_offset(p, sz)->head == FENCEPOST_HEAD);\n    assert(chunk_plus_offset(p, sz + SIZE_T_SIZE)->head == 0);\n}\n\n/* Check properties of inuse chunks */\nstatic void\ndo_check_inuse_chunk(mstate m, mchunkptr p)\n{\n    do_check_any_chunk(m, p);\n    assert(cinuse(p));\n    assert(next_pinuse(p));\n    /* If not pinuse and not mmapped, previous chunk has OK offset */\n    assert(is_mmapped(p) || pinuse(p) || next_chunk(prev_chunk(p)) == p);\n    if (is_mmapped(p))\n        do_check_mmapped_chunk(m, p);\n}\n\n/* Check properties of free chunks */\nstatic void\ndo_check_free_chunk(mstate m, mchunkptr p)\n{\n    size_t sz = p->head & ~(PINUSE_BIT | CINUSE_BIT);\n    mchunkptr next = chunk_plus_offset(p, sz);\n    do_check_any_chunk(m, p);\n    assert(!cinuse(p));\n    assert(!next_pinuse(p));\n    assert(!is_mmapped(p));\n    if (p != m->dv && p != m->top) {\n        if (sz >= MIN_CHUNK_SIZE) {\n            assert((sz & CHUNK_ALIGN_MASK) == 0);\n            assert(is_aligned(chunk2mem(p)));\n            assert(next->prev_foot == sz);\n            assert(pinuse(p));\n            assert(next == m->top || cinuse(next));\n            assert(p->fd->bk == p);\n            assert(p->bk->fd == p);\n        } else                  /* markers are always of size SIZE_T_SIZE */\n            assert(sz == SIZE_T_SIZE);\n    }\n}\n\n/* Check properties of malloced chunks at the point they are malloced */\nstatic void\ndo_check_malloced_chunk(mstate m, void *mem, size_t s)\n{\n    if (mem != 0) {\n        mchunkptr p = mem2chunk(mem);\n        size_t sz = p->head & ~(PINUSE_BIT | CINUSE_BIT);\n        do_check_inuse_chunk(m, p);\n        assert((sz & CHUNK_ALIGN_MASK) == 0);\n        assert(sz >= MIN_CHUNK_SIZE);\n        assert(sz >= s);\n        /* unless mmapped, size is less than MIN_CHUNK_SIZE more than request */\n        assert(is_mmapped(p) || sz < (s + MIN_CHUNK_SIZE));\n    }\n}\n\n/* Check a tree and its subtrees.  */\nstatic void\ndo_check_tree(mstate m, tchunkptr t)\n{\n    tchunkptr head = 0;\n    tchunkptr u = t;\n    bindex_t tindex = t->index;\n    size_t tsize = chunksize(t);\n    bindex_t idx;\n    compute_tree_index(tsize, idx);\n    assert(tindex == idx);\n    assert(tsize >= MIN_LARGE_SIZE);\n    assert(tsize >= minsize_for_tree_index(idx));\n    assert((idx == NTREEBINS - 1)\n           || (tsize < minsize_for_tree_index((idx + 1))));\n\n    do {                        /* traverse through chain of same-sized nodes */\n        do_check_any_chunk(m, ((mchunkptr) u));\n        assert(u->index == tindex);\n        assert(chunksize(u) == tsize);\n        assert(!cinuse(u));\n        assert(!next_pinuse(u));\n        assert(u->fd->bk == u);\n        assert(u->bk->fd == u);\n        if (u->parent == 0) {\n            assert(u->child[0] == 0);\n            assert(u->child[1] == 0);\n        } else {\n            assert(head == 0);  /* only one node on chain has parent */\n            head = u;\n            assert(u->parent != u);\n            assert(u->parent->child[0] == u ||\n                   u->parent->child[1] == u ||\n                   *((tbinptr *) (u->parent)) == u);\n            if (u->child[0] != 0) {\n                assert(u->child[0]->parent == u);\n                assert(u->child[0] != u);\n                do_check_tree(m, u->child[0]);\n            }\n            if (u->child[1] != 0) {\n                assert(u->child[1]->parent == u);\n                assert(u->child[1] != u);\n                do_check_tree(m, u->child[1]);\n            }\n            if (u->child[0] != 0 && u->child[1] != 0) {\n                assert(chunksize(u->child[0]) < chunksize(u->child[1]));\n            }\n        }\n        u = u->fd;\n    } while (u != t);\n    assert(head != 0);\n}\n\n/*  Check all the chunks in a treebin.  */\nstatic void\ndo_check_treebin(mstate m, bindex_t i)\n{\n    tbinptr *tb = treebin_at(m, i);\n    tchunkptr t = *tb;\n    int empty = (m->treemap & (1U << i)) == 0;\n    if (t == 0)\n        assert(empty);\n    if (!empty)\n        do_check_tree(m, t);\n}\n\n/*  Check all the chunks in a smallbin.  */\nstatic void\ndo_check_smallbin(mstate m, bindex_t i)\n{\n    sbinptr b = smallbin_at(m, i);\n    mchunkptr p = b->bk;\n    unsigned int empty = (m->smallmap & (1U << i)) == 0;\n    if (p == b)\n        assert(empty);\n    if (!empty) {\n        for (; p != b; p = p->bk) {\n            size_t size = chunksize(p);\n            mchunkptr q;\n            /* each chunk claims to be free */\n            do_check_free_chunk(m, p);\n            /* chunk belongs in bin */\n            assert(small_index(size) == i);\n            assert(p->bk == b || chunksize(p->bk) == chunksize(p));\n            /* chunk is followed by an inuse chunk */\n            q = next_chunk(p);\n            if (q->head != FENCEPOST_HEAD)\n                do_check_inuse_chunk(m, q);\n        }\n    }\n}\n\n/* Find x in a bin. Used in other check functions. */\nstatic int\nbin_find(mstate m, mchunkptr x)\n{\n    size_t size = chunksize(x);\n    if (is_small(size)) {\n        bindex_t sidx = small_index(size);\n        sbinptr b = smallbin_at(m, sidx);\n        if (smallmap_is_marked(m, sidx)) {\n            mchunkptr p = b;\n            do {\n                if (p == x)\n                    return 1;\n            } while ((p = p->fd) != b);\n        }\n    } else {\n        bindex_t tidx;\n        compute_tree_index(size, tidx);\n        if (treemap_is_marked(m, tidx)) {\n            tchunkptr t = *treebin_at(m, tidx);\n            size_t sizebits = size << leftshift_for_tree_index(tidx);\n            while (t != 0 && chunksize(t) != size) {\n                t = t->child[(sizebits >> (SIZE_T_BITSIZE - SIZE_T_ONE)) & 1];\n                sizebits <<= 1;\n            }\n            if (t != 0) {\n                tchunkptr u = t;\n                do {\n                    if (u == (tchunkptr) x)\n                        return 1;\n                } while ((u = u->fd) != t);\n            }\n        }\n    }\n    return 0;\n}\n\n/* Traverse each chunk and check it; return total */\nstatic size_t\ntraverse_and_check(mstate m)\n{\n    size_t sum = 0;\n    if (is_initialized(m)) {\n        msegmentptr s = &m->seg;\n        sum += m->topsize + TOP_FOOT_SIZE;\n        while (s != 0) {\n            mchunkptr q = align_as_chunk(s->base);\n            mchunkptr lastq = 0;\n            assert(pinuse(q));\n            while (segment_holds(s, q) &&\n                   q != m->top && q->head != FENCEPOST_HEAD) {\n                sum += chunksize(q);\n                if (cinuse(q)) {\n                    assert(!bin_find(m, q));\n                    do_check_inuse_chunk(m, q);\n                } else {\n                    assert(q == m->dv || bin_find(m, q));\n                    assert(lastq == 0 || cinuse(lastq));        /* Not 2 consecutive free */\n                    do_check_free_chunk(m, q);\n                }\n                lastq = q;\n                q = next_chunk(q);\n            }\n            s = s->next;\n        }\n    }\n    return sum;\n}\n\n/* Check all properties of malloc_state. */\nstatic void\ndo_check_malloc_state(mstate m)\n{\n    bindex_t i;\n    size_t total;\n    /* check bins */\n    for (i = 0; i < NSMALLBINS; ++i)\n        do_check_smallbin(m, i);\n    for (i = 0; i < NTREEBINS; ++i)\n        do_check_treebin(m, i);\n\n    if (m->dvsize != 0) {       /* check dv chunk */\n        do_check_any_chunk(m, m->dv);\n        assert(m->dvsize == chunksize(m->dv));\n        assert(m->dvsize >= MIN_CHUNK_SIZE);\n        assert(bin_find(m, m->dv) == 0);\n    }\n\n    if (m->top != 0) {          /* check top chunk */\n        do_check_top_chunk(m, m->top);\n        assert(m->topsize == chunksize(m->top));\n        assert(m->topsize > 0);\n        assert(bin_find(m, m->top) == 0);\n    }\n\n    total = traverse_and_check(m);\n    assert(total <= m->footprint);\n    assert(m->footprint <= m->max_footprint);\n}\n#endif /* DEBUG */\n\n/* ----------------------------- statistics ------------------------------ */\n\n#if !NO_MALLINFO\nstatic struct mallinfo\ninternal_mallinfo(mstate m)\n{\n    struct mallinfo nm = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n    if (!PREACTION(m)) {\n        check_malloc_state(m);\n        if (is_initialized(m)) {\n            size_t nfree = SIZE_T_ONE;  /* top always free */\n            size_t mfree = m->topsize + TOP_FOOT_SIZE;\n            size_t sum = mfree;\n            msegmentptr s = &m->seg;\n            while (s != 0) {\n                mchunkptr q = align_as_chunk(s->base);\n                while (segment_holds(s, q) &&\n                       q != m->top && q->head != FENCEPOST_HEAD) {\n                    size_t sz = chunksize(q);\n                    sum += sz;\n                    if (!cinuse(q)) {\n                        mfree += sz;\n                        ++nfree;\n                    }\n                    q = next_chunk(q);\n                }\n                s = s->next;\n            }\n\n            nm.arena = sum;\n            nm.ordblks = nfree;\n            nm.hblkhd = m->footprint - sum;\n            nm.usmblks = m->max_footprint;\n            nm.uordblks = m->footprint - mfree;\n            nm.fordblks = mfree;\n            nm.keepcost = m->topsize;\n        }\n\n        POSTACTION(m);\n    }\n    return nm;\n}\n#endif /* !NO_MALLINFO */\n\nstatic void\ninternal_malloc_stats(mstate m)\n{\n    if (!PREACTION(m)) {\n        size_t maxfp = 0;\n        size_t fp = 0;\n        size_t used = 0;\n        check_malloc_state(m);\n        if (is_initialized(m)) {\n            msegmentptr s = &m->seg;\n            maxfp = m->max_footprint;\n            fp = m->footprint;\n            used = fp - (m->topsize + TOP_FOOT_SIZE);\n\n            while (s != 0) {\n                mchunkptr q = align_as_chunk(s->base);\n                while (segment_holds(s, q) &&\n                       q != m->top && q->head != FENCEPOST_HEAD) {\n                    if (!cinuse(q))\n                        used -= chunksize(q);\n                    q = next_chunk(q);\n                }\n                s = s->next;\n            }\n        }\n#ifndef LACKS_STDIO_H\n        fprintf(stderr, \"max system bytes = %10lu\\n\",\n                (unsigned long) (maxfp));\n        fprintf(stderr, \"system bytes     = %10lu\\n\", (unsigned long) (fp));\n        fprintf(stderr, \"in use bytes     = %10lu\\n\", (unsigned long) (used));\n#endif\n\n        POSTACTION(m);\n    }\n}\n\n/* ----------------------- Operations on smallbins ----------------------- */\n\n/*\n  Various forms of linking and unlinking are defined as macros.  Even\n  the ones for trees, which are very long but have very short typical\n  paths.  This is ugly but reduces reliance on inlining support of\n  compilers.\n*/\n\n/* Link a free chunk into a smallbin  */\n#define insert_small_chunk(M, P, S) {\\\n  bindex_t I  = small_index(S);\\\n  mchunkptr B = smallbin_at(M, I);\\\n  mchunkptr F = B;\\\n  assert(S >= MIN_CHUNK_SIZE);\\\n  if (!smallmap_is_marked(M, I))\\\n    mark_smallmap(M, I);\\\n  else if (RTCHECK(ok_address(M, B->fd)))\\\n    F = B->fd;\\\n  else {\\\n    CORRUPTION_ERROR_ACTION(M);\\\n  }\\\n  B->fd = P;\\\n  F->bk = P;\\\n  P->fd = F;\\\n  P->bk = B;\\\n}\n\n/* Unlink a chunk from a smallbin  */\n#define unlink_small_chunk(M, P, S) {\\\n  mchunkptr F = P->fd;\\\n  mchunkptr B = P->bk;\\\n  bindex_t I = small_index(S);\\\n  assert(P != B);\\\n  assert(P != F);\\\n  assert(chunksize(P) == small_index2size(I));\\\n  if (F == B)\\\n    clear_smallmap(M, I);\\\n  else if (RTCHECK((F == smallbin_at(M,I) || ok_address(M, F)) &&\\\n                   (B == smallbin_at(M,I) || ok_address(M, B)))) {\\\n    F->bk = B;\\\n    B->fd = F;\\\n  }\\\n  else {\\\n    CORRUPTION_ERROR_ACTION(M);\\\n  }\\\n}\n\n/* Unlink the first chunk from a smallbin */\n#define unlink_first_small_chunk(M, B, P, I) {\\\n  mchunkptr F = P->fd;\\\n  assert(P != B);\\\n  assert(P != F);\\\n  assert(chunksize(P) == small_index2size(I));\\\n  if (B == F)\\\n    clear_smallmap(M, I);\\\n  else if (RTCHECK(ok_address(M, F))) {\\\n    B->fd = F;\\\n    F->bk = B;\\\n  }\\\n  else {\\\n    CORRUPTION_ERROR_ACTION(M);\\\n  }\\\n}\n\n/* Replace dv node, binning the old one */\n/* Used only when dvsize known to be small */\n#define replace_dv(M, P, S) {\\\n  size_t DVS = M->dvsize;\\\n  if (DVS != 0) {\\\n    mchunkptr DV = M->dv;\\\n    assert(is_small(DVS));\\\n    insert_small_chunk(M, DV, DVS);\\\n  }\\\n  M->dvsize = S;\\\n  M->dv = P;\\\n}\n\n/* ------------------------- Operations on trees ------------------------- */\n\n/* Insert chunk into tree */\n#define insert_large_chunk(M, X, S) {\\\n  tbinptr* H;\\\n  bindex_t I;\\\n  compute_tree_index(S, I);\\\n  H = treebin_at(M, I);\\\n  X->index = I;\\\n  X->child[0] = X->child[1] = 0;\\\n  if (!treemap_is_marked(M, I)) {\\\n    mark_treemap(M, I);\\\n    *H = X;\\\n    X->parent = (tchunkptr)H;\\\n    X->fd = X->bk = X;\\\n  }\\\n  else {\\\n    tchunkptr T = *H;\\\n    size_t K = S << leftshift_for_tree_index(I);\\\n    for (;;) {\\\n      if (chunksize(T) != S) {\\\n        tchunkptr* C = &(T->child[(K >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1]);\\\n        K <<= 1;\\\n        if (*C != 0)\\\n          T = *C;\\\n        else if (RTCHECK(ok_address(M, C))) {\\\n          *C = X;\\\n          X->parent = T;\\\n          X->fd = X->bk = X;\\\n          break;\\\n        }\\\n        else {\\\n          CORRUPTION_ERROR_ACTION(M);\\\n          break;\\\n        }\\\n      }\\\n      else {\\\n        tchunkptr F = T->fd;\\\n        if (RTCHECK(ok_address(M, T) && ok_address(M, F))) {\\\n          T->fd = F->bk = X;\\\n          X->fd = F;\\\n          X->bk = T;\\\n          X->parent = 0;\\\n          break;\\\n        }\\\n        else {\\\n          CORRUPTION_ERROR_ACTION(M);\\\n          break;\\\n        }\\\n      }\\\n    }\\\n  }\\\n}\n\n/*\n  Unlink steps:\n\n  1. If x is a chained node, unlink it from its same-sized fd/bk links\n     and choose its bk node as its replacement.\n  2. If x was the last node of its size, but not a leaf node, it must\n     be replaced with a leaf node (not merely one with an open left or\n     right), to make sure that lefts and rights of descendents\n     correspond properly to bit masks.  We use the rightmost descendent\n     of x.  We could use any other leaf, but this is easy to locate and\n     tends to counteract removal of leftmosts elsewhere, and so keeps\n     paths shorter than minimally guaranteed.  This doesn't loop much\n     because on average a node in a tree is near the bottom.\n  3. If x is the base of a chain (i.e., has parent links) relink\n     x's parent and children to x's replacement (or null if none).\n*/\n\n#define unlink_large_chunk(M, X) {\\\n  tchunkptr XP = X->parent;\\\n  tchunkptr R;\\\n  if (X->bk != X) {\\\n    tchunkptr F = X->fd;\\\n    R = X->bk;\\\n    if (RTCHECK(ok_address(M, F))) {\\\n      F->bk = R;\\\n      R->fd = F;\\\n    }\\\n    else {\\\n      CORRUPTION_ERROR_ACTION(M);\\\n    }\\\n  }\\\n  else {\\\n    tchunkptr* RP;\\\n    if (((R = *(RP = &(X->child[1]))) != 0) ||\\\n        ((R = *(RP = &(X->child[0]))) != 0)) {\\\n      tchunkptr* CP;\\\n      while ((*(CP = &(R->child[1])) != 0) ||\\\n             (*(CP = &(R->child[0])) != 0)) {\\\n        R = *(RP = CP);\\\n      }\\\n      if (RTCHECK(ok_address(M, RP)))\\\n        *RP = 0;\\\n      else {\\\n        CORRUPTION_ERROR_ACTION(M);\\\n      }\\\n    }\\\n  }\\\n  if (XP != 0) {\\\n    tbinptr* H = treebin_at(M, X->index);\\\n    if (X == *H) {\\\n      if ((*H = R) == 0) \\\n        clear_treemap(M, X->index);\\\n    }\\\n    else if (RTCHECK(ok_address(M, XP))) {\\\n      if (XP->child[0] == X) \\\n        XP->child[0] = R;\\\n      else \\\n        XP->child[1] = R;\\\n    }\\\n    else\\\n      CORRUPTION_ERROR_ACTION(M);\\\n    if (R != 0) {\\\n      if (RTCHECK(ok_address(M, R))) {\\\n        tchunkptr C0, C1;\\\n        R->parent = XP;\\\n        if ((C0 = X->child[0]) != 0) {\\\n          if (RTCHECK(ok_address(M, C0))) {\\\n            R->child[0] = C0;\\\n            C0->parent = R;\\\n          }\\\n          else\\\n            CORRUPTION_ERROR_ACTION(M);\\\n        }\\\n        if ((C1 = X->child[1]) != 0) {\\\n          if (RTCHECK(ok_address(M, C1))) {\\\n            R->child[1] = C1;\\\n            C1->parent = R;\\\n          }\\\n          else\\\n            CORRUPTION_ERROR_ACTION(M);\\\n        }\\\n      }\\\n      else\\\n        CORRUPTION_ERROR_ACTION(M);\\\n    }\\\n  }\\\n}\n\n/* Relays to large vs small bin operations */\n\n#define insert_chunk(M, P, S)\\\n  if (is_small(S)) insert_small_chunk(M, P, S)\\\n  else { tchunkptr TP = (tchunkptr)(P); insert_large_chunk(M, TP, S); }\n\n#define unlink_chunk(M, P, S)\\\n  if (is_small(S)) unlink_small_chunk(M, P, S)\\\n  else { tchunkptr TP = (tchunkptr)(P); unlink_large_chunk(M, TP); }\n\n\n/* Relays to internal calls to malloc/free from realloc, memalign etc */\n\n#if ONLY_MSPACES\n#define internal_malloc(m, b) mspace_malloc(m, b)\n#define internal_free(m, mem) mspace_free(m,mem);\n#else /* ONLY_MSPACES */\n#if MSPACES\n#define internal_malloc(m, b)\\\n   (m == gm)? dlmalloc(b) : mspace_malloc(m, b)\n#define internal_free(m, mem)\\\n   if (m == gm) dlfree(mem); else mspace_free(m,mem);\n#else /* MSPACES */\n#define internal_malloc(m, b) dlmalloc(b)\n#define internal_free(m, mem) dlfree(mem)\n#endif /* MSPACES */\n#endif /* ONLY_MSPACES */\n\n/* -----------------------  Direct-mmapping chunks ----------------------- */\n\n/*\n  Directly mmapped chunks are set up with an offset to the start of\n  the mmapped region stored in the prev_foot field of the chunk. This\n  allows reconstruction of the required argument to MUNMAP when freed,\n  and also allows adjustment of the returned chunk to meet alignment\n  requirements (especially in memalign).  There is also enough space\n  allocated to hold a fake next chunk of size SIZE_T_SIZE to maintain\n  the PINUSE bit so frees can be checked.\n*/\n\n/* Malloc using mmap */\nstatic void *\nmmap_alloc(mstate m, size_t nb)\n{\n    size_t mmsize =\n        granularity_align(nb + SIX_SIZE_T_SIZES + CHUNK_ALIGN_MASK);\n    if (mmsize > nb) {          /* Check for wrap around 0 */\n        char *mm = (char *) (DIRECT_MMAP(mmsize));\n        if (mm != CMFAIL) {\n            size_t offset = align_offset(chunk2mem(mm));\n            size_t psize = mmsize - offset - MMAP_FOOT_PAD;\n            mchunkptr p = (mchunkptr) (mm + offset);\n            p->prev_foot = offset | IS_MMAPPED_BIT;\n            (p)->head = (psize | CINUSE_BIT);\n            mark_inuse_foot(m, p, psize);\n            chunk_plus_offset(p, psize)->head = FENCEPOST_HEAD;\n            chunk_plus_offset(p, psize + SIZE_T_SIZE)->head = 0;\n\n            if (mm < m->least_addr)\n                m->least_addr = mm;\n            if ((m->footprint += mmsize) > m->max_footprint)\n                m->max_footprint = m->footprint;\n            assert(is_aligned(chunk2mem(p)));\n            check_mmapped_chunk(m, p);\n            return chunk2mem(p);\n        }\n    }\n    return 0;\n}\n\n/* Realloc using mmap */\nstatic mchunkptr\nmmap_resize(mstate m, mchunkptr oldp, size_t nb)\n{\n    size_t oldsize = chunksize(oldp);\n    if (is_small(nb))           /* Can't shrink mmap regions below small size */\n        return 0;\n    /* Keep old chunk if big enough but not too big */\n    if (oldsize >= nb + SIZE_T_SIZE &&\n        (oldsize - nb) <= (mparams.granularity << 1))\n        return oldp;\n    else {\n        size_t offset = oldp->prev_foot & ~IS_MMAPPED_BIT;\n        size_t oldmmsize = oldsize + offset + MMAP_FOOT_PAD;\n        size_t newmmsize = granularity_align(nb + SIX_SIZE_T_SIZES +\n                                             CHUNK_ALIGN_MASK);\n        char *cp = (char *) CALL_MREMAP((char *) oldp - offset,\n                                        oldmmsize, newmmsize, 1);\n        if (cp != CMFAIL) {\n            mchunkptr newp = (mchunkptr) (cp + offset);\n            size_t psize = newmmsize - offset - MMAP_FOOT_PAD;\n            newp->head = (psize | CINUSE_BIT);\n            mark_inuse_foot(m, newp, psize);\n            chunk_plus_offset(newp, psize)->head = FENCEPOST_HEAD;\n            chunk_plus_offset(newp, psize + SIZE_T_SIZE)->head = 0;\n\n            if (cp < m->least_addr)\n                m->least_addr = cp;\n            if ((m->footprint += newmmsize - oldmmsize) > m->max_footprint)\n                m->max_footprint = m->footprint;\n            check_mmapped_chunk(m, newp);\n            return newp;\n        }\n    }\n    return 0;\n}\n\n/* -------------------------- mspace management -------------------------- */\n\n/* Initialize top chunk and its size */\nstatic void\ninit_top(mstate m, mchunkptr p, size_t psize)\n{\n    /* Ensure alignment */\n    size_t offset = align_offset(chunk2mem(p));\n    p = (mchunkptr) ((char *) p + offset);\n    psize -= offset;\n\n    m->top = p;\n    m->topsize = psize;\n    p->head = psize | PINUSE_BIT;\n    /* set size of fake trailing chunk holding overhead space only once */\n    chunk_plus_offset(p, psize)->head = TOP_FOOT_SIZE;\n    m->trim_check = mparams.trim_threshold;     /* reset on each update */\n}\n\n/* Initialize bins for a new mstate that is otherwise zeroed out */\nstatic void\ninit_bins(mstate m)\n{\n    /* Establish circular links for smallbins */\n    bindex_t i;\n    for (i = 0; i < NSMALLBINS; ++i) {\n        sbinptr bin = smallbin_at(m, i);\n        bin->fd = bin->bk = bin;\n    }\n}\n\n#if PROCEED_ON_ERROR\n\n/* default corruption action */\nstatic void\nreset_on_error(mstate m)\n{\n    int i;\n    ++malloc_corruption_error_count;\n    /* Reinitialize fields to forget about all memory */\n    m->smallbins = m->treebins = 0;\n    m->dvsize = m->topsize = 0;\n    m->seg.base = 0;\n    m->seg.size = 0;\n    m->seg.next = 0;\n    m->top = m->dv = 0;\n    for (i = 0; i < NTREEBINS; ++i)\n        *treebin_at(m, i) = 0;\n    init_bins(m);\n}\n#endif /* PROCEED_ON_ERROR */\n\n/* Allocate chunk and prepend remainder with chunk in successor base. */\nstatic void *\nprepend_alloc(mstate m, char *newbase, char *oldbase, size_t nb)\n{\n    mchunkptr p = align_as_chunk(newbase);\n    mchunkptr oldfirst = align_as_chunk(oldbase);\n    size_t psize = (char *) oldfirst - (char *) p;\n    mchunkptr q = chunk_plus_offset(p, nb);\n    size_t qsize = psize - nb;\n    set_size_and_pinuse_of_inuse_chunk(m, p, nb);\n\n    assert((char *) oldfirst > (char *) q);\n    assert(pinuse(oldfirst));\n    assert(qsize >= MIN_CHUNK_SIZE);\n\n    /* consolidate remainder with first chunk of old base */\n    if (oldfirst == m->top) {\n        size_t tsize = m->topsize += qsize;\n        m->top = q;\n        q->head = tsize | PINUSE_BIT;\n        check_top_chunk(m, q);\n    } else if (oldfirst == m->dv) {\n        size_t dsize = m->dvsize += qsize;\n        m->dv = q;\n        set_size_and_pinuse_of_free_chunk(q, dsize);\n    } else {\n        if (!cinuse(oldfirst)) {\n            size_t nsize = chunksize(oldfirst);\n            unlink_chunk(m, oldfirst, nsize);\n            oldfirst = chunk_plus_offset(oldfirst, nsize);\n            qsize += nsize;\n        }\n        set_free_with_pinuse(q, qsize, oldfirst);\n        insert_chunk(m, q, qsize);\n        check_free_chunk(m, q);\n    }\n\n    check_malloced_chunk(m, chunk2mem(p), nb);\n    return chunk2mem(p);\n}\n\n\n/* Add a segment to hold a new noncontiguous region */\nstatic void\nadd_segment(mstate m, char *tbase, size_t tsize, flag_t mmapped)\n{\n    /* Determine locations and sizes of segment, fenceposts, old top */\n    char *old_top = (char *) m->top;\n    msegmentptr oldsp = segment_holding(m, old_top);\n    char *old_end = oldsp->base + oldsp->size;\n    size_t ssize = pad_request(sizeof(struct malloc_segment));\n    char *rawsp = old_end - (ssize + FOUR_SIZE_T_SIZES + CHUNK_ALIGN_MASK);\n    size_t offset = align_offset(chunk2mem(rawsp));\n    char *asp = rawsp + offset;\n    char *csp = (asp < (old_top + MIN_CHUNK_SIZE)) ? old_top : asp;\n    mchunkptr sp = (mchunkptr) csp;\n    msegmentptr ss = (msegmentptr) (chunk2mem(sp));\n    mchunkptr tnext = chunk_plus_offset(sp, ssize);\n    mchunkptr p = tnext;\n    int nfences = 0;\n\n    /* reset top to new space */\n    init_top(m, (mchunkptr) tbase, tsize - TOP_FOOT_SIZE);\n\n    /* Set up segment record */\n    assert(is_aligned(ss));\n    set_size_and_pinuse_of_inuse_chunk(m, sp, ssize);\n    *ss = m->seg;               /* Push current record */\n    m->seg.base = tbase;\n    m->seg.size = tsize;\n    m->seg.sflags = mmapped;\n    m->seg.next = ss;\n\n    /* Insert trailing fenceposts */\n    for (;;) {\n        mchunkptr nextp = chunk_plus_offset(p, SIZE_T_SIZE);\n        p->head = FENCEPOST_HEAD;\n        ++nfences;\n        if ((char *) (&(nextp->head)) < old_end)\n            p = nextp;\n        else\n            break;\n    }\n    assert(nfences >= 2);\n\n    /* Insert the rest of old top into a bin as an ordinary free chunk */\n    if (csp != old_top) {\n        mchunkptr q = (mchunkptr) old_top;\n        size_t psize = csp - old_top;\n        mchunkptr tn = chunk_plus_offset(q, psize);\n        set_free_with_pinuse(q, psize, tn);\n        insert_chunk(m, q, psize);\n    }\n\n    check_top_chunk(m, m->top);\n}\n\n/* -------------------------- System allocation -------------------------- */\n\n/* Get memory from system using MORECORE or MMAP */\nstatic void *\nsys_alloc(mstate m, size_t nb)\n{\n    char *tbase = CMFAIL;\n    size_t tsize = 0;\n    flag_t mmap_flag = 0;\n\n    init_mparams();\n\n    /* Directly map large chunks */\n    if (use_mmap(m) && nb >= mparams.mmap_threshold) {\n        void *mem = mmap_alloc(m, nb);\n        if (mem != 0)\n            return mem;\n    }\n\n    /*\n       Try getting memory in any of three ways (in most-preferred to\n       least-preferred order):\n       1. A call to MORECORE that can normally contiguously extend memory.\n       (disabled if not MORECORE_CONTIGUOUS or not HAVE_MORECORE or\n       or main space is mmapped or a previous contiguous call failed)\n       2. A call to MMAP new space (disabled if not HAVE_MMAP).\n       Note that under the default settings, if MORECORE is unable to\n       fulfill a request, and HAVE_MMAP is true, then mmap is\n       used as a noncontiguous system allocator. This is a useful backup\n       strategy for systems with holes in address spaces -- in this case\n       sbrk cannot contiguously expand the heap, but mmap may be able to\n       find space.\n       3. A call to MORECORE that cannot usually contiguously extend memory.\n       (disabled if not HAVE_MORECORE)\n     */\n\n    if (MORECORE_CONTIGUOUS && !use_noncontiguous(m)) {\n        char *br = CMFAIL;\n        msegmentptr ss =\n            (m->top == 0) ? 0 : segment_holding(m, (char *) m->top);\n        size_t asize = 0;\n        ACQUIRE_MORECORE_LOCK();\n\n        if (ss == 0) {          /* First time through or recovery */\n            char *base = (char *) CALL_MORECORE(0);\n            if (base != CMFAIL) {\n                asize =\n                    granularity_align(nb + TOP_FOOT_SIZE + MALLOC_ALIGNMENT +\n                                      SIZE_T_ONE);\n                /* Adjust to end on a page boundary */\n                if (!is_page_aligned(base))\n                    asize += (page_align((size_t) base) - (size_t) base);\n                /* Can't call MORECORE if size is negative when treated as signed */\n                if (asize < HALF_MAX_SIZE_T &&\n                    (br = (char *) (CALL_MORECORE(asize))) == base) {\n                    tbase = base;\n                    tsize = asize;\n                }\n            }\n        } else {\n            /* Subtract out existing available top space from MORECORE request. */\n            asize =\n                granularity_align(nb - m->topsize + TOP_FOOT_SIZE +\n                                  MALLOC_ALIGNMENT + SIZE_T_ONE);\n            /* Use mem here only if it did continuously extend old space */\n            if (asize < HALF_MAX_SIZE_T &&\n                (br =\n                 (char *) (CALL_MORECORE(asize))) == ss->base + ss->size) {\n                tbase = br;\n                tsize = asize;\n            }\n        }\n\n        if (tbase == CMFAIL) {  /* Cope with partial failure */\n            if (br != CMFAIL) { /* Try to use/extend the space we did get */\n                if (asize < HALF_MAX_SIZE_T &&\n                    asize < nb + TOP_FOOT_SIZE + SIZE_T_ONE) {\n                    size_t esize =\n                        granularity_align(nb + TOP_FOOT_SIZE +\n                                          MALLOC_ALIGNMENT + SIZE_T_ONE -\n                                          asize);\n                    if (esize < HALF_MAX_SIZE_T) {\n                        char *end = (char *) CALL_MORECORE(esize);\n                        if (end != CMFAIL)\n                            asize += esize;\n                        else {  /* Can't use; try to release */\n                            end = (char *) CALL_MORECORE(-asize);\n                            br = CMFAIL;\n                        }\n                    }\n                }\n            }\n            if (br != CMFAIL) { /* Use the space we did get */\n                tbase = br;\n                tsize = asize;\n            } else\n                disable_contiguous(m);  /* Don't try contiguous path in the future */\n        }\n\n        RELEASE_MORECORE_LOCK();\n    }\n\n    if (HAVE_MMAP && tbase == CMFAIL) { /* Try MMAP */\n        size_t req = nb + TOP_FOOT_SIZE + MALLOC_ALIGNMENT + SIZE_T_ONE;\n        size_t rsize = granularity_align(req);\n        if (rsize > nb) {       /* Fail if wraps around zero */\n            char *mp = (char *) (CALL_MMAP(rsize));\n            if (mp != CMFAIL) {\n                tbase = mp;\n                tsize = rsize;\n                mmap_flag = IS_MMAPPED_BIT;\n            }\n        }\n    }\n\n    if (HAVE_MORECORE && tbase == CMFAIL) {     /* Try noncontiguous MORECORE */\n        size_t asize =\n            granularity_align(nb + TOP_FOOT_SIZE + MALLOC_ALIGNMENT +\n                              SIZE_T_ONE);\n        if (asize < HALF_MAX_SIZE_T) {\n            char *br = CMFAIL;\n            char *end = CMFAIL;\n            ACQUIRE_MORECORE_LOCK();\n            br = (char *) (CALL_MORECORE(asize));\n            end = (char *) (CALL_MORECORE(0));\n            RELEASE_MORECORE_LOCK();\n            if (br != CMFAIL && end != CMFAIL && br < end) {\n                size_t ssize = end - br;\n                if (ssize > nb + TOP_FOOT_SIZE) {\n                    tbase = br;\n                    tsize = ssize;\n                }\n            }\n        }\n    }\n\n    if (tbase != CMFAIL) {\n\n        if ((m->footprint += tsize) > m->max_footprint)\n            m->max_footprint = m->footprint;\n\n        if (!is_initialized(m)) {       /* first-time initialization */\n            m->seg.base = m->least_addr = tbase;\n            m->seg.size = tsize;\n            m->seg.sflags = mmap_flag;\n            m->magic = mparams.magic;\n            init_bins(m);\n            if (is_global(m))\n                init_top(m, (mchunkptr) tbase, tsize - TOP_FOOT_SIZE);\n            else {\n                /* Offset top by embedded malloc_state */\n                mchunkptr mn = next_chunk(mem2chunk(m));\n                init_top(m, mn,\n                         (size_t) ((tbase + tsize) - (char *) mn) -\n                         TOP_FOOT_SIZE);\n            }\n        }\n\n        else {\n            /* Try to merge with an existing segment */\n            msegmentptr sp = &m->seg;\n            while (sp != 0 && tbase != sp->base + sp->size)\n                sp = sp->next;\n            if (sp != 0 && !is_extern_segment(sp) && (sp->sflags & IS_MMAPPED_BIT) == mmap_flag && segment_holds(sp, m->top)) { /* append */\n                sp->size += tsize;\n                init_top(m, m->top, m->topsize + tsize);\n            } else {\n                if (tbase < m->least_addr)\n                    m->least_addr = tbase;\n                sp = &m->seg;\n                while (sp != 0 && sp->base != tbase + tsize)\n                    sp = sp->next;\n                if (sp != 0 &&\n                    !is_extern_segment(sp) &&\n                    (sp->sflags & IS_MMAPPED_BIT) == mmap_flag) {\n                    char *oldbase = sp->base;\n                    sp->base = tbase;\n                    sp->size += tsize;\n                    return prepend_alloc(m, tbase, oldbase, nb);\n                } else\n                    add_segment(m, tbase, tsize, mmap_flag);\n            }\n        }\n\n        if (nb < m->topsize) {  /* Allocate from new or extended top space */\n            size_t rsize = m->topsize -= nb;\n            mchunkptr p = m->top;\n            mchunkptr r = m->top = chunk_plus_offset(p, nb);\n            r->head = rsize | PINUSE_BIT;\n            set_size_and_pinuse_of_inuse_chunk(m, p, nb);\n            check_top_chunk(m, m->top);\n            check_malloced_chunk(m, chunk2mem(p), nb);\n            return chunk2mem(p);\n        }\n    }\n\n    MALLOC_FAILURE_ACTION;\n    return 0;\n}\n\n/* -----------------------  system deallocation -------------------------- */\n\n/* Unmap and unlink any mmapped segments that don't contain used chunks */\nstatic size_t\nrelease_unused_segments(mstate m)\n{\n    size_t released = 0;\n    msegmentptr pred = &m->seg;\n    msegmentptr sp = pred->next;\n    while (sp != 0) {\n        char *base = sp->base;\n        size_t size = sp->size;\n        msegmentptr next = sp->next;\n        if (is_mmapped_segment(sp) && !is_extern_segment(sp)) {\n            mchunkptr p = align_as_chunk(base);\n            size_t psize = chunksize(p);\n            /* Can unmap if first chunk holds entire segment and not pinned */\n            if (!cinuse(p)\n                && (char *) p + psize >= base + size - TOP_FOOT_SIZE) {\n                tchunkptr tp = (tchunkptr) p;\n                assert(segment_holds(sp, (char *) sp));\n                if (p == m->dv) {\n                    m->dv = 0;\n                    m->dvsize = 0;\n                } else {\n                    unlink_large_chunk(m, tp);\n                }\n                if (CALL_MUNMAP(base, size) == 0) {\n                    released += size;\n                    m->footprint -= size;\n                    /* unlink obsoleted record */\n                    sp = pred;\n                    sp->next = next;\n                } else {        /* back out if cannot unmap */\n                    insert_large_chunk(m, tp, psize);\n                }\n            }\n        }\n        pred = sp;\n        sp = next;\n    }\n    return released;\n}\n\nstatic int\nsys_trim(mstate m, size_t pad)\n{\n    size_t released = 0;\n    if (pad < MAX_REQUEST && is_initialized(m)) {\n        pad += TOP_FOOT_SIZE;   /* ensure enough room for segment overhead */\n\n        if (m->topsize > pad) {\n            /* Shrink top space in granularity-size units, keeping at least one */\n            size_t unit = mparams.granularity;\n            size_t extra = ((m->topsize - pad + (unit - SIZE_T_ONE)) / unit -\n                            SIZE_T_ONE) * unit;\n            msegmentptr sp = segment_holding(m, (char *) m->top);\n\n            if (!is_extern_segment(sp)) {\n                if (is_mmapped_segment(sp)) {\n                    if (HAVE_MMAP && sp->size >= extra && !has_segment_link(m, sp)) {   /* can't shrink if pinned */\n                        size_t newsize = sp->size - extra;\n                        /* Prefer mremap, fall back to munmap */\n                        if ((CALL_MREMAP(sp->base, sp->size, newsize, 0) !=\n                             MFAIL)\n                            || (CALL_MUNMAP(sp->base + newsize, extra) == 0)) {\n                            released = extra;\n                        }\n                    }\n                } else if (HAVE_MORECORE) {\n                    if (extra >= HALF_MAX_SIZE_T)       /* Avoid wrapping negative */\n                        extra = (HALF_MAX_SIZE_T) + SIZE_T_ONE - unit;\n                    ACQUIRE_MORECORE_LOCK();\n                    {\n                        /* Make sure end of memory is where we last set it. */\n                        char *old_br = (char *) (CALL_MORECORE(0));\n                        if (old_br == sp->base + sp->size) {\n                            char *rel_br = (char *) (CALL_MORECORE(-extra));\n                            char *new_br = (char *) (CALL_MORECORE(0));\n                            if (rel_br != CMFAIL && new_br < old_br)\n                                released = old_br - new_br;\n                        }\n                    }\n                    RELEASE_MORECORE_LOCK();\n                }\n            }\n\n            if (released != 0) {\n                sp->size -= released;\n                m->footprint -= released;\n                init_top(m, m->top, m->topsize - released);\n                check_top_chunk(m, m->top);\n            }\n        }\n\n        /* Unmap any unused mmapped segments */\n        if (HAVE_MMAP)\n            released += release_unused_segments(m);\n\n        /* On failure, disable autotrim to avoid repeated failed future calls */\n        if (released == 0)\n            m->trim_check = MAX_SIZE_T;\n    }\n\n    return (released != 0) ? 1 : 0;\n}\n\n/* ---------------------------- malloc support --------------------------- */\n\n/* allocate a large request from the best fitting chunk in a treebin */\nstatic void *\ntmalloc_large(mstate m, size_t nb)\n{\n    tchunkptr v = 0;\n    size_t rsize = -nb;         /* Unsigned negation */\n    tchunkptr t;\n    bindex_t idx;\n    compute_tree_index(nb, idx);\n\n    if ((t = *treebin_at(m, idx)) != 0) {\n        /* Traverse tree for this bin looking for node with size == nb */\n        size_t sizebits = nb << leftshift_for_tree_index(idx);\n        tchunkptr rst = 0;      /* The deepest untaken right subtree */\n        for (;;) {\n            tchunkptr rt;\n            size_t trem = chunksize(t) - nb;\n            if (trem < rsize) {\n                v = t;\n                if ((rsize = trem) == 0)\n                    break;\n            }\n            rt = t->child[1];\n            t = t->child[(sizebits >> (SIZE_T_BITSIZE - SIZE_T_ONE)) & 1];\n            if (rt != 0 && rt != t)\n                rst = rt;\n            if (t == 0) {\n                t = rst;        /* set t to least subtree holding sizes > nb */\n                break;\n            }\n            sizebits <<= 1;\n        }\n    }\n\n    if (t == 0 && v == 0) {     /* set t to root of next non-empty treebin */\n        binmap_t leftbits = left_bits(idx2bit(idx)) & m->treemap;\n        if (leftbits != 0) {\n            bindex_t i;\n            binmap_t leastbit = least_bit(leftbits);\n            compute_bit2idx(leastbit, i);\n            t = *treebin_at(m, i);\n        }\n    }\n\n    while (t != 0) {            /* find smallest of tree or subtree */\n        size_t trem = chunksize(t) - nb;\n        if (trem < rsize) {\n            rsize = trem;\n            v = t;\n        }\n        t = leftmost_child(t);\n    }\n\n    /*  If dv is a better fit, return 0 so malloc will use it */\n    if (v != 0 && rsize < (size_t) (m->dvsize - nb)) {\n        if (RTCHECK(ok_address(m, v))) {        /* split */\n            mchunkptr r = chunk_plus_offset(v, nb);\n            assert(chunksize(v) == rsize + nb);\n            if (RTCHECK(ok_next(v, r))) {\n                unlink_large_chunk(m, v);\n                if (rsize < MIN_CHUNK_SIZE)\n                    set_inuse_and_pinuse(m, v, (rsize + nb));\n                else {\n                    set_size_and_pinuse_of_inuse_chunk(m, v, nb);\n                    set_size_and_pinuse_of_free_chunk(r, rsize);\n                    insert_chunk(m, r, rsize);\n                }\n                return chunk2mem(v);\n            }\n        }\n        CORRUPTION_ERROR_ACTION(m);\n    }\n    return 0;\n}\n\n/* allocate a small request from the best fitting chunk in a treebin */\nstatic void *\ntmalloc_small(mstate m, size_t nb)\n{\n    tchunkptr t, v;\n    size_t rsize;\n    bindex_t i;\n    binmap_t leastbit = least_bit(m->treemap);\n    compute_bit2idx(leastbit, i);\n\n    v = t = *treebin_at(m, i);\n    rsize = chunksize(t) - nb;\n\n    while ((t = leftmost_child(t)) != 0) {\n        size_t trem = chunksize(t) - nb;\n        if (trem < rsize) {\n            rsize = trem;\n            v = t;\n        }\n    }\n\n    if (RTCHECK(ok_address(m, v))) {\n        mchunkptr r = chunk_plus_offset(v, nb);\n        assert(chunksize(v) == rsize + nb);\n        if (RTCHECK(ok_next(v, r))) {\n            unlink_large_chunk(m, v);\n            if (rsize < MIN_CHUNK_SIZE)\n                set_inuse_and_pinuse(m, v, (rsize + nb));\n            else {\n                set_size_and_pinuse_of_inuse_chunk(m, v, nb);\n                set_size_and_pinuse_of_free_chunk(r, rsize);\n                replace_dv(m, r, rsize);\n            }\n            return chunk2mem(v);\n        }\n    }\n\n    CORRUPTION_ERROR_ACTION(m);\n    return 0;\n}\n\n/* --------------------------- realloc support --------------------------- */\n\nstatic void *\ninternal_realloc(mstate m, void *oldmem, size_t bytes)\n{\n    if (bytes >= MAX_REQUEST) {\n        MALLOC_FAILURE_ACTION;\n        return 0;\n    }\n    if (!PREACTION(m)) {\n        mchunkptr oldp = mem2chunk(oldmem);\n        size_t oldsize = chunksize(oldp);\n        mchunkptr next = chunk_plus_offset(oldp, oldsize);\n        mchunkptr newp = 0;\n        void *extra = 0;\n\n        /* Try to either shrink or extend into top. Else malloc-copy-free */\n\n        if (RTCHECK(ok_address(m, oldp) && ok_cinuse(oldp) &&\n                    ok_next(oldp, next) && ok_pinuse(next))) {\n            size_t nb = request2size(bytes);\n            if (is_mmapped(oldp))\n                newp = mmap_resize(m, oldp, nb);\n            else if (oldsize >= nb) {   /* already big enough */\n                size_t rsize = oldsize - nb;\n                newp = oldp;\n                if (rsize >= MIN_CHUNK_SIZE) {\n                    mchunkptr remainder = chunk_plus_offset(newp, nb);\n                    set_inuse(m, newp, nb);\n                    set_inuse(m, remainder, rsize);\n                    extra = chunk2mem(remainder);\n                }\n            } else if (next == m->top && oldsize + m->topsize > nb) {\n                /* Expand into top */\n                size_t newsize = oldsize + m->topsize;\n                size_t newtopsize = newsize - nb;\n                mchunkptr newtop = chunk_plus_offset(oldp, nb);\n                set_inuse(m, oldp, nb);\n                newtop->head = newtopsize | PINUSE_BIT;\n                m->top = newtop;\n                m->topsize = newtopsize;\n                newp = oldp;\n            }\n        } else {\n            USAGE_ERROR_ACTION(m, oldmem);\n            POSTACTION(m);\n            return 0;\n        }\n\n        POSTACTION(m);\n\n        if (newp != 0) {\n            if (extra != 0) {\n                internal_free(m, extra);\n            }\n            check_inuse_chunk(m, newp);\n            return chunk2mem(newp);\n        } else {\n            void *newmem = internal_malloc(m, bytes);\n            if (newmem != 0) {\n                size_t oc = oldsize - overhead_for(oldp);\n                memcpy(newmem, oldmem, (oc < bytes) ? oc : bytes);\n                internal_free(m, oldmem);\n            }\n            return newmem;\n        }\n    }\n    return 0;\n}\n\n/* --------------------------- memalign support -------------------------- */\n\nstatic void *\ninternal_memalign(mstate m, size_t alignment, size_t bytes)\n{\n    if (alignment <= MALLOC_ALIGNMENT)  /* Can just use malloc */\n        return internal_malloc(m, bytes);\n    if (alignment < MIN_CHUNK_SIZE)     /* must be at least a minimum chunk size */\n        alignment = MIN_CHUNK_SIZE;\n    if ((alignment & (alignment - SIZE_T_ONE)) != 0) {  /* Ensure a power of 2 */\n        size_t a = MALLOC_ALIGNMENT << 1;\n        while (a < alignment)\n            a <<= 1;\n        alignment = a;\n    }\n\n    if (bytes >= MAX_REQUEST - alignment) {\n        if (m != 0) {           /* Test isn't needed but avoids compiler warning */\n            MALLOC_FAILURE_ACTION;\n        }\n    } else {\n        size_t nb = request2size(bytes);\n        size_t req = nb + alignment + MIN_CHUNK_SIZE - CHUNK_OVERHEAD;\n        char *mem = (char *) internal_malloc(m, req);\n        if (mem != 0) {\n            void *leader = 0;\n            void *trailer = 0;\n            mchunkptr p = mem2chunk(mem);\n\n            if (PREACTION(m))\n                return 0;\n            if ((((size_t) (mem)) % alignment) != 0) {  /* misaligned */\n                /*\n                   Find an aligned spot inside chunk.  Since we need to give\n                   back leading space in a chunk of at least MIN_CHUNK_SIZE, if\n                   the first calculation places us at a spot with less than\n                   MIN_CHUNK_SIZE leader, we can move to the next aligned spot.\n                   We've allocated enough total room so that this is always\n                   possible.\n                 */\n                char *br = (char *) mem2chunk((size_t) (((size_t) (mem +\n                                                                   alignment -\n                                                                   SIZE_T_ONE))\n                                                        & -alignment));\n                char *pos =\n                    ((size_t) (br - (char *) (p)) >=\n                     MIN_CHUNK_SIZE) ? br : br + alignment;\n                mchunkptr newp = (mchunkptr) pos;\n                size_t leadsize = pos - (char *) (p);\n                size_t newsize = chunksize(p) - leadsize;\n\n                if (is_mmapped(p)) {    /* For mmapped chunks, just adjust offset */\n                    newp->prev_foot = p->prev_foot + leadsize;\n                    newp->head = (newsize | CINUSE_BIT);\n                } else {        /* Otherwise, give back leader, use the rest */\n                    set_inuse(m, newp, newsize);\n                    set_inuse(m, p, leadsize);\n                    leader = chunk2mem(p);\n                }\n                p = newp;\n            }\n\n            /* Give back spare room at the end */\n            if (!is_mmapped(p)) {\n                size_t size = chunksize(p);\n                if (size > nb + MIN_CHUNK_SIZE) {\n                    size_t remainder_size = size - nb;\n                    mchunkptr remainder = chunk_plus_offset(p, nb);\n                    set_inuse(m, p, nb);\n                    set_inuse(m, remainder, remainder_size);\n                    trailer = chunk2mem(remainder);\n                }\n            }\n\n            assert(chunksize(p) >= nb);\n            assert((((size_t) (chunk2mem(p))) % alignment) == 0);\n            check_inuse_chunk(m, p);\n            POSTACTION(m);\n            if (leader != 0) {\n                internal_free(m, leader);\n            }\n            if (trailer != 0) {\n                internal_free(m, trailer);\n            }\n            return chunk2mem(p);\n        }\n    }\n    return 0;\n}\n\n/* ------------------------ comalloc/coalloc support --------------------- */\n\nstatic void **\nialloc(mstate m, size_t n_elements, size_t * sizes, int opts, void *chunks[])\n{\n    /*\n       This provides common support for independent_X routines, handling\n       all of the combinations that can result.\n\n       The opts arg has:\n       bit 0 set if all elements are same size (using sizes[0])\n       bit 1 set if elements should be zeroed\n     */\n\n    size_t element_size;        /* chunksize of each element, if all same */\n    size_t contents_size;       /* total size of elements */\n    size_t array_size;          /* request size of pointer array */\n    void *mem;                  /* malloced aggregate space */\n    mchunkptr p;                /* corresponding chunk */\n    size_t remainder_size;      /* remaining bytes while splitting */\n    void **marray;              /* either \"chunks\" or malloced ptr array */\n    mchunkptr array_chunk;      /* chunk for malloced ptr array */\n    flag_t was_enabled;         /* to disable mmap */\n    size_t size;\n    size_t i;\n\n    /* compute array length, if needed */\n    if (chunks != 0) {\n        if (n_elements == 0)\n            return chunks;      /* nothing to do */\n        marray = chunks;\n        array_size = 0;\n    } else {\n        /* if empty req, must still return chunk representing empty array */\n        if (n_elements == 0)\n            return (void **) internal_malloc(m, 0);\n        marray = 0;\n        array_size = request2size(n_elements * (sizeof(void *)));\n    }\n\n    /* compute total element size */\n    if (opts & 0x1) {           /* all-same-size */\n        element_size = request2size(*sizes);\n        contents_size = n_elements * element_size;\n    } else {                    /* add up all the sizes */\n        element_size = 0;\n        contents_size = 0;\n        for (i = 0; i != n_elements; ++i)\n            contents_size += request2size(sizes[i]);\n    }\n\n    size = contents_size + array_size;\n\n    /*\n       Allocate the aggregate chunk.  First disable direct-mmapping so\n       malloc won't use it, since we would not be able to later\n       free/realloc space internal to a segregated mmap region.\n     */\n    was_enabled = use_mmap(m);\n    disable_mmap(m);\n    mem = internal_malloc(m, size - CHUNK_OVERHEAD);\n    if (was_enabled)\n        enable_mmap(m);\n    if (mem == 0)\n        return 0;\n\n    if (PREACTION(m))\n        return 0;\n    p = mem2chunk(mem);\n    remainder_size = chunksize(p);\n\n    assert(!is_mmapped(p));\n\n    if (opts & 0x2) {           /* optionally clear the elements */\n        memset((size_t *) mem, 0, remainder_size - SIZE_T_SIZE - array_size);\n    }\n\n    /* If not provided, allocate the pointer array as final part of chunk */\n    if (marray == 0) {\n        size_t array_chunk_size;\n        array_chunk = chunk_plus_offset(p, contents_size);\n        array_chunk_size = remainder_size - contents_size;\n        marray = (void **) (chunk2mem(array_chunk));\n        set_size_and_pinuse_of_inuse_chunk(m, array_chunk, array_chunk_size);\n        remainder_size = contents_size;\n    }\n\n    /* split out elements */\n    for (i = 0;; ++i) {\n        marray[i] = chunk2mem(p);\n        if (i != n_elements - 1) {\n            if (element_size != 0)\n                size = element_size;\n            else\n                size = request2size(sizes[i]);\n            remainder_size -= size;\n            set_size_and_pinuse_of_inuse_chunk(m, p, size);\n            p = chunk_plus_offset(p, size);\n        } else {                /* the final element absorbs any overallocation slop */\n            set_size_and_pinuse_of_inuse_chunk(m, p, remainder_size);\n            break;\n        }\n    }\n\n#if DEBUG\n    if (marray != chunks) {\n        /* final element must have exactly exhausted chunk */\n        if (element_size != 0) {\n            assert(remainder_size == element_size);\n        } else {\n            assert(remainder_size == request2size(sizes[i]));\n        }\n        check_inuse_chunk(m, mem2chunk(marray));\n    }\n    for (i = 0; i != n_elements; ++i)\n        check_inuse_chunk(m, mem2chunk(marray[i]));\n\n#endif /* DEBUG */\n\n    POSTACTION(m);\n    return marray;\n}\n\n\n/* -------------------------- public routines ---------------------------- */\n\n#if !ONLY_MSPACES\n\nvoid *\ndlmalloc(size_t bytes)\n{\n    /*\n       Basic algorithm:\n       If a small request (< 256 bytes minus per-chunk overhead):\n       1. If one exists, use a remainderless chunk in associated smallbin.\n       (Remainderless means that there are too few excess bytes to\n       represent as a chunk.)\n       2. If it is big enough, use the dv chunk, which is normally the\n       chunk adjacent to the one used for the most recent small request.\n       3. If one exists, split the smallest available chunk in a bin,\n       saving remainder in dv.\n       4. If it is big enough, use the top chunk.\n       5. If available, get memory from system and use it\n       Otherwise, for a large request:\n       1. Find the smallest available binned chunk that fits, and use it\n       if it is better fitting than dv chunk, splitting if necessary.\n       2. If better fitting than any binned chunk, use the dv chunk.\n       3. If it is big enough, use the top chunk.\n       4. If request size >= mmap threshold, try to directly mmap this chunk.\n       5. If available, get memory from system and use it\n\n       The ugly goto's here ensure that postaction occurs along all paths.\n     */\n\n    if (!PREACTION(gm)) {\n        void *mem;\n        size_t nb;\n        if (bytes <= MAX_SMALL_REQUEST) {\n            bindex_t idx;\n            binmap_t smallbits;\n            nb = (bytes < MIN_REQUEST) ? MIN_CHUNK_SIZE : pad_request(bytes);\n            idx = small_index(nb);\n            smallbits = gm->smallmap >> idx;\n\n            if ((smallbits & 0x3U) != 0) {      /* Remainderless fit to a smallbin. */\n                mchunkptr b, p;\n                idx += ~smallbits & 1;  /* Uses next bin if idx empty */\n                b = smallbin_at(gm, idx);\n                p = b->fd;\n                assert(chunksize(p) == small_index2size(idx));\n                unlink_first_small_chunk(gm, b, p, idx);\n                set_inuse_and_pinuse(gm, p, small_index2size(idx));\n                mem = chunk2mem(p);\n                check_malloced_chunk(gm, mem, nb);\n                goto postaction;\n            }\n\n            else if (nb > gm->dvsize) {\n                if (smallbits != 0) {   /* Use chunk in next nonempty smallbin */\n                    mchunkptr b, p, r;\n                    size_t rsize;\n                    bindex_t i;\n                    binmap_t leftbits =\n                        (smallbits << idx) & left_bits(idx2bit(idx));\n                    binmap_t leastbit = least_bit(leftbits);\n                    compute_bit2idx(leastbit, i);\n                    b = smallbin_at(gm, i);\n                    p = b->fd;\n                    assert(chunksize(p) == small_index2size(i));\n                    unlink_first_small_chunk(gm, b, p, i);\n                    rsize = small_index2size(i) - nb;\n                    /* Fit here cannot be remainderless if 4byte sizes */\n                    if (SIZE_T_SIZE != 4 && rsize < MIN_CHUNK_SIZE)\n                        set_inuse_and_pinuse(gm, p, small_index2size(i));\n                    else {\n                        set_size_and_pinuse_of_inuse_chunk(gm, p, nb);\n                        r = chunk_plus_offset(p, nb);\n                        set_size_and_pinuse_of_free_chunk(r, rsize);\n                        replace_dv(gm, r, rsize);\n                    }\n                    mem = chunk2mem(p);\n                    check_malloced_chunk(gm, mem, nb);\n                    goto postaction;\n                }\n\n                else if (gm->treemap != 0\n                         && (mem = tmalloc_small(gm, nb)) != 0) {\n                    check_malloced_chunk(gm, mem, nb);\n                    goto postaction;\n                }\n            }\n        } else if (bytes >= MAX_REQUEST)\n            nb = MAX_SIZE_T;    /* Too big to allocate. Force failure (in sys alloc) */\n        else {\n            nb = pad_request(bytes);\n            if (gm->treemap != 0 && (mem = tmalloc_large(gm, nb)) != 0) {\n                check_malloced_chunk(gm, mem, nb);\n                goto postaction;\n            }\n        }\n\n        if (nb <= gm->dvsize) {\n            size_t rsize = gm->dvsize - nb;\n            mchunkptr p = gm->dv;\n            if (rsize >= MIN_CHUNK_SIZE) {      /* split dv */\n                mchunkptr r = gm->dv = chunk_plus_offset(p, nb);\n                gm->dvsize = rsize;\n                set_size_and_pinuse_of_free_chunk(r, rsize);\n                set_size_and_pinuse_of_inuse_chunk(gm, p, nb);\n            } else {            /* exhaust dv */\n                size_t dvs = gm->dvsize;\n                gm->dvsize = 0;\n                gm->dv = 0;\n                set_inuse_and_pinuse(gm, p, dvs);\n            }\n            mem = chunk2mem(p);\n            check_malloced_chunk(gm, mem, nb);\n            goto postaction;\n        }\n\n        else if (nb < gm->topsize) {    /* Split top */\n            size_t rsize = gm->topsize -= nb;\n            mchunkptr p = gm->top;\n            mchunkptr r = gm->top = chunk_plus_offset(p, nb);\n            r->head = rsize | PINUSE_BIT;\n            set_size_and_pinuse_of_inuse_chunk(gm, p, nb);\n            mem = chunk2mem(p);\n            check_top_chunk(gm, gm->top);\n            check_malloced_chunk(gm, mem, nb);\n            goto postaction;\n        }\n\n        mem = sys_alloc(gm, nb);\n\n      postaction:\n        POSTACTION(gm);\n        return mem;\n    }\n\n    return 0;\n}\n\nvoid\ndlfree(void *mem)\n{\n    /*\n       Consolidate freed chunks with preceeding or succeeding bordering\n       free chunks, if they exist, and then place in a bin.  Intermixed\n       with special cases for top, dv, mmapped chunks, and usage errors.\n     */\n\n    if (mem != 0) {\n        mchunkptr p = mem2chunk(mem);\n#if FOOTERS\n        mstate fm = get_mstate_for(p);\n        if (!ok_magic(fm)) {\n            USAGE_ERROR_ACTION(fm, p);\n            return;\n        }\n#else /* FOOTERS */\n#define fm gm\n#endif /* FOOTERS */\n        if (!PREACTION(fm)) {\n            check_inuse_chunk(fm, p);\n            if (RTCHECK(ok_address(fm, p) && ok_cinuse(p))) {\n                size_t psize = chunksize(p);\n                mchunkptr next = chunk_plus_offset(p, psize);\n                if (!pinuse(p)) {\n                    size_t prevsize = p->prev_foot;\n                    if ((prevsize & IS_MMAPPED_BIT) != 0) {\n                        prevsize &= ~IS_MMAPPED_BIT;\n                        psize += prevsize + MMAP_FOOT_PAD;\n                        if (CALL_MUNMAP((char *) p - prevsize, psize) == 0)\n                            fm->footprint -= psize;\n                        goto postaction;\n                    } else {\n                        mchunkptr prev = chunk_minus_offset(p, prevsize);\n                        psize += prevsize;\n                        p = prev;\n                        if (RTCHECK(ok_address(fm, prev))) {    /* consolidate backward */\n                            if (p != fm->dv) {\n                                unlink_chunk(fm, p, prevsize);\n                            } else if ((next->head & INUSE_BITS) ==\n                                       INUSE_BITS) {\n                                fm->dvsize = psize;\n                                set_free_with_pinuse(p, psize, next);\n                                goto postaction;\n                            }\n                        } else\n                            goto erroraction;\n                    }\n                }\n\n                if (RTCHECK(ok_next(p, next) && ok_pinuse(next))) {\n                    if (!cinuse(next)) {        /* consolidate forward */\n                        if (next == fm->top) {\n                            size_t tsize = fm->topsize += psize;\n                            fm->top = p;\n                            p->head = tsize | PINUSE_BIT;\n                            if (p == fm->dv) {\n                                fm->dv = 0;\n                                fm->dvsize = 0;\n                            }\n                            if (should_trim(fm, tsize))\n                                sys_trim(fm, 0);\n                            goto postaction;\n                        } else if (next == fm->dv) {\n                            size_t dsize = fm->dvsize += psize;\n                            fm->dv = p;\n                            set_size_and_pinuse_of_free_chunk(p, dsize);\n                            goto postaction;\n                        } else {\n                            size_t nsize = chunksize(next);\n                            psize += nsize;\n                            unlink_chunk(fm, next, nsize);\n                            set_size_and_pinuse_of_free_chunk(p, psize);\n                            if (p == fm->dv) {\n                                fm->dvsize = psize;\n                                goto postaction;\n                            }\n                        }\n                    } else\n                        set_free_with_pinuse(p, psize, next);\n                    insert_chunk(fm, p, psize);\n                    check_free_chunk(fm, p);\n                    goto postaction;\n                }\n            }\n          erroraction:\n            USAGE_ERROR_ACTION(fm, p);\n          postaction:\n            POSTACTION(fm);\n        }\n    }\n#if !FOOTERS\n#undef fm\n#endif /* FOOTERS */\n}\n\nvoid *\ndlcalloc(size_t n_elements, size_t elem_size)\n{\n    void *mem;\n    size_t req = 0;\n    if (n_elements != 0) {\n        req = n_elements * elem_size;\n        if (((n_elements | elem_size) & ~(size_t) 0xffff) &&\n            (req / n_elements != elem_size))\n            req = MAX_SIZE_T;   /* force downstream failure on overflow */\n    }\n    mem = dlmalloc(req);\n    if (mem != 0 && calloc_must_clear(mem2chunk(mem)))\n        memset(mem, 0, req);\n    return mem;\n}\n\nvoid *\ndlrealloc(void *oldmem, size_t bytes)\n{\n    if (oldmem == 0)\n        return dlmalloc(bytes);\n#ifdef REALLOC_ZERO_BYTES_FREES\n    if (bytes == 0) {\n        dlfree(oldmem);\n        return 0;\n    }\n#endif /* REALLOC_ZERO_BYTES_FREES */\n    else {\n#if ! FOOTERS\n        mstate m = gm;\n#else /* FOOTERS */\n        mstate m = get_mstate_for(mem2chunk(oldmem));\n        if (!ok_magic(m)) {\n            USAGE_ERROR_ACTION(m, oldmem);\n            return 0;\n        }\n#endif /* FOOTERS */\n        return internal_realloc(m, oldmem, bytes);\n    }\n}\n\nvoid *\ndlmemalign(size_t alignment, size_t bytes)\n{\n    return internal_memalign(gm, alignment, bytes);\n}\n\nvoid **\ndlindependent_calloc(size_t n_elements, size_t elem_size, void *chunks[])\n{\n    size_t sz = elem_size;      /* serves as 1-element array */\n    return ialloc(gm, n_elements, &sz, 3, chunks);\n}\n\nvoid **\ndlindependent_comalloc(size_t n_elements, size_t sizes[], void *chunks[])\n{\n    return ialloc(gm, n_elements, sizes, 0, chunks);\n}\n\nvoid *\ndlvalloc(size_t bytes)\n{\n    size_t pagesz;\n    init_mparams();\n    pagesz = mparams.page_size;\n    return dlmemalign(pagesz, bytes);\n}\n\nvoid *\ndlpvalloc(size_t bytes)\n{\n    size_t pagesz;\n    init_mparams();\n    pagesz = mparams.page_size;\n    return dlmemalign(pagesz,\n                      (bytes + pagesz - SIZE_T_ONE) & ~(pagesz - SIZE_T_ONE));\n}\n\nint\ndlmalloc_trim(size_t pad)\n{\n    int result = 0;\n    if (!PREACTION(gm)) {\n        result = sys_trim(gm, pad);\n        POSTACTION(gm);\n    }\n    return result;\n}\n\nsize_t\ndlmalloc_footprint(void)\n{\n    return gm->footprint;\n}\n\nsize_t\ndlmalloc_max_footprint(void)\n{\n    return gm->max_footprint;\n}\n\n#if !NO_MALLINFO\nstruct mallinfo\ndlmallinfo(void)\n{\n    return internal_mallinfo(gm);\n}\n#endif /* NO_MALLINFO */\n\nvoid\ndlmalloc_stats()\n{\n    internal_malloc_stats(gm);\n}\n\nsize_t\ndlmalloc_usable_size(void *mem)\n{\n    if (mem != 0) {\n        mchunkptr p = mem2chunk(mem);\n        if (cinuse(p))\n            return chunksize(p) - overhead_for(p);\n    }\n    return 0;\n}\n\nint\ndlmallopt(int param_number, int value)\n{\n    return change_mparam(param_number, value);\n}\n\n#endif /* !ONLY_MSPACES */\n\n/* ----------------------------- user mspaces ---------------------------- */\n\n#if MSPACES\n\nstatic mstate\ninit_user_mstate(char *tbase, size_t tsize)\n{\n    size_t msize = pad_request(sizeof(struct malloc_state));\n    mchunkptr mn;\n    mchunkptr msp = align_as_chunk(tbase);\n    mstate m = (mstate) (chunk2mem(msp));\n    memset(m, 0, msize);\n    INITIAL_LOCK(&m->mutex);\n    msp->head = (msize | PINUSE_BIT | CINUSE_BIT);\n    m->seg.base = m->least_addr = tbase;\n    m->seg.size = m->footprint = m->max_footprint = tsize;\n    m->magic = mparams.magic;\n    m->mflags = mparams.default_mflags;\n    disable_contiguous(m);\n    init_bins(m);\n    mn = next_chunk(mem2chunk(m));\n    init_top(m, mn, (size_t) ((tbase + tsize) - (char *) mn) - TOP_FOOT_SIZE);\n    check_top_chunk(m, m->top);\n    return m;\n}\n\nmspace\ncreate_mspace(size_t capacity, int locked)\n{\n    mstate m = 0;\n    size_t msize = pad_request(sizeof(struct malloc_state));\n    init_mparams();             /* Ensure pagesize etc initialized */\n\n    if (capacity < (size_t) - (msize + TOP_FOOT_SIZE + mparams.page_size)) {\n        size_t rs = ((capacity == 0) ? mparams.granularity :\n                     (capacity + TOP_FOOT_SIZE + msize));\n        size_t tsize = granularity_align(rs);\n        char *tbase = (char *) (CALL_MMAP(tsize));\n        if (tbase != CMFAIL) {\n            m = init_user_mstate(tbase, tsize);\n            m->seg.sflags = IS_MMAPPED_BIT;\n            set_lock(m, locked);\n        }\n    }\n    return (mspace) m;\n}\n\nmspace\ncreate_mspace_with_base(void *base, size_t capacity, int locked)\n{\n    mstate m = 0;\n    size_t msize = pad_request(sizeof(struct malloc_state));\n    init_mparams();             /* Ensure pagesize etc initialized */\n\n    if (capacity > msize + TOP_FOOT_SIZE &&\n        capacity < (size_t) - (msize + TOP_FOOT_SIZE + mparams.page_size)) {\n        m = init_user_mstate((char *) base, capacity);\n        m->seg.sflags = EXTERN_BIT;\n        set_lock(m, locked);\n    }\n    return (mspace) m;\n}\n\nsize_t\ndestroy_mspace(mspace msp)\n{\n    size_t freed = 0;\n    mstate ms = (mstate) msp;\n    if (ok_magic(ms)) {\n        msegmentptr sp = &ms->seg;\n        while (sp != 0) {\n            char *base = sp->base;\n            size_t size = sp->size;\n            flag_t flag = sp->sflags;\n            sp = sp->next;\n            if ((flag & IS_MMAPPED_BIT) && !(flag & EXTERN_BIT) &&\n                CALL_MUNMAP(base, size) == 0)\n                freed += size;\n        }\n    } else {\n        USAGE_ERROR_ACTION(ms, ms);\n    }\n    return freed;\n}\n\n/*\n  mspace versions of routines are near-clones of the global\n  versions. This is not so nice but better than the alternatives.\n*/\n\n\nvoid *\nmspace_malloc(mspace msp, size_t bytes)\n{\n    mstate ms = (mstate) msp;\n    if (!ok_magic(ms)) {\n        USAGE_ERROR_ACTION(ms, ms);\n        return 0;\n    }\n    if (!PREACTION(ms)) {\n        void *mem;\n        size_t nb;\n        if (bytes <= MAX_SMALL_REQUEST) {\n            bindex_t idx;\n            binmap_t smallbits;\n            nb = (bytes < MIN_REQUEST) ? MIN_CHUNK_SIZE : pad_request(bytes);\n            idx = small_index(nb);\n            smallbits = ms->smallmap >> idx;\n\n            if ((smallbits & 0x3U) != 0) {      /* Remainderless fit to a smallbin. */\n                mchunkptr b, p;\n                idx += ~smallbits & 1;  /* Uses next bin if idx empty */\n                b = smallbin_at(ms, idx);\n                p = b->fd;\n                assert(chunksize(p) == small_index2size(idx));\n                unlink_first_small_chunk(ms, b, p, idx);\n                set_inuse_and_pinuse(ms, p, small_index2size(idx));\n                mem = chunk2mem(p);\n                check_malloced_chunk(ms, mem, nb);\n                goto postaction;\n            }\n\n            else if (nb > ms->dvsize) {\n                if (smallbits != 0) {   /* Use chunk in next nonempty smallbin */\n                    mchunkptr b, p, r;\n                    size_t rsize;\n                    bindex_t i;\n                    binmap_t leftbits =\n                        (smallbits << idx) & left_bits(idx2bit(idx));\n                    binmap_t leastbit = least_bit(leftbits);\n                    compute_bit2idx(leastbit, i);\n                    b = smallbin_at(ms, i);\n                    p = b->fd;\n                    assert(chunksize(p) == small_index2size(i));\n                    unlink_first_small_chunk(ms, b, p, i);\n                    rsize = small_index2size(i) - nb;\n                    /* Fit here cannot be remainderless if 4byte sizes */\n                    if (SIZE_T_SIZE != 4 && rsize < MIN_CHUNK_SIZE)\n                        set_inuse_and_pinuse(ms, p, small_index2size(i));\n                    else {\n                        set_size_and_pinuse_of_inuse_chunk(ms, p, nb);\n                        r = chunk_plus_offset(p, nb);\n                        set_size_and_pinuse_of_free_chunk(r, rsize);\n                        replace_dv(ms, r, rsize);\n                    }\n                    mem = chunk2mem(p);\n                    check_malloced_chunk(ms, mem, nb);\n                    goto postaction;\n                }\n\n                else if (ms->treemap != 0\n                         && (mem = tmalloc_small(ms, nb)) != 0) {\n                    check_malloced_chunk(ms, mem, nb);\n                    goto postaction;\n                }\n            }\n        } else if (bytes >= MAX_REQUEST)\n            nb = MAX_SIZE_T;    /* Too big to allocate. Force failure (in sys alloc) */\n        else {\n            nb = pad_request(bytes);\n            if (ms->treemap != 0 && (mem = tmalloc_large(ms, nb)) != 0) {\n                check_malloced_chunk(ms, mem, nb);\n                goto postaction;\n            }\n        }\n\n        if (nb <= ms->dvsize) {\n            size_t rsize = ms->dvsize - nb;\n            mchunkptr p = ms->dv;\n            if (rsize >= MIN_CHUNK_SIZE) {      /* split dv */\n                mchunkptr r = ms->dv = chunk_plus_offset(p, nb);\n                ms->dvsize = rsize;\n                set_size_and_pinuse_of_free_chunk(r, rsize);\n                set_size_and_pinuse_of_inuse_chunk(ms, p, nb);\n            } else {            /* exhaust dv */\n                size_t dvs = ms->dvsize;\n                ms->dvsize = 0;\n                ms->dv = 0;\n                set_inuse_and_pinuse(ms, p, dvs);\n            }\n            mem = chunk2mem(p);\n            check_malloced_chunk(ms, mem, nb);\n            goto postaction;\n        }\n\n        else if (nb < ms->topsize) {    /* Split top */\n            size_t rsize = ms->topsize -= nb;\n            mchunkptr p = ms->top;\n            mchunkptr r = ms->top = chunk_plus_offset(p, nb);\n            r->head = rsize | PINUSE_BIT;\n            set_size_and_pinuse_of_inuse_chunk(ms, p, nb);\n            mem = chunk2mem(p);\n            check_top_chunk(ms, ms->top);\n            check_malloced_chunk(ms, mem, nb);\n            goto postaction;\n        }\n\n        mem = sys_alloc(ms, nb);\n\n      postaction:\n        POSTACTION(ms);\n        return mem;\n    }\n\n    return 0;\n}\n\nvoid\nmspace_free(mspace msp, void *mem)\n{\n    if (mem != 0) {\n        mchunkptr p = mem2chunk(mem);\n#if FOOTERS\n        mstate fm = get_mstate_for(p);\n#else /* FOOTERS */\n        mstate fm = (mstate) msp;\n#endif /* FOOTERS */\n        if (!ok_magic(fm)) {\n            USAGE_ERROR_ACTION(fm, p);\n            return;\n        }\n        if (!PREACTION(fm)) {\n            check_inuse_chunk(fm, p);\n            if (RTCHECK(ok_address(fm, p) && ok_cinuse(p))) {\n                size_t psize = chunksize(p);\n                mchunkptr next = chunk_plus_offset(p, psize);\n                if (!pinuse(p)) {\n                    size_t prevsize = p->prev_foot;\n                    if ((prevsize & IS_MMAPPED_BIT) != 0) {\n                        prevsize &= ~IS_MMAPPED_BIT;\n                        psize += prevsize + MMAP_FOOT_PAD;\n                        if (CALL_MUNMAP((char *) p - prevsize, psize) == 0)\n                            fm->footprint -= psize;\n                        goto postaction;\n                    } else {\n                        mchunkptr prev = chunk_minus_offset(p, prevsize);\n                        psize += prevsize;\n                        p = prev;\n                        if (RTCHECK(ok_address(fm, prev))) {    /* consolidate backward */\n                            if (p != fm->dv) {\n                                unlink_chunk(fm, p, prevsize);\n                            } else if ((next->head & INUSE_BITS) ==\n                                       INUSE_BITS) {\n                                fm->dvsize = psize;\n                                set_free_with_pinuse(p, psize, next);\n                                goto postaction;\n                            }\n                        } else\n                            goto erroraction;\n                    }\n                }\n\n                if (RTCHECK(ok_next(p, next) && ok_pinuse(next))) {\n                    if (!cinuse(next)) {        /* consolidate forward */\n                        if (next == fm->top) {\n                            size_t tsize = fm->topsize += psize;\n                            fm->top = p;\n                            p->head = tsize | PINUSE_BIT;\n                            if (p == fm->dv) {\n                                fm->dv = 0;\n                                fm->dvsize = 0;\n                            }\n                            if (should_trim(fm, tsize))\n                                sys_trim(fm, 0);\n                            goto postaction;\n                        } else if (next == fm->dv) {\n                            size_t dsize = fm->dvsize += psize;\n                            fm->dv = p;\n                            set_size_and_pinuse_of_free_chunk(p, dsize);\n                            goto postaction;\n                        } else {\n                            size_t nsize = chunksize(next);\n                            psize += nsize;\n                            unlink_chunk(fm, next, nsize);\n                            set_size_and_pinuse_of_free_chunk(p, psize);\n                            if (p == fm->dv) {\n                                fm->dvsize = psize;\n                                goto postaction;\n                            }\n                        }\n                    } else\n                        set_free_with_pinuse(p, psize, next);\n                    insert_chunk(fm, p, psize);\n                    check_free_chunk(fm, p);\n                    goto postaction;\n                }\n            }\n          erroraction:\n            USAGE_ERROR_ACTION(fm, p);\n          postaction:\n            POSTACTION(fm);\n        }\n    }\n}\n\nvoid *\nmspace_calloc(mspace msp, size_t n_elements, size_t elem_size)\n{\n    void *mem;\n    size_t req = 0;\n    mstate ms = (mstate) msp;\n    if (!ok_magic(ms)) {\n        USAGE_ERROR_ACTION(ms, ms);\n        return 0;\n    }\n    if (n_elements != 0) {\n        req = n_elements * elem_size;\n        if (((n_elements | elem_size) & ~(size_t) 0xffff) &&\n            (req / n_elements != elem_size))\n            req = MAX_SIZE_T;   /* force downstream failure on overflow */\n    }\n    mem = internal_malloc(ms, req);\n    if (mem != 0 && calloc_must_clear(mem2chunk(mem)))\n        memset(mem, 0, req);\n    return mem;\n}\n\nvoid *\nmspace_realloc(mspace msp, void *oldmem, size_t bytes)\n{\n    if (oldmem == 0)\n        return mspace_malloc(msp, bytes);\n#ifdef REALLOC_ZERO_BYTES_FREES\n    if (bytes == 0) {\n        mspace_free(msp, oldmem);\n        return 0;\n    }\n#endif /* REALLOC_ZERO_BYTES_FREES */\n    else {\n#if FOOTERS\n        mchunkptr p = mem2chunk(oldmem);\n        mstate ms = get_mstate_for(p);\n#else /* FOOTERS */\n        mstate ms = (mstate) msp;\n#endif /* FOOTERS */\n        if (!ok_magic(ms)) {\n            USAGE_ERROR_ACTION(ms, ms);\n            return 0;\n        }\n        return internal_realloc(ms, oldmem, bytes);\n    }\n}\n\nvoid *\nmspace_memalign(mspace msp, size_t alignment, size_t bytes)\n{\n    mstate ms = (mstate) msp;\n    if (!ok_magic(ms)) {\n        USAGE_ERROR_ACTION(ms, ms);\n        return 0;\n    }\n    return internal_memalign(ms, alignment, bytes);\n}\n\nvoid **\nmspace_independent_calloc(mspace msp, size_t n_elements,\n                          size_t elem_size, void *chunks[])\n{\n    size_t sz = elem_size;      /* serves as 1-element array */\n    mstate ms = (mstate) msp;\n    if (!ok_magic(ms)) {\n        USAGE_ERROR_ACTION(ms, ms);\n        return 0;\n    }\n    return ialloc(ms, n_elements, &sz, 3, chunks);\n}\n\nvoid **\nmspace_independent_comalloc(mspace msp, size_t n_elements,\n                            size_t sizes[], void *chunks[])\n{\n    mstate ms = (mstate) msp;\n    if (!ok_magic(ms)) {\n        USAGE_ERROR_ACTION(ms, ms);\n        return 0;\n    }\n    return ialloc(ms, n_elements, sizes, 0, chunks);\n}\n\nint\nmspace_trim(mspace msp, size_t pad)\n{\n    int result = 0;\n    mstate ms = (mstate) msp;\n    if (ok_magic(ms)) {\n        if (!PREACTION(ms)) {\n            result = sys_trim(ms, pad);\n            POSTACTION(ms);\n        }\n    } else {\n        USAGE_ERROR_ACTION(ms, ms);\n    }\n    return result;\n}\n\nvoid\nmspace_malloc_stats(mspace msp)\n{\n    mstate ms = (mstate) msp;\n    if (ok_magic(ms)) {\n        internal_malloc_stats(ms);\n    } else {\n        USAGE_ERROR_ACTION(ms, ms);\n    }\n}\n\nsize_t\nmspace_footprint(mspace msp)\n{\n    size_t result;\n    mstate ms = (mstate) msp;\n    if (ok_magic(ms)) {\n        result = ms->footprint;\n    }\n    USAGE_ERROR_ACTION(ms, ms);\n    return result;\n}\n\n\nsize_t\nmspace_max_footprint(mspace msp)\n{\n    size_t result;\n    mstate ms = (mstate) msp;\n    if (ok_magic(ms)) {\n        result = ms->max_footprint;\n    }\n    USAGE_ERROR_ACTION(ms, ms);\n    return result;\n}\n\n\n#if !NO_MALLINFO\nstruct mallinfo\nmspace_mallinfo(mspace msp)\n{\n    mstate ms = (mstate) msp;\n    if (!ok_magic(ms)) {\n        USAGE_ERROR_ACTION(ms, ms);\n    }\n    return internal_mallinfo(ms);\n}\n#endif /* NO_MALLINFO */\n\nint\nmspace_mallopt(int param_number, int value)\n{\n    return change_mparam(param_number, value);\n}\n\n#endif /* MSPACES */\n\n/* -------------------- Alternative MORECORE functions ------------------- */\n\n/*\n  Guidelines for creating a custom version of MORECORE:\n\n  * For best performance, MORECORE should allocate in multiples of pagesize.\n  * MORECORE may allocate more memory than requested. (Or even less,\n      but this will usually result in a malloc failure.)\n  * MORECORE must not allocate memory when given argument zero, but\n      instead return one past the end address of memory from previous\n      nonzero call.\n  * For best performance, consecutive calls to MORECORE with positive\n      arguments should return increasing addresses, indicating that\n      space has been contiguously extended.\n  * Even though consecutive calls to MORECORE need not return contiguous\n      addresses, it must be OK for malloc'ed chunks to span multiple\n      regions in those cases where they do happen to be contiguous.\n  * MORECORE need not handle negative arguments -- it may instead\n      just return MFAIL when given negative arguments.\n      Negative arguments are always multiples of pagesize. MORECORE\n      must not misinterpret negative args as large positive unsigned\n      args. You can suppress all such calls from even occurring by defining\n      MORECORE_CANNOT_TRIM,\n\n  As an example alternative MORECORE, here is a custom allocator\n  kindly contributed for pre-OSX macOS.  It uses virtually but not\n  necessarily physically contiguous non-paged memory (locked in,\n  present and won't get swapped out).  You can use it by uncommenting\n  this section, adding some #includes, and setting up the appropriate\n  defines above:\n\n      #define MORECORE osMoreCore\n\n  There is also a shutdown routine that should somehow be called for\n  cleanup upon program exit.\n\n  #define MAX_POOL_ENTRIES 100\n  #define MINIMUM_MORECORE_SIZE  (64 * 1024U)\n  static int next_os_pool;\n  void *our_os_pools[MAX_POOL_ENTRIES];\n\n  void *osMoreCore(int size)\n  {\n    void *ptr = 0;\n    static void *sbrk_top = 0;\n\n    if (size > 0)\n    {\n      if (size < MINIMUM_MORECORE_SIZE)\n         size = MINIMUM_MORECORE_SIZE;\n      if (CurrentExecutionLevel() == kTaskLevel)\n         ptr = PoolAllocateResident(size + RM_PAGE_SIZE, 0);\n      if (ptr == 0)\n      {\n        return (void *) MFAIL;\n      }\n      // save ptrs so they can be freed during cleanup\n      our_os_pools[next_os_pool] = ptr;\n      next_os_pool++;\n      ptr = (void *) ((((size_t) ptr) + RM_PAGE_MASK) & ~RM_PAGE_MASK);\n      sbrk_top = (char *) ptr + size;\n      return ptr;\n    }\n    else if (size < 0)\n    {\n      // we don't currently support shrink behavior\n      return (void *) MFAIL;\n    }\n    else\n    {\n      return sbrk_top;\n    }\n  }\n\n  // cleanup any allocated memory pools\n  // called as last thing before shutting down driver\n\n  void osCleanupMem(void)\n  {\n    void **ptr;\n\n    for (ptr = our_os_pools; ptr < &our_os_pools[MAX_POOL_ENTRIES]; ptr++)\n      if (*ptr)\n      {\n         PoolDeallocate(*ptr);\n         *ptr = 0;\n      }\n  }\n\n*/\n\n\n/* -----------------------------------------------------------------------\nHistory:\n    V2.8.3 Thu Sep 22 11:16:32 2005  Doug Lea  (dl at gee)\n      * Add max_footprint functions\n      * Ensure all appropriate literals are size_t\n      * Fix conditional compilation problem for some #define settings\n      * Avoid concatenating segments with the one provided\n        in create_mspace_with_base\n      * Rename some variables to avoid compiler shadowing warnings\n      * Use explicit lock initialization.\n      * Better handling of sbrk interference.\n      * Simplify and fix segment insertion, trimming and mspace_destroy\n      * Reinstate REALLOC_ZERO_BYTES_FREES option from 2.7.x\n      * Thanks especially to Dennis Flanagan for help on these.\n\n    V2.8.2 Sun Jun 12 16:01:10 2005  Doug Lea  (dl at gee)\n      * Fix memalign brace error.\n\n    V2.8.1 Wed Jun  8 16:11:46 2005  Doug Lea  (dl at gee)\n      * Fix improper #endif nesting in C++\n      * Add explicit casts needed for C++\n\n    V2.8.0 Mon May 30 14:09:02 2005  Doug Lea  (dl at gee)\n      * Use trees for large bins\n      * Support mspaces\n      * Use segments to unify sbrk-based and mmap-based system allocation,\n        removing need for emulation on most platforms without sbrk.\n      * Default safety checks\n      * Optional footer checks. Thanks to William Robertson for the idea.\n      * Internal code refactoring\n      * Incorporate suggestions and platform-specific changes.\n        Thanks to Dennis Flanagan, Colin Plumb, Niall Douglas,\n        Aaron Bachmann,  Emery Berger, and others.\n      * Speed up non-fastbin processing enough to remove fastbins.\n      * Remove useless cfree() to avoid conflicts with other apps.\n      * Remove internal memcpy, memset. Compilers handle builtins better.\n      * Remove some options that no one ever used and rename others.\n\n    V2.7.2 Sat Aug 17 09:07:30 2002  Doug Lea  (dl at gee)\n      * Fix malloc_state bitmap array misdeclaration\n\n    V2.7.1 Thu Jul 25 10:58:03 2002  Doug Lea  (dl at gee)\n      * Allow tuning of FIRST_SORTED_BIN_SIZE\n      * Use PTR_UINT as type for all ptr->int casts. Thanks to John Belmonte.\n      * Better detection and support for non-contiguousness of MORECORE.\n        Thanks to Andreas Mueller, Conal Walsh, and Wolfram Gloger\n      * Bypass most of malloc if no frees. Thanks To Emery Berger.\n      * Fix freeing of old top non-contiguous chunk im sysmalloc.\n      * Raised default trim and map thresholds to 256K.\n      * Fix mmap-related #defines. Thanks to Lubos Lunak.\n      * Fix copy macros; added LACKS_FCNTL_H. Thanks to Neal Walfield.\n      * Branch-free bin calculation\n      * Default trim and mmap thresholds now 256K.\n\n    V2.7.0 Sun Mar 11 14:14:06 2001  Doug Lea  (dl at gee)\n      * Introduce independent_comalloc and independent_calloc.\n        Thanks to Michael Pachos for motivation and help.\n      * Make optional .h file available\n      * Allow > 2GB requests on 32bit systems.\n      * new WIN32 sbrk, mmap, munmap, lock code from <Walter@GeNeSys-e.de>.\n        Thanks also to Andreas Mueller <a.mueller at paradatec.de>,\n        and Anonymous.\n      * Allow override of MALLOC_ALIGNMENT (Thanks to Ruud Waij for\n        helping test this.)\n      * memalign: check alignment arg\n      * realloc: don't try to shift chunks backwards, since this\n        leads to  more fragmentation in some programs and doesn't\n        seem to help in any others.\n      * Collect all cases in malloc requiring system memory into sysmalloc\n      * Use mmap as backup to sbrk\n      * Place all internal state in malloc_state\n      * Introduce fastbins (although similar to 2.5.1)\n      * Many minor tunings and cosmetic improvements\n      * Introduce USE_PUBLIC_MALLOC_WRAPPERS, USE_MALLOC_LOCK\n      * Introduce MALLOC_FAILURE_ACTION, MORECORE_CONTIGUOUS\n        Thanks to Tony E. Bennett <tbennett@nvidia.com> and others.\n      * Include errno.h to support default failure action.\n\n    V2.6.6 Sun Dec  5 07:42:19 1999  Doug Lea  (dl at gee)\n      * return null for negative arguments\n      * Added Several WIN32 cleanups from Martin C. Fong <mcfong at yahoo.com>\n         * Add 'LACKS_SYS_PARAM_H' for those systems without 'sys/param.h'\n          (e.g. WIN32 platforms)\n         * Cleanup header file inclusion for WIN32 platforms\n         * Cleanup code to avoid Microsoft Visual C++ compiler complaints\n         * Add 'USE_DL_PREFIX' to quickly allow co-existence with existing\n           memory allocation routines\n         * Set 'malloc_getpagesize' for WIN32 platforms (needs more work)\n         * Use 'assert' rather than 'ASSERT' in WIN32 code to conform to\n           usage of 'assert' in non-WIN32 code\n         * Improve WIN32 'sbrk()' emulation's 'findRegion()' routine to\n           avoid infinite loop\n      * Always call 'fREe()' rather than 'free()'\n\n    V2.6.5 Wed Jun 17 15:57:31 1998  Doug Lea  (dl at gee)\n      * Fixed ordering problem with boundary-stamping\n\n    V2.6.3 Sun May 19 08:17:58 1996  Doug Lea  (dl at gee)\n      * Added pvalloc, as recommended by H.J. Liu\n      * Added 64bit pointer support mainly from Wolfram Gloger\n      * Added anonymously donated WIN32 sbrk emulation\n      * Malloc, calloc, getpagesize: add optimizations from Raymond Nijssen\n      * malloc_extend_top: fix mask error that caused wastage after\n        foreign sbrks\n      * Add linux mremap support code from HJ Liu\n\n    V2.6.2 Tue Dec  5 06:52:55 1995  Doug Lea  (dl at gee)\n      * Integrated most documentation with the code.\n      * Add support for mmap, with help from\n        Wolfram Gloger (Gloger@lrz.uni-muenchen.de).\n      * Use last_remainder in more cases.\n      * Pack bins using idea from  colin@nyx10.cs.du.edu\n      * Use ordered bins instead of best-fit threshhold\n      * Eliminate block-local decls to simplify tracing and debugging.\n      * Support another case of realloc via move into top\n      * Fix error occuring when initial sbrk_base not word-aligned.\n      * Rely on page size for units instead of SBRK_UNIT to\n        avoid surprises about sbrk alignment conventions.\n      * Add mallinfo, mallopt. Thanks to Raymond Nijssen\n        (raymond@es.ele.tue.nl) for the suggestion.\n      * Add `pad' argument to malloc_trim and top_pad mallopt parameter.\n      * More precautions for cases where other routines call sbrk,\n        courtesy of Wolfram Gloger (Gloger@lrz.uni-muenchen.de).\n      * Added macros etc., allowing use in linux libc from\n        H.J. Lu (hjl@gnu.ai.mit.edu)\n      * Inverted this history list\n\n    V2.6.1 Sat Dec  2 14:10:57 1995  Doug Lea  (dl at gee)\n      * Re-tuned and fixed to behave more nicely with V2.6.0 changes.\n      * Removed all preallocation code since under current scheme\n        the work required to undo bad preallocations exceeds\n        the work saved in good cases for most test programs.\n      * No longer use return list or unconsolidated bins since\n        no scheme using them consistently outperforms those that don't\n        given above changes.\n      * Use best fit for very large chunks to prevent some worst-cases.\n      * Added some support for debugging\n\n    V2.6.0 Sat Nov  4 07:05:23 1995  Doug Lea  (dl at gee)\n      * Removed footers when chunks are in use. Thanks to\n        Paul Wilson (wilson@cs.texas.edu) for the suggestion.\n\n    V2.5.4 Wed Nov  1 07:54:51 1995  Doug Lea  (dl at gee)\n      * Added malloc_trim, with help from Wolfram Gloger\n        (wmglo@Dent.MED.Uni-Muenchen.DE).\n\n    V2.5.3 Tue Apr 26 10:16:01 1994  Doug Lea  (dl at g)\n\n    V2.5.2 Tue Apr  5 16:20:40 1994  Doug Lea  (dl at g)\n      * realloc: try to expand in both directions\n      * malloc: swap order of clean-bin strategy;\n      * realloc: only conditionally expand backwards\n      * Try not to scavenge used bins\n      * Use bin counts as a guide to preallocation\n      * Occasionally bin return list chunks in first scan\n      * Add a few optimizations from colin@nyx10.cs.du.edu\n\n    V2.5.1 Sat Aug 14 15:40:43 1993  Doug Lea  (dl at g)\n      * faster bin computation & slightly different binning\n      * merged all consolidations to one part of malloc proper\n         (eliminating old malloc_find_space & malloc_clean_bin)\n      * Scan 2 returns chunks (not just 1)\n      * Propagate failure in realloc if malloc returns 0\n      * Add stuff to allow compilation on non-ANSI compilers\n          from kpv@research.att.com\n\n    V2.5 Sat Aug  7 07:41:59 1993  Doug Lea  (dl at g.oswego.edu)\n      * removed potential for odd address access in prev_chunk\n      * removed dependency on getpagesize.h\n      * misc cosmetics and a bit more internal documentation\n      * anticosmetics: mangled names in macros to evade debugger strangeness\n      * tested on sparc, hp-700, dec-mips, rs6000\n          with gcc & native cc (hp, dec only) allowing\n          Detlefs & Zorn comparison study (in SIGPLAN Notices.)\n\n    Trial version Fri Aug 28 13:14:29 1992  Doug Lea  (dl at g.oswego.edu)\n      * Based loosely on libg++-1.2X malloc. (It retains some of the overall\n         structure of old version,  but most details differ.)\n\n*/\n\n#endif /* !HAVE_MALLOC */\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n\n#if defined(__clang_analyzer__) && !defined(SDL_DISABLE_ANALYZE_MACROS)\n#define SDL_DISABLE_ANALYZE_MACROS 1\n#endif\n\n#include \"../SDL_internal.h\"\n\n/* This file contains portable stdlib functions for SDL */\n\n#include \"SDL_stdinc.h\"\n#include \"../libm/math_libm.h\"\n\n\ndouble\nSDL_atan(double x)\n{\n#ifdef HAVE_ATAN\n    return atan(x);\n#else\n    return SDL_uclibc_atan(x);\n#endif /* HAVE_ATAN */\n}\n\ndouble\nSDL_atan2(double x, double y)\n{\n#if defined(HAVE_ATAN2)\n    return atan2(x, y);\n#else\n    return SDL_uclibc_atan2(x, y);\n#endif /* HAVE_ATAN2 */\n}\n\ndouble\nSDL_acos(double val)\n{\n#if defined(HAVE_ACOS)\n    return acos(val);\n#else\n    double result;\n    if (val == -1.0) {\n        result = M_PI;\n    } else {\n        result = SDL_atan(SDL_sqrt(1.0 - val * val) / val);\n        if (result < 0.0)\n        {\n            result += M_PI;\n        }\n    }\n    return result;\n#endif\n}\n\ndouble\nSDL_asin(double val)\n{\n#if defined(HAVE_ASIN)\n    return asin(val);\n#else\n    double result;\n    if (val == -1.0) {\n        result = -(M_PI / 2.0);\n    } else {\n        result = (M_PI / 2.0) - SDL_acos(val);\n    }\n    return result;\n#endif\n}\n\ndouble\nSDL_ceil(double x)\n{\n#ifdef HAVE_CEIL\n    return ceil(x);\n#else\n    double integer = SDL_floor(x);\n    double fraction = x - integer;\n    if (fraction > 0.0) {\n        integer += 1.0;\n    }\n    return integer;\n#endif /* HAVE_CEIL */\n}\n\ndouble\nSDL_copysign(double x, double y)\n{\n#if defined(HAVE_COPYSIGN)\n    return copysign(x, y);\n#elif defined(HAVE__COPYSIGN)\n    return _copysign(x, y);\n#else\n    return SDL_uclibc_copysign(x, y);\n#endif /* HAVE_COPYSIGN */\n}\n\ndouble\nSDL_cos(double x)\n{\n#if defined(HAVE_COS)\n    return cos(x);\n#else\n    return SDL_uclibc_cos(x);\n#endif /* HAVE_COS */\n}\n\nfloat\nSDL_cosf(float x)\n{\n#ifdef HAVE_COSF\n    return cosf(x);\n#else\n    return (float)SDL_cos((double)x);\n#endif\n}\n\ndouble\nSDL_fabs(double x)\n{\n#if defined(HAVE_FABS)\n    return fabs(x); \n#else\n    return SDL_uclibc_fabs(x);\n#endif /* HAVE_FABS */\n}\n\ndouble\nSDL_floor(double x)\n{\n#if defined(HAVE_FLOOR)\n    return floor(x);\n#else\n    return SDL_uclibc_floor(x);\n#endif /* HAVE_FLOOR */\n}\n\ndouble\nSDL_log(double x)\n{\n#if defined(HAVE_LOG)\n    return log(x);\n#else\n    return SDL_uclibc_log(x);\n#endif /* HAVE_LOG */\n}\n\ndouble\nSDL_pow(double x, double y)\n{\n#if defined(HAVE_POW)\n    return pow(x, y);\n#else\n    return SDL_uclibc_pow(x, y);\n#endif /* HAVE_POW */\n}\n\ndouble\nSDL_scalbn(double x, int n)\n{\n#if defined(HAVE_SCALBN)\n    return scalbn(x, n);\n#elif defined(HAVE__SCALB)\n    return _scalb(x, n);\n#else\n    return SDL_uclibc_scalbn(x, n);\n#endif /* HAVE_SCALBN */\n}\n\ndouble\nSDL_sin(double x)\n{\n#if defined(HAVE_SIN)\n    return sin(x);\n#else\n    return SDL_uclibc_sin(x);\n#endif /* HAVE_SIN */\n}\n\nfloat \nSDL_sinf(float x)\n{\n#ifdef HAVE_SINF\n    return sinf(x);\n#else\n    return (float)SDL_sin((double)x);\n#endif /* HAVE_SINF */\n}\n\ndouble\nSDL_sqrt(double x)\n{\n#if defined(HAVE_SQRT)\n    return sqrt(x);\n#else\n    return SDL_uclibc_sqrt(x);\n#endif\n}\n\nfloat\nSDL_sqrtf(float x)\n{\n#if defined(HAVE_SQRTF)\n    return sqrtf(x);\n#else\n    return (float)SDL_sqrt((double)x);\n#endif\n}\n\ndouble\nSDL_tan(double x)\n{\n#if defined(HAVE_TAN)\n    return tan(x);\n#else\n    return SDL_uclibc_tan(x);\n#endif\n}\n\nfloat\nSDL_tanf(float x)\n{\n#if defined(HAVE_TANF)\n    return tanf(x);\n#else\n    return (float)SDL_tan((double)x);\n#endif\n}\n\nint SDL_abs(int x)\n{\n#ifdef HAVE_ABS\n    return abs(x);\n#else\n    return ((x) < 0 ? -(x) : (x));\n#endif\n}\n\n#ifdef HAVE_CTYPE_H\nint SDL_isdigit(int x) { return isdigit(x); }\nint SDL_isspace(int x) { return isspace(x); }\nint SDL_toupper(int x) { return toupper(x); }\nint SDL_tolower(int x) { return tolower(x); }\n#else\nint SDL_isdigit(int x) { return ((x) >= '0') && ((x) <= '9'); }\nint SDL_isspace(int x) { return ((x) == ' ') || ((x) == '\\t') || ((x) == '\\r') || ((x) == '\\n') || ((x) == '\\f') || ((x) == '\\v'); }\nint SDL_toupper(int x) { return ((x) >= 'a') && ((x) <= 'z') ? ('A'+((x)-'a')) : (x); }\nint SDL_tolower(int x) { return ((x) >= 'A') && ((x) <= 'Z') ? ('a'+((x)-'A')) : (x); }\n#endif\n\n\n#ifndef HAVE_LIBC\n/* These are some C runtime intrinsics that need to be defined */\n\n#if defined(_MSC_VER)\n\n#ifndef __FLTUSED__\n#define __FLTUSED__\n__declspec(selectany) int _fltused = 1;\n#endif\n\n/* The optimizer on Visual Studio 2010/2012 generates memcpy() calls */\n#if _MSC_VER >= 1600 && defined(_WIN64) && !defined(_DEBUG)\n#include <intrin.h>\n\n#pragma function(memcpy)\nvoid * memcpy ( void * destination, const void * source, size_t num )\n{\n    const Uint8 *src = (const Uint8 *)source;\n    Uint8 *dst = (Uint8 *)destination;\n    size_t i;\n    \n    /* All WIN64 architectures have SSE, right? */\n    if (!((uintptr_t) src & 15) && !((uintptr_t) dst & 15)) {\n        __m128 values[4];\n        for (i = num / 64; i--;) {\n            _mm_prefetch(src, _MM_HINT_NTA);\n            values[0] = *(__m128 *) (src + 0);\n            values[1] = *(__m128 *) (src + 16);\n            values[2] = *(__m128 *) (src + 32);\n            values[3] = *(__m128 *) (src + 48);\n            _mm_stream_ps((float *) (dst + 0), values[0]);\n            _mm_stream_ps((float *) (dst + 16), values[1]);\n            _mm_stream_ps((float *) (dst + 32), values[2]);\n            _mm_stream_ps((float *) (dst + 48), values[3]);\n            src += 64;\n            dst += 64;\n        }\n        num &= 63;\n    }\n\n    while (num--) {\n        *dst++ = *src++;\n    }\n    return destination;\n}\n#endif /* _MSC_VER == 1600 && defined(_WIN64) && !defined(_DEBUG) */\n\n#ifdef _M_IX86\n\n/* Float to long */\nvoid\n__declspec(naked)\n_ftol()\n{\n    /* *INDENT-OFF* */\n    __asm {\n        push        ebp\n        mov         ebp,esp\n        sub         esp,20h\n        and         esp,0FFFFFFF0h\n        fld         st(0)\n        fst         dword ptr [esp+18h]\n        fistp       qword ptr [esp+10h]\n        fild        qword ptr [esp+10h]\n        mov         edx,dword ptr [esp+18h]\n        mov         eax,dword ptr [esp+10h]\n        test        eax,eax\n        je          integer_QnaN_or_zero\narg_is_not_integer_QnaN:\n        fsubp       st(1),st\n        test        edx,edx\n        jns         positive\n        fstp        dword ptr [esp]\n        mov         ecx,dword ptr [esp]\n        xor         ecx,80000000h\n        add         ecx,7FFFFFFFh\n        adc         eax,0\n        mov         edx,dword ptr [esp+14h]\n        adc         edx,0\n        jmp         localexit\npositive:\n        fstp        dword ptr [esp]\n        mov         ecx,dword ptr [esp]\n        add         ecx,7FFFFFFFh\n        sbb         eax,0\n        mov         edx,dword ptr [esp+14h]\n        sbb         edx,0\n        jmp         localexit\ninteger_QnaN_or_zero:\n        mov         edx,dword ptr [esp+14h]\n        test        edx,7FFFFFFFh\n        jne         arg_is_not_integer_QnaN\n        fstp        dword ptr [esp+18h]\n        fstp        dword ptr [esp+18h]\nlocalexit:\n        leave\n        ret\n    }\n    /* *INDENT-ON* */\n}\n\nvoid\n_ftol2_sse()\n{\n    _ftol();\n}\n\n/* 64-bit math operators for 32-bit systems */\r\nvoid\r\n__declspec(naked)\r\n_allmul()\r\n{\r\n    /* *INDENT-OFF* */\r\n    __asm {\r\n        mov         eax, dword ptr[esp+8]\r\n        mov         ecx, dword ptr[esp+10h]\r\n        or          ecx, eax\r\n        mov         ecx, dword ptr[esp+0Ch]\r\n        jne         hard\r\n        mov         eax, dword ptr[esp+4]\r\n        mul         ecx\r\n        ret         10h\r\nhard:\r\n        push        ebx\r\n        mul         ecx\r\n        mov         ebx, eax\r\n        mov         eax, dword ptr[esp+8]\r\n        mul         dword ptr[esp+14h]\r\n        add         ebx, eax\r\n        mov         eax, dword ptr[esp+8]\r\n        mul         ecx\r\n        add         edx, ebx\r\n        pop         ebx\r\n        ret         10h\r\n    }\r\n    /* *INDENT-ON* */\r\n}\n\nvoid\n__declspec(naked)\n_alldiv()\n{\n    /* *INDENT-OFF* */\n    __asm {\n        push        edi\n        push        esi\n        push        ebx\n        xor         edi,edi\n        mov         eax,dword ptr [esp+14h]\n        or          eax,eax\n        jge         L1\n        inc         edi\n        mov         edx,dword ptr [esp+10h]\n        neg         eax\n        neg         edx\n        sbb         eax,0\n        mov         dword ptr [esp+14h],eax\n        mov         dword ptr [esp+10h],edx\nL1:\n        mov         eax,dword ptr [esp+1Ch]\n        or          eax,eax\n        jge         L2\n        inc         edi\n        mov         edx,dword ptr [esp+18h]\n        neg         eax\n        neg         edx\n        sbb         eax,0\n        mov         dword ptr [esp+1Ch],eax\n        mov         dword ptr [esp+18h],edx\nL2:\n        or          eax,eax\n        jne         L3\n        mov         ecx,dword ptr [esp+18h]\n        mov         eax,dword ptr [esp+14h]\n        xor         edx,edx\n        div         ecx\n        mov         ebx,eax\n        mov         eax,dword ptr [esp+10h]\n        div         ecx\n        mov         edx,ebx\n        jmp         L4\nL3:\n        mov         ebx,eax\n        mov         ecx,dword ptr [esp+18h]\n        mov         edx,dword ptr [esp+14h]\n        mov         eax,dword ptr [esp+10h]\nL5:\n        shr         ebx,1\n        rcr         ecx,1\n        shr         edx,1\n        rcr         eax,1\n        or          ebx,ebx\n        jne         L5\n        div         ecx\n        mov         esi,eax\n        mul         dword ptr [esp+1Ch]\n        mov         ecx,eax\n        mov         eax,dword ptr [esp+18h]\n        mul         esi\n        add         edx,ecx\n        jb          L6\n        cmp         edx,dword ptr [esp+14h]\n        ja          L6\n        jb          L7\n        cmp         eax,dword ptr [esp+10h]\n        jbe         L7\nL6:\n        dec         esi\nL7:\n        xor         edx,edx\n        mov         eax,esi\nL4:\n        dec         edi\n        jne         L8\n        neg         edx\n        neg         eax\n        sbb         edx,0\nL8:\n        pop         ebx\n        pop         esi\n        pop         edi\n        ret         10h\n    }\n    /* *INDENT-ON* */\n}\n\nvoid\n__declspec(naked)\n_aulldiv()\n{\n    /* *INDENT-OFF* */\n    __asm {\n        push        ebx\n        push        esi\n        mov         eax,dword ptr [esp+18h]\n        or          eax,eax\n        jne         L1\n        mov         ecx,dword ptr [esp+14h]\n        mov         eax,dword ptr [esp+10h]\n        xor         edx,edx\n        div         ecx\n        mov         ebx,eax\n        mov         eax,dword ptr [esp+0Ch]\n        div         ecx\n        mov         edx,ebx\n        jmp         L2\nL1:\n        mov         ecx,eax\n        mov         ebx,dword ptr [esp+14h]\n        mov         edx,dword ptr [esp+10h]\n        mov         eax,dword ptr [esp+0Ch]\nL3:\n        shr         ecx,1\n        rcr         ebx,1\n        shr         edx,1\n        rcr         eax,1\n        or          ecx,ecx\n        jne         L3\n        div         ebx\n        mov         esi,eax\n        mul         dword ptr [esp+18h]\n        mov         ecx,eax\n        mov         eax,dword ptr [esp+14h]\n        mul         esi\n        add         edx,ecx\n        jb          L4\n        cmp         edx,dword ptr [esp+10h]\n        ja          L4\n        jb          L5\n        cmp         eax,dword ptr [esp+0Ch]\n        jbe         L5\nL4:\n        dec         esi\nL5:\n        xor         edx,edx\n        mov         eax,esi\nL2:\n        pop         esi\n        pop         ebx\n        ret         10h\n    }\n    /* *INDENT-ON* */\n}\n\nvoid\n__declspec(naked)\n_allrem()\n{\n    /* *INDENT-OFF* */\n    __asm {\n        push        ebx\n        push        edi\n        xor         edi,edi\n        mov         eax,dword ptr [esp+10h]\n        or          eax,eax\n        jge         L1\n        inc         edi\n        mov         edx,dword ptr [esp+0Ch]\n        neg         eax\n        neg         edx\n        sbb         eax,0\n        mov         dword ptr [esp+10h],eax\n        mov         dword ptr [esp+0Ch],edx\nL1:\n        mov         eax,dword ptr [esp+18h]\n        or          eax,eax\n        jge         L2\n        mov         edx,dword ptr [esp+14h]\n        neg         eax\n        neg         edx\n        sbb         eax,0\n        mov         dword ptr [esp+18h],eax\n        mov         dword ptr [esp+14h],edx\nL2:\n        or          eax,eax\n        jne         L3\n        mov         ecx,dword ptr [esp+14h]\n        mov         eax,dword ptr [esp+10h]\n        xor         edx,edx\n        div         ecx\n        mov         eax,dword ptr [esp+0Ch]\n        div         ecx\n        mov         eax,edx\n        xor         edx,edx\n        dec         edi\n        jns         L4\n        jmp         L8\nL3:\n        mov         ebx,eax\n        mov         ecx,dword ptr [esp+14h]\n        mov         edx,dword ptr [esp+10h]\n        mov         eax,dword ptr [esp+0Ch]\nL5:\n        shr         ebx,1\n        rcr         ecx,1\n        shr         edx,1\n        rcr         eax,1\n        or          ebx,ebx\n        jne         L5\n        div         ecx\n        mov         ecx,eax\n        mul         dword ptr [esp+18h]\n        xchg        eax,ecx\n        mul         dword ptr [esp+14h]\n        add         edx,ecx\n        jb          L6\n        cmp         edx,dword ptr [esp+10h]\n        ja          L6\n        jb          L7\n        cmp         eax,dword ptr [esp+0Ch]\n        jbe         L7\nL6:\n        sub         eax,dword ptr [esp+14h]\n        sbb         edx,dword ptr [esp+18h]\nL7:\n        sub         eax,dword ptr [esp+0Ch]\n        sbb         edx,dword ptr [esp+10h]\n        dec         edi\n        jns         L8\nL4:\n        neg         edx\n        neg         eax\n        sbb         edx,0\nL8:\n        pop         edi\n        pop         ebx\n        ret         10h\n    }\n    /* *INDENT-ON* */\n}\n\nvoid\n__declspec(naked)\n_aullrem()\n{\n    /* *INDENT-OFF* */\n    __asm {\n        push        ebx\n        mov         eax,dword ptr [esp+14h]\n        or          eax,eax\n        jne         L1\n        mov         ecx,dword ptr [esp+10h]\n        mov         eax,dword ptr [esp+0Ch]\n        xor         edx,edx\n        div         ecx\n        mov         eax,dword ptr [esp+8]\n        div         ecx\n        mov         eax,edx\n        xor         edx,edx\n        jmp         L2\nL1:\n        mov         ecx,eax\n        mov         ebx,dword ptr [esp+10h]\n        mov         edx,dword ptr [esp+0Ch]\n        mov         eax,dword ptr [esp+8]\nL3:\n        shr         ecx,1\n        rcr         ebx,1\n        shr         edx,1\n        rcr         eax,1\n        or          ecx,ecx\n        jne         L3\n        div         ebx\n        mov         ecx,eax\n        mul         dword ptr [esp+14h]\n        xchg        eax,ecx\n        mul         dword ptr [esp+10h]\n        add         edx,ecx\n        jb          L4\n        cmp         edx,dword ptr [esp+0Ch]\n        ja          L4\n        jb          L5\n        cmp         eax,dword ptr [esp+8]\n        jbe         L5\nL4:\n        sub         eax,dword ptr [esp+10h]\n        sbb         edx,dword ptr [esp+14h]\nL5:\n        sub         eax,dword ptr [esp+8]\n        sbb         edx,dword ptr [esp+0Ch]\n        neg         edx\n        neg         eax\n        sbb         edx,0\nL2:\n        pop         ebx\n        ret         10h\n    }\n    /* *INDENT-ON* */\n}\n\nvoid\n__declspec(naked)\n_alldvrm()\n{\n    /* *INDENT-OFF* */\n    __asm {\n        push        edi\n        push        esi\n        push        ebp\n        xor         edi,edi\n        xor         ebp,ebp\n        mov         eax,dword ptr [esp+14h]\n        or          eax,eax\n        jge         L1\n        inc         edi\n        inc         ebp\n        mov         edx,dword ptr [esp+10h]\n        neg         eax\n        neg         edx\n        sbb         eax,0\n        mov         dword ptr [esp+14h],eax\n        mov         dword ptr [esp+10h],edx\nL1:\n        mov         eax,dword ptr [esp+1Ch]\n        or          eax,eax\n        jge         L2\n        inc         edi\n        mov         edx,dword ptr [esp+18h]\n        neg         eax\n        neg         edx\n        sbb         eax,0\n        mov         dword ptr [esp+1Ch],eax\n        mov         dword ptr [esp+18h],edx\nL2:\n        or          eax,eax\n        jne         L3\n        mov         ecx,dword ptr [esp+18h]\n        mov         eax,dword ptr [esp+14h]\n        xor         edx,edx\n        div         ecx\n        mov         ebx,eax\n        mov         eax,dword ptr [esp+10h]\n        div         ecx\n        mov         esi,eax\n        mov         eax,ebx\n        mul         dword ptr [esp+18h]\n        mov         ecx,eax\n        mov         eax,esi\n        mul         dword ptr [esp+18h]\n        add         edx,ecx\n        jmp         L4\nL3:\n        mov         ebx,eax\n        mov         ecx,dword ptr [esp+18h]\n        mov         edx,dword ptr [esp+14h]\n        mov         eax,dword ptr [esp+10h]\nL5:\n        shr         ebx,1\n        rcr         ecx,1\n        shr         edx,1\n        rcr         eax,1\n        or          ebx,ebx\n        jne         L5\n        div         ecx\n        mov         esi,eax\n        mul         dword ptr [esp+1Ch]\n        mov         ecx,eax\n        mov         eax,dword ptr [esp+18h]\n        mul         esi\n        add         edx,ecx\n        jb          L6\n        cmp         edx,dword ptr [esp+14h]\n        ja          L6\n        jb          L7\n        cmp         eax,dword ptr [esp+10h]\n        jbe         L7\nL6:\n        dec         esi\n        sub         eax,dword ptr [esp+18h]\n        sbb         edx,dword ptr [esp+1Ch]\nL7:\n        xor         ebx,ebx\nL4:\n        sub         eax,dword ptr [esp+10h]\n        sbb         edx,dword ptr [esp+14h]\n        dec         ebp\n        jns         L9\n        neg         edx\n        neg         eax\n        sbb         edx,0\nL9:\n        mov         ecx,edx\n        mov         edx,ebx\n        mov         ebx,ecx\n        mov         ecx,eax\n        mov         eax,esi\n        dec         edi\n        jne         L8\n        neg         edx\n        neg         eax\n        sbb         edx,0\nL8:\n        pop         ebp\n        pop         esi\n        pop         edi\n        ret         10h\n    }\n    /* *INDENT-ON* */\n}\n\nvoid\n__declspec(naked)\n_aulldvrm()\n{\n    /* *INDENT-OFF* */\n    __asm {\n        push        esi\n        mov         eax,dword ptr [esp+14h]\n        or          eax,eax\n        jne         L1\n        mov         ecx,dword ptr [esp+10h]\n        mov         eax,dword ptr [esp+0Ch]\n        xor         edx,edx\n        div         ecx\n        mov         ebx,eax\n        mov         eax,dword ptr [esp+8]\n        div         ecx\n        mov         esi,eax\n        mov         eax,ebx\n        mul         dword ptr [esp+10h]\n        mov         ecx,eax\n        mov         eax,esi\n        mul         dword ptr [esp+10h]\n        add         edx,ecx\n        jmp         L2\nL1:\n        mov         ecx,eax\n        mov         ebx,dword ptr [esp+10h]\n        mov         edx,dword ptr [esp+0Ch]\n        mov         eax,dword ptr [esp+8]\nL3:\n        shr         ecx,1\n        rcr         ebx,1\n        shr         edx,1\n        rcr         eax,1\n        or          ecx,ecx\n        jne         L3\n        div         ebx\n        mov         esi,eax\n        mul         dword ptr [esp+14h]\n        mov         ecx,eax\n        mov         eax,dword ptr [esp+10h]\n        mul         esi\n        add         edx,ecx\n        jb          L4\n        cmp         edx,dword ptr [esp+0Ch]\n        ja          L4\n        jb          L5\n        cmp         eax,dword ptr [esp+8]\n        jbe         L5\nL4:\n        dec         esi\n        sub         eax,dword ptr [esp+10h]\n        sbb         edx,dword ptr [esp+14h]\nL5:\n        xor         ebx,ebx\nL2:\n        sub         eax,dword ptr [esp+8]\n        sbb         edx,dword ptr [esp+0Ch]\n        neg         edx\n        neg         eax\n        sbb         edx,0\n        mov         ecx,edx\n        mov         edx,ebx\n        mov         ebx,ecx\n        mov         ecx,eax\n        mov         eax,esi\n        pop         esi\n        ret         10h\n    }\n    /* *INDENT-ON* */\n}\n\nvoid\n__declspec(naked)\n_allshl()\n{\n    /* *INDENT-OFF* */\n    __asm {\n        cmp         cl,40h\n        jae         RETZERO\n        cmp         cl,20h\n        jae         MORE32\n        shld        edx,eax,cl\n        shl         eax,cl\n        ret\nMORE32:\n        mov         edx,eax\n        xor         eax,eax\n        and         cl,1Fh\n        shl         edx,cl\n        ret\nRETZERO:\n        xor         eax,eax\n        xor         edx,edx\n        ret\n    }\n    /* *INDENT-ON* */\n}\n\nvoid\n__declspec(naked)\n_allshr()\n{\n    /* *INDENT-OFF* */\n    __asm {\n        cmp         cl,40h\n        jae         RETZERO\n        cmp         cl,20h\n        jae         MORE32\n        shrd        eax,edx,cl\n        sar         edx,cl\n        ret\nMORE32:\n        mov         eax,edx\n        xor         edx,edx\n        and         cl,1Fh\n        sar         eax,cl\n        ret\nRETZERO:\n        xor         eax,eax\n        xor         edx,edx\n        ret\n    }\n    /* *INDENT-ON* */\n}\n\nvoid\n__declspec(naked)\n_aullshr()\n{\n    /* *INDENT-OFF* */\n    __asm {\n        cmp         cl,40h\n        jae         RETZERO\n        cmp         cl,20h\n        jae         MORE32\n        shrd        eax,edx,cl\n        shr         edx,cl\n        ret\nMORE32:\n        mov         eax,edx\n        xor         edx,edx\n        and         cl,1Fh\n        shr         eax,cl\n        ret\nRETZERO:\n        xor         eax,eax\n        xor         edx,edx\n        ret\n    }\n    /* *INDENT-ON* */\n}\n\n#endif /* _M_IX86 */\n\n#endif /* MSC_VER */\n\n#endif /* !HAVE_LIBC */\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n\n#if defined(__clang_analyzer__) && !defined(SDL_DISABLE_ANALYZE_MACROS)\n#define SDL_DISABLE_ANALYZE_MACROS 1\n#endif\n\n#include \"../SDL_internal.h\"\n\n/* This file contains portable string manipulation functions for SDL */\n\n#include \"SDL_stdinc.h\"\n\n\n#define SDL_isupperhex(X)   (((X) >= 'A') && ((X) <= 'F'))\n#define SDL_islowerhex(X)   (((X) >= 'a') && ((X) <= 'f'))\n\n#define UTF8_IsLeadByte(c) ((c) >= 0xC0 && (c) <= 0xF4)\n#define UTF8_IsTrailingByte(c) ((c) >= 0x80 && (c) <= 0xBF)\n\nstatic int UTF8_TrailingBytes(unsigned char c)\n{\n    if (c >= 0xC0 && c <= 0xDF)\n        return 1;\n    else if (c >= 0xE0 && c <= 0xEF)\n        return 2;\n    else if (c >= 0xF0 && c <= 0xF4)\n        return 3;\n    else\n        return 0;\n}\n\n#if !defined(HAVE_VSSCANF) || !defined(HAVE_STRTOL)\nstatic size_t\nSDL_ScanLong(const char *text, int radix, long *valuep)\n{\n    const char *textstart = text;\n    long value = 0;\n    SDL_bool negative = SDL_FALSE;\n\n    if (*text == '-') {\n        negative = SDL_TRUE;\n        ++text;\n    }\n    if (radix == 16 && SDL_strncmp(text, \"0x\", 2) == 0) {\n        text += 2;\n    }\n    for (;;) {\n        int v;\n        if (SDL_isdigit((unsigned char) *text)) {\n            v = *text - '0';\n        } else if (radix == 16 && SDL_isupperhex(*text)) {\n            v = 10 + (*text - 'A');\n        } else if (radix == 16 && SDL_islowerhex(*text)) {\n            v = 10 + (*text - 'a');\n        } else {\n            break;\n        }\n        value *= radix;\n        value += v;\n        ++text;\n    }\n    if (valuep) {\n        if (negative && value) {\n            *valuep = -value;\n        } else {\n            *valuep = value;\n        }\n    }\n    return (text - textstart);\n}\n#endif\n\n#if !defined(HAVE_VSSCANF) || !defined(HAVE_STRTOUL) || !defined(HAVE_STRTOD)\nstatic size_t\nSDL_ScanUnsignedLong(const char *text, int radix, unsigned long *valuep)\n{\n    const char *textstart = text;\n    unsigned long value = 0;\n\n    if (radix == 16 && SDL_strncmp(text, \"0x\", 2) == 0) {\n        text += 2;\n    }\n    for (;;) {\n        int v;\n        if (SDL_isdigit((unsigned char) *text)) {\n            v = *text - '0';\n        } else if (radix == 16 && SDL_isupperhex(*text)) {\n            v = 10 + (*text - 'A');\n        } else if (radix == 16 && SDL_islowerhex(*text)) {\n            v = 10 + (*text - 'a');\n        } else {\n            break;\n        }\n        value *= radix;\n        value += v;\n        ++text;\n    }\n    if (valuep) {\n        *valuep = value;\n    }\n    return (text - textstart);\n}\n#endif\n\n#ifndef HAVE_VSSCANF\nstatic size_t\nSDL_ScanUintPtrT(const char *text, int radix, uintptr_t * valuep)\n{\n    const char *textstart = text;\n    uintptr_t value = 0;\n\n    if (radix == 16 && SDL_strncmp(text, \"0x\", 2) == 0) {\n        text += 2;\n    }\n    for (;;) {\n        int v;\n        if (SDL_isdigit((unsigned char) *text)) {\n            v = *text - '0';\n        } else if (radix == 16 && SDL_isupperhex(*text)) {\n            v = 10 + (*text - 'A');\n        } else if (radix == 16 && SDL_islowerhex(*text)) {\n            v = 10 + (*text - 'a');\n        } else {\n            break;\n        }\n        value *= radix;\n        value += v;\n        ++text;\n    }\n    if (valuep) {\n        *valuep = value;\n    }\n    return (text - textstart);\n}\n#endif\n\n#if !defined(HAVE_VSSCANF) || !defined(HAVE_STRTOLL)\nstatic size_t\nSDL_ScanLongLong(const char *text, int radix, Sint64 * valuep)\n{\n    const char *textstart = text;\n    Sint64 value = 0;\n    SDL_bool negative = SDL_FALSE;\n\n    if (*text == '-') {\n        negative = SDL_TRUE;\n        ++text;\n    }\n    if (radix == 16 && SDL_strncmp(text, \"0x\", 2) == 0) {\n        text += 2;\n    }\n    for (;;) {\n        int v;\n        if (SDL_isdigit((unsigned char) *text)) {\n            v = *text - '0';\n        } else if (radix == 16 && SDL_isupperhex(*text)) {\n            v = 10 + (*text - 'A');\n        } else if (radix == 16 && SDL_islowerhex(*text)) {\n            v = 10 + (*text - 'a');\n        } else {\n            break;\n        }\n        value *= radix;\n        value += v;\n        ++text;\n    }\n    if (valuep) {\n        if (negative && value) {\n            *valuep = -value;\n        } else {\n            *valuep = value;\n        }\n    }\n    return (text - textstart);\n}\n#endif\n\n#if !defined(HAVE_VSSCANF) || !defined(HAVE_STRTOULL)\nstatic size_t\nSDL_ScanUnsignedLongLong(const char *text, int radix, Uint64 * valuep)\n{\n    const char *textstart = text;\n    Uint64 value = 0;\n\n    if (radix == 16 && SDL_strncmp(text, \"0x\", 2) == 0) {\n        text += 2;\n    }\n    for (;;) {\n        int v;\n        if (SDL_isdigit((unsigned char) *text)) {\n            v = *text - '0';\n        } else if (radix == 16 && SDL_isupperhex(*text)) {\n            v = 10 + (*text - 'A');\n        } else if (radix == 16 && SDL_islowerhex(*text)) {\n            v = 10 + (*text - 'a');\n        } else {\n            break;\n        }\n        value *= radix;\n        value += v;\n        ++text;\n    }\n    if (valuep) {\n        *valuep = value;\n    }\n    return (text - textstart);\n}\n#endif\n\n#if !defined(HAVE_VSSCANF) || !defined(HAVE_STRTOD)\nstatic size_t\nSDL_ScanFloat(const char *text, double *valuep)\n{\n    const char *textstart = text;\n    unsigned long lvalue = 0;\n    double value = 0.0;\n    SDL_bool negative = SDL_FALSE;\n\n    if (*text == '-') {\n        negative = SDL_TRUE;\n        ++text;\n    }\n    text += SDL_ScanUnsignedLong(text, 10, &lvalue);\n    value += lvalue;\n    if (*text == '.') {\n        int mult = 10;\n        ++text;\n        while (SDL_isdigit((unsigned char) *text)) {\n            lvalue = *text - '0';\n            value += (double) lvalue / mult;\n            mult *= 10;\n            ++text;\n        }\n    }\n    if (valuep) {\n        if (negative && value) {\n            *valuep = -value;\n        } else {\n            *valuep = value;\n        }\n    }\n    return (text - textstart);\n}\n#endif\n\nvoid *\nSDL_memset(SDL_OUT_BYTECAP(len) void *dst, int c, size_t len)\n{\n#if defined(HAVE_MEMSET)\n    return memset(dst, c, len);\n#else\n    size_t left;\n    Uint32 *dstp4;\n    Uint8 *dstp1 = (Uint8 *) dst;\n    Uint32 value4 = (c | (c << 8) | (c << 16) | (c << 24));\n    Uint8 value1 = (Uint8) c;\n\n    /* The destination pointer needs to be aligned on a 4-byte boundary to\n     * execute a 32-bit set. Set first bytes manually if needed until it is\n     * aligned. */\n    while ((intptr_t)dstp1 & 0x3) {\n        if (len--) {\n            *dstp1++ = value1;\n        } else {\n            return dst;\n        }\n    }\n\n    dstp4 = (Uint32 *) dstp1;\n    left = (len % 4);\n    len /= 4;\n    while (len--) {\n        *dstp4++ = value4;\n    }\n\n    dstp1 = (Uint8 *) dstp4;\n    switch (left) {\n    case 3:\n        *dstp1++ = value1;\n    case 2:\n        *dstp1++ = value1;\n    case 1:\n        *dstp1++ = value1;\n    }\n\n    return dst;\n#endif /* HAVE_MEMSET */\n}\n\nvoid *\nSDL_memcpy(SDL_OUT_BYTECAP(len) void *dst, SDL_IN_BYTECAP(len) const void *src, size_t len)\n{\n#ifdef __GNUC__\n    /* Presumably this is well tuned for speed.\n       On my machine this is twice as fast as the C code below.\n     */\n    return __builtin_memcpy(dst, src, len);\n#elif defined(HAVE_MEMCPY)\n    return memcpy(dst, src, len);\n#elif defined(HAVE_BCOPY)\n    bcopy(src, dst, len);\n    return dst;\n#else\n    /* GCC 4.9.0 with -O3 will generate movaps instructions with the loop\n       using Uint32* pointers, so we need to make sure the pointers are\n       aligned before we loop using them.\n     */\n    if (((intptr_t)src & 0x3) || ((intptr_t)dst & 0x3)) {\n        /* Do an unaligned byte copy */\n        Uint8 *srcp1 = (Uint8 *)src;\n        Uint8 *dstp1 = (Uint8 *)dst;\n\n        while (len--) {\n            *dstp1++ = *srcp1++;\n        }\n    } else {\n        size_t left = (len % 4);\n        Uint32 *srcp4, *dstp4;\n        Uint8 *srcp1, *dstp1;\n\n        srcp4 = (Uint32 *) src;\n        dstp4 = (Uint32 *) dst;\n        len /= 4;\n        while (len--) {\n            *dstp4++ = *srcp4++;\n        }\n\n        srcp1 = (Uint8 *) srcp4;\n        dstp1 = (Uint8 *) dstp4;\n        switch (left) {\n        case 3:\n            *dstp1++ = *srcp1++;\n        case 2:\n            *dstp1++ = *srcp1++;\n        case 1:\n            *dstp1++ = *srcp1++;\n        }\n    }\n    return dst;\n#endif /* __GNUC__ */\n}\n\nvoid *\nSDL_memmove(SDL_OUT_BYTECAP(len) void *dst, SDL_IN_BYTECAP(len) const void *src, size_t len)\n{\n#if defined(HAVE_MEMMOVE)\n    return memmove(dst, src, len);\n#else\n    char *srcp = (char *) src;\n    char *dstp = (char *) dst;\n\n    if (src < dst) {\n        srcp += len - 1;\n        dstp += len - 1;\n        while (len--) {\n            *dstp-- = *srcp--;\n        }\n    } else {\n        while (len--) {\n            *dstp++ = *srcp++;\n        }\n    }\n    return dst;\n#endif /* HAVE_MEMMOVE */\n}\n\nint\nSDL_memcmp(const void *s1, const void *s2, size_t len)\n{\n#if defined(HAVE_MEMCMP)\n    return memcmp(s1, s2, len);\n#else\n    char *s1p = (char *) s1;\n    char *s2p = (char *) s2;\n    while (len--) {\n        if (*s1p != *s2p) {\n            return (*s1p - *s2p);\n        }\n        ++s1p;\n        ++s2p;\n    }\n    return 0;\n#endif /* HAVE_MEMCMP */\n}\n\nsize_t\nSDL_strlen(const char *string)\n{\n#if defined(HAVE_STRLEN)\n    return strlen(string);\n#else\n    size_t len = 0;\n    while (*string++) {\n        ++len;\n    }\n    return len;\n#endif /* HAVE_STRLEN */\n}\n\nsize_t\nSDL_wcslen(const wchar_t * string)\n{\n#if defined(HAVE_WCSLEN)\n    return wcslen(string);\n#else\n    size_t len = 0;\n    while (*string++) {\n        ++len;\n    }\n    return len;\n#endif /* HAVE_WCSLEN */\n}\n\nsize_t\nSDL_wcslcpy(SDL_OUT_Z_CAP(maxlen) wchar_t *dst, const wchar_t *src, size_t maxlen)\n{\n#if defined(HAVE_WCSLCPY)\n    return wcslcpy(dst, src, maxlen);\n#else\n    size_t srclen = SDL_wcslen(src);\n    if (maxlen > 0) {\n        size_t len = SDL_min(srclen, maxlen - 1);\n        SDL_memcpy(dst, src, len * sizeof(wchar_t));\n        dst[len] = '\\0';\n    }\n    return srclen;\n#endif /* HAVE_WCSLCPY */\n}\n\nsize_t\nSDL_wcslcat(SDL_INOUT_Z_CAP(maxlen) wchar_t *dst, const wchar_t *src, size_t maxlen)\n{\n#if defined(HAVE_WCSLCAT)\n    return wcslcat(dst, src, maxlen);\n#else\n    size_t dstlen = SDL_wcslen(dst);\n    size_t srclen = SDL_wcslen(src);\n    if (dstlen < maxlen) {\n        SDL_wcslcpy(dst + dstlen, src, maxlen - dstlen);\n    }\n    return dstlen + srclen;\n#endif /* HAVE_WCSLCAT */\n}\n\nsize_t\nSDL_strlcpy(SDL_OUT_Z_CAP(maxlen) char *dst, const char *src, size_t maxlen)\n{\n#if defined(HAVE_STRLCPY)\n    return strlcpy(dst, src, maxlen);\n#else\n    size_t srclen = SDL_strlen(src);\n    if (maxlen > 0) {\n        size_t len = SDL_min(srclen, maxlen - 1);\n        SDL_memcpy(dst, src, len);\n        dst[len] = '\\0';\n    }\n    return srclen;\n#endif /* HAVE_STRLCPY */\n}\n\nsize_t SDL_utf8strlcpy(SDL_OUT_Z_CAP(dst_bytes) char *dst, const char *src, size_t dst_bytes)\n{\n    size_t src_bytes = SDL_strlen(src);\n    size_t bytes = SDL_min(src_bytes, dst_bytes - 1);\n    size_t i = 0;\n    char trailing_bytes = 0;\n    if (bytes)\n    {\n        unsigned char c = (unsigned char)src[bytes - 1];\n        if (UTF8_IsLeadByte(c))\n            --bytes;\n        else if (UTF8_IsTrailingByte(c))\n        {\n            for (i = bytes - 1; i != 0; --i)\n            {\n                c = (unsigned char)src[i];\n                trailing_bytes = UTF8_TrailingBytes(c);\n                if (trailing_bytes)\n                {\n                    if (bytes - i != trailing_bytes + 1)\n                        bytes = i;\n\n                    break;\n                }\n            }\n        }\n        SDL_memcpy(dst, src, bytes);\n    }\n    dst[bytes] = '\\0';\n    return bytes;\n}\n\nsize_t\nSDL_strlcat(SDL_INOUT_Z_CAP(maxlen) char *dst, const char *src, size_t maxlen)\n{\n#if defined(HAVE_STRLCAT)\n    return strlcat(dst, src, maxlen);\n#else\n    size_t dstlen = SDL_strlen(dst);\n    size_t srclen = SDL_strlen(src);\n    if (dstlen < maxlen) {\n        SDL_strlcpy(dst + dstlen, src, maxlen - dstlen);\n    }\n    return dstlen + srclen;\n#endif /* HAVE_STRLCAT */\n}\n\nchar *\nSDL_strdup(const char *string)\n{\n#if defined(HAVE_STRDUP)\n    return strdup(string);\n#else\n    size_t len = SDL_strlen(string) + 1;\n    char *newstr = SDL_malloc(len);\n    if (newstr) {\n        SDL_strlcpy(newstr, string, len);\n    }\n    return newstr;\n#endif /* HAVE_STRDUP */\n}\n\nchar *\nSDL_strrev(char *string)\n{\n#if defined(HAVE__STRREV)\n    return _strrev(string);\n#else\n    size_t len = SDL_strlen(string);\n    char *a = &string[0];\n    char *b = &string[len - 1];\n    len /= 2;\n    while (len--) {\n        char c = *a;\n        *a++ = *b;\n        *b-- = c;\n    }\n    return string;\n#endif /* HAVE__STRREV */\n}\n\nchar *\nSDL_strupr(char *string)\n{\n#if defined(HAVE__STRUPR)\n    return _strupr(string);\n#else\n    char *bufp = string;\n    while (*bufp) {\n        *bufp = SDL_toupper((unsigned char) *bufp);\n        ++bufp;\n    }\n    return string;\n#endif /* HAVE__STRUPR */\n}\n\nchar *\nSDL_strlwr(char *string)\n{\n#if defined(HAVE__STRLWR)\n    return _strlwr(string);\n#else\n    char *bufp = string;\n    while (*bufp) {\n        *bufp = SDL_tolower((unsigned char) *bufp);\n        ++bufp;\n    }\n    return string;\n#endif /* HAVE__STRLWR */\n}\n\nchar *\nSDL_strchr(const char *string, int c)\n{\n#ifdef HAVE_STRCHR\n    return SDL_const_cast(char*,strchr(string, c));\n#elif defined(HAVE_INDEX)\n    return SDL_const_cast(char*,index(string, c));\n#else\n    while (*string) {\n        if (*string == c) {\n            return (char *) string;\n        }\n        ++string;\n    }\n    return NULL;\n#endif /* HAVE_STRCHR */\n}\n\nchar *\nSDL_strrchr(const char *string, int c)\n{\n#ifdef HAVE_STRRCHR\n    return SDL_const_cast(char*,strrchr(string, c));\n#elif defined(HAVE_RINDEX)\n    return SDL_const_cast(char*,rindex(string, c));\n#else\n    const char *bufp = string + SDL_strlen(string) - 1;\n    while (bufp >= string) {\n        if (*bufp == c) {\n            return (char *) bufp;\n        }\n        --bufp;\n    }\n    return NULL;\n#endif /* HAVE_STRRCHR */\n}\n\nchar *\nSDL_strstr(const char *haystack, const char *needle)\n{\n#if defined(HAVE_STRSTR)\n    return SDL_const_cast(char*,strstr(haystack, needle));\n#else\n    size_t length = SDL_strlen(needle);\n    while (*haystack) {\n        if (SDL_strncmp(haystack, needle, length) == 0) {\n            return (char *) haystack;\n        }\n        ++haystack;\n    }\n    return NULL;\n#endif /* HAVE_STRSTR */\n}\n\n#if !defined(HAVE__LTOA) || !defined(HAVE__I64TOA) || \\\n    !defined(HAVE__ULTOA) || !defined(HAVE__UI64TOA)\nstatic const char ntoa_table[] = {\n    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\n    'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',\n    'U', 'V', 'W', 'X', 'Y', 'Z'\n};\n#endif /* ntoa() conversion table */\n\nchar *\nSDL_itoa(int value, char *string, int radix)\n{\n#ifdef HAVE_ITOA\n    return itoa(value, string, radix);\n#else\n    return SDL_ltoa((long)value, string, radix);\n#endif /* HAVE_ITOA */\n}\n\nchar *\nSDL_uitoa(unsigned int value, char *string, int radix)\n{\n#ifdef HAVE__UITOA\n    return _uitoa(value, string, radix);\n#else\n    return SDL_ultoa((unsigned long)value, string, radix);\n#endif /* HAVE__UITOA */\n}\n\nchar *\nSDL_ltoa(long value, char *string, int radix)\n{\n#if defined(HAVE__LTOA)\n    return _ltoa(value, string, radix);\n#else\n    char *bufp = string;\n\n    if (value < 0) {\n        *bufp++ = '-';\n        SDL_ultoa(-value, bufp, radix);\n    } else {\n        SDL_ultoa(value, bufp, radix);\n    }\n\n    return string;\n#endif /* HAVE__LTOA */\n}\n\nchar *\nSDL_ultoa(unsigned long value, char *string, int radix)\n{\n#if defined(HAVE__ULTOA)\n    return _ultoa(value, string, radix);\n#else\n    char *bufp = string;\n\n    if (value) {\n        while (value > 0) {\n            *bufp++ = ntoa_table[value % radix];\n            value /= radix;\n        }\n    } else {\n        *bufp++ = '0';\n    }\n    *bufp = '\\0';\n\n    /* The numbers went into the string backwards. :) */\n    SDL_strrev(string);\n\n    return string;\n#endif /* HAVE__ULTOA */\n}\n\nchar *\nSDL_lltoa(Sint64 value, char *string, int radix)\n{\n#if defined(HAVE__I64TOA)\n    return _i64toa(value, string, radix);\n#else\n    char *bufp = string;\n\n    if (value < 0) {\n        *bufp++ = '-';\n        SDL_ulltoa(-value, bufp, radix);\n    } else {\n        SDL_ulltoa(value, bufp, radix);\n    }\n\n    return string;\n#endif /* HAVE__I64TOA */\n}\n\nchar *\nSDL_ulltoa(Uint64 value, char *string, int radix)\n{\n#if defined(HAVE__UI64TOA)\n    return _ui64toa(value, string, radix);\n#else\n    char *bufp = string;\n\n    if (value) {\n        while (value > 0) {\n            *bufp++ = ntoa_table[value % radix];\n            value /= radix;\n        }\n    } else {\n        *bufp++ = '0';\n    }\n    *bufp = '\\0';\n\n    /* The numbers went into the string backwards. :) */\n    SDL_strrev(string);\n\n    return string;\n#endif /* HAVE__UI64TOA */\n}\n\nint SDL_atoi(const char *string)\n{\n#ifdef HAVE_ATOI\n    return atoi(string);\n#else\n    return SDL_strtol(string, NULL, 0);\n#endif /* HAVE_ATOI */\n}\n\ndouble SDL_atof(const char *string)\n{\n#ifdef HAVE_ATOF\n    return (double) atof(string);\n#else\n    return SDL_strtod(string, NULL);\n#endif /* HAVE_ATOF */\n}\n\nlong\nSDL_strtol(const char *string, char **endp, int base)\n{\n#if defined(HAVE_STRTOL)\n    return strtol(string, endp, base);\n#else\n    size_t len;\n    long value;\n\n    if (!base) {\n        if ((SDL_strlen(string) > 2) && (SDL_strncmp(string, \"0x\", 2) == 0)) {\n            base = 16;\n        } else {\n            base = 10;\n        }\n    }\n\n    len = SDL_ScanLong(string, base, &value);\n    if (endp) {\n        *endp = (char *) string + len;\n    }\n    return value;\n#endif /* HAVE_STRTOL */\n}\n\nunsigned long\nSDL_strtoul(const char *string, char **endp, int base)\n{\n#if defined(HAVE_STRTOUL)\n    return strtoul(string, endp, base);\n#else\n    size_t len;\n    unsigned long value;\n\n    if (!base) {\n        if ((SDL_strlen(string) > 2) && (SDL_strncmp(string, \"0x\", 2) == 0)) {\n            base = 16;\n        } else {\n            base = 10;\n        }\n    }\n\n    len = SDL_ScanUnsignedLong(string, base, &value);\n    if (endp) {\n        *endp = (char *) string + len;\n    }\n    return value;\n#endif /* HAVE_STRTOUL */\n}\n\nSint64\nSDL_strtoll(const char *string, char **endp, int base)\n{\n#if defined(HAVE_STRTOLL)\n    return strtoll(string, endp, base);\n#else\n    size_t len;\n    Sint64 value;\n\n    if (!base) {\n        if ((SDL_strlen(string) > 2) && (SDL_strncmp(string, \"0x\", 2) == 0)) {\n            base = 16;\n        } else {\n            base = 10;\n        }\n    }\n\n    len = SDL_ScanLongLong(string, base, &value);\n    if (endp) {\n        *endp = (char *) string + len;\n    }\n    return value;\n#endif /* HAVE_STRTOLL */\n}\n\nUint64\nSDL_strtoull(const char *string, char **endp, int base)\n{\n#if defined(HAVE_STRTOULL)\n    return strtoull(string, endp, base);\n#else\n    size_t len;\n    Uint64 value;\n\n    if (!base) {\n        if ((SDL_strlen(string) > 2) && (SDL_strncmp(string, \"0x\", 2) == 0)) {\n            base = 16;\n        } else {\n            base = 10;\n        }\n    }\n\n    len = SDL_ScanUnsignedLongLong(string, base, &value);\n    if (endp) {\n        *endp = (char *) string + len;\n    }\n    return value;\n#endif /* HAVE_STRTOULL */\n}\n\ndouble\nSDL_strtod(const char *string, char **endp)\n{\n#if defined(HAVE_STRTOD)\n    return strtod(string, endp);\n#else\n    size_t len;\n    double value;\n\n    len = SDL_ScanFloat(string, &value);\n    if (endp) {\n        *endp = (char *) string + len;\n    }\n    return value;\n#endif /* HAVE_STRTOD */\n}\n\nint\nSDL_strcmp(const char *str1, const char *str2)\n{\n#if defined(HAVE_STRCMP)\n    return strcmp(str1, str2);\n#else\n    while (*str1 && *str2) {\n        if (*str1 != *str2)\n            break;\n        ++str1;\n        ++str2;\n    }\n    return (int) ((unsigned char) *str1 - (unsigned char) *str2);\n#endif /* HAVE_STRCMP */\n}\n\nint\nSDL_strncmp(const char *str1, const char *str2, size_t maxlen)\n{\n#if defined(HAVE_STRNCMP)\n    return strncmp(str1, str2, maxlen);\n#else\n    while (*str1 && *str2 && maxlen) {\n        if (*str1 != *str2)\n            break;\n        ++str1;\n        ++str2;\n        --maxlen;\n    }\n    if (!maxlen) {\n        return 0;\n    }\n    return (int) ((unsigned char) *str1 - (unsigned char) *str2);\n#endif /* HAVE_STRNCMP */\n}\n\nint\nSDL_strcasecmp(const char *str1, const char *str2)\n{\n#ifdef HAVE_STRCASECMP\n    return strcasecmp(str1, str2);\n#elif defined(HAVE__STRICMP)\n    return _stricmp(str1, str2);\n#else\n    char a = 0;\n    char b = 0;\n    while (*str1 && *str2) {\n        a = SDL_toupper((unsigned char) *str1);\n        b = SDL_toupper((unsigned char) *str2);\n        if (a != b)\n            break;\n        ++str1;\n        ++str2;\n    }\n    a = SDL_toupper(*str1);\n    b = SDL_toupper(*str2);\n    return (int) ((unsigned char) a - (unsigned char) b);\n#endif /* HAVE_STRCASECMP */\n}\n\nint\nSDL_strncasecmp(const char *str1, const char *str2, size_t maxlen)\n{\n#ifdef HAVE_STRNCASECMP\n    return strncasecmp(str1, str2, maxlen);\n#elif defined(HAVE__STRNICMP)\n    return _strnicmp(str1, str2, maxlen);\n#else\n    char a = 0;\n    char b = 0;\n    while (*str1 && *str2 && maxlen) {\n        a = SDL_tolower((unsigned char) *str1);\n        b = SDL_tolower((unsigned char) *str2);\n        if (a != b)\n            break;\n        ++str1;\n        ++str2;\n        --maxlen;\n    }\n    if (maxlen == 0) {\n        return 0;\n    } else {\n        a = SDL_tolower((unsigned char) *str1);\n        b = SDL_tolower((unsigned char) *str2);\n        return (int) ((unsigned char) a - (unsigned char) b);\n    }\n#endif /* HAVE_STRNCASECMP */\n}\n\nint\nSDL_sscanf(const char *text, SDL_SCANF_FORMAT_STRING const char *fmt, ...)\n{\n    int rc;\n    va_list ap;\n    va_start(ap, fmt);\n    rc = SDL_vsscanf(text, fmt, ap);\n    va_end(ap);\n    return rc;\n}\n\n#ifdef HAVE_VSSCANF\nint\nSDL_vsscanf(const char *text, const char *fmt, va_list ap)\n{\n    return vsscanf(text, fmt, ap);\n}\n#else\nint\nSDL_vsscanf(const char *text, const char *fmt, va_list ap)\n{\n    int retval = 0;\n\n    while (*fmt) {\n        if (*fmt == ' ') {\n            while (SDL_isspace((unsigned char) *text)) {\n                ++text;\n            }\n            ++fmt;\n            continue;\n        }\n        if (*fmt == '%') {\n            SDL_bool done = SDL_FALSE;\n            long count = 0;\n            int radix = 10;\n            enum\n            {\n                DO_SHORT,\n                DO_INT,\n                DO_LONG,\n                DO_LONGLONG\n            } inttype = DO_INT;\n            SDL_bool suppress = SDL_FALSE;\n\n            ++fmt;\n            if (*fmt == '%') {\n                if (*text == '%') {\n                    ++text;\n                    ++fmt;\n                    continue;\n                }\n                break;\n            }\n            if (*fmt == '*') {\n                suppress = SDL_TRUE;\n                ++fmt;\n            }\n            fmt += SDL_ScanLong(fmt, 10, &count);\n\n            if (*fmt == 'c') {\n                if (!count) {\n                    count = 1;\n                }\n                if (suppress) {\n                    while (count--) {\n                        ++text;\n                    }\n                } else {\n                    char *valuep = va_arg(ap, char *);\n                    while (count--) {\n                        *valuep++ = *text++;\n                    }\n                    ++retval;\n                }\n                continue;\n            }\n\n            while (SDL_isspace((unsigned char) *text)) {\n                ++text;\n            }\n\n            /* FIXME: implement more of the format specifiers */\n            while (!done) {\n                switch (*fmt) {\n                case '*':\n                    suppress = SDL_TRUE;\n                    break;\n                case 'h':\n                    if (inttype > DO_SHORT) {\n                        ++inttype;\n                    }\n                    break;\n                case 'l':\n                    if (inttype < DO_LONGLONG) {\n                        ++inttype;\n                    }\n                    break;\n                case 'I':\n                    if (SDL_strncmp(fmt, \"I64\", 3) == 0) {\n                        fmt += 2;\n                        inttype = DO_LONGLONG;\n                    }\n                    break;\n                case 'i':\n                    {\n                        int index = 0;\n                        if (text[index] == '-') {\n                            ++index;\n                        }\n                        if (text[index] == '0') {\n                            if (SDL_tolower((unsigned char) text[index + 1]) == 'x') {\n                                radix = 16;\n                            } else {\n                                radix = 8;\n                            }\n                        }\n                    }\n                    /* Fall through to %d handling */\n                case 'd':\n                    if (inttype == DO_LONGLONG) {\n                        Sint64 value;\n                        text += SDL_ScanLongLong(text, radix, &value);\n                        if (!suppress) {\n                            Sint64 *valuep = va_arg(ap, Sint64 *);\n                            *valuep = value;\n                            ++retval;\n                        }\n                    } else {\n                        long value;\n                        text += SDL_ScanLong(text, radix, &value);\n                        if (!suppress) {\n                            switch (inttype) {\n                            case DO_SHORT:\n                                {\n                                    short *valuep = va_arg(ap, short *);\n                                    *valuep = (short) value;\n                                }\n                                break;\n                            case DO_INT:\n                                {\n                                    int *valuep = va_arg(ap, int *);\n                                    *valuep = (int) value;\n                                }\n                                break;\n                            case DO_LONG:\n                                {\n                                    long *valuep = va_arg(ap, long *);\n                                    *valuep = value;\n                                }\n                                break;\n                            case DO_LONGLONG:\n                                /* Handled above */\n                                break;\n                            }\n                            ++retval;\n                        }\n                    }\n                    done = SDL_TRUE;\n                    break;\n                case 'o':\n                    if (radix == 10) {\n                        radix = 8;\n                    }\n                    /* Fall through to unsigned handling */\n                case 'x':\n                case 'X':\n                    if (radix == 10) {\n                        radix = 16;\n                    }\n                    /* Fall through to unsigned handling */\n                case 'u':\n                    if (inttype == DO_LONGLONG) {\n                        Uint64 value;\n                        text += SDL_ScanUnsignedLongLong(text, radix, &value);\n                        if (!suppress) {\n                            Uint64 *valuep = va_arg(ap, Uint64 *);\n                            *valuep = value;\n                            ++retval;\n                        }\n                    } else {\n                        unsigned long value;\n                        text += SDL_ScanUnsignedLong(text, radix, &value);\n                        if (!suppress) {\n                            switch (inttype) {\n                            case DO_SHORT:\n                                {\n                                    short *valuep = va_arg(ap, short *);\n                                    *valuep = (short) value;\n                                }\n                                break;\n                            case DO_INT:\n                                {\n                                    int *valuep = va_arg(ap, int *);\n                                    *valuep = (int) value;\n                                }\n                                break;\n                            case DO_LONG:\n                                {\n                                    long *valuep = va_arg(ap, long *);\n                                    *valuep = value;\n                                }\n                                break;\n                            case DO_LONGLONG:\n                                /* Handled above */\n                                break;\n                            }\n                            ++retval;\n                        }\n                    }\n                    done = SDL_TRUE;\n                    break;\n                case 'p':\n                    {\n                        uintptr_t value;\n                        text += SDL_ScanUintPtrT(text, 16, &value);\n                        if (!suppress) {\n                            void **valuep = va_arg(ap, void **);\n                            *valuep = (void *) value;\n                            ++retval;\n                        }\n                    }\n                    done = SDL_TRUE;\n                    break;\n                case 'f':\n                    {\n                        double value;\n                        text += SDL_ScanFloat(text, &value);\n                        if (!suppress) {\n                            float *valuep = va_arg(ap, float *);\n                            *valuep = (float) value;\n                            ++retval;\n                        }\n                    }\n                    done = SDL_TRUE;\n                    break;\n                case 's':\n                    if (suppress) {\n                        while (!SDL_isspace((unsigned char) *text)) {\n                            ++text;\n                            if (count) {\n                                if (--count == 0) {\n                                    break;\n                                }\n                            }\n                        }\n                    } else {\n                        char *valuep = va_arg(ap, char *);\n                        while (!SDL_isspace((unsigned char) *text)) {\n                            *valuep++ = *text++;\n                            if (count) {\n                                if (--count == 0) {\n                                    break;\n                                }\n                            }\n                        }\n                        *valuep = '\\0';\n                        ++retval;\n                    }\n                    done = SDL_TRUE;\n                    break;\n                default:\n                    done = SDL_TRUE;\n                    break;\n                }\n                ++fmt;\n            }\n            continue;\n        }\n        if (*text == *fmt) {\n            ++text;\n            ++fmt;\n            continue;\n        }\n        /* Text didn't match format specifier */\n        break;\n    }\n\n    return retval;\n}\n#endif /* HAVE_VSSCANF */\n\nint\nSDL_snprintf(SDL_OUT_Z_CAP(maxlen) char *text, size_t maxlen, SDL_PRINTF_FORMAT_STRING const char *fmt, ...)\n{\n    va_list ap;\n    int retval;\n\n    va_start(ap, fmt);\n    retval = SDL_vsnprintf(text, maxlen, fmt, ap);\n    va_end(ap);\n\n    return retval;\n}\n\n#ifdef HAVE_VSNPRINTF\nint SDL_vsnprintf(SDL_OUT_Z_CAP(maxlen) char *text, size_t maxlen, const char *fmt, va_list ap)\n{\n    if (!fmt) {\n        fmt = \"\";\n    }\n    return vsnprintf(text, maxlen, fmt, ap);\n}\n#else\n /* FIXME: implement more of the format specifiers */\ntypedef enum\n{\n    SDL_CASE_NOCHANGE,\n    SDL_CASE_LOWER,\n    SDL_CASE_UPPER\n} SDL_letter_case;\n\ntypedef struct\n{\n    SDL_bool left_justify;\n    SDL_bool force_sign;\n    SDL_bool force_type;\n    SDL_bool pad_zeroes;\n    SDL_letter_case force_case;\n    int width;\n    int radix;\n    int precision;\n} SDL_FormatInfo;\n\nstatic size_t\nSDL_PrintString(char *text, size_t maxlen, SDL_FormatInfo *info, const char *string)\n{\n    size_t length = 0;\n\n    if (info && info->width && (size_t)info->width > SDL_strlen(string)) {\n        char fill = info->pad_zeroes ? '0' : ' ';\n        size_t width = info->width - SDL_strlen(string);\n        while (width-- > 0 && maxlen > 0) {\n            *text++ = fill;\n            ++length;\n            --maxlen;\n        }\n    }\n\n    length += SDL_strlcpy(text, string, maxlen);\n\n    if (info) {\n        if (info->force_case == SDL_CASE_LOWER) {\n            SDL_strlwr(text);\n        } else if (info->force_case == SDL_CASE_UPPER) {\n            SDL_strupr(text);\n        }\n    }\n    return length;\n}\n\nstatic size_t\nSDL_PrintLong(char *text, size_t maxlen, SDL_FormatInfo *info, long value)\n{\n    char num[130];\n\n    SDL_ltoa(value, num, info ? info->radix : 10);\n    return SDL_PrintString(text, maxlen, info, num);\n}\n\nstatic size_t\nSDL_PrintUnsignedLong(char *text, size_t maxlen, SDL_FormatInfo *info, unsigned long value)\n{\n    char num[130];\n\n    SDL_ultoa(value, num, info ? info->radix : 10);\n    return SDL_PrintString(text, maxlen, info, num);\n}\n\nstatic size_t\nSDL_PrintLongLong(char *text, size_t maxlen, SDL_FormatInfo *info, Sint64 value)\n{\n    char num[130];\n\n    SDL_lltoa(value, num, info ? info->radix : 10);\n    return SDL_PrintString(text, maxlen, info, num);\n}\n\nstatic size_t\nSDL_PrintUnsignedLongLong(char *text, size_t maxlen, SDL_FormatInfo *info, Uint64 value)\n{\n    char num[130];\n\n    SDL_ulltoa(value, num, info ? info->radix : 10);\n    return SDL_PrintString(text, maxlen, info, num);\n}\n\nstatic size_t\nSDL_PrintFloat(char *text, size_t maxlen, SDL_FormatInfo *info, double arg)\n{\n    int width;\n    size_t len;\n    size_t left = maxlen;\n    char *textstart = text;\n\n    if (arg) {\n        /* This isn't especially accurate, but hey, it's easy. :) */\n        unsigned long value;\n\n        if (arg < 0) {\n            if (left > 1) {\n                *text = '-';\n                --left;\n            }\n            ++text;\n            arg = -arg;\n        } else if (info->force_sign) {\n            if (left > 1) {\n                *text = '+';\n                --left;\n            }\n            ++text;\n        }\n        value = (unsigned long) arg;\n        len = SDL_PrintUnsignedLong(text, left, NULL, value);\n        text += len;\n        if (len >= left) {\n            left = SDL_min(left, 1);\n        } else {\n            left -= len;\n        }\n        arg -= value;\n        if (info->precision < 0) {\n            info->precision = 6;\n        }\n        if (info->force_type || info->precision > 0) {\n            int mult = 10;\n            if (left > 1) {\n                *text = '.';\n                --left;\n            }\n            ++text;\n            while (info->precision-- > 0) {\n                value = (unsigned long) (arg * mult);\n                len = SDL_PrintUnsignedLong(text, left, NULL, value);\n                text += len;\n                if (len >= left) {\n                    left = SDL_min(left, 1);\n                } else {\n                    left -= len;\n                }\n                arg -= (double) value / mult;\n                mult *= 10;\n            }\n        }\n    } else {\n        if (left > 1) {\n            *text = '0';\n            --left;\n        }\n        ++text;\n        if (info->force_type) {\n            if (left > 1) {\n                *text = '.';\n                --left;\n            }\n            ++text;\n        }\n    }\n\n    width = info->width - (int)(text - textstart);\n    if (width > 0) {\n        char fill = info->pad_zeroes ? '0' : ' ';\n        char *end = text+left-1;\n        len = (text - textstart);\n        for (len = (text - textstart); len--; ) {\n            if ((textstart+len+width) < end) {\n                *(textstart+len+width) = *(textstart+len);\n            }\n        }\n        len = (size_t)width;\n        text += len;\n        if (len >= left) {\n            left = SDL_min(left, 1);\n        } else {\n            left -= len;\n        }\n        while (len--) {\n            if (textstart+len < end) {\n                textstart[len] = fill;\n            }\n        }\n    }\n\n    return (text - textstart);\n}\n\nint\nSDL_vsnprintf(SDL_OUT_Z_CAP(maxlen) char *text, size_t maxlen, const char *fmt, va_list ap)\n{\n    size_t left = maxlen;\n    char *textstart = text;\n\n    if (!fmt) {\n        fmt = \"\";\n    }\n    while (*fmt) {\n        if (*fmt == '%') {\n            SDL_bool done = SDL_FALSE;\n            size_t len = 0;\n            SDL_bool check_flag;\n            SDL_FormatInfo info;\n            enum\n            {\n                DO_INT,\n                DO_LONG,\n                DO_LONGLONG\n            } inttype = DO_INT;\n\n            SDL_zero(info);\n            info.radix = 10;\n            info.precision = -1;\n\n            check_flag = SDL_TRUE;\n            while (check_flag) {\n                ++fmt;\n                switch (*fmt) {\n                case '-':\n                    info.left_justify = SDL_TRUE;\n                    break;\n                case '+':\n                    info.force_sign = SDL_TRUE;\n                    break;\n                case '#':\n                    info.force_type = SDL_TRUE;\n                    break;\n                case '0':\n                    info.pad_zeroes = SDL_TRUE;\n                    break;\n                default:\n                    check_flag = SDL_FALSE;\n                    break;\n                }\n            }\n\n            if (*fmt >= '0' && *fmt <= '9') {\n                info.width = SDL_strtol(fmt, (char **)&fmt, 0);\n            }\n\n            if (*fmt == '.') {\n                ++fmt;\n                if (*fmt >= '0' && *fmt <= '9') {\n                    info.precision = SDL_strtol(fmt, (char **)&fmt, 0);\n                } else {\n                    info.precision = 0;\n                }\n            }\n\n            while (!done) {\n                switch (*fmt) {\n                case '%':\n                    if (left > 1) {\n                        *text = '%';\n                    }\n                    len = 1;\n                    done = SDL_TRUE;\n                    break;\n                case 'c':\n                    /* char is promoted to int when passed through (...) */\n                    if (left > 1) {\n                        *text = (char) va_arg(ap, int);\n                    }\n                    len = 1;\n                    done = SDL_TRUE;\n                    break;\n                case 'h':\n                    /* short is promoted to int when passed through (...) */\n                    break;\n                case 'l':\n                    if (inttype < DO_LONGLONG) {\n                        ++inttype;\n                    }\n                    break;\n                case 'I':\n                    if (SDL_strncmp(fmt, \"I64\", 3) == 0) {\n                        fmt += 2;\n                        inttype = DO_LONGLONG;\n                    }\n                    break;\n                case 'i':\n                case 'd':\n                    switch (inttype) {\n                    case DO_INT:\n                        len = SDL_PrintLong(text, left, &info,\n                                            (long) va_arg(ap, int));\n                        break;\n                    case DO_LONG:\n                        len = SDL_PrintLong(text, left, &info,\n                                            va_arg(ap, long));\n                        break;\n                    case DO_LONGLONG:\n                        len = SDL_PrintLongLong(text, left, &info,\n                                                va_arg(ap, Sint64));\n                        break;\n                    }\n                    done = SDL_TRUE;\n                    break;\n                case 'p':\n                case 'x':\n                    info.force_case = SDL_CASE_LOWER;\n                    /* Fall through to 'X' handling */\n                case 'X':\n                    if (info.force_case == SDL_CASE_NOCHANGE) {\n                        info.force_case = SDL_CASE_UPPER;\n                    }\n                    if (info.radix == 10) {\n                        info.radix = 16;\n                    }\n                    if (*fmt == 'p') {\n                        inttype = DO_LONG;\n                    }\n                    /* Fall through to unsigned handling */\n                case 'o':\n                    if (info.radix == 10) {\n                        info.radix = 8;\n                    }\n                    /* Fall through to unsigned handling */\n                case 'u':\n                    info.pad_zeroes = SDL_TRUE;\n                    switch (inttype) {\n                    case DO_INT:\n                        len = SDL_PrintUnsignedLong(text, left, &info,\n                                                    (unsigned long)\n                                                    va_arg(ap, unsigned int));\n                        break;\n                    case DO_LONG:\n                        len = SDL_PrintUnsignedLong(text, left, &info,\n                                                    va_arg(ap, unsigned long));\n                        break;\n                    case DO_LONGLONG:\n                        len = SDL_PrintUnsignedLongLong(text, left, &info,\n                                                        va_arg(ap, Uint64));\n                        break;\n                    }\n                    done = SDL_TRUE;\n                    break;\n                case 'f':\n                    len = SDL_PrintFloat(text, left, &info, va_arg(ap, double));\n                    done = SDL_TRUE;\n                    break;\n                case 's':\n                    len = SDL_PrintString(text, left, &info, va_arg(ap, char *));\n                    done = SDL_TRUE;\n                    break;\n                default:\n                    done = SDL_TRUE;\n                    break;\n                }\n                ++fmt;\n            }\n            text += len;\n            if (len >= left) {\n                left = SDL_min(left, 1);\n            } else {\n                left -= len;\n            }\n        } else {\n            if (left > 1) {\n                *text = *fmt;\n                --left;\n            }\n            ++fmt;\n            ++text;\n        }\n    }\n    if (left > 0) {\n        *text = '\\0';\n    }\n    return (int)(text - textstart);\n}\n#endif /* HAVE_VSNPRINTF */\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../SDL_internal.h\"\n\n#include \"SDL_video.h\"\n#include \"SDL_blit.h\"\n\n\n#ifdef __SSE__\n/* *INDENT-OFF* */\n\n#ifdef _MSC_VER\n#define SSE_BEGIN \\\n    __m128 c128; \\\n    c128.m128_u32[0] = color; \\\n    c128.m128_u32[1] = color; \\\n    c128.m128_u32[2] = color; \\\n    c128.m128_u32[3] = color;\n#else\n#define SSE_BEGIN \\\n    __m128 c128; \\\n    DECLARE_ALIGNED(Uint32, cccc[4], 16); \\\n    cccc[0] = color; \\\n    cccc[1] = color; \\\n    cccc[2] = color; \\\n    cccc[3] = color; \\\n    c128 = *(__m128 *)cccc;\n#endif\n\n#define SSE_WORK \\\n    for (i = n / 64; i--;) { \\\n        _mm_stream_ps((float *)(p+0), c128); \\\n        _mm_stream_ps((float *)(p+16), c128); \\\n        _mm_stream_ps((float *)(p+32), c128); \\\n        _mm_stream_ps((float *)(p+48), c128); \\\n        p += 64; \\\n    }\n\n#define SSE_END\n\n#define DEFINE_SSE_FILLRECT(bpp, type) \\\nstatic void \\\nSDL_FillRect##bpp##SSE(Uint8 *pixels, int pitch, Uint32 color, int w, int h) \\\n{ \\\n    int i, n; \\\n    Uint8 *p = NULL; \\\n \\\n    SSE_BEGIN; \\\n \\\n    while (h--) { \\\n        n = w * bpp; \\\n        p = pixels; \\\n \\\n        if (n > 63) { \\\n            int adjust = 16 - ((uintptr_t)p & 15); \\\n            if (adjust < 16) { \\\n                n -= adjust; \\\n                adjust /= bpp; \\\n                while (adjust--) { \\\n                    *((type *)p) = (type)color; \\\n                    p += bpp; \\\n                } \\\n            } \\\n            SSE_WORK; \\\n        } \\\n        if (n & 63) { \\\n            int remainder = (n & 63); \\\n            remainder /= bpp; \\\n            while (remainder--) { \\\n                *((type *)p) = (type)color; \\\n                p += bpp; \\\n            } \\\n        } \\\n        pixels += pitch; \\\n    } \\\n \\\n    SSE_END; \\\n}\n\nstatic void\nSDL_FillRect1SSE(Uint8 *pixels, int pitch, Uint32 color, int w, int h)\n{\n    int i, n;\n\n    SSE_BEGIN;\n    while (h--) {\n        Uint8 *p = pixels;\n        n = w;\n\n        if (n > 63) {\n            int adjust = 16 - ((uintptr_t)p & 15);\n            if (adjust) {\n                n -= adjust;\n                SDL_memset(p, color, adjust);\n                p += adjust;\n            }\n            SSE_WORK;\n        }\n        if (n & 63) {\n            int remainder = (n & 63);\n            SDL_memset(p, color, remainder);\n        }\n        pixels += pitch;\n    }\n\n    SSE_END;\n}\n/* DEFINE_SSE_FILLRECT(1, Uint8) */\nDEFINE_SSE_FILLRECT(2, Uint16)\nDEFINE_SSE_FILLRECT(4, Uint32)\n\n/* *INDENT-ON* */\n#endif /* __SSE__ */\n\nstatic void\nSDL_FillRect1(Uint8 * pixels, int pitch, Uint32 color, int w, int h)\n{\n    int n;\n    Uint8 *p = NULL;\n    \n    while (h--) {\n        n = w;\n        p = pixels;\n\n        if (n > 3) {\n            switch ((uintptr_t) p & 3) {\n            case 1:\n                *p++ = (Uint8) color;\n                --n;\n            case 2:\n                *p++ = (Uint8) color;\n                --n;\n            case 3:\n                *p++ = (Uint8) color;\n                --n;\n            }\n            SDL_memset4(p, color, (n >> 2));\n        }\n        if (n & 3) {\n            p += (n & ~3);\n            switch (n & 3) {\n            case 3:\n                *p++ = (Uint8) color;\n            case 2:\n                *p++ = (Uint8) color;\n            case 1:\n                *p++ = (Uint8) color;\n            }\n        }\n        pixels += pitch;\n    }\n}\n\nstatic void\nSDL_FillRect2(Uint8 * pixels, int pitch, Uint32 color, int w, int h)\n{\n    int n;\n    Uint16 *p = NULL;\n    \n    while (h--) {\n        n = w;\n        p = (Uint16 *) pixels;\n\n        if (n > 1) {\n            if ((uintptr_t) p & 2) {\n                *p++ = (Uint16) color;\n                --n;\n            }\n            SDL_memset4(p, color, (n >> 1));\n        }\n        if (n & 1) {\n            p[n - 1] = (Uint16) color;\n        }\n        pixels += pitch;\n    }\n}\n\nstatic void\nSDL_FillRect3(Uint8 * pixels, int pitch, Uint32 color, int w, int h)\n{\n    Uint8 r = (Uint8) ((color >> 16) & 0xFF);\n    Uint8 g = (Uint8) ((color >> 8) & 0xFF);\n    Uint8 b = (Uint8) (color & 0xFF);\n    int n;\n    Uint8 *p = NULL;\n\n    while (h--) {\n        n = w;\n        p = pixels;\n\n        while (n--) {\n            *p++ = r;\n            *p++ = g;\n            *p++ = b;\n        }\n        pixels += pitch;\n    }\n}\n\nstatic void\nSDL_FillRect4(Uint8 * pixels, int pitch, Uint32 color, int w, int h)\n{\n    while (h--) {\n        SDL_memset4(pixels, color, w);\n        pixels += pitch;\n    }\n}\n\n/* \n * This function performs a fast fill of the given rectangle with 'color'\n */\nint\nSDL_FillRect(SDL_Surface * dst, const SDL_Rect * rect, Uint32 color)\n{\n    SDL_Rect clipped;\n    Uint8 *pixels;\n\n    if (!dst) {\n        return SDL_SetError(\"Passed NULL destination surface\");\n    }\n\n    /* This function doesn't work on surfaces < 8 bpp */\n    if (dst->format->BitsPerPixel < 8) {\n        return SDL_SetError(\"SDL_FillRect(): Unsupported surface format\");\n    }\n\n    /* If 'rect' == NULL, then fill the whole surface */\n    if (rect) {\n        /* Perform clipping */\n        if (!SDL_IntersectRect(rect, &dst->clip_rect, &clipped)) {\n            return 0;\n        }\n        rect = &clipped;\n    } else {\n        rect = &dst->clip_rect;\n        /* Don't attempt to fill if the surface's clip_rect is empty */\n        if (SDL_RectEmpty(rect)) {\n            return 0;\n        }\n    }\n\n    /* Perform software fill */\n    if (!dst->pixels) {\n        return SDL_SetError(\"SDL_FillRect(): You must lock the surface\");\n    }\n\n    pixels = (Uint8 *) dst->pixels + rect->y * dst->pitch +\n                                     rect->x * dst->format->BytesPerPixel;\n\n    switch (dst->format->BytesPerPixel) {\n    case 1:\n        {\n            color |= (color << 8);\n            color |= (color << 16);\n#ifdef __SSE__\n            if (SDL_HasSSE()) {\n                SDL_FillRect1SSE(pixels, dst->pitch, color, rect->w, rect->h);\n                break;\n            }\n#endif\n            SDL_FillRect1(pixels, dst->pitch, color, rect->w, rect->h);\n            break;\n        }\n\n    case 2:\n        {\n            color |= (color << 16);\n#ifdef __SSE__\n            if (SDL_HasSSE()) {\n                SDL_FillRect2SSE(pixels, dst->pitch, color, rect->w, rect->h);\n                break;\n            }\n#endif\n            SDL_FillRect2(pixels, dst->pitch, color, rect->w, rect->h);\n            break;\n        }\n\n    case 3:\n        /* 24-bit RGB is a slow path, at least for now. */\n        {\n            SDL_FillRect3(pixels, dst->pitch, color, rect->w, rect->h);\n            break;\n        }\n\n    case 4:\n        {\n#ifdef __SSE__\n            if (SDL_HasSSE()) {\n                SDL_FillRect4SSE(pixels, dst->pitch, color, rect->w, rect->h);\n                break;\n            }\n#endif\n            SDL_FillRect4(pixels, dst->pitch, color, rect->w, rect->h);\n            break;\n        }\n    }\n\n    /* We're done! */\n    return 0;\n}\n\nint\nSDL_FillRects(SDL_Surface * dst, const SDL_Rect * rects, int count,\n              Uint32 color)\n{\n    int i;\n    int status = 0;\n\n    if (!rects) {\n        return SDL_SetError(\"SDL_FillRects() passed NULL rects\");\n    }\n\n    for (i = 0; i < count; ++i) {\n        status += SDL_FillRect(dst, &rects[i], color);\n    }\n    return status;\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n\n/**\n *  \\file SDL_rect.h\n *\n *  Header file for SDL_rect definition and management functions.\n */\n\n#ifndef _SDL_rect_h\n#define _SDL_rect_h\n\n#include \"SDL_stdinc.h\"\n#include \"SDL_error.h\"\n#include \"SDL_pixels.h\"\n#include \"SDL_rwops.h\"\n\n#include \"begin_code.h\"\n/* Set up for C function definitions, even when using C++ */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n *  \\brief  The structure that defines a point\n *\n *  \\sa SDL_EnclosePoints\n *  \\sa SDL_PointInRect\n */\ntypedef struct SDL_Point\n{\n    int x;\n    int y;\n} SDL_Point;\n\n/**\n *  \\brief A rectangle, with the origin at the upper left.\n *\n *  \\sa SDL_RectEmpty\n *  \\sa SDL_RectEquals\n *  \\sa SDL_HasIntersection\n *  \\sa SDL_IntersectRect\n *  \\sa SDL_UnionRect\n *  \\sa SDL_EnclosePoints\n */\ntypedef struct SDL_Rect\n{\n    int x, y;\n    int w, h;\n} SDL_Rect;\n\n/**\n *  \\brief Returns true if point resides inside a rectangle.\n */\nSDL_FORCE_INLINE SDL_bool SDL_PointInRect(const SDL_Point *p, const SDL_Rect *r)\n{\n    return ( (p->x >= r->x) && (p->x < (r->x + r->w)) &&\n             (p->y >= r->y) && (p->y < (r->y + r->h)) ) ? SDL_TRUE : SDL_FALSE;\n}\n\n/**\n *  \\brief Returns true if the rectangle has no area.\n */\nSDL_FORCE_INLINE SDL_bool SDL_RectEmpty(const SDL_Rect *r)\n{\n    return ((!r) || (r->w <= 0) || (r->h <= 0)) ? SDL_TRUE : SDL_FALSE;\n}\n\n/**\n *  \\brief Returns true if the two rectangles are equal.\n */\nSDL_FORCE_INLINE SDL_bool SDL_RectEquals(const SDL_Rect *a, const SDL_Rect *b)\n{\n    return (a && b && (a->x == b->x) && (a->y == b->y) &&\n            (a->w == b->w) && (a->h == b->h)) ? SDL_TRUE : SDL_FALSE;\n}\n\n/**\n *  \\brief Determine whether two rectangles intersect.\n *\n *  \\return SDL_TRUE if there is an intersection, SDL_FALSE otherwise.\n */\nextern DECLSPEC SDL_bool SDLCALL SDL_HasIntersection(const SDL_Rect * A,\n                                                     const SDL_Rect * B);\n\n/**\n *  \\brief Calculate the intersection of two rectangles.\n *\n *  \\return SDL_TRUE if there is an intersection, SDL_FALSE otherwise.\n */\nextern DECLSPEC SDL_bool SDLCALL SDL_IntersectRect(const SDL_Rect * A,\n                                                   const SDL_Rect * B,\n                                                   SDL_Rect * result);\n\n/**\n *  \\brief Calculate the union of two rectangles.\n */\nextern DECLSPEC void SDLCALL SDL_UnionRect(const SDL_Rect * A,\n                                           const SDL_Rect * B,\n                                           SDL_Rect * result);\n\n/**\n *  \\brief Calculate a minimal rectangle enclosing a set of points\n *\n *  \\return SDL_TRUE if any points were within the clipping rect\n */\nextern DECLSPEC SDL_bool SDLCALL SDL_EnclosePoints(const SDL_Point * points,\n                                                   int count,\n                                                   const SDL_Rect * clip,\n                                                   SDL_Rect * result);\n\n/**\n *  \\brief Calculate the intersection of a rectangle and line segment.\n *\n *  \\return SDL_TRUE if there is an intersection, SDL_FALSE otherwise.\n */\nextern DECLSPEC SDL_bool SDLCALL SDL_IntersectRectAndLine(const SDL_Rect *\n                                                          rect, int *X1,\n                                                          int *Y1, int *X2,\n                                                          int *Y2);\n\n/* Ends C function definitions when using C++ */\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif /* _SDL_rect_h */\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n\n/**\n *  \\file SDL_stdinc.h\n *\n *  This is a general header that includes C language support.\n */\n\n#ifndef _SDL_stdinc_h\n#define _SDL_stdinc_h\n\n#include \"SDL_config.h\"\n\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_STDIO_H\n#include <stdio.h>\n#endif\n#if defined(STDC_HEADERS)\n# include <stdlib.h>\n# include <stddef.h>\n# include <stdarg.h>\n#else\n# if defined(HAVE_STDLIB_H)\n#  include <stdlib.h>\n# elif defined(HAVE_MALLOC_H)\n#  include <malloc.h>\n# endif\n# if defined(HAVE_STDDEF_H)\n#  include <stddef.h>\n# endif\n# if defined(HAVE_STDARG_H)\n#  include <stdarg.h>\n# endif\n#endif\n#ifdef HAVE_STRING_H\n# if !defined(STDC_HEADERS) && defined(HAVE_MEMORY_H)\n#  include <memory.h>\n# endif\n# include <string.h>\n#endif\n#ifdef HAVE_STRINGS_H\n# include <strings.h>\n#endif\n#if defined(HAVE_INTTYPES_H)\n# include <inttypes.h>\n#elif defined(HAVE_STDINT_H)\n# include <stdint.h>\n#endif\n#ifdef HAVE_CTYPE_H\n# include <ctype.h>\n#endif\n#ifdef HAVE_MATH_H\n# if defined(__WINRT__)\n/* Defining _USE_MATH_DEFINES is required to get M_PI to be defined on\n   WinRT.  See http://msdn.microsoft.com/en-us/library/4hwaceh6.aspx\n   for more information.\n*/\n#  define _USE_MATH_DEFINES\n# endif\n# include <math.h>\n#endif\n#ifdef HAVE_FLOAT_H\n# include <float.h>\n#endif\n#if defined(HAVE_ICONV) && defined(HAVE_ICONV_H)\n# include <iconv.h>\n#endif\n\n/**\n *  The number of elements in an array.\n */\n#define SDL_arraysize(array)    (sizeof(array)/sizeof(array[0]))\n#define SDL_TABLESIZE(table)    SDL_arraysize(table)\n\n/**\n *  \\name Cast operators\n *\n *  Use proper C++ casts when compiled as C++ to be compatible with the option\n *  -Wold-style-cast of GCC (and -Werror=old-style-cast in GCC 4.2 and above).\n */\n/* @{ */\n#ifdef __cplusplus\n#define SDL_reinterpret_cast(type, expression) reinterpret_cast<type>(expression)\n#define SDL_static_cast(type, expression) static_cast<type>(expression)\n#define SDL_const_cast(type, expression) const_cast<type>(expression)\n#else\n#define SDL_reinterpret_cast(type, expression) ((type)(expression))\n#define SDL_static_cast(type, expression) ((type)(expression))\n#define SDL_const_cast(type, expression) ((type)(expression))\n#endif\n/* @} *//* Cast operators */\n\n/* Define a four character code as a Uint32 */\n#define SDL_FOURCC(A, B, C, D) \\\n    ((SDL_static_cast(Uint32, SDL_static_cast(Uint8, (A))) << 0) | \\\n     (SDL_static_cast(Uint32, SDL_static_cast(Uint8, (B))) << 8) | \\\n     (SDL_static_cast(Uint32, SDL_static_cast(Uint8, (C))) << 16) | \\\n     (SDL_static_cast(Uint32, SDL_static_cast(Uint8, (D))) << 24))\n\n/**\n *  \\name Basic data types\n */\n/* @{ */\n\ntypedef enum\n{\n    SDL_FALSE = 0,\n    SDL_TRUE = 1\n} SDL_bool;\n\n/**\n * \\brief A signed 8-bit integer type.\n */\ntypedef int8_t Sint8;\n/**\n * \\brief An unsigned 8-bit integer type.\n */\ntypedef uint8_t Uint8;\n/**\n * \\brief A signed 16-bit integer type.\n */\ntypedef int16_t Sint16;\n/**\n * \\brief An unsigned 16-bit integer type.\n */\ntypedef uint16_t Uint16;\n/**\n * \\brief A signed 32-bit integer type.\n */\ntypedef int32_t Sint32;\n/**\n * \\brief An unsigned 32-bit integer type.\n */\ntypedef uint32_t Uint32;\n\n/**\n * \\brief A signed 64-bit integer type.\n */\ntypedef int64_t Sint64;\n/**\n * \\brief An unsigned 64-bit integer type.\n */\ntypedef uint64_t Uint64;\n\n/* @} *//* Basic data types */\n\n/* Make sure we have macros for printing 64 bit values.\n * <stdint.h> should define these but this is not true all platforms.\n * (for example win32) */\n#ifndef SDL_PRIs64\n#ifdef PRIs64\n#define SDL_PRIs64 PRIs64\n#elif defined(__WIN32__)\n#define SDL_PRIs64 \"I64d\"\n#elif defined(__LINUX__) && defined(__LP64__)\n#define SDL_PRIs64 \"ld\"\n#else\n#define SDL_PRIs64 \"lld\"\n#endif\n#endif\n#ifndef SDL_PRIu64\n#ifdef PRIu64\n#define SDL_PRIu64 PRIu64\n#elif defined(__WIN32__)\n#define SDL_PRIu64 \"I64u\"\n#elif defined(__LINUX__) && defined(__LP64__)\n#define SDL_PRIu64 \"lu\"\n#else\n#define SDL_PRIu64 \"llu\"\n#endif\n#endif\n#ifndef SDL_PRIx64\n#ifdef PRIx64\n#define SDL_PRIx64 PRIx64\n#elif defined(__WIN32__)\n#define SDL_PRIx64 \"I64x\"\n#elif defined(__LINUX__) && defined(__LP64__)\n#define SDL_PRIx64 \"lx\"\n#else\n#define SDL_PRIx64 \"llx\"\n#endif\n#endif\n#ifndef SDL_PRIX64\n#ifdef PRIX64\n#define SDL_PRIX64 PRIX64\n#elif defined(__WIN32__)\n#define SDL_PRIX64 \"I64X\"\n#elif defined(__LINUX__) && defined(__LP64__)\n#define SDL_PRIX64 \"lX\"\n#else\n#define SDL_PRIX64 \"llX\"\n#endif\n#endif\n\n/* Annotations to help code analysis tools */\n#ifdef SDL_DISABLE_ANALYZE_MACROS\n#define SDL_IN_BYTECAP(x)\n#define SDL_INOUT_Z_CAP(x)\n#define SDL_OUT_Z_CAP(x)\n#define SDL_OUT_CAP(x)\n#define SDL_OUT_BYTECAP(x)\n#define SDL_OUT_Z_BYTECAP(x)\n#define SDL_PRINTF_FORMAT_STRING\n#define SDL_SCANF_FORMAT_STRING\n#define SDL_PRINTF_VARARG_FUNC( fmtargnumber )\n#define SDL_SCANF_VARARG_FUNC( fmtargnumber )\n#else\n#if _MSC_VER >= 1600 /* VS 2010 and above */\n#include <sal.h>\n\n#define SDL_IN_BYTECAP(x) _In_bytecount_(x)\n#define SDL_INOUT_Z_CAP(x) _Inout_z_cap_(x)\n#define SDL_OUT_Z_CAP(x) _Out_z_cap_(x)\n#define SDL_OUT_CAP(x) _Out_cap_(x)\n#define SDL_OUT_BYTECAP(x) _Out_bytecap_(x)\n#define SDL_OUT_Z_BYTECAP(x) _Out_z_bytecap_(x)\n\n#define SDL_PRINTF_FORMAT_STRING _Printf_format_string_\n#define SDL_SCANF_FORMAT_STRING _Scanf_format_string_impl_\n#else\n#define SDL_IN_BYTECAP(x)\n#define SDL_INOUT_Z_CAP(x)\n#define SDL_OUT_Z_CAP(x)\n#define SDL_OUT_CAP(x)\n#define SDL_OUT_BYTECAP(x)\n#define SDL_OUT_Z_BYTECAP(x)\n#define SDL_PRINTF_FORMAT_STRING\n#define SDL_SCANF_FORMAT_STRING\n#endif\n#if defined(__GNUC__)\n#define SDL_PRINTF_VARARG_FUNC( fmtargnumber ) __attribute__ (( format( __printf__, fmtargnumber, fmtargnumber+1 )))\n#define SDL_SCANF_VARARG_FUNC( fmtargnumber ) __attribute__ (( format( __scanf__, fmtargnumber, fmtargnumber+1 )))\n#else\n#define SDL_PRINTF_VARARG_FUNC( fmtargnumber )\n#define SDL_SCANF_VARARG_FUNC( fmtargnumber )\n#endif\n#endif /* SDL_DISABLE_ANALYZE_MACROS */\n\n#define SDL_COMPILE_TIME_ASSERT(name, x)               \\\n       typedef int SDL_dummy_ ## name[(x) * 2 - 1]\n/** \\cond */\n#ifndef DOXYGEN_SHOULD_IGNORE_THIS\nSDL_COMPILE_TIME_ASSERT(uint8, sizeof(Uint8) == 1);\nSDL_COMPILE_TIME_ASSERT(sint8, sizeof(Sint8) == 1);\nSDL_COMPILE_TIME_ASSERT(uint16, sizeof(Uint16) == 2);\nSDL_COMPILE_TIME_ASSERT(sint16, sizeof(Sint16) == 2);\nSDL_COMPILE_TIME_ASSERT(uint32, sizeof(Uint32) == 4);\nSDL_COMPILE_TIME_ASSERT(sint32, sizeof(Sint32) == 4);\nSDL_COMPILE_TIME_ASSERT(uint64, sizeof(Uint64) == 8);\nSDL_COMPILE_TIME_ASSERT(sint64, sizeof(Sint64) == 8);\n#endif /* DOXYGEN_SHOULD_IGNORE_THIS */\n/** \\endcond */\n\n/* Check to make sure enums are the size of ints, for structure packing.\n   For both Watcom C/C++ and Borland C/C++ the compiler option that makes\n   enums having the size of an int must be enabled.\n   This is \"-b\" for Borland C/C++ and \"-ei\" for Watcom C/C++ (v11).\n*/\n\n/** \\cond */\n#ifndef DOXYGEN_SHOULD_IGNORE_THIS\n#if !defined(__ANDROID__)\n   /* TODO: include/SDL_stdinc.h:174: error: size of array 'SDL_dummy_enum' is negative */\ntypedef enum\n{\n    DUMMY_ENUM_VALUE\n} SDL_DUMMY_ENUM;\n\nSDL_COMPILE_TIME_ASSERT(enum, sizeof(SDL_DUMMY_ENUM) == sizeof(int));\n#endif\n#endif /* DOXYGEN_SHOULD_IGNORE_THIS */\n/** \\endcond */\n\n#include \"begin_code.h\"\n/* Set up for C function definitions, even when using C++ */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#if defined(HAVE_ALLOCA) && !defined(alloca)\n# if defined(HAVE_ALLOCA_H)\n#  include <alloca.h>\n# elif defined(__GNUC__)\n#  define alloca __builtin_alloca\n# elif defined(_MSC_VER)\n#  include <malloc.h>\n#  define alloca _alloca\n# elif defined(__WATCOMC__)\n#  include <malloc.h>\n# elif defined(__BORLANDC__)\n#  include <malloc.h>\n# elif defined(__DMC__)\n#  include <stdlib.h>\n# elif defined(__AIX__)\n#pragma alloca\n# elif defined(__MRC__)\nvoid *alloca(unsigned);\n# else\nchar *alloca();\n# endif\n#endif\n#ifdef HAVE_ALLOCA\n#define SDL_stack_alloc(type, count)    (type*)alloca(sizeof(type)*(count))\n#define SDL_stack_free(data)\n#else\n#define SDL_stack_alloc(type, count)    (type*)SDL_malloc(sizeof(type)*(count))\n#define SDL_stack_free(data)            SDL_free(data)\n#endif\n\nextern DECLSPEC void *SDLCALL SDL_malloc(size_t size);\nextern DECLSPEC void *SDLCALL SDL_calloc(size_t nmemb, size_t size);\nextern DECLSPEC void *SDLCALL SDL_realloc(void *mem, size_t size);\nextern DECLSPEC void SDLCALL SDL_free(void *mem);\n\nextern DECLSPEC char *SDLCALL SDL_getenv(const char *name);\nextern DECLSPEC int SDLCALL SDL_setenv(const char *name, const char *value, int overwrite);\n\nextern DECLSPEC void SDLCALL SDL_qsort(void *base, size_t nmemb, size_t size, int (*compare) (const void *, const void *));\n\nextern DECLSPEC int SDLCALL SDL_abs(int x);\n\n/* !!! FIXME: these have side effects. You probably shouldn't use them. */\n/* !!! FIXME: Maybe we do forceinline functions of SDL_mini, SDL_minf, etc? */\n#define SDL_min(x, y) (((x) < (y)) ? (x) : (y))\n#define SDL_max(x, y) (((x) > (y)) ? (x) : (y))\n\nextern DECLSPEC int SDLCALL SDL_isdigit(int x);\nextern DECLSPEC int SDLCALL SDL_isspace(int x);\nextern DECLSPEC int SDLCALL SDL_toupper(int x);\nextern DECLSPEC int SDLCALL SDL_tolower(int x);\n\nextern DECLSPEC void *SDLCALL SDL_memset(SDL_OUT_BYTECAP(len) void *dst, int c, size_t len);\n\n#define SDL_zero(x) SDL_memset(&(x), 0, sizeof((x)))\n#define SDL_zerop(x) SDL_memset((x), 0, sizeof(*(x)))\n\n/* Note that memset() is a byte assignment and this is a 32-bit assignment, so they're not directly equivalent. */\nSDL_FORCE_INLINE void SDL_memset4(void *dst, Uint32 val, size_t dwords)\n{\n#if defined(__GNUC__) && defined(i386)\n    int u0, u1, u2;\n    __asm__ __volatile__ (\n        \"cld \\n\\t\"\n        \"rep ; stosl \\n\\t\"\n        : \"=&D\" (u0), \"=&a\" (u1), \"=&c\" (u2)\n        : \"0\" (dst), \"1\" (val), \"2\" (SDL_static_cast(Uint32, dwords))\n        : \"memory\"\n    );\n#else\n    size_t _n = (dwords + 3) / 4;\n    Uint32 *_p = SDL_static_cast(Uint32 *, dst);\n    Uint32 _val = (val);\n    if (dwords == 0)\n        return;\n    switch (dwords % 4)\n    {\n        case 0: do {    *_p++ = _val;\n        case 3:         *_p++ = _val;\n        case 2:         *_p++ = _val;\n        case 1:         *_p++ = _val;\n        } while ( --_n );\n    }\n#endif\n}\n\n\nextern DECLSPEC void *SDLCALL SDL_memcpy(SDL_OUT_BYTECAP(len) void *dst, SDL_IN_BYTECAP(len) const void *src, size_t len);\n\nextern DECLSPEC void *SDLCALL SDL_memmove(SDL_OUT_BYTECAP(len) void *dst, SDL_IN_BYTECAP(len) const void *src, size_t len);\nextern DECLSPEC int SDLCALL SDL_memcmp(const void *s1, const void *s2, size_t len);\n\nextern DECLSPEC size_t SDLCALL SDL_wcslen(const wchar_t *wstr);\nextern DECLSPEC size_t SDLCALL SDL_wcslcpy(SDL_OUT_Z_CAP(maxlen) wchar_t *dst, const wchar_t *src, size_t maxlen);\nextern DECLSPEC size_t SDLCALL SDL_wcslcat(SDL_INOUT_Z_CAP(maxlen) wchar_t *dst, const wchar_t *src, size_t maxlen);\n\nextern DECLSPEC size_t SDLCALL SDL_strlen(const char *str);\nextern DECLSPEC size_t SDLCALL SDL_strlcpy(SDL_OUT_Z_CAP(maxlen) char *dst, const char *src, size_t maxlen);\nextern DECLSPEC size_t SDLCALL SDL_utf8strlcpy(SDL_OUT_Z_CAP(dst_bytes) char *dst, const char *src, size_t dst_bytes);\nextern DECLSPEC size_t SDLCALL SDL_strlcat(SDL_INOUT_Z_CAP(maxlen) char *dst, const char *src, size_t maxlen);\nextern DECLSPEC char *SDLCALL SDL_strdup(const char *str);\nextern DECLSPEC char *SDLCALL SDL_strrev(char *str);\nextern DECLSPEC char *SDLCALL SDL_strupr(char *str);\nextern DECLSPEC char *SDLCALL SDL_strlwr(char *str);\nextern DECLSPEC char *SDLCALL SDL_strchr(const char *str, int c);\nextern DECLSPEC char *SDLCALL SDL_strrchr(const char *str, int c);\nextern DECLSPEC char *SDLCALL SDL_strstr(const char *haystack, const char *needle);\n\nextern DECLSPEC char *SDLCALL SDL_itoa(int value, char *str, int radix);\nextern DECLSPEC char *SDLCALL SDL_uitoa(unsigned int value, char *str, int radix);\nextern DECLSPEC char *SDLCALL SDL_ltoa(long value, char *str, int radix);\nextern DECLSPEC char *SDLCALL SDL_ultoa(unsigned long value, char *str, int radix);\nextern DECLSPEC char *SDLCALL SDL_lltoa(Sint64 value, char *str, int radix);\nextern DECLSPEC char *SDLCALL SDL_ulltoa(Uint64 value, char *str, int radix);\n\nextern DECLSPEC int SDLCALL SDL_atoi(const char *str);\nextern DECLSPEC double SDLCALL SDL_atof(const char *str);\nextern DECLSPEC long SDLCALL SDL_strtol(const char *str, char **endp, int base);\nextern DECLSPEC unsigned long SDLCALL SDL_strtoul(const char *str, char **endp, int base);\nextern DECLSPEC Sint64 SDLCALL SDL_strtoll(const char *str, char **endp, int base);\nextern DECLSPEC Uint64 SDLCALL SDL_strtoull(const char *str, char **endp, int base);\nextern DECLSPEC double SDLCALL SDL_strtod(const char *str, char **endp);\n\nextern DECLSPEC int SDLCALL SDL_strcmp(const char *str1, const char *str2);\nextern DECLSPEC int SDLCALL SDL_strncmp(const char *str1, const char *str2, size_t maxlen);\nextern DECLSPEC int SDLCALL SDL_strcasecmp(const char *str1, const char *str2);\nextern DECLSPEC int SDLCALL SDL_strncasecmp(const char *str1, const char *str2, size_t len);\n\nextern DECLSPEC int SDLCALL SDL_sscanf(const char *text, SDL_SCANF_FORMAT_STRING const char *fmt, ...) SDL_SCANF_VARARG_FUNC(2);\nextern DECLSPEC int SDLCALL SDL_vsscanf(const char *text, const char *fmt, va_list ap);\nextern DECLSPEC int SDLCALL SDL_snprintf(SDL_OUT_Z_CAP(maxlen) char *text, size_t maxlen, SDL_PRINTF_FORMAT_STRING const char *fmt, ... ) SDL_PRINTF_VARARG_FUNC(3);\nextern DECLSPEC int SDLCALL SDL_vsnprintf(SDL_OUT_Z_CAP(maxlen) char *text, size_t maxlen, const char *fmt, va_list ap);\n\n#ifndef HAVE_M_PI\n#ifndef M_PI\n#define M_PI    3.14159265358979323846264338327950288   /* pi */\n#endif\n#endif\n\nextern DECLSPEC double SDLCALL SDL_acos(double x);\nextern DECLSPEC double SDLCALL SDL_asin(double x);\nextern DECLSPEC double SDLCALL SDL_atan(double x);\nextern DECLSPEC double SDLCALL SDL_atan2(double x, double y);\nextern DECLSPEC double SDLCALL SDL_ceil(double x);\nextern DECLSPEC double SDLCALL SDL_copysign(double x, double y);\nextern DECLSPEC double SDLCALL SDL_cos(double x);\nextern DECLSPEC float SDLCALL SDL_cosf(float x);\nextern DECLSPEC double SDLCALL SDL_fabs(double x);\nextern DECLSPEC double SDLCALL SDL_floor(double x);\nextern DECLSPEC double SDLCALL SDL_log(double x);\nextern DECLSPEC double SDLCALL SDL_pow(double x, double y);\nextern DECLSPEC double SDLCALL SDL_scalbn(double x, int n);\nextern DECLSPEC double SDLCALL SDL_sin(double x);\nextern DECLSPEC float SDLCALL SDL_sinf(float x);\nextern DECLSPEC double SDLCALL SDL_sqrt(double x);\nextern DECLSPEC float SDLCALL SDL_sqrtf(float x);\nextern DECLSPEC double SDLCALL SDL_tan(double x);\nextern DECLSPEC float SDLCALL SDL_tanf(float x);\n\n/* The SDL implementation of iconv() returns these error codes */\n#define SDL_ICONV_ERROR     (size_t)-1\n#define SDL_ICONV_E2BIG     (size_t)-2\n#define SDL_ICONV_EILSEQ    (size_t)-3\n#define SDL_ICONV_EINVAL    (size_t)-4\n\n/* SDL_iconv_* are now always real symbols/types, not macros or inlined. */\ntypedef struct _SDL_iconv_t *SDL_iconv_t;\nextern DECLSPEC SDL_iconv_t SDLCALL SDL_iconv_open(const char *tocode,\n                                                   const char *fromcode);\nextern DECLSPEC int SDLCALL SDL_iconv_close(SDL_iconv_t cd);\nextern DECLSPEC size_t SDLCALL SDL_iconv(SDL_iconv_t cd, const char **inbuf,\n                                         size_t * inbytesleft, char **outbuf,\n                                         size_t * outbytesleft);\n/**\n *  This function converts a string between encodings in one pass, returning a\n *  string that must be freed with SDL_free() or NULL on error.\n */\nextern DECLSPEC char *SDLCALL SDL_iconv_string(const char *tocode,\n                                               const char *fromcode,\n                                               const char *inbuf,\n                                               size_t inbytesleft);\n#define SDL_iconv_utf8_locale(S)    SDL_iconv_string(\"\", \"UTF-8\", S, SDL_strlen(S)+1)\n#define SDL_iconv_utf8_ucs2(S)      (Uint16 *)SDL_iconv_string(\"UCS-2-INTERNAL\", \"UTF-8\", S, SDL_strlen(S)+1)\n#define SDL_iconv_utf8_ucs4(S)      (Uint32 *)SDL_iconv_string(\"UCS-4-INTERNAL\", \"UTF-8\", S, SDL_strlen(S)+1)\n\n/* force builds using Clang's static analysis tools to use literal C runtime\n   here, since there are possibly tests that are ineffective otherwise. */\n#if defined(__clang_analyzer__) && !defined(SDL_DISABLE_ANALYZE_MACROS)\n#define SDL_malloc malloc\n#define SDL_calloc calloc\n#define SDL_realloc realloc\n#define SDL_free free\n#define SDL_memset memset\n#define SDL_memcpy memcpy\n#define SDL_memmove memmove\n#define SDL_memcmp memcmp\n#define SDL_strlen strlen\n#define SDL_strlcpy strlcpy\n#define SDL_strlcat strlcat\n#define SDL_strdup strdup\n#define SDL_strchr strchr\n#define SDL_strrchr strrchr\n#define SDL_strstr strstr\n#define SDL_strcmp strcmp\n#define SDL_strncmp strncmp\n#define SDL_strcasecmp strcasecmp\n#define SDL_strncasecmp strncasecmp\n#define SDL_sscanf sscanf\n#define SDL_vsscanf vsscanf\n#define SDL_snprintf snprintf\n#define SDL_vsnprintf vsnprintf\n#endif\n\nSDL_FORCE_INLINE void *SDL_memcpy4(SDL_OUT_BYTECAP(dwords*4) void *dst, SDL_IN_BYTECAP(dwords*4) const void *src, size_t dwords)\n{\n    return SDL_memcpy(dst, src, dwords * 4);\n}\n\n/* Ends C function definitions when using C++ */\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif /* _SDL_stdinc_h */\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../SDL_internal.h\"\n\n/* General (mostly internal) pixel/color manipulation routines for SDL */\n\n#include \"SDL_endian.h\"\n#include \"SDL_video.h\"\n#include \"SDL_sysvideo.h\"\n#include \"SDL_blit.h\"\n#include \"SDL_pixels_c.h\"\n#include \"SDL_RLEaccel_c.h\"\n\n\n/* Lookup tables to expand partial bytes to the full 0..255 range */\n\nstatic Uint8 lookup_0[] = {\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255\n};\n\nstatic Uint8 lookup_1[] = {\n0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 255\n};\n\nstatic Uint8 lookup_2[] = {\n0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 85, 89, 93, 97, 101, 105, 109, 113, 117, 121, 125, 129, 133, 137, 141, 145, 149, 153, 157, 161, 165, 170, 174, 178, 182, 186, 190, 194, 198, 202, 206, 210, 214, 218, 222, 226, 230, 234, 238, 242, 246, 250, 255\n};\n\nstatic Uint8 lookup_3[] = {\n0, 8, 16, 24, 32, 41, 49, 57, 65, 74, 82, 90, 98, 106, 115, 123, 131, 139, 148, 156, 164, 172, 180, 189, 197, 205, 213, 222, 230, 238, 246, 255\n};\n\nstatic Uint8 lookup_4[] = {\n0, 17, 34, 51, 68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238, 255\n};\n\nstatic Uint8 lookup_5[] = {\n0, 36, 72, 109, 145, 182, 218, 255\n};\n\nstatic Uint8 lookup_6[] = {\n0, 85, 170, 255\n};\n\nstatic Uint8 lookup_7[] = {\n0, 255\n};\n\nstatic Uint8 lookup_8[] = {\n255\n};\n\nUint8* SDL_expand_byte[9] = {\n    lookup_0,\n    lookup_1,\n    lookup_2,\n    lookup_3,\n    lookup_4,\n    lookup_5,\n    lookup_6,\n    lookup_7,\n    lookup_8\n};\n\n/* Helper functions */\n\nconst char*\nSDL_GetPixelFormatName(Uint32 format)\n{\n    switch (format) {\n#define CASE(X) case X: return #X;\n    CASE(SDL_PIXELFORMAT_INDEX1LSB)\n    CASE(SDL_PIXELFORMAT_INDEX1MSB)\n    CASE(SDL_PIXELFORMAT_INDEX4LSB)\n    CASE(SDL_PIXELFORMAT_INDEX4MSB)\n    CASE(SDL_PIXELFORMAT_INDEX8)\n    CASE(SDL_PIXELFORMAT_RGB332)\n    CASE(SDL_PIXELFORMAT_RGB444)\n    CASE(SDL_PIXELFORMAT_RGB555)\n    CASE(SDL_PIXELFORMAT_BGR555)\n    CASE(SDL_PIXELFORMAT_ARGB4444)\n    CASE(SDL_PIXELFORMAT_RGBA4444)\n    CASE(SDL_PIXELFORMAT_ABGR4444)\n    CASE(SDL_PIXELFORMAT_BGRA4444)\n    CASE(SDL_PIXELFORMAT_ARGB1555)\n    CASE(SDL_PIXELFORMAT_RGBA5551)\n    CASE(SDL_PIXELFORMAT_ABGR1555)\n    CASE(SDL_PIXELFORMAT_BGRA5551)\n    CASE(SDL_PIXELFORMAT_RGB565)\n    CASE(SDL_PIXELFORMAT_BGR565)\n    CASE(SDL_PIXELFORMAT_RGB24)\n    CASE(SDL_PIXELFORMAT_BGR24)\n    CASE(SDL_PIXELFORMAT_RGB888)\n    CASE(SDL_PIXELFORMAT_RGBX8888)\n    CASE(SDL_PIXELFORMAT_BGR888)\n    CASE(SDL_PIXELFORMAT_BGRX8888)\n    CASE(SDL_PIXELFORMAT_ARGB8888)\n    CASE(SDL_PIXELFORMAT_RGBA8888)\n    CASE(SDL_PIXELFORMAT_ABGR8888)\n    CASE(SDL_PIXELFORMAT_BGRA8888)\n    CASE(SDL_PIXELFORMAT_ARGB2101010)\n    CASE(SDL_PIXELFORMAT_YV12)\n    CASE(SDL_PIXELFORMAT_IYUV)\n    CASE(SDL_PIXELFORMAT_YUY2)\n    CASE(SDL_PIXELFORMAT_UYVY)\n    CASE(SDL_PIXELFORMAT_YVYU)\n    CASE(SDL_PIXELFORMAT_NV12)\n    CASE(SDL_PIXELFORMAT_NV21)\n#undef CASE\n    default:\n        return \"SDL_PIXELFORMAT_UNKNOWN\";\n    }\n}\n\nSDL_bool\nSDL_PixelFormatEnumToMasks(Uint32 format, int *bpp, Uint32 * Rmask,\n                           Uint32 * Gmask, Uint32 * Bmask, Uint32 * Amask)\n{\n    Uint32 masks[4];\n\n    /* This function doesn't work with FourCC pixel formats */\n    if (SDL_ISPIXELFORMAT_FOURCC(format)) {\n        SDL_SetError(\"FOURCC pixel formats are not supported\");\n        return SDL_FALSE;\n    }\n\n    /* Initialize the values here */\n    if (SDL_BYTESPERPIXEL(format) <= 2) {\n        *bpp = SDL_BITSPERPIXEL(format);\n    } else {\n        *bpp = SDL_BYTESPERPIXEL(format) * 8;\n    }\n    *Rmask = *Gmask = *Bmask = *Amask = 0;\n\n    if (format == SDL_PIXELFORMAT_RGB24) {\n#if SDL_BYTEORDER == SDL_BIG_ENDIAN\n        *Rmask = 0x00FF0000;\n        *Gmask = 0x0000FF00;\n        *Bmask = 0x000000FF;\n#else\n        *Rmask = 0x000000FF;\n        *Gmask = 0x0000FF00;\n        *Bmask = 0x00FF0000;\n#endif\n        return SDL_TRUE;\n    }\n\n    if (format == SDL_PIXELFORMAT_BGR24) {\n#if SDL_BYTEORDER == SDL_BIG_ENDIAN\n        *Rmask = 0x000000FF;\n        *Gmask = 0x0000FF00;\n        *Bmask = 0x00FF0000;\n#else\n        *Rmask = 0x00FF0000;\n        *Gmask = 0x0000FF00;\n        *Bmask = 0x000000FF;\n#endif\n        return SDL_TRUE;\n    }\n\n    if (SDL_PIXELTYPE(format) != SDL_PIXELTYPE_PACKED8 &&\n        SDL_PIXELTYPE(format) != SDL_PIXELTYPE_PACKED16 &&\n        SDL_PIXELTYPE(format) != SDL_PIXELTYPE_PACKED32) {\n        /* Not a format that uses masks */\n        return SDL_TRUE;\n    }\n\n    switch (SDL_PIXELLAYOUT(format)) {\n    case SDL_PACKEDLAYOUT_332:\n        masks[0] = 0x00000000;\n        masks[1] = 0x000000E0;\n        masks[2] = 0x0000001C;\n        masks[3] = 0x00000003;\n        break;\n    case SDL_PACKEDLAYOUT_4444:\n        masks[0] = 0x0000F000;\n        masks[1] = 0x00000F00;\n        masks[2] = 0x000000F0;\n        masks[3] = 0x0000000F;\n        break;\n    case SDL_PACKEDLAYOUT_1555:\n        masks[0] = 0x00008000;\n        masks[1] = 0x00007C00;\n        masks[2] = 0x000003E0;\n        masks[3] = 0x0000001F;\n        break;\n    case SDL_PACKEDLAYOUT_5551:\n        masks[0] = 0x0000F800;\n        masks[1] = 0x000007C0;\n        masks[2] = 0x0000003E;\n        masks[3] = 0x00000001;\n        break;\n    case SDL_PACKEDLAYOUT_565:\n        masks[0] = 0x00000000;\n        masks[1] = 0x0000F800;\n        masks[2] = 0x000007E0;\n        masks[3] = 0x0000001F;\n        break;\n    case SDL_PACKEDLAYOUT_8888:\n        masks[0] = 0xFF000000;\n        masks[1] = 0x00FF0000;\n        masks[2] = 0x0000FF00;\n        masks[3] = 0x000000FF;\n        break;\n    case SDL_PACKEDLAYOUT_2101010:\n        masks[0] = 0xC0000000;\n        masks[1] = 0x3FF00000;\n        masks[2] = 0x000FFC00;\n        masks[3] = 0x000003FF;\n        break;\n    case SDL_PACKEDLAYOUT_1010102:\n        masks[0] = 0xFFC00000;\n        masks[1] = 0x003FF000;\n        masks[2] = 0x00000FFC;\n        masks[3] = 0x00000003;\n        break;\n    default:\n        SDL_SetError(\"Unknown pixel format\");\n        return SDL_FALSE;\n    }\n\n    switch (SDL_PIXELORDER(format)) {\n    case SDL_PACKEDORDER_XRGB:\n        *Rmask = masks[1];\n        *Gmask = masks[2];\n        *Bmask = masks[3];\n        break;\n    case SDL_PACKEDORDER_RGBX:\n        *Rmask = masks[0];\n        *Gmask = masks[1];\n        *Bmask = masks[2];\n        break;\n    case SDL_PACKEDORDER_ARGB:\n        *Amask = masks[0];\n        *Rmask = masks[1];\n        *Gmask = masks[2];\n        *Bmask = masks[3];\n        break;\n    case SDL_PACKEDORDER_RGBA:\n        *Rmask = masks[0];\n        *Gmask = masks[1];\n        *Bmask = masks[2];\n        *Amask = masks[3];\n        break;\n    case SDL_PACKEDORDER_XBGR:\n        *Bmask = masks[1];\n        *Gmask = masks[2];\n        *Rmask = masks[3];\n        break;\n    case SDL_PACKEDORDER_BGRX:\n        *Bmask = masks[0];\n        *Gmask = masks[1];\n        *Rmask = masks[2];\n        break;\n    case SDL_PACKEDORDER_BGRA:\n        *Bmask = masks[0];\n        *Gmask = masks[1];\n        *Rmask = masks[2];\n        *Amask = masks[3];\n        break;\n    case SDL_PACKEDORDER_ABGR:\n        *Amask = masks[0];\n        *Bmask = masks[1];\n        *Gmask = masks[2];\n        *Rmask = masks[3];\n        break;\n    default:\n        SDL_SetError(\"Unknown pixel format\");\n        return SDL_FALSE;\n    }\n    return SDL_TRUE;\n}\n\nUint32\nSDL_MasksToPixelFormatEnum(int bpp, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask,\n                           Uint32 Amask)\n{\n    switch (bpp) {\n    case 1:\n        /* SDL defaults to MSB ordering */\n        return SDL_PIXELFORMAT_INDEX1MSB;\n    case 4:\n        /* SDL defaults to MSB ordering */\n        return SDL_PIXELFORMAT_INDEX4MSB;\n    case 8:\n        if (Rmask == 0) {\n            return SDL_PIXELFORMAT_INDEX8;\n        }\n        if (Rmask == 0xE0 &&\n            Gmask == 0x1C &&\n            Bmask == 0x03 &&\n            Amask == 0x00) {\n            return SDL_PIXELFORMAT_RGB332;\n        }\n        break;\n    case 12:\n        if (Rmask == 0) {\n            return SDL_PIXELFORMAT_RGB444;\n        }\n        if (Rmask == 0x0F00 &&\n            Gmask == 0x00F0 &&\n            Bmask == 0x000F &&\n            Amask == 0x0000) {\n            return SDL_PIXELFORMAT_RGB444;\n        }\n        break;\n    case 15:\n        if (Rmask == 0) {\n            return SDL_PIXELFORMAT_RGB555;\n        }\n        /* Fall through to 16-bit checks */\n    case 16:\n        if (Rmask == 0) {\n            return SDL_PIXELFORMAT_RGB565;\n        }\n        if (Rmask == 0x7C00 &&\n            Gmask == 0x03E0 &&\n            Bmask == 0x001F &&\n            Amask == 0x0000) {\n            return SDL_PIXELFORMAT_RGB555;\n        }\n        if (Rmask == 0x001F &&\n            Gmask == 0x03E0 &&\n            Bmask == 0x7C00 &&\n            Amask == 0x0000) {\n            return SDL_PIXELFORMAT_BGR555;\n        }\n        if (Rmask == 0x0F00 &&\n            Gmask == 0x00F0 &&\n            Bmask == 0x000F &&\n            Amask == 0xF000) {\n            return SDL_PIXELFORMAT_ARGB4444;\n        }\n        if (Rmask == 0xF000 &&\n            Gmask == 0x0F00 &&\n            Bmask == 0x00F0 &&\n            Amask == 0x000F) {\n            return SDL_PIXELFORMAT_RGBA4444;\n        }\n        if (Rmask == 0x000F &&\n            Gmask == 0x00F0 &&\n            Bmask == 0x0F00 &&\n            Amask == 0xF000) {\n            return SDL_PIXELFORMAT_ABGR4444;\n        }\n        if (Rmask == 0x00F0 &&\n            Gmask == 0x0F00 &&\n            Bmask == 0xF000 &&\n            Amask == 0x000F) {\n            return SDL_PIXELFORMAT_BGRA4444;\n        }\n        if (Rmask == 0x7C00 &&\n            Gmask == 0x03E0 &&\n            Bmask == 0x001F &&\n            Amask == 0x8000) {\n            return SDL_PIXELFORMAT_ARGB1555;\n        }\n        if (Rmask == 0xF800 &&\n            Gmask == 0x07C0 &&\n            Bmask == 0x003E &&\n            Amask == 0x0001) {\n            return SDL_PIXELFORMAT_RGBA5551;\n        }\n        if (Rmask == 0x001F &&\n            Gmask == 0x03E0 &&\n            Bmask == 0x7C00 &&\n            Amask == 0x8000) {\n            return SDL_PIXELFORMAT_ABGR1555;\n        }\n        if (Rmask == 0x003E &&\n            Gmask == 0x07C0 &&\n            Bmask == 0xF800 &&\n            Amask == 0x0001) {\n            return SDL_PIXELFORMAT_BGRA5551;\n        }\n        if (Rmask == 0xF800 &&\n            Gmask == 0x07E0 &&\n            Bmask == 0x001F &&\n            Amask == 0x0000) {\n            return SDL_PIXELFORMAT_RGB565;\n        }\n        if (Rmask == 0x001F &&\n            Gmask == 0x07E0 &&\n            Bmask == 0xF800 &&\n            Amask == 0x0000) {\n            return SDL_PIXELFORMAT_BGR565;\n        }\n        break;\n    case 24:\n        switch (Rmask) {\n        case 0:\n        case 0x00FF0000:\n#if SDL_BYTEORDER == SDL_BIG_ENDIAN\n            return SDL_PIXELFORMAT_RGB24;\n#else\n            return SDL_PIXELFORMAT_BGR24;\n#endif\n        case 0x000000FF:\n#if SDL_BYTEORDER == SDL_BIG_ENDIAN\n            return SDL_PIXELFORMAT_BGR24;\n#else\n            return SDL_PIXELFORMAT_RGB24;\n#endif\n        }\n    case 32:\n        if (Rmask == 0) {\n            return SDL_PIXELFORMAT_RGB888;\n        }\n        if (Rmask == 0x00FF0000 &&\n            Gmask == 0x0000FF00 &&\n            Bmask == 0x000000FF &&\n            Amask == 0x00000000) {\n            return SDL_PIXELFORMAT_RGB888;\n        }\n        if (Rmask == 0xFF000000 &&\n            Gmask == 0x00FF0000 &&\n            Bmask == 0x0000FF00 &&\n            Amask == 0x00000000) {\n            return SDL_PIXELFORMAT_RGBX8888;\n        }\n        if (Rmask == 0x000000FF &&\n            Gmask == 0x0000FF00 &&\n            Bmask == 0x00FF0000 &&\n            Amask == 0x00000000) {\n            return SDL_PIXELFORMAT_BGR888;\n        }\n        if (Rmask == 0x0000FF00 &&\n            Gmask == 0x00FF0000 &&\n            Bmask == 0xFF000000 &&\n            Amask == 0x00000000) {\n            return SDL_PIXELFORMAT_BGRX8888;\n        }\n        if (Rmask == 0x00FF0000 &&\n            Gmask == 0x0000FF00 &&\n            Bmask == 0x000000FF &&\n            Amask == 0xFF000000) {\n            return SDL_PIXELFORMAT_ARGB8888;\n        }\n        if (Rmask == 0xFF000000 &&\n            Gmask == 0x00FF0000 &&\n            Bmask == 0x0000FF00 &&\n            Amask == 0x000000FF) {\n            return SDL_PIXELFORMAT_RGBA8888;\n        }\n        if (Rmask == 0x000000FF &&\n            Gmask == 0x0000FF00 &&\n            Bmask == 0x00FF0000 &&\n            Amask == 0xFF000000) {\n            return SDL_PIXELFORMAT_ABGR8888;\n        }\n        if (Rmask == 0x0000FF00 &&\n            Gmask == 0x00FF0000 &&\n            Bmask == 0xFF000000 &&\n            Amask == 0x000000FF) {\n            return SDL_PIXELFORMAT_BGRA8888;\n        }\n        if (Rmask == 0x3FF00000 &&\n            Gmask == 0x000FFC00 &&\n            Bmask == 0x000003FF &&\n            Amask == 0xC0000000) {\n            return SDL_PIXELFORMAT_ARGB2101010;\n        }\n    }\n    return SDL_PIXELFORMAT_UNKNOWN;\n}\n\nstatic SDL_PixelFormat *formats;\n\nSDL_PixelFormat *\nSDL_AllocFormat(Uint32 pixel_format)\n{\n    SDL_PixelFormat *format;\n\n    /* Look it up in our list of previously allocated formats */\n    for (format = formats; format; format = format->next) {\n        if (pixel_format == format->format) {\n            ++format->refcount;\n            return format;\n        }\n    }\n\n    /* Allocate an empty pixel format structure, and initialize it */\n    format = SDL_malloc(sizeof(*format));\n    if (format == NULL) {\n        SDL_OutOfMemory();\n        return NULL;\n    }\n    if (SDL_InitFormat(format, pixel_format) < 0) {\n        SDL_free(format);\n        SDL_InvalidParamError(\"format\");\n        return NULL;\n    }\n\n    if (!SDL_ISPIXELFORMAT_INDEXED(pixel_format)) {\n        /* Cache the RGB formats */\n        format->next = formats;\n        formats = format;\n    }\n    return format;\n}\n\nint\nSDL_InitFormat(SDL_PixelFormat * format, Uint32 pixel_format)\n{\n    int bpp;\n    Uint32 Rmask, Gmask, Bmask, Amask;\n    Uint32 mask;\n\n    if (!SDL_PixelFormatEnumToMasks(pixel_format, &bpp,\n                                    &Rmask, &Gmask, &Bmask, &Amask)) {\n        return -1;\n    }\n\n    /* Set up the format */\n    SDL_zerop(format);\n    format->format = pixel_format;\n    format->BitsPerPixel = bpp;\n    format->BytesPerPixel = (bpp + 7) / 8;\n\n    format->Rmask = Rmask;\n    format->Rshift = 0;\n    format->Rloss = 8;\n    if (Rmask) {\n        for (mask = Rmask; !(mask & 0x01); mask >>= 1)\n            ++format->Rshift;\n        for (; (mask & 0x01); mask >>= 1)\n            --format->Rloss;\n    }\n\n    format->Gmask = Gmask;\n    format->Gshift = 0;\n    format->Gloss = 8;\n    if (Gmask) {\n        for (mask = Gmask; !(mask & 0x01); mask >>= 1)\n            ++format->Gshift;\n        for (; (mask & 0x01); mask >>= 1)\n            --format->Gloss;\n    }\n\n    format->Bmask = Bmask;\n    format->Bshift = 0;\n    format->Bloss = 8;\n    if (Bmask) {\n        for (mask = Bmask; !(mask & 0x01); mask >>= 1)\n            ++format->Bshift;\n        for (; (mask & 0x01); mask >>= 1)\n            --format->Bloss;\n    }\n\n    format->Amask = Amask;\n    format->Ashift = 0;\n    format->Aloss = 8;\n    if (Amask) {\n        for (mask = Amask; !(mask & 0x01); mask >>= 1)\n            ++format->Ashift;\n        for (; (mask & 0x01); mask >>= 1)\n            --format->Aloss;\n    }\n\n    format->palette = NULL;\n    format->refcount = 1;\n    format->next = NULL;\n\n    return 0;\n}\n\nvoid\nSDL_FreeFormat(SDL_PixelFormat *format)\n{\n    SDL_PixelFormat *prev;\n\n    if (!format) {\n        SDL_InvalidParamError(\"format\");\n        return;\n    }\n    if (--format->refcount > 0) {\n        return;\n    }\n\n    /* Remove this format from our list */\n    if (format == formats) {\n        formats = format->next;\n    } else if (formats) {\n        for (prev = formats; prev->next; prev = prev->next) {\n            if (prev->next == format) {\n                prev->next = format->next;\n                break;\n            }\n        }\n    }\n\n    if (format->palette) {\n        SDL_FreePalette(format->palette);\n    }\n    SDL_free(format);\n}\n\nSDL_Palette *\nSDL_AllocPalette(int ncolors)\n{\n    SDL_Palette *palette;\n\n    /* Input validation */\n    if (ncolors < 1) {\n      SDL_InvalidParamError(\"ncolors\");\n      return NULL;\n    }\n\n    palette = (SDL_Palette *) SDL_malloc(sizeof(*palette));\n    if (!palette) {\n        SDL_OutOfMemory();\n        return NULL;\n    }\n    palette->colors =\n        (SDL_Color *) SDL_malloc(ncolors * sizeof(*palette->colors));\n    if (!palette->colors) {\n        SDL_free(palette);\n        return NULL;\n    }\n    palette->ncolors = ncolors;\n    palette->version = 1;\n    palette->refcount = 1;\n\n    SDL_memset(palette->colors, 0xFF, ncolors * sizeof(*palette->colors));\n\n    return palette;\n}\n\nint\nSDL_SetPixelFormatPalette(SDL_PixelFormat * format, SDL_Palette *palette)\n{\n    if (!format) {\n        return SDL_SetError(\"SDL_SetPixelFormatPalette() passed NULL format\");\n    }\n\n    if (palette && palette->ncolors != (1 << format->BitsPerPixel)) {\n        return SDL_SetError(\"SDL_SetPixelFormatPalette() passed a palette that doesn't match the format\");\n    }\n\n    if (format->palette == palette) {\n        return 0;\n    }\n\n    if (format->palette) {\n        SDL_FreePalette(format->palette);\n    }\n\n    format->palette = palette;\n\n    if (format->palette) {\n        ++format->palette->refcount;\n    }\n\n    return 0;\n}\n\nint\nSDL_SetPaletteColors(SDL_Palette * palette, const SDL_Color * colors,\n                     int firstcolor, int ncolors)\n{\n    int status = 0;\n\n    /* Verify the parameters */\n    if (!palette) {\n        return -1;\n    }\n    if (ncolors > (palette->ncolors - firstcolor)) {\n        ncolors = (palette->ncolors - firstcolor);\n        status = -1;\n    }\n\n    if (colors != (palette->colors + firstcolor)) {\n        SDL_memcpy(palette->colors + firstcolor, colors,\n                   ncolors * sizeof(*colors));\n    }\n    ++palette->version;\n    if (!palette->version) {\n        palette->version = 1;\n    }\n\n    return status;\n}\n\nvoid\nSDL_FreePalette(SDL_Palette * palette)\n{\n    if (!palette) {\n        SDL_InvalidParamError(\"palette\");\n        return;\n    }\n    if (--palette->refcount > 0) {\n        return;\n    }\n    SDL_free(palette->colors);\n    SDL_free(palette);\n}\n\n/*\n * Calculate an 8-bit (3 red, 3 green, 2 blue) dithered palette of colors\n */\nvoid\nSDL_DitherColors(SDL_Color * colors, int bpp)\n{\n    int i;\n    if (bpp != 8)\n        return;                 /* only 8bpp supported right now */\n\n    for (i = 0; i < 256; i++) {\n        int r, g, b;\n        /* map each bit field to the full [0, 255] interval,\n           so 0 is mapped to (0, 0, 0) and 255 to (255, 255, 255) */\n        r = i & 0xe0;\n        r |= r >> 3 | r >> 6;\n        colors[i].r = r;\n        g = (i << 3) & 0xe0;\n        g |= g >> 3 | g >> 6;\n        colors[i].g = g;\n        b = i & 0x3;\n        b |= b << 2;\n        b |= b << 4;\n        colors[i].b = b;\n        colors[i].a = SDL_ALPHA_OPAQUE;\n    }\n}\n\n/*\n * Calculate the pad-aligned scanline width of a surface\n */\nint\nSDL_CalculatePitch(SDL_Surface * surface)\n{\n    int pitch;\n\n    /* Surface should be 4-byte aligned for speed */\n    pitch = surface->w * surface->format->BytesPerPixel;\n    switch (surface->format->BitsPerPixel) {\n    case 1:\n        pitch = (pitch + 7) / 8;\n        break;\n    case 4:\n        pitch = (pitch + 1) / 2;\n        break;\n    default:\n        break;\n    }\n    pitch = (pitch + 3) & ~3;   /* 4-byte aligning */\n    return (pitch);\n}\n\n/*\n * Match an RGB value to a particular palette index\n */\nUint8\nSDL_FindColor(SDL_Palette * pal, Uint8 r, Uint8 g, Uint8 b, Uint8 a)\n{\n    /* Do colorspace distance matching */\n    unsigned int smallest;\n    unsigned int distance;\n    int rd, gd, bd, ad;\n    int i;\n    Uint8 pixel = 0;\n\n    smallest = ~0;\n    for (i = 0; i < pal->ncolors; ++i) {\n        rd = pal->colors[i].r - r;\n        gd = pal->colors[i].g - g;\n        bd = pal->colors[i].b - b;\n        ad = pal->colors[i].a - a;\n        distance = (rd * rd) + (gd * gd) + (bd * bd) + (ad * ad);\n        if (distance < smallest) {\n            pixel = i;\n            if (distance == 0) {        /* Perfect match! */\n                break;\n            }\n            smallest = distance;\n        }\n    }\n    return (pixel);\n}\n\n/* Find the opaque pixel value corresponding to an RGB triple */\nUint32\nSDL_MapRGB(const SDL_PixelFormat * format, Uint8 r, Uint8 g, Uint8 b)\n{\n    if (format->palette == NULL) {\n        return (r >> format->Rloss) << format->Rshift\n            | (g >> format->Gloss) << format->Gshift\n            | (b >> format->Bloss) << format->Bshift | format->Amask;\n    } else {\n        return SDL_FindColor(format->palette, r, g, b, SDL_ALPHA_OPAQUE);\n    }\n}\n\n/* Find the pixel value corresponding to an RGBA quadruple */\nUint32\nSDL_MapRGBA(const SDL_PixelFormat * format, Uint8 r, Uint8 g, Uint8 b,\n            Uint8 a)\n{\n    if (format->palette == NULL) {\n        return (r >> format->Rloss) << format->Rshift\n            | (g >> format->Gloss) << format->Gshift\n            | (b >> format->Bloss) << format->Bshift\n            | ((a >> format->Aloss) << format->Ashift & format->Amask);\n    } else {\n        return SDL_FindColor(format->palette, r, g, b, a);\n    }\n}\n\nvoid\nSDL_GetRGB(Uint32 pixel, const SDL_PixelFormat * format, Uint8 * r, Uint8 * g,\n           Uint8 * b)\n{\n    if (format->palette == NULL) {\n        unsigned v;\n        v = (pixel & format->Rmask) >> format->Rshift;\n        *r = SDL_expand_byte[format->Rloss][v];\n        v = (pixel & format->Gmask) >> format->Gshift;\n        *g = SDL_expand_byte[format->Gloss][v];\n        v = (pixel & format->Bmask) >> format->Bshift;\n        *b = SDL_expand_byte[format->Bloss][v];\n    } else {\n        if (pixel < (unsigned)format->palette->ncolors) {\n            *r = format->palette->colors[pixel].r;\n            *g = format->palette->colors[pixel].g;\n            *b = format->palette->colors[pixel].b;\n        } else {\n            *r = *g = *b = 0;\n        }\n    }\n}\n\nvoid\nSDL_GetRGBA(Uint32 pixel, const SDL_PixelFormat * format,\n            Uint8 * r, Uint8 * g, Uint8 * b, Uint8 * a)\n{\n    if (format->palette == NULL) {\n        unsigned v;\n        v = (pixel & format->Rmask) >> format->Rshift;\n        *r = SDL_expand_byte[format->Rloss][v];\n        v = (pixel & format->Gmask) >> format->Gshift;\n        *g = SDL_expand_byte[format->Gloss][v];\n        v = (pixel & format->Bmask) >> format->Bshift;\n        *b = SDL_expand_byte[format->Bloss][v];\n        v = (pixel & format->Amask) >> format->Ashift;\n        *a = SDL_expand_byte[format->Aloss][v];\n    } else {\n        if (pixel < (unsigned)format->palette->ncolors) {\n            *r = format->palette->colors[pixel].r;\n            *g = format->palette->colors[pixel].g;\n            *b = format->palette->colors[pixel].b;\n            *a = format->palette->colors[pixel].a;\n        } else {\n            *r = *g = *b = *a = 0;\n        }\n    }\n}\n\n/* Map from Palette to Palette */\nstatic Uint8 *\nMap1to1(SDL_Palette * src, SDL_Palette * dst, int *identical)\n{\n    Uint8 *map;\n    int i;\n\n    if (identical) {\n        if (src->ncolors <= dst->ncolors) {\n            /* If an identical palette, no need to map */\n            if (src == dst\n                ||\n                (SDL_memcmp\n                 (src->colors, dst->colors,\n                  src->ncolors * sizeof(SDL_Color)) == 0)) {\n                *identical = 1;\n                return (NULL);\n            }\n        }\n        *identical = 0;\n    }\n    map = (Uint8 *) SDL_malloc(src->ncolors);\n    if (map == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n    for (i = 0; i < src->ncolors; ++i) {\n        map[i] = SDL_FindColor(dst,\n                               src->colors[i].r, src->colors[i].g,\n                               src->colors[i].b, src->colors[i].a);\n    }\n    return (map);\n}\n\n/* Map from Palette to BitField */\nstatic Uint8 *\nMap1toN(SDL_PixelFormat * src, Uint8 Rmod, Uint8 Gmod, Uint8 Bmod, Uint8 Amod,\n        SDL_PixelFormat * dst)\n{\n    Uint8 *map;\n    int i;\n    int bpp;\n    SDL_Palette *pal = src->palette;\n\n    bpp = ((dst->BytesPerPixel == 3) ? 4 : dst->BytesPerPixel);\n    map = (Uint8 *) SDL_malloc(pal->ncolors * bpp);\n    if (map == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n\n    /* We memory copy to the pixel map so the endianness is preserved */\n    for (i = 0; i < pal->ncolors; ++i) {\n        Uint8 R = (Uint8) ((pal->colors[i].r * Rmod) / 255);\n        Uint8 G = (Uint8) ((pal->colors[i].g * Gmod) / 255);\n        Uint8 B = (Uint8) ((pal->colors[i].b * Bmod) / 255);\n        Uint8 A = (Uint8) ((pal->colors[i].a * Amod) / 255);\n        ASSEMBLE_RGBA(&map[i * bpp], dst->BytesPerPixel, dst, R, G, B, A);\n    }\n    return (map);\n}\n\n/* Map from BitField to Dithered-Palette to Palette */\nstatic Uint8 *\nMapNto1(SDL_PixelFormat * src, SDL_PixelFormat * dst, int *identical)\n{\n    /* Generate a 256 color dither palette */\n    SDL_Palette dithered;\n    SDL_Color colors[256];\n    SDL_Palette *pal = dst->palette;\n\n    dithered.ncolors = 256;\n    SDL_DitherColors(colors, 8);\n    dithered.colors = colors;\n    return (Map1to1(&dithered, pal, identical));\n}\n\nSDL_BlitMap *\nSDL_AllocBlitMap(void)\n{\n    SDL_BlitMap *map;\n\n    /* Allocate the empty map */\n    map = (SDL_BlitMap *) SDL_calloc(1, sizeof(*map));\n    if (map == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n    map->info.r = 0xFF;\n    map->info.g = 0xFF;\n    map->info.b = 0xFF;\n    map->info.a = 0xFF;\n\n    /* It's ready to go */\n    return (map);\n}\n\nvoid\nSDL_InvalidateMap(SDL_BlitMap * map)\n{\n    if (!map) {\n        return;\n    }\n    if (map->dst) {\n        /* Release our reference to the surface - see the note below */\n        if (--map->dst->refcount <= 0) {\n            SDL_FreeSurface(map->dst);\n        }\n    }\n    map->dst = NULL;\n    map->src_palette_version = 0;\n    map->dst_palette_version = 0;\n    SDL_free(map->info.table);\n    map->info.table = NULL;\n}\n\nint\nSDL_MapSurface(SDL_Surface * src, SDL_Surface * dst)\n{\n    SDL_PixelFormat *srcfmt;\n    SDL_PixelFormat *dstfmt;\n    SDL_BlitMap *map;\n\n    /* Clear out any previous mapping */\n    map = src->map;\n    if ((src->flags & SDL_RLEACCEL) == SDL_RLEACCEL) {\n        SDL_UnRLESurface(src, 1);\n    }\n    SDL_InvalidateMap(map);\n\n    /* Figure out what kind of mapping we're doing */\n    map->identity = 0;\n    srcfmt = src->format;\n    dstfmt = dst->format;\n    if (SDL_ISPIXELFORMAT_INDEXED(srcfmt->format)) {\n        if (SDL_ISPIXELFORMAT_INDEXED(dstfmt->format)) {\n            /* Palette --> Palette */\n            map->info.table =\n                Map1to1(srcfmt->palette, dstfmt->palette, &map->identity);\n            if (!map->identity) {\n                if (map->info.table == NULL) {\n                    return (-1);\n                }\n            }\n            if (srcfmt->BitsPerPixel != dstfmt->BitsPerPixel)\n                map->identity = 0;\n        } else {\n            /* Palette --> BitField */\n            map->info.table =\n                Map1toN(srcfmt, src->map->info.r, src->map->info.g,\n                        src->map->info.b, src->map->info.a, dstfmt);\n            if (map->info.table == NULL) {\n                return (-1);\n            }\n        }\n    } else {\n        if (SDL_ISPIXELFORMAT_INDEXED(dstfmt->format)) {\n            /* BitField --> Palette */\n            map->info.table = MapNto1(srcfmt, dstfmt, &map->identity);\n            if (!map->identity) {\n                if (map->info.table == NULL) {\n                    return (-1);\n                }\n            }\n            map->identity = 0;  /* Don't optimize to copy */\n        } else {\n            /* BitField --> BitField */\n            if (srcfmt == dstfmt) {\n                map->identity = 1;\n            }\n        }\n    }\n\n    map->dst = dst;\n\n    if (map->dst) {\n        /* Keep a reference to this surface so it doesn't get deleted\n           while we're still pointing at it.\n\n           A better method would be for the destination surface to keep\n           track of surfaces that are mapped to it and automatically\n           invalidate them when it is freed, but this will do for now.\n        */\n        ++map->dst->refcount;\n    }\n\n    if (dstfmt->palette) {\n        map->dst_palette_version = dstfmt->palette->version;\n    } else {\n        map->dst_palette_version = 0;\n    }\n\n    if (srcfmt->palette) {\n        map->src_palette_version = srcfmt->palette->version;\n    } else {\n        map->src_palette_version = 0;\n    }\n\n    /* Choose your blitters wisely */\n    return (SDL_CalculateBlit(src));\n}\n\nvoid\nSDL_FreeBlitMap(SDL_BlitMap * map)\n{\n    if (map) {\n        SDL_InvalidateMap(map);\n        SDL_free(map);\n    }\n}\n\nvoid\nSDL_CalculateGammaRamp(float gamma, Uint16 * ramp)\n{\n    int i;\n\n    /* Input validation */\n    if (gamma < 0.0f ) {\n      SDL_InvalidParamError(\"gamma\");\n      return;\n    }\n    if (ramp == NULL) {\n      SDL_InvalidParamError(\"ramp\");\n      return;\n    }\n\n    /* 0.0 gamma is all black */\n    if (gamma == 0.0f) {\n        for (i = 0; i < 256; ++i) {\n            ramp[i] = 0;\n        }\n        return;\n    } else if (gamma == 1.0f) {\n        /* 1.0 gamma is identity */\n        for (i = 0; i < 256; ++i) {\n            ramp[i] = (i << 8) | i;\n        }\n        return;\n    } else {\n        /* Calculate a real gamma ramp */\n        int value;\n        gamma = 1.0f / gamma;\n        for (i = 0; i < 256; ++i) {\n            value =\n                (int) (SDL_pow((double) i / 256.0, gamma) * 65535.0 + 0.5);\n            if (value > 65535) {\n                value = 65535;\n            }\n            ramp[i] = (Uint16) value;\n        }\n    }\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../SDL_internal.h\"\n\n#include \"SDL_rect.h\"\n#include \"SDL_rect_c.h\"\n\n\nSDL_bool\nSDL_HasIntersection(const SDL_Rect * A, const SDL_Rect * B)\n{\n    int Amin, Amax, Bmin, Bmax;\n\n    if (!A) {\n        SDL_InvalidParamError(\"A\");\n        return SDL_FALSE;\n    }\n\n    if (!B) {\n        SDL_InvalidParamError(\"B\");\n        return SDL_FALSE;\n    }\n\n    /* Special cases for empty rects */\n    if (SDL_RectEmpty(A) || SDL_RectEmpty(B)) {\n        return SDL_FALSE;\n    }\n\n    /* Horizontal intersection */\n    Amin = A->x;\n    Amax = Amin + A->w;\n    Bmin = B->x;\n    Bmax = Bmin + B->w;\n    if (Bmin > Amin)\n        Amin = Bmin;\n    if (Bmax < Amax)\n        Amax = Bmax;\n    if (Amax <= Amin)\n        return SDL_FALSE;\n\n    /* Vertical intersection */\n    Amin = A->y;\n    Amax = Amin + A->h;\n    Bmin = B->y;\n    Bmax = Bmin + B->h;\n    if (Bmin > Amin)\n        Amin = Bmin;\n    if (Bmax < Amax)\n        Amax = Bmax;\n    if (Amax <= Amin)\n        return SDL_FALSE;\n\n    return SDL_TRUE;\n}\n\nSDL_bool\nSDL_IntersectRect(const SDL_Rect * A, const SDL_Rect * B, SDL_Rect * result)\n{\n    int Amin, Amax, Bmin, Bmax;\n\n    if (!A) {\n        SDL_InvalidParamError(\"A\");\n        return SDL_FALSE;\n    }\n\n    if (!B) {\n        SDL_InvalidParamError(\"B\");\n        return SDL_FALSE;\n    }\n\n    if (!result) {\n        SDL_InvalidParamError(\"result\");\n        return SDL_FALSE;\n    }\n\n    /* Special cases for empty rects */\n    if (SDL_RectEmpty(A) || SDL_RectEmpty(B)) {\n        result->w = 0;\n        result->h = 0;\n        return SDL_FALSE;\n    }\n\n    /* Horizontal intersection */\n    Amin = A->x;\n    Amax = Amin + A->w;\n    Bmin = B->x;\n    Bmax = Bmin + B->w;\n    if (Bmin > Amin)\n        Amin = Bmin;\n    result->x = Amin;\n    if (Bmax < Amax)\n        Amax = Bmax;\n    result->w = Amax - Amin;\n\n    /* Vertical intersection */\n    Amin = A->y;\n    Amax = Amin + A->h;\n    Bmin = B->y;\n    Bmax = Bmin + B->h;\n    if (Bmin > Amin)\n        Amin = Bmin;\n    result->y = Amin;\n    if (Bmax < Amax)\n        Amax = Bmax;\n    result->h = Amax - Amin;\n\n    return !SDL_RectEmpty(result);\n}\n\nvoid\nSDL_UnionRect(const SDL_Rect * A, const SDL_Rect * B, SDL_Rect * result)\n{\n    int Amin, Amax, Bmin, Bmax;\n\n    if (!A) {\n        SDL_InvalidParamError(\"A\");\n        return;\n    }\n\n    if (!B) {\n        SDL_InvalidParamError(\"B\");\n        return;\n    }\n\n    if (!result) {\n        SDL_InvalidParamError(\"result\");\n        return;\n    }\n\n    /* Special cases for empty Rects */\n    if (SDL_RectEmpty(A)) {\n      if (SDL_RectEmpty(B)) {\n       /* A and B empty */\n       return;\n      } else {\n       /* A empty, B not empty */\n       *result = *B;\n       return;\n      }\n    } else {\n      if (SDL_RectEmpty(B)) {\n       /* A not empty, B empty */\n       *result = *A;\n       return;\n      }\n    }\n\n    /* Horizontal union */\n    Amin = A->x;\n    Amax = Amin + A->w;\n    Bmin = B->x;\n    Bmax = Bmin + B->w;\n    if (Bmin < Amin)\n        Amin = Bmin;\n    result->x = Amin;\n    if (Bmax > Amax)\n        Amax = Bmax;\n    result->w = Amax - Amin;\n\n    /* Vertical union */\n    Amin = A->y;\n    Amax = Amin + A->h;\n    Bmin = B->y;\n    Bmax = Bmin + B->h;\n    if (Bmin < Amin)\n        Amin = Bmin;\n    result->y = Amin;\n    if (Bmax > Amax)\n        Amax = Bmax;\n    result->h = Amax - Amin;\n}\n\nSDL_bool\nSDL_EnclosePoints(const SDL_Point * points, int count, const SDL_Rect * clip,\n                  SDL_Rect * result)\n{\n    int minx = 0;\n    int miny = 0;\n    int maxx = 0;\n    int maxy = 0;\n    int x, y, i;\n\n    if (!points) {\n        SDL_InvalidParamError(\"points\");\n        return SDL_FALSE;\n    }\n\n    if (count < 1) {\n        SDL_InvalidParamError(\"count\");\n        return SDL_FALSE;\n    }\n\n    if (clip) {\n        SDL_bool added = SDL_FALSE;\n        const int clip_minx = clip->x;\n        const int clip_miny = clip->y;\n        const int clip_maxx = clip->x+clip->w-1;\n        const int clip_maxy = clip->y+clip->h-1;\n\n        /* Special case for empty rectangle */\n        if (SDL_RectEmpty(clip)) {\n            return SDL_FALSE;\n        }\n\n        for (i = 0; i < count; ++i) {\n            x = points[i].x;\n            y = points[i].y;\n\n            if (x < clip_minx || x > clip_maxx ||\n                y < clip_miny || y > clip_maxy) {\n                continue;\n            }\n            if (!added) {\n                /* Special case: if no result was requested, we are done */\n                if (result == NULL) {\n                    return SDL_TRUE;\n                }\n\n                /* First point added */\n                minx = maxx = x;\n                miny = maxy = y;\n                added = SDL_TRUE;\n                continue;\n            }\n            if (x < minx) {\n                minx = x;\n            } else if (x > maxx) {\n                maxx = x;\n            }\n            if (y < miny) {\n                miny = y;\n            } else if (y > maxy) {\n                maxy = y;\n            }\n        }\n        if (!added) {\n            return SDL_FALSE;\n        }\n    } else {\n        /* Special case: if no result was requested, we are done */\n        if (result == NULL) {\n            return SDL_TRUE;\n        }\n\n        /* No clipping, always add the first point */\n        minx = maxx = points[0].x;\n        miny = maxy = points[0].y;\n\n        for (i = 1; i < count; ++i) {\n            x = points[i].x;\n            y = points[i].y;\n\n            if (x < minx) {\n                minx = x;\n            } else if (x > maxx) {\n                maxx = x;\n            }\n            if (y < miny) {\n                miny = y;\n            } else if (y > maxy) {\n                maxy = y;\n            }\n        }\n    }\n\n    if (result) {\n        result->x = minx;\n        result->y = miny;\n        result->w = (maxx-minx)+1;\n        result->h = (maxy-miny)+1;\n    }\n    return SDL_TRUE;\n}\n\n/* Use the Cohen-Sutherland algorithm for line clipping */\n#define CODE_BOTTOM 1\n#define CODE_TOP    2\n#define CODE_LEFT   4\n#define CODE_RIGHT  8\n\nstatic int\nComputeOutCode(const SDL_Rect * rect, int x, int y)\n{\n    int code = 0;\n    if (y < rect->y) {\n        code |= CODE_TOP;\n    } else if (y >= rect->y + rect->h) {\n        code |= CODE_BOTTOM;\n    }\n    if (x < rect->x) {\n        code |= CODE_LEFT;\n    } else if (x >= rect->x + rect->w) {\n        code |= CODE_RIGHT;\n    }\n    return code;\n}\n\nSDL_bool\nSDL_IntersectRectAndLine(const SDL_Rect * rect, int *X1, int *Y1, int *X2,\n                         int *Y2)\n{\n    int x = 0;\n    int y = 0;\n    int x1, y1;\n    int x2, y2;\n    int rectx1;\n    int recty1;\n    int rectx2;\n    int recty2;\n    int outcode1, outcode2;\n\n    if (!rect) {\n        SDL_InvalidParamError(\"rect\");\n        return SDL_FALSE;\n    }\n\n    if (!X1) {\n        SDL_InvalidParamError(\"X1\");\n        return SDL_FALSE;\n    }\n\n    if (!Y1) {\n        SDL_InvalidParamError(\"Y1\");\n        return SDL_FALSE;\n    }\n\n    if (!X2) {\n        SDL_InvalidParamError(\"X2\");\n        return SDL_FALSE;\n    }\n\n    if (!Y2) {\n        SDL_InvalidParamError(\"Y2\");\n        return SDL_FALSE;\n    }\n\n    /* Special case for empty rect */\n    if (SDL_RectEmpty(rect)) {\n        return SDL_FALSE;\n    }\n\n    x1 = *X1;\n    y1 = *Y1;\n    x2 = *X2;\n    y2 = *Y2;\n    rectx1 = rect->x;\n    recty1 = rect->y;\n    rectx2 = rect->x + rect->w - 1;\n    recty2 = rect->y + rect->h - 1;\n\n    /* Check to see if entire line is inside rect */\n    if (x1 >= rectx1 && x1 <= rectx2 && x2 >= rectx1 && x2 <= rectx2 &&\n        y1 >= recty1 && y1 <= recty2 && y2 >= recty1 && y2 <= recty2) {\n        return SDL_TRUE;\n    }\n\n    /* Check to see if entire line is to one side of rect */\n    if ((x1 < rectx1 && x2 < rectx1) || (x1 > rectx2 && x2 > rectx2) ||\n        (y1 < recty1 && y2 < recty1) || (y1 > recty2 && y2 > recty2)) {\n        return SDL_FALSE;\n    }\n\n    if (y1 == y2) {\n        /* Horizontal line, easy to clip */\n        if (x1 < rectx1) {\n            *X1 = rectx1;\n        } else if (x1 > rectx2) {\n            *X1 = rectx2;\n        }\n        if (x2 < rectx1) {\n            *X2 = rectx1;\n        } else if (x2 > rectx2) {\n            *X2 = rectx2;\n        }\n        return SDL_TRUE;\n    }\n\n    if (x1 == x2) {\n        /* Vertical line, easy to clip */\n        if (y1 < recty1) {\n            *Y1 = recty1;\n        } else if (y1 > recty2) {\n            *Y1 = recty2;\n        }\n        if (y2 < recty1) {\n            *Y2 = recty1;\n        } else if (y2 > recty2) {\n            *Y2 = recty2;\n        }\n        return SDL_TRUE;\n    }\n\n    /* More complicated Cohen-Sutherland algorithm */\n    outcode1 = ComputeOutCode(rect, x1, y1);\n    outcode2 = ComputeOutCode(rect, x2, y2);\n    while (outcode1 || outcode2) {\n        if (outcode1 & outcode2) {\n            return SDL_FALSE;\n        }\n\n        if (outcode1) {\n            if (outcode1 & CODE_TOP) {\n                y = recty1;\n                x = x1 + ((x2 - x1) * (y - y1)) / (y2 - y1);\n            } else if (outcode1 & CODE_BOTTOM) {\n                y = recty2;\n                x = x1 + ((x2 - x1) * (y - y1)) / (y2 - y1);\n            } else if (outcode1 & CODE_LEFT) {\n                x = rectx1;\n                y = y1 + ((y2 - y1) * (x - x1)) / (x2 - x1);\n            } else if (outcode1 & CODE_RIGHT) {\n                x = rectx2;\n                y = y1 + ((y2 - y1) * (x - x1)) / (x2 - x1);\n            }\n            x1 = x;\n            y1 = y;\n            outcode1 = ComputeOutCode(rect, x, y);\n        } else {\n            if (outcode2 & CODE_TOP) {\n                y = recty1;\n                x = x1 + ((x2 - x1) * (y - y1)) / (y2 - y1);\n            } else if (outcode2 & CODE_BOTTOM) {\n                y = recty2;\n                x = x1 + ((x2 - x1) * (y - y1)) / (y2 - y1);\n            } else if (outcode2 & CODE_LEFT) {\n                x = rectx1;\n                y = y1 + ((y2 - y1) * (x - x1)) / (x2 - x1);\n            } else if (outcode2 & CODE_RIGHT) {\n                x = rectx2;\n                y = y1 + ((y2 - y1) * (x - x1)) / (x2 - x1);\n            }\n            x2 = x;\n            y2 = y;\n            outcode2 = ComputeOutCode(rect, x, y);\n        }\n    }\n    *X1 = x1;\n    *Y1 = y1;\n    *X2 = x2;\n    *Y2 = y2;\n    return SDL_TRUE;\n}\n\nSDL_bool\nSDL_GetSpanEnclosingRect(int width, int height,\n                         int numrects, const SDL_Rect * rects, SDL_Rect *span)\n{\n    int i;\n    int span_y1, span_y2;\n    int rect_y1, rect_y2;\n\n    if (width < 1) {\n        SDL_InvalidParamError(\"width\");\n        return SDL_FALSE;\n    }\n\n    if (height < 1) {\n        SDL_InvalidParamError(\"height\");\n        return SDL_FALSE;\n    }\n\n    if (!rects) {\n        SDL_InvalidParamError(\"rects\");\n        return SDL_FALSE;\n    }\n\n    if (!span) {\n        SDL_InvalidParamError(\"span\");\n        return SDL_FALSE;\n    }\n\n    if (numrects < 1) {\n        SDL_InvalidParamError(\"numrects\");\n        return SDL_FALSE;\n    }\n\n    /* Initialize to empty rect */\n    span_y1 = height;\n    span_y2 = 0;\n\n    for (i = 0; i < numrects; ++i) {\n        rect_y1 = rects[i].y;\n        rect_y2 = rect_y1 + rects[i].h;\n\n        /* Clip out of bounds rectangles, and expand span rect */\n        if (rect_y1 < 0) {\n            span_y1 = 0;\n        } else if (rect_y1 < span_y1) {\n            span_y1 = rect_y1;\n        }\n        if (rect_y2 > height) {\n            span_y2 = height;\n        } else if (rect_y2 > span_y2) {\n            span_y2 = rect_y2;\n        }\n    }\n    if (span_y2 > span_y1) {\n        span->x = 0;\n        span->y = span_y1;\n        span->w = width;\n        span->h = (span_y2 - span_y1);\n        return SDL_TRUE;\n    }\n    return SDL_FALSE;\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../SDL_internal.h\"\n\n/*\n * RLE encoding for software colorkey and alpha-channel acceleration\n *\n * Original version by Sam Lantinga\n *\n * Mattias Engdegrd (Yorick): Rewrite. New encoding format, encoder and\n * decoder. Added per-surface alpha blitter. Added per-pixel alpha\n * format, encoder and blitter.\n *\n * Many thanks to Xark and johns for hints, benchmarks and useful comments\n * leading to this code.\n *\n * Welcome to Macro Mayhem.\n */\n\n/*\n * The encoding translates the image data to a stream of segments of the form\n *\n * <skip> <run> <data>\n *\n * where <skip> is the number of transparent pixels to skip,\n *       <run>  is the number of opaque pixels to blit,\n * and   <data> are the pixels themselves.\n *\n * This basic structure is used both for colorkeyed surfaces, used for simple\n * binary transparency and for per-surface alpha blending, and for surfaces\n * with per-pixel alpha. The details differ, however:\n *\n * Encoding of colorkeyed surfaces:\n *\n *   Encoded pixels always have the same format as the target surface.\n *   <skip> and <run> are unsigned 8 bit integers, except for 32 bit depth\n *   where they are 16 bit. This makes the pixel data aligned at all times.\n *   Segments never wrap around from one scan line to the next.\n *\n *   The end of the sequence is marked by a zero <skip>,<run> pair at the *\n *   beginning of a line.\n *\n * Encoding of surfaces with per-pixel alpha:\n *\n *   The sequence begins with a struct RLEDestFormat describing the target\n *   pixel format, to provide reliable un-encoding.\n *\n *   Each scan line is encoded twice: First all completely opaque pixels,\n *   encoded in the target format as described above, and then all\n *   partially transparent (translucent) pixels (where 1 <= alpha <= 254),\n *   in the following 32-bit format:\n *\n *   For 32-bit targets, each pixel has the target RGB format but with\n *   the alpha value occupying the highest 8 bits. The <skip> and <run>\n *   counts are 16 bit.\n *\n *   For 16-bit targets, each pixel has the target RGB format, but with\n *   the middle component (usually green) shifted 16 steps to the left,\n *   and the hole filled with the 5 most significant bits of the alpha value.\n *   i.e. if the target has the format         rrrrrggggggbbbbb,\n *   the encoded pixel will be 00000gggggg00000rrrrr0aaaaabbbbb.\n *   The <skip> and <run> counts are 8 bit for the opaque lines, 16 bit\n *   for the translucent lines. Two padding bytes may be inserted\n *   before each translucent line to keep them 32-bit aligned.\n *\n *   The end of the sequence is marked by a zero <skip>,<run> pair at the\n *   beginning of an opaque line.\n */\n\n#include \"SDL_video.h\"\n#include \"SDL_sysvideo.h\"\n#include \"SDL_blit.h\"\n#include \"SDL_RLEaccel_c.h\"\n\n#ifndef MAX\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#endif\n#ifndef MIN\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#endif\n\n#define PIXEL_COPY(to, from, len, bpp)          \\\n    SDL_memcpy(to, from, (size_t)(len) * (bpp))\n\n/*\n * Various colorkey blit methods, for opaque and per-surface alpha\n */\n\n#define OPAQUE_BLIT(to, from, length, bpp, alpha)   \\\n    PIXEL_COPY(to, from, length, bpp)\n\n/*\n * For 32bpp pixels on the form 0x00rrggbb:\n * If we treat the middle component separately, we can process the two\n * remaining in parallel. This is safe to do because of the gap to the left\n * of each component, so the bits from the multiplication don't collide.\n * This can be used for any RGB permutation of course.\n */\n#define ALPHA_BLIT32_888(to, from, length, bpp, alpha)      \\\n    do {                                                    \\\n        int i;                                              \\\n        Uint32 *src = (Uint32 *)(from);                     \\\n        Uint32 *dst = (Uint32 *)(to);                       \\\n        for (i = 0; i < (int)(length); i++) {               \\\n            Uint32 s = *src++;                              \\\n            Uint32 d = *dst;                                \\\n            Uint32 s1 = s & 0xff00ff;                       \\\n            Uint32 d1 = d & 0xff00ff;                       \\\n            d1 = (d1 + ((s1 - d1) * alpha >> 8)) & 0xff00ff; \\\n            s &= 0xff00;                                    \\\n            d &= 0xff00;                                    \\\n            d = (d + ((s - d) * alpha >> 8)) & 0xff00;      \\\n            *dst++ = d1 | d;                                \\\n        }                                                   \\\n    } while (0)\n\n/*\n * For 16bpp pixels we can go a step further: put the middle component\n * in the high 16 bits of a 32 bit word, and process all three RGB\n * components at the same time. Since the smallest gap is here just\n * 5 bits, we have to scale alpha down to 5 bits as well.\n */\n#define ALPHA_BLIT16_565(to, from, length, bpp, alpha)  \\\n    do {                                                \\\n        int i;                                          \\\n        Uint16 *src = (Uint16 *)(from);                 \\\n        Uint16 *dst = (Uint16 *)(to);                   \\\n        Uint32 ALPHA = alpha >> 3;                      \\\n        for(i = 0; i < (int)(length); i++) {            \\\n            Uint32 s = *src++;                          \\\n            Uint32 d = *dst;                            \\\n            s = (s | s << 16) & 0x07e0f81f;             \\\n            d = (d | d << 16) & 0x07e0f81f;             \\\n            d += (s - d) * ALPHA >> 5;                  \\\n            d &= 0x07e0f81f;                            \\\n            *dst++ = (Uint16)(d | d >> 16);             \\\n        }                                               \\\n    } while(0)\n\n#define ALPHA_BLIT16_555(to, from, length, bpp, alpha)  \\\n    do {                                                \\\n        int i;                                          \\\n        Uint16 *src = (Uint16 *)(from);                 \\\n        Uint16 *dst = (Uint16 *)(to);                   \\\n        Uint32 ALPHA = alpha >> 3;                      \\\n        for(i = 0; i < (int)(length); i++) {            \\\n            Uint32 s = *src++;                          \\\n            Uint32 d = *dst;                            \\\n            s = (s | s << 16) & 0x03e07c1f;             \\\n            d = (d | d << 16) & 0x03e07c1f;             \\\n            d += (s - d) * ALPHA >> 5;                  \\\n            d &= 0x03e07c1f;                            \\\n            *dst++ = (Uint16)(d | d >> 16);             \\\n        }                                               \\\n    } while(0)\n\n/*\n * The general slow catch-all function, for remaining depths and formats\n */\n#define ALPHA_BLIT_ANY(to, from, length, bpp, alpha)            \\\n    do {                                                        \\\n        int i;                                                  \\\n        Uint8 *src = from;                                      \\\n        Uint8 *dst = to;                                        \\\n        for (i = 0; i < (int)(length); i++) {                   \\\n            Uint32 s, d;                                        \\\n            unsigned rs, gs, bs, rd, gd, bd;                    \\\n            switch (bpp) {                                      \\\n            case 2:                                             \\\n                s = *(Uint16 *)src;                             \\\n                d = *(Uint16 *)dst;                             \\\n                break;                                          \\\n            case 3:                                             \\\n                if (SDL_BYTEORDER == SDL_BIG_ENDIAN) {          \\\n                    s = (src[0] << 16) | (src[1] << 8) | src[2]; \\\n                    d = (dst[0] << 16) | (dst[1] << 8) | dst[2]; \\\n                } else {                                        \\\n                    s = (src[2] << 16) | (src[1] << 8) | src[0]; \\\n                    d = (dst[2] << 16) | (dst[1] << 8) | dst[0]; \\\n                }                                               \\\n                break;                                          \\\n            case 4:                                             \\\n                s = *(Uint32 *)src;                             \\\n                d = *(Uint32 *)dst;                             \\\n                break;                                          \\\n            }                                                   \\\n            RGB_FROM_PIXEL(s, fmt, rs, gs, bs);                 \\\n            RGB_FROM_PIXEL(d, fmt, rd, gd, bd);                 \\\n            rd += (rs - rd) * alpha >> 8;                       \\\n            gd += (gs - gd) * alpha >> 8;                       \\\n            bd += (bs - bd) * alpha >> 8;                       \\\n            PIXEL_FROM_RGB(d, fmt, rd, gd, bd);                 \\\n            switch (bpp) {                                      \\\n            case 2:                                             \\\n                *(Uint16 *)dst = (Uint16)d;                     \\\n                break;                                          \\\n            case 3:                                             \\\n                if (SDL_BYTEORDER == SDL_BIG_ENDIAN) {          \\\n                    dst[0] = (Uint8)(d >> 16);                  \\\n                    dst[1] = (Uint8)(d >> 8);                   \\\n                    dst[2] = (Uint8)(d);                        \\\n                } else {                                        \\\n                    dst[0] = (Uint8)d;                          \\\n                    dst[1] = (Uint8)(d >> 8);                   \\\n                    dst[2] = (Uint8)(d >> 16);                  \\\n                }                                               \\\n                break;                                          \\\n            case 4:                                             \\\n                *(Uint32 *)dst = d;                             \\\n                break;                                          \\\n            }                                                   \\\n            src += bpp;                                         \\\n            dst += bpp;                                         \\\n        }                                                       \\\n    } while(0)\n\n/*\n * Special case: 50% alpha (alpha=128)\n * This is treated specially because it can be optimized very well, and\n * since it is good for many cases of semi-translucency.\n * The theory is to do all three components at the same time:\n * First zero the lowest bit of each component, which gives us room to\n * add them. Then shift right and add the sum of the lowest bits.\n */\n#define ALPHA_BLIT32_888_50(to, from, length, bpp, alpha)       \\\n    do {                                                        \\\n        int i;                                                  \\\n        Uint32 *src = (Uint32 *)(from);                         \\\n        Uint32 *dst = (Uint32 *)(to);                           \\\n        for(i = 0; i < (int)(length); i++) {                    \\\n            Uint32 s = *src++;                                  \\\n            Uint32 d = *dst;                                    \\\n            *dst++ = (((s & 0x00fefefe) + (d & 0x00fefefe)) >> 1) \\\n                 + (s & d & 0x00010101);                        \\\n        }                                                       \\\n    } while(0)\n\n/*\n * For 16bpp, we can actually blend two pixels in parallel, if we take\n * care to shift before we add, not after.\n */\n\n/* helper: blend a single 16 bit pixel at 50% */\n#define BLEND16_50(dst, src, mask)                              \\\n    do {                                                        \\\n        Uint32 s = *src++;                                      \\\n        Uint32 d = *dst;                                        \\\n        *dst++ = (Uint16)((((s & mask) + (d & mask)) >> 1) +    \\\n                          (s & d & (~mask & 0xffff)));          \\\n    } while(0)\n\n/* basic 16bpp blender. mask is the pixels to keep when adding. */\n#define ALPHA_BLIT16_50(to, from, length, bpp, alpha, mask)     \\\n    do {                                                        \\\n        unsigned n = (length);                                  \\\n        Uint16 *src = (Uint16 *)(from);                         \\\n        Uint16 *dst = (Uint16 *)(to);                           \\\n        if (((uintptr_t)src ^ (uintptr_t)dst) & 3) {            \\\n            /* source and destination not in phase, blit one by one */ \\\n            while (n--)                                         \\\n                BLEND16_50(dst, src, mask);                     \\\n        } else {                                                \\\n            if ((uintptr_t)src & 3) {                           \\\n                /* first odd pixel */                           \\\n                BLEND16_50(dst, src, mask);                     \\\n                n--;                                            \\\n            }                                                   \\\n            for (; n > 1; n -= 2) {                             \\\n                Uint32 s = *(Uint32 *)src;                      \\\n                Uint32 d = *(Uint32 *)dst;                      \\\n                *(Uint32 *)dst = ((s & (mask | mask << 16)) >> 1) \\\n                    + ((d & (mask | mask << 16)) >> 1)          \\\n                    + (s & d & (~(mask | mask << 16)));         \\\n                src += 2;                                       \\\n                dst += 2;                                       \\\n            }                                                   \\\n            if (n)                                              \\\n                BLEND16_50(dst, src, mask); /* last odd pixel */ \\\n        }                                                       \\\n    } while(0)\n\n#define ALPHA_BLIT16_565_50(to, from, length, bpp, alpha)       \\\n    ALPHA_BLIT16_50(to, from, length, bpp, alpha, 0xf7de)\n\n#define ALPHA_BLIT16_555_50(to, from, length, bpp, alpha)       \\\n    ALPHA_BLIT16_50(to, from, length, bpp, alpha, 0xfbde)\n\n#define CHOOSE_BLIT(blitter, alpha, fmt)                        \\\n    do {                                                        \\\n        if (alpha == 255) {                                     \\\n            switch (fmt->BytesPerPixel) {                       \\\n            case 1: blitter(1, Uint8, OPAQUE_BLIT); break;      \\\n            case 2: blitter(2, Uint8, OPAQUE_BLIT); break;      \\\n            case 3: blitter(3, Uint8, OPAQUE_BLIT); break;      \\\n            case 4: blitter(4, Uint16, OPAQUE_BLIT); break;     \\\n            }                                                   \\\n        } else {                                                \\\n            switch (fmt->BytesPerPixel) {                       \\\n            case 1:                                             \\\n                /* No 8bpp alpha blitting */                    \\\n                break;                                          \\\n                                                                \\\n            case 2:                                             \\\n                switch (fmt->Rmask | fmt->Gmask | fmt->Bmask) { \\\n                case 0xffff:                                    \\\n                    if (fmt->Gmask == 0x07e0                    \\\n                        || fmt->Rmask == 0x07e0                 \\\n                        || fmt->Bmask == 0x07e0) {              \\\n                        if (alpha == 128) {                     \\\n                            blitter(2, Uint8, ALPHA_BLIT16_565_50); \\\n                        } else {                                \\\n                            blitter(2, Uint8, ALPHA_BLIT16_565); \\\n                        }                                       \\\n                    } else                                      \\\n                        goto general16;                         \\\n                    break;                                      \\\n                                                                \\\n                case 0x7fff:                                    \\\n                    if (fmt->Gmask == 0x03e0                    \\\n                        || fmt->Rmask == 0x03e0                 \\\n                        || fmt->Bmask == 0x03e0) {              \\\n                        if (alpha == 128) {                     \\\n                            blitter(2, Uint8, ALPHA_BLIT16_555_50); \\\n                        } else {                                \\\n                            blitter(2, Uint8, ALPHA_BLIT16_555); \\\n                        }                                       \\\n                        break;                                  \\\n                    } else                                      \\\n                        goto general16;                         \\\n                    break;                                      \\\n                                                                \\\n                default:                                        \\\n    general16:                                                  \\\n                    blitter(2, Uint8, ALPHA_BLIT_ANY);          \\\n                }                                               \\\n                break;                                          \\\n                                                                \\\n            case 3:                                             \\\n                blitter(3, Uint8, ALPHA_BLIT_ANY);              \\\n                break;                                          \\\n                                                                \\\n            case 4:                                             \\\n                if ((fmt->Rmask | fmt->Gmask | fmt->Bmask) == 0x00ffffff \\\n                    && (fmt->Gmask == 0xff00 || fmt->Rmask == 0xff00 \\\n                    || fmt->Bmask == 0xff00)) {                 \\\n                    if (alpha == 128) {                         \\\n                        blitter(4, Uint16, ALPHA_BLIT32_888_50); \\\n                    } else {                                    \\\n                        blitter(4, Uint16, ALPHA_BLIT32_888);   \\\n                    }                                           \\\n                } else                                          \\\n                    blitter(4, Uint16, ALPHA_BLIT_ANY);         \\\n                break;                                          \\\n            }                                                   \\\n        }                                                       \\\n    } while(0)\n\n/*\n * This takes care of the case when the surface is clipped on the left and/or\n * right. Top clipping has already been taken care of.\n */\nstatic void\nRLEClipBlit(int w, Uint8 * srcbuf, SDL_Surface * surf_dst,\n            Uint8 * dstbuf, SDL_Rect * srcrect, unsigned alpha)\n{\n    SDL_PixelFormat *fmt = surf_dst->format;\n\n#define RLECLIPBLIT(bpp, Type, do_blit)                         \\\n    do {                                                        \\\n        int linecount = srcrect->h;                             \\\n        int ofs = 0;                                            \\\n        int left = srcrect->x;                                  \\\n        int right = left + srcrect->w;                          \\\n        dstbuf -= left * bpp;                                   \\\n        for (;;) {                                              \\\n            int run;                                            \\\n            ofs += *(Type *)srcbuf;                             \\\n            run = ((Type *)srcbuf)[1];                          \\\n            srcbuf += 2 * sizeof(Type);                         \\\n            if (run) {                                          \\\n                /* clip to left and right borders */            \\\n                if (ofs < right) {                              \\\n                    int start = 0;                              \\\n                    int len = run;                              \\\n                    int startcol;                               \\\n                    if (left - ofs > 0) {                       \\\n                        start = left - ofs;                     \\\n                        len -= start;                           \\\n                        if (len <= 0)                           \\\n                            goto nocopy ## bpp ## do_blit;      \\\n                    }                                           \\\n                    startcol = ofs + start;                     \\\n                    if (len > right - startcol)                 \\\n                        len = right - startcol;                 \\\n                    do_blit(dstbuf + startcol * bpp, srcbuf + start * bpp, \\\n                        len, bpp, alpha);                       \\\n                }                                               \\\n    nocopy ## bpp ## do_blit:                                   \\\n                srcbuf += run * bpp;                            \\\n                ofs += run;                                     \\\n            } else if (!ofs)                                    \\\n                break;                                          \\\n                                                                \\\n            if (ofs == w) {                                     \\\n                ofs = 0;                                        \\\n                dstbuf += surf_dst->pitch;                      \\\n                if (!--linecount)                               \\\n                    break;                                      \\\n            }                                                   \\\n        }                                                       \\\n    } while(0)\n\n    CHOOSE_BLIT(RLECLIPBLIT, alpha, fmt);\n\n#undef RLECLIPBLIT\n\n}\n\n\n/* blit a colorkeyed RLE surface */\nint\nSDL_RLEBlit(SDL_Surface * surf_src, SDL_Rect * srcrect,\n            SDL_Surface * surf_dst, SDL_Rect * dstrect)\n{\n    Uint8 *dstbuf;\n    Uint8 *srcbuf;\n    int x, y;\n    int w = surf_src->w;\n    unsigned alpha;\n\n    /* Lock the destination if necessary */\n    if (SDL_MUSTLOCK(surf_dst)) {\n        if (SDL_LockSurface(surf_dst) < 0) {\n            return (-1);\n        }\n    }\n\n    /* Set up the source and destination pointers */\n    x = dstrect->x;\n    y = dstrect->y;\n    dstbuf = (Uint8 *) surf_dst->pixels\n        + y * surf_dst->pitch + x * surf_src->format->BytesPerPixel;\n    srcbuf = (Uint8 *) surf_src->map->data;\n\n    {\n        /* skip lines at the top if necessary */\n        int vskip = srcrect->y;\n        int ofs = 0;\n        if (vskip) {\n\n#define RLESKIP(bpp, Type)          \\\n        for(;;) {           \\\n            int run;            \\\n            ofs += *(Type *)srcbuf; \\\n            run = ((Type *)srcbuf)[1];  \\\n            srcbuf += sizeof(Type) * 2; \\\n            if(run) {           \\\n            srcbuf += run * bpp;    \\\n            ofs += run;     \\\n            } else if(!ofs)     \\\n            goto done;      \\\n            if(ofs == w) {      \\\n            ofs = 0;        \\\n            if(!--vskip)        \\\n                break;      \\\n            }               \\\n        }\n\n            switch (surf_src->format->BytesPerPixel) {\n            case 1:\n                RLESKIP(1, Uint8);\n                break;\n            case 2:\n                RLESKIP(2, Uint8);\n                break;\n            case 3:\n                RLESKIP(3, Uint8);\n                break;\n            case 4:\n                RLESKIP(4, Uint16);\n                break;\n            }\n\n#undef RLESKIP\n\n        }\n    }\n\n    alpha = surf_src->map->info.a;\n    /* if left or right edge clipping needed, call clip blit */\n    if (srcrect->x || srcrect->w != surf_src->w) {\n        RLEClipBlit(w, srcbuf, surf_dst, dstbuf, srcrect, alpha);\n    } else {\n        SDL_PixelFormat *fmt = surf_src->format;\n\n#define RLEBLIT(bpp, Type, do_blit)                       \\\n        do {                                  \\\n        int linecount = srcrect->h;                   \\\n        int ofs = 0;                              \\\n        for(;;) {                             \\\n            unsigned run;                         \\\n            ofs += *(Type *)srcbuf;                   \\\n            run = ((Type *)srcbuf)[1];                    \\\n            srcbuf += 2 * sizeof(Type);                   \\\n            if(run) {                             \\\n            do_blit(dstbuf + ofs * bpp, srcbuf, run, bpp, alpha); \\\n            srcbuf += run * bpp;                      \\\n            ofs += run;                       \\\n            } else if(!ofs)                       \\\n            break;                            \\\n            if(ofs == w) {                        \\\n            ofs = 0;                          \\\n            dstbuf += surf_dst->pitch;                     \\\n            if(!--linecount)                      \\\n                break;                        \\\n            }                                 \\\n        }                                 \\\n        } while(0)\n\n        CHOOSE_BLIT(RLEBLIT, alpha, fmt);\n\n#undef RLEBLIT\n    }\n\n  done:\n    /* Unlock the destination if necessary */\n    if (SDL_MUSTLOCK(surf_dst)) {\n        SDL_UnlockSurface(surf_dst);\n    }\n    return (0);\n}\n\n#undef OPAQUE_BLIT\n\n/*\n * Per-pixel blitting macros for translucent pixels:\n * These use the same techniques as the per-surface blitting macros\n */\n\n/*\n * For 32bpp pixels, we have made sure the alpha is stored in the top\n * 8 bits, so proceed as usual\n */\n#define BLIT_TRANSL_888(src, dst)               \\\n    do {                            \\\n        Uint32 s = src;                     \\\n    Uint32 d = dst;                     \\\n    unsigned alpha = s >> 24;               \\\n    Uint32 s1 = s & 0xff00ff;               \\\n    Uint32 d1 = d & 0xff00ff;               \\\n    d1 = (d1 + ((s1 - d1) * alpha >> 8)) & 0xff00ff;    \\\n    s &= 0xff00;                        \\\n    d &= 0xff00;                        \\\n    d = (d + ((s - d) * alpha >> 8)) & 0xff00;      \\\n    dst = d1 | d | 0xff000000;              \\\n    } while(0)\n\n/*\n * For 16bpp pixels, we have stored the 5 most significant alpha bits in\n * bits 5-10. As before, we can process all 3 RGB components at the same time.\n */\n#define BLIT_TRANSL_565(src, dst)       \\\n    do {                    \\\n    Uint32 s = src;             \\\n    Uint32 d = dst;             \\\n    unsigned alpha = (s & 0x3e0) >> 5;  \\\n    s &= 0x07e0f81f;            \\\n    d = (d | d << 16) & 0x07e0f81f;     \\\n    d += (s - d) * alpha >> 5;      \\\n    d &= 0x07e0f81f;            \\\n    dst = (Uint16)(d | d >> 16);            \\\n    } while(0)\n\n#define BLIT_TRANSL_555(src, dst)       \\\n    do {                    \\\n    Uint32 s = src;             \\\n    Uint32 d = dst;             \\\n    unsigned alpha = (s & 0x3e0) >> 5;  \\\n    s &= 0x03e07c1f;            \\\n    d = (d | d << 16) & 0x03e07c1f;     \\\n    d += (s - d) * alpha >> 5;      \\\n    d &= 0x03e07c1f;            \\\n    dst = (Uint16)(d | d >> 16);            \\\n    } while(0)\n\n/* used to save the destination format in the encoding. Designed to be\n   macro-compatible with SDL_PixelFormat but without the unneeded fields */\ntypedef struct\n{\n    Uint8 BytesPerPixel;\n    Uint8 padding[3];\n    Uint32 Rmask;\n    Uint32 Gmask;\n    Uint32 Bmask;\n    Uint32 Amask;\n    Uint8 Rloss;\n    Uint8 Gloss;\n    Uint8 Bloss;\n    Uint8 Aloss;\n    Uint8 Rshift;\n    Uint8 Gshift;\n    Uint8 Bshift;\n    Uint8 Ashift;\n} RLEDestFormat;\n\n/* blit a pixel-alpha RLE surface clipped at the right and/or left edges */\nstatic void\nRLEAlphaClipBlit(int w, Uint8 * srcbuf, SDL_Surface * surf_dst,\n                 Uint8 * dstbuf, SDL_Rect * srcrect)\n{\n    SDL_PixelFormat *df = surf_dst->format;\n    /*\n     * clipped blitter: Ptype is the destination pixel type,\n     * Ctype the translucent count type, and do_blend the macro\n     * to blend one pixel.\n     */\n#define RLEALPHACLIPBLIT(Ptype, Ctype, do_blend)              \\\n    do {                                  \\\n    int linecount = srcrect->h;                   \\\n    int left = srcrect->x;                        \\\n    int right = left + srcrect->w;                    \\\n    dstbuf -= left * sizeof(Ptype);                   \\\n    do {                                  \\\n        int ofs = 0;                          \\\n        /* blit opaque pixels on one line */              \\\n        do {                              \\\n        unsigned run;                         \\\n        ofs += ((Ctype *)srcbuf)[0];                  \\\n        run = ((Ctype *)srcbuf)[1];               \\\n        srcbuf += 2 * sizeof(Ctype);                  \\\n        if(run) {                         \\\n            /* clip to left and right borders */          \\\n            int cofs = ofs;                   \\\n            int crun = run;                   \\\n            if(left - cofs > 0) {                 \\\n            crun -= left - cofs;                  \\\n            cofs = left;                      \\\n            }                             \\\n            if(crun > right - cofs)               \\\n            crun = right - cofs;                  \\\n            if(crun > 0)                      \\\n            PIXEL_COPY(dstbuf + cofs * sizeof(Ptype),     \\\n                   srcbuf + (cofs - ofs) * sizeof(Ptype), \\\n                   (unsigned)crun, sizeof(Ptype));    \\\n            srcbuf += run * sizeof(Ptype);            \\\n            ofs += run;                       \\\n        } else if(!ofs)                       \\\n            return;                       \\\n        } while(ofs < w);                         \\\n        /* skip padding if necessary */               \\\n        if(sizeof(Ptype) == 2)                    \\\n        srcbuf += (uintptr_t)srcbuf & 2;              \\\n        /* blit translucent pixels on the same line */        \\\n        ofs = 0;                              \\\n        do {                              \\\n        unsigned run;                         \\\n        ofs += ((Uint16 *)srcbuf)[0];                 \\\n        run = ((Uint16 *)srcbuf)[1];                  \\\n        srcbuf += 4;                          \\\n        if(run) {                         \\\n            /* clip to left and right borders */          \\\n            int cofs = ofs;                   \\\n            int crun = run;                   \\\n            if(left - cofs > 0) {                 \\\n            crun -= left - cofs;                  \\\n            cofs = left;                      \\\n            }                             \\\n            if(crun > right - cofs)               \\\n            crun = right - cofs;                  \\\n            if(crun > 0) {                    \\\n            Ptype *dst = (Ptype *)dstbuf + cofs;          \\\n            Uint32 *src = (Uint32 *)srcbuf + (cofs - ofs);    \\\n            int i;                        \\\n            for(i = 0; i < crun; i++)             \\\n                do_blend(src[i], dst[i]);             \\\n            }                             \\\n            srcbuf += run * 4;                    \\\n            ofs += run;                       \\\n        }                             \\\n        } while(ofs < w);                         \\\n        dstbuf += surf_dst->pitch;                     \\\n    } while(--linecount);                         \\\n    } while(0)\n\n    switch (df->BytesPerPixel) {\n    case 2:\n        if (df->Gmask == 0x07e0 || df->Rmask == 0x07e0 || df->Bmask == 0x07e0)\n            RLEALPHACLIPBLIT(Uint16, Uint8, BLIT_TRANSL_565);\n        else\n            RLEALPHACLIPBLIT(Uint16, Uint8, BLIT_TRANSL_555);\n        break;\n    case 4:\n        RLEALPHACLIPBLIT(Uint32, Uint16, BLIT_TRANSL_888);\n        break;\n    }\n}\n\n/* blit a pixel-alpha RLE surface */\nint\nSDL_RLEAlphaBlit(SDL_Surface * surf_src, SDL_Rect * srcrect,\n                 SDL_Surface * surf_dst, SDL_Rect * dstrect)\n{\n    int x, y;\n    int w = surf_src->w;\n    Uint8 *srcbuf, *dstbuf;\n    SDL_PixelFormat *df = surf_dst->format;\n\n    /* Lock the destination if necessary */\n    if (SDL_MUSTLOCK(surf_dst)) {\n        if (SDL_LockSurface(surf_dst) < 0) {\n            return -1;\n        }\n    }\n\n    x = dstrect->x;\n    y = dstrect->y;\n    dstbuf = (Uint8 *) surf_dst->pixels + y * surf_dst->pitch + x * df->BytesPerPixel;\n    srcbuf = (Uint8 *) surf_src->map->data + sizeof(RLEDestFormat);\n\n    {\n        /* skip lines at the top if necessary */\n        int vskip = srcrect->y;\n        if (vskip) {\n            int ofs;\n            if (df->BytesPerPixel == 2) {\n                /* the 16/32 interleaved format */\n                do {\n                    /* skip opaque line */\n                    ofs = 0;\n                    do {\n                        int run;\n                        ofs += srcbuf[0];\n                        run = srcbuf[1];\n                        srcbuf += 2;\n                        if (run) {\n                            srcbuf += 2 * run;\n                            ofs += run;\n                        } else if (!ofs)\n                            goto done;\n                    } while (ofs < w);\n\n                    /* skip padding */\n                    srcbuf += (uintptr_t) srcbuf & 2;\n\n                    /* skip translucent line */\n                    ofs = 0;\n                    do {\n                        int run;\n                        ofs += ((Uint16 *) srcbuf)[0];\n                        run = ((Uint16 *) srcbuf)[1];\n                        srcbuf += 4 * (run + 1);\n                        ofs += run;\n                    } while (ofs < w);\n                } while (--vskip);\n            } else {\n                /* the 32/32 interleaved format */\n                vskip <<= 1;    /* opaque and translucent have same format */\n                do {\n                    ofs = 0;\n                    do {\n                        int run;\n                        ofs += ((Uint16 *) srcbuf)[0];\n                        run = ((Uint16 *) srcbuf)[1];\n                        srcbuf += 4;\n                        if (run) {\n                            srcbuf += 4 * run;\n                            ofs += run;\n                        } else if (!ofs)\n                            goto done;\n                    } while (ofs < w);\n                } while (--vskip);\n            }\n        }\n    }\n\n    /* if left or right edge clipping needed, call clip blit */\n    if (srcrect->x || srcrect->w != surf_src->w) {\n        RLEAlphaClipBlit(w, srcbuf, surf_dst, dstbuf, srcrect);\n    } else {\n\n        /*\n         * non-clipped blitter. Ptype is the destination pixel type,\n         * Ctype the translucent count type, and do_blend the\n         * macro to blend one pixel.\n         */\n#define RLEALPHABLIT(Ptype, Ctype, do_blend)                 \\\n    do {                                 \\\n        int linecount = srcrect->h;                  \\\n        do {                             \\\n        int ofs = 0;                         \\\n        /* blit opaque pixels on one line */             \\\n        do {                             \\\n            unsigned run;                    \\\n            ofs += ((Ctype *)srcbuf)[0];             \\\n            run = ((Ctype *)srcbuf)[1];              \\\n            srcbuf += 2 * sizeof(Ctype);             \\\n            if(run) {                        \\\n            PIXEL_COPY(dstbuf + ofs * sizeof(Ptype), srcbuf, \\\n                   run, sizeof(Ptype));          \\\n            srcbuf += run * sizeof(Ptype);           \\\n            ofs += run;                  \\\n            } else if(!ofs)                  \\\n            goto done;                   \\\n        } while(ofs < w);                    \\\n        /* skip padding if necessary */              \\\n        if(sizeof(Ptype) == 2)                   \\\n            srcbuf += (uintptr_t)srcbuf & 2;             \\\n        /* blit translucent pixels on the same line */       \\\n        ofs = 0;                         \\\n        do {                             \\\n            unsigned run;                    \\\n            ofs += ((Uint16 *)srcbuf)[0];            \\\n            run = ((Uint16 *)srcbuf)[1];             \\\n            srcbuf += 4;                     \\\n            if(run) {                        \\\n            Ptype *dst = (Ptype *)dstbuf + ofs;      \\\n            unsigned i;                  \\\n            for(i = 0; i < run; i++) {           \\\n                Uint32 src = *(Uint32 *)srcbuf;      \\\n                do_blend(src, *dst);             \\\n                srcbuf += 4;                 \\\n                dst++;                   \\\n            }                        \\\n            ofs += run;                  \\\n            }                            \\\n        } while(ofs < w);                    \\\n        dstbuf += surf_dst->pitch;                    \\\n        } while(--linecount);                    \\\n    } while(0)\n\n        switch (df->BytesPerPixel) {\n        case 2:\n            if (df->Gmask == 0x07e0 || df->Rmask == 0x07e0\n                || df->Bmask == 0x07e0)\n                RLEALPHABLIT(Uint16, Uint8, BLIT_TRANSL_565);\n            else\n                RLEALPHABLIT(Uint16, Uint8, BLIT_TRANSL_555);\n            break;\n        case 4:\n            RLEALPHABLIT(Uint32, Uint16, BLIT_TRANSL_888);\n            break;\n        }\n    }\n\n  done:\n    /* Unlock the destination if necessary */\n    if (SDL_MUSTLOCK(surf_dst)) {\n        SDL_UnlockSurface(surf_dst);\n    }\n    return 0;\n}\n\n/*\n * Auxiliary functions:\n * The encoding functions take 32bpp rgb + a, and\n * return the number of bytes copied to the destination.\n * The decoding functions copy to 32bpp rgb + a, and\n * return the number of bytes copied from the source.\n * These are only used in the encoder and un-RLE code and are therefore not\n * highly optimised.\n */\n\n/* encode 32bpp rgb + a into 16bpp rgb, losing alpha */\nstatic int\ncopy_opaque_16(void *dst, Uint32 * src, int n,\n               SDL_PixelFormat * sfmt, SDL_PixelFormat * dfmt)\n{\n    int i;\n    Uint16 *d = dst;\n    for (i = 0; i < n; i++) {\n        unsigned r, g, b;\n        RGB_FROM_PIXEL(*src, sfmt, r, g, b);\n        PIXEL_FROM_RGB(*d, dfmt, r, g, b);\n        src++;\n        d++;\n    }\n    return n * 2;\n}\n\n/* decode opaque pixels from 16bpp to 32bpp rgb + a */\nstatic int\nuncopy_opaque_16(Uint32 * dst, void *src, int n,\n                 RLEDestFormat * sfmt, SDL_PixelFormat * dfmt)\n{\n    int i;\n    Uint16 *s = src;\n    unsigned alpha = dfmt->Amask ? 255 : 0;\n    for (i = 0; i < n; i++) {\n        unsigned r, g, b;\n        RGB_FROM_PIXEL(*s, sfmt, r, g, b);\n        PIXEL_FROM_RGBA(*dst, dfmt, r, g, b, alpha);\n        s++;\n        dst++;\n    }\n    return n * 2;\n}\n\n\n\n/* encode 32bpp rgb + a into 32bpp G0RAB format for blitting into 565 */\nstatic int\ncopy_transl_565(void *dst, Uint32 * src, int n,\n                SDL_PixelFormat * sfmt, SDL_PixelFormat * dfmt)\n{\n    int i;\n    Uint32 *d = dst;\n    for (i = 0; i < n; i++) {\n        unsigned r, g, b, a;\n        Uint16 pix;\n        RGBA_FROM_8888(*src, sfmt, r, g, b, a);\n        PIXEL_FROM_RGB(pix, dfmt, r, g, b);\n        *d = ((pix & 0x7e0) << 16) | (pix & 0xf81f) | ((a << 2) & 0x7e0);\n        src++;\n        d++;\n    }\n    return n * 4;\n}\n\n/* encode 32bpp rgb + a into 32bpp G0RAB format for blitting into 555 */\nstatic int\ncopy_transl_555(void *dst, Uint32 * src, int n,\n                SDL_PixelFormat * sfmt, SDL_PixelFormat * dfmt)\n{\n    int i;\n    Uint32 *d = dst;\n    for (i = 0; i < n; i++) {\n        unsigned r, g, b, a;\n        Uint16 pix;\n        RGBA_FROM_8888(*src, sfmt, r, g, b, a);\n        PIXEL_FROM_RGB(pix, dfmt, r, g, b);\n        *d = ((pix & 0x3e0) << 16) | (pix & 0xfc1f) | ((a << 2) & 0x3e0);\n        src++;\n        d++;\n    }\n    return n * 4;\n}\n\n/* decode translucent pixels from 32bpp GORAB to 32bpp rgb + a */\nstatic int\nuncopy_transl_16(Uint32 * dst, void *src, int n,\n                 RLEDestFormat * sfmt, SDL_PixelFormat * dfmt)\n{\n    int i;\n    Uint32 *s = src;\n    for (i = 0; i < n; i++) {\n        unsigned r, g, b, a;\n        Uint32 pix = *s++;\n        a = (pix & 0x3e0) >> 2;\n        pix = (pix & ~0x3e0) | pix >> 16;\n        RGB_FROM_PIXEL(pix, sfmt, r, g, b);\n        PIXEL_FROM_RGBA(*dst, dfmt, r, g, b, a);\n        dst++;\n    }\n    return n * 4;\n}\n\n/* encode 32bpp rgba into 32bpp rgba, keeping alpha (dual purpose) */\nstatic int\ncopy_32(void *dst, Uint32 * src, int n,\n        SDL_PixelFormat * sfmt, SDL_PixelFormat * dfmt)\n{\n    int i;\n    Uint32 *d = dst;\n    for (i = 0; i < n; i++) {\n        unsigned r, g, b, a;\n        RGBA_FROM_8888(*src, sfmt, r, g, b, a);\n        PIXEL_FROM_RGBA(*d, dfmt, r, g, b, a);\n        d++;\n        src++;\n    }\n    return n * 4;\n}\n\n/* decode 32bpp rgba into 32bpp rgba, keeping alpha (dual purpose) */\nstatic int\nuncopy_32(Uint32 * dst, void *src, int n,\n          RLEDestFormat * sfmt, SDL_PixelFormat * dfmt)\n{\n    int i;\n    Uint32 *s = src;\n    for (i = 0; i < n; i++) {\n        unsigned r, g, b, a;\n        Uint32 pixel = *s++;\n        RGB_FROM_PIXEL(pixel, sfmt, r, g, b);\n        a = pixel >> 24;\n        PIXEL_FROM_RGBA(*dst, dfmt, r, g, b, a);\n        dst++;\n    }\n    return n * 4;\n}\n\n#define ISOPAQUE(pixel, fmt) ((((pixel) & fmt->Amask) >> fmt->Ashift) == 255)\n\n#define ISTRANSL(pixel, fmt)    \\\n    ((unsigned)((((pixel) & fmt->Amask) >> fmt->Ashift) - 1U) < 254U)\n\n/* convert surface to be quickly alpha-blittable onto dest, if possible */\nstatic int\nRLEAlphaSurface(SDL_Surface * surface)\n{\n    SDL_Surface *dest;\n    SDL_PixelFormat *df;\n    int maxsize = 0;\n    int max_opaque_run;\n    int max_transl_run = 65535;\n    unsigned masksum;\n    Uint8 *rlebuf, *dst;\n    int (*copy_opaque) (void *, Uint32 *, int,\n                        SDL_PixelFormat *, SDL_PixelFormat *);\n    int (*copy_transl) (void *, Uint32 *, int,\n                        SDL_PixelFormat *, SDL_PixelFormat *);\n\n    dest = surface->map->dst;\n    if (!dest)\n        return -1;\n    df = dest->format;\n    if (surface->format->BitsPerPixel != 32)\n        return -1;              /* only 32bpp source supported */\n\n    /* find out whether the destination is one we support,\n       and determine the max size of the encoded result */\n    masksum = df->Rmask | df->Gmask | df->Bmask;\n    switch (df->BytesPerPixel) {\n    case 2:\n        /* 16bpp: only support 565 and 555 formats */\n        switch (masksum) {\n        case 0xffff:\n            if (df->Gmask == 0x07e0\n                || df->Rmask == 0x07e0 || df->Bmask == 0x07e0) {\n                copy_opaque = copy_opaque_16;\n                copy_transl = copy_transl_565;\n            } else\n                return -1;\n            break;\n        case 0x7fff:\n            if (df->Gmask == 0x03e0\n                || df->Rmask == 0x03e0 || df->Bmask == 0x03e0) {\n                copy_opaque = copy_opaque_16;\n                copy_transl = copy_transl_555;\n            } else\n                return -1;\n            break;\n        default:\n            return -1;\n        }\n        max_opaque_run = 255;   /* runs stored as bytes */\n\n        /* worst case is alternating opaque and translucent pixels,\n           with room for alignment padding between lines */\n        maxsize = surface->h * (2 + (4 + 2) * (surface->w + 1)) + 2;\n        break;\n    case 4:\n        if (masksum != 0x00ffffff)\n            return -1;          /* requires unused high byte */\n        copy_opaque = copy_32;\n        copy_transl = copy_32;\n        max_opaque_run = 255;   /* runs stored as short ints */\n\n        /* worst case is alternating opaque and translucent pixels */\n        maxsize = surface->h * 2 * 4 * (surface->w + 1) + 4;\n        break;\n    default:\n        return -1;              /* anything else unsupported right now */\n    }\n\n    maxsize += sizeof(RLEDestFormat);\n    rlebuf = (Uint8 *) SDL_malloc(maxsize);\n    if (!rlebuf) {\n        return SDL_OutOfMemory();\n    }\n    {\n        /* save the destination format so we can undo the encoding later */\n        RLEDestFormat *r = (RLEDestFormat *) rlebuf;\n        r->BytesPerPixel = df->BytesPerPixel;\n        r->Rmask = df->Rmask;\n        r->Gmask = df->Gmask;\n        r->Bmask = df->Bmask;\n        r->Amask = df->Amask;\n        r->Rloss = df->Rloss;\n        r->Gloss = df->Gloss;\n        r->Bloss = df->Bloss;\n        r->Aloss = df->Aloss;\n        r->Rshift = df->Rshift;\n        r->Gshift = df->Gshift;\n        r->Bshift = df->Bshift;\n        r->Ashift = df->Ashift;\n    }\n    dst = rlebuf + sizeof(RLEDestFormat);\n\n    /* Do the actual encoding */\n    {\n        int x, y;\n        int h = surface->h, w = surface->w;\n        SDL_PixelFormat *sf = surface->format;\n        Uint32 *src = (Uint32 *) surface->pixels;\n        Uint8 *lastline = dst;  /* end of last non-blank line */\n\n        /* opaque counts are 8 or 16 bits, depending on target depth */\n#define ADD_OPAQUE_COUNTS(n, m)         \\\n    if(df->BytesPerPixel == 4) {        \\\n        ((Uint16 *)dst)[0] = n;     \\\n        ((Uint16 *)dst)[1] = m;     \\\n        dst += 4;               \\\n    } else {                \\\n        dst[0] = n;             \\\n        dst[1] = m;             \\\n        dst += 2;               \\\n    }\n\n        /* translucent counts are always 16 bit */\n#define ADD_TRANSL_COUNTS(n, m)     \\\n    (((Uint16 *)dst)[0] = n, ((Uint16 *)dst)[1] = m, dst += 4)\n\n        for (y = 0; y < h; y++) {\n            int runstart, skipstart;\n            int blankline = 0;\n            /* First encode all opaque pixels of a scan line */\n            x = 0;\n            do {\n                int run, skip, len;\n                skipstart = x;\n                while (x < w && !ISOPAQUE(src[x], sf))\n                    x++;\n                runstart = x;\n                while (x < w && ISOPAQUE(src[x], sf))\n                    x++;\n                skip = runstart - skipstart;\n                if (skip == w)\n                    blankline = 1;\n                run = x - runstart;\n                while (skip > max_opaque_run) {\n                    ADD_OPAQUE_COUNTS(max_opaque_run, 0);\n                    skip -= max_opaque_run;\n                }\n                len = MIN(run, max_opaque_run);\n                ADD_OPAQUE_COUNTS(skip, len);\n                dst += copy_opaque(dst, src + runstart, len, sf, df);\n                runstart += len;\n                run -= len;\n                while (run) {\n                    len = MIN(run, max_opaque_run);\n                    ADD_OPAQUE_COUNTS(0, len);\n                    dst += copy_opaque(dst, src + runstart, len, sf, df);\n                    runstart += len;\n                    run -= len;\n                }\n            } while (x < w);\n\n            /* Make sure the next output address is 32-bit aligned */\n            dst += (uintptr_t) dst & 2;\n\n            /* Next, encode all translucent pixels of the same scan line */\n            x = 0;\n            do {\n                int run, skip, len;\n                skipstart = x;\n                while (x < w && !ISTRANSL(src[x], sf))\n                    x++;\n                runstart = x;\n                while (x < w && ISTRANSL(src[x], sf))\n                    x++;\n                skip = runstart - skipstart;\n                blankline &= (skip == w);\n                run = x - runstart;\n                while (skip > max_transl_run) {\n                    ADD_TRANSL_COUNTS(max_transl_run, 0);\n                    skip -= max_transl_run;\n                }\n                len = MIN(run, max_transl_run);\n                ADD_TRANSL_COUNTS(skip, len);\n                dst += copy_transl(dst, src + runstart, len, sf, df);\n                runstart += len;\n                run -= len;\n                while (run) {\n                    len = MIN(run, max_transl_run);\n                    ADD_TRANSL_COUNTS(0, len);\n                    dst += copy_transl(dst, src + runstart, len, sf, df);\n                    runstart += len;\n                    run -= len;\n                }\n                if (!blankline)\n                    lastline = dst;\n            } while (x < w);\n\n            src += surface->pitch >> 2;\n        }\n        dst = lastline;         /* back up past trailing blank lines */\n        ADD_OPAQUE_COUNTS(0, 0);\n    }\n\n#undef ADD_OPAQUE_COUNTS\n#undef ADD_TRANSL_COUNTS\n\n    /* Now that we have it encoded, release the original pixels */\n    if (!(surface->flags & SDL_PREALLOC)) {\n        SDL_free(surface->pixels);\n        surface->pixels = NULL;\n    }\n\n    /* realloc the buffer to release unused memory */\n    {\n        Uint8 *p = SDL_realloc(rlebuf, dst - rlebuf);\n        if (!p)\n            p = rlebuf;\n        surface->map->data = p;\n    }\n\n    return 0;\n}\n\nstatic Uint32\ngetpix_8(Uint8 * srcbuf)\n{\n    return *srcbuf;\n}\n\nstatic Uint32\ngetpix_16(Uint8 * srcbuf)\n{\n    return *(Uint16 *) srcbuf;\n}\n\nstatic Uint32\ngetpix_24(Uint8 * srcbuf)\n{\n#if SDL_BYTEORDER == SDL_LIL_ENDIAN\n    return srcbuf[0] + (srcbuf[1] << 8) + (srcbuf[2] << 16);\n#else\n    return (srcbuf[0] << 16) + (srcbuf[1] << 8) + srcbuf[2];\n#endif\n}\n\nstatic Uint32\ngetpix_32(Uint8 * srcbuf)\n{\n    return *(Uint32 *) srcbuf;\n}\n\ntypedef Uint32(*getpix_func) (Uint8 *);\n\nstatic const getpix_func getpixes[4] = {\n    getpix_8, getpix_16, getpix_24, getpix_32\n};\n\nstatic int\nRLEColorkeySurface(SDL_Surface * surface)\n{\n    Uint8 *rlebuf, *dst;\n    int maxn;\n    int y;\n    Uint8 *srcbuf, *lastline;\n    int maxsize = 0;\n    int bpp = surface->format->BytesPerPixel;\n    getpix_func getpix;\n    Uint32 ckey, rgbmask;\n    int w, h;\n\n    /* calculate the worst case size for the compressed surface */\n    switch (bpp) {\n    case 1:\n        /* worst case is alternating opaque and transparent pixels,\n           starting with an opaque pixel */\n        maxsize = surface->h * 3 * (surface->w / 2 + 1) + 2;\n        break;\n    case 2:\n    case 3:\n        /* worst case is solid runs, at most 255 pixels wide */\n        maxsize = surface->h * (2 * (surface->w / 255 + 1)\n                                + surface->w * bpp) + 2;\n        break;\n    case 4:\n        /* worst case is solid runs, at most 65535 pixels wide */\n        maxsize = surface->h * (4 * (surface->w / 65535 + 1)\n                                + surface->w * 4) + 4;\n        break;\n    }\n\n    rlebuf = (Uint8 *) SDL_malloc(maxsize);\n    if (rlebuf == NULL) {\n        return SDL_OutOfMemory();\n    }\n\n    /* Set up the conversion */\n    srcbuf = (Uint8 *) surface->pixels;\n    maxn = bpp == 4 ? 65535 : 255;\n    dst = rlebuf;\n    rgbmask = ~surface->format->Amask;\n    ckey = surface->map->info.colorkey & rgbmask;\n    lastline = dst;\n    getpix = getpixes[bpp - 1];\n    w = surface->w;\n    h = surface->h;\n\n#define ADD_COUNTS(n, m)            \\\n    if(bpp == 4) {              \\\n        ((Uint16 *)dst)[0] = n;     \\\n        ((Uint16 *)dst)[1] = m;     \\\n        dst += 4;               \\\n    } else {                \\\n        dst[0] = n;             \\\n        dst[1] = m;             \\\n        dst += 2;               \\\n    }\n\n    for (y = 0; y < h; y++) {\n        int x = 0;\n        int blankline = 0;\n        do {\n            int run, skip, len;\n            int runstart;\n            int skipstart = x;\n\n            /* find run of transparent, then opaque pixels */\n            while (x < w && (getpix(srcbuf + x * bpp) & rgbmask) == ckey)\n                x++;\n            runstart = x;\n            while (x < w && (getpix(srcbuf + x * bpp) & rgbmask) != ckey)\n                x++;\n            skip = runstart - skipstart;\n            if (skip == w)\n                blankline = 1;\n            run = x - runstart;\n\n            /* encode segment */\n            while (skip > maxn) {\n                ADD_COUNTS(maxn, 0);\n                skip -= maxn;\n            }\n            len = MIN(run, maxn);\n            ADD_COUNTS(skip, len);\n            SDL_memcpy(dst, srcbuf + runstart * bpp, len * bpp);\n            dst += len * bpp;\n            run -= len;\n            runstart += len;\n            while (run) {\n                len = MIN(run, maxn);\n                ADD_COUNTS(0, len);\n                SDL_memcpy(dst, srcbuf + runstart * bpp, len * bpp);\n                dst += len * bpp;\n                runstart += len;\n                run -= len;\n            }\n            if (!blankline)\n                lastline = dst;\n        } while (x < w);\n\n        srcbuf += surface->pitch;\n    }\n    dst = lastline;             /* back up bast trailing blank lines */\n    ADD_COUNTS(0, 0);\n\n#undef ADD_COUNTS\n\n    /* Now that we have it encoded, release the original pixels */\n    if (!(surface->flags & SDL_PREALLOC)) {\n        SDL_free(surface->pixels);\n        surface->pixels = NULL;\n    }\n\n    /* realloc the buffer to release unused memory */\n    {\n        /* If realloc returns NULL, the original block is left intact */\n        Uint8 *p = SDL_realloc(rlebuf, dst - rlebuf);\n        if (!p)\n            p = rlebuf;\n        surface->map->data = p;\n    }\n\n    return (0);\n}\n\nint\nSDL_RLESurface(SDL_Surface * surface)\n{\n    int flags;\n\n    /* Clear any previous RLE conversion */\n    if ((surface->flags & SDL_RLEACCEL) == SDL_RLEACCEL) {\n        SDL_UnRLESurface(surface, 1);\n    }\n\n    /* We don't support RLE encoding of bitmaps */\n    if (surface->format->BitsPerPixel < 8) {\n        return -1;\n    }\n\n    /* Make sure the pixels are available */\n    if (!surface->pixels) {\n        return -1;\n    }\n\n    /* If we don't have colorkey or blending, nothing to do... */\n    flags = surface->map->info.flags;\n    if (!(flags & (SDL_COPY_COLORKEY | SDL_COPY_BLEND))) {\n        return -1;\n    }\n\n    /* Pass on combinations not supported */\n    if ((flags & SDL_COPY_MODULATE_COLOR) ||\n        ((flags & SDL_COPY_MODULATE_ALPHA) && surface->format->Amask) ||\n        (flags & (SDL_COPY_ADD | SDL_COPY_MOD)) ||\n        (flags & SDL_COPY_NEAREST)) {\n        return -1;\n    }\n\n    /* Encode and set up the blit */\n    if (!surface->format->Amask || !(flags & SDL_COPY_BLEND)) {\n        if (!surface->map->identity) {\n            return -1;\n        }\n        if (RLEColorkeySurface(surface) < 0) {\n            return -1;\n        }\n        surface->map->blit = SDL_RLEBlit;\n        surface->map->info.flags |= SDL_COPY_RLE_COLORKEY;\n    } else {\n        if (RLEAlphaSurface(surface) < 0) {\n            return -1;\n        }\n        surface->map->blit = SDL_RLEAlphaBlit;\n        surface->map->info.flags |= SDL_COPY_RLE_ALPHAKEY;\n    }\n\n    /* The surface is now accelerated */\n    surface->flags |= SDL_RLEACCEL;\n\n    return (0);\n}\n\n/*\n * Un-RLE a surface with pixel alpha\n * This may not give back exactly the image before RLE-encoding; all\n * completely transparent pixels will be lost, and color and alpha depth\n * may have been reduced (when encoding for 16bpp targets).\n */\nstatic SDL_bool\nUnRLEAlpha(SDL_Surface * surface)\n{\n    Uint8 *srcbuf;\n    Uint32 *dst;\n    SDL_PixelFormat *sf = surface->format;\n    RLEDestFormat *df = surface->map->data;\n    int (*uncopy_opaque) (Uint32 *, void *, int,\n                          RLEDestFormat *, SDL_PixelFormat *);\n    int (*uncopy_transl) (Uint32 *, void *, int,\n                          RLEDestFormat *, SDL_PixelFormat *);\n    int w = surface->w;\n    int bpp = df->BytesPerPixel;\n\n    if (bpp == 2) {\n        uncopy_opaque = uncopy_opaque_16;\n        uncopy_transl = uncopy_transl_16;\n    } else {\n        uncopy_opaque = uncopy_transl = uncopy_32;\n    }\n\n    surface->pixels = SDL_malloc(surface->h * surface->pitch);\n    if (!surface->pixels) {\n        return (SDL_FALSE);\n    }\n    /* fill background with transparent pixels */\n    SDL_memset(surface->pixels, 0, surface->h * surface->pitch);\n\n    dst = surface->pixels;\n    srcbuf = (Uint8 *) (df + 1);\n    for (;;) {\n        /* copy opaque pixels */\n        int ofs = 0;\n        do {\n            unsigned run;\n            if (bpp == 2) {\n                ofs += srcbuf[0];\n                run = srcbuf[1];\n                srcbuf += 2;\n            } else {\n                ofs += ((Uint16 *) srcbuf)[0];\n                run = ((Uint16 *) srcbuf)[1];\n                srcbuf += 4;\n            }\n            if (run) {\n                srcbuf += uncopy_opaque(dst + ofs, srcbuf, run, df, sf);\n                ofs += run;\n            } else if (!ofs)\n                return (SDL_TRUE);\n        } while (ofs < w);\n\n        /* skip padding if needed */\n        if (bpp == 2)\n            srcbuf += (uintptr_t) srcbuf & 2;\n\n        /* copy translucent pixels */\n        ofs = 0;\n        do {\n            unsigned run;\n            ofs += ((Uint16 *) srcbuf)[0];\n            run = ((Uint16 *) srcbuf)[1];\n            srcbuf += 4;\n            if (run) {\n                srcbuf += uncopy_transl(dst + ofs, srcbuf, run, df, sf);\n                ofs += run;\n            }\n        } while (ofs < w);\n        dst += surface->pitch >> 2;\n    }\n    /* Make the compiler happy */\n    return (SDL_TRUE);\n}\n\nvoid\nSDL_UnRLESurface(SDL_Surface * surface, int recode)\n{\n    if (surface->flags & SDL_RLEACCEL) {\n        surface->flags &= ~SDL_RLEACCEL;\n\n        if (recode && !(surface->flags & SDL_PREALLOC)) {\n            if (surface->map->info.flags & SDL_COPY_RLE_COLORKEY) {\n                SDL_Rect full;\n\n                /* re-create the original surface */\n                surface->pixels = SDL_malloc(surface->h * surface->pitch);\n                if (!surface->pixels) {\n                    /* Oh crap... */\n                    surface->flags |= SDL_RLEACCEL;\n                    return;\n                }\n\n                /* fill it with the background color */\n                SDL_FillRect(surface, NULL, surface->map->info.colorkey);\n\n                /* now render the encoded surface */\n                full.x = full.y = 0;\n                full.w = surface->w;\n                full.h = surface->h;\n                SDL_RLEBlit(surface, &full, surface, &full);\n            } else {\n                if (!UnRLEAlpha(surface)) {\n                    /* Oh crap... */\n                    surface->flags |= SDL_RLEACCEL;\n                    return;\n                }\n            }\n        }\n        surface->map->info.flags &=\n            ~(SDL_COPY_RLE_COLORKEY | SDL_COPY_RLE_ALPHAKEY);\n\n        SDL_free(surface->map->data);\n        surface->map->data = NULL;\n    }\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../SDL_internal.h\"\n\n/* This a stretch blit implementation based on ideas given to me by\n   Tomasz Cejner - thanks! :)\n\n   April 27, 2000 - Sam Lantinga\n*/\n\n#include \"SDL_video.h\"\n#include \"SDL_blit.h\"\n\n/* This isn't ready for general consumption yet - it should be folded\n   into the general blitting mechanism.\n*/\n\n#if ((defined(_MFC_VER) && defined(_M_IX86)) || \\\n     defined(__WATCOMC__) || \\\n     (defined(__GNUC__) && defined(__i386__))) && SDL_ASSEMBLY_ROUTINES\n/* There's a bug with gcc 4.4.1 and -O2 where srcp doesn't get the correct\n * value after the first scanline.  FIXME? */\n/* #define USE_ASM_STRETCH */\n#endif\n\n#ifdef USE_ASM_STRETCH\n\n#ifdef HAVE_MPROTECT\n#include <sys/types.h>\n#include <sys/mman.h>\n#endif\n#ifdef __GNUC__\n#define PAGE_ALIGNED __attribute__((__aligned__(4096)))\n#else\n#define PAGE_ALIGNED\n#endif\n\n#if defined(_M_IX86) || defined(i386)\n#define PREFIX16    0x66\n#define STORE_BYTE  0xAA\n#define STORE_WORD  0xAB\n#define LOAD_BYTE   0xAC\n#define LOAD_WORD   0xAD\n#define RETURN      0xC3\n#else\n#error Need assembly opcodes for this architecture\n#endif\n\nstatic unsigned char copy_row[4096] PAGE_ALIGNED;\n\nstatic int\ngenerate_rowbytes(int src_w, int dst_w, int bpp)\n{\n    static struct\n    {\n        int bpp;\n        int src_w;\n        int dst_w;\n        int status;\n    } last;\n\n    int i;\n    int pos, inc;\n    unsigned char *eip, *fence;\n    unsigned char load, store;\n\n    /* See if we need to regenerate the copy buffer */\n    if ((src_w == last.src_w) && (dst_w == last.dst_w) && (bpp == last.bpp)) {\n        return (last.status);\n    }\n    last.bpp = bpp;\n    last.src_w = src_w;\n    last.dst_w = dst_w;\n    last.status = -1;\n\n    switch (bpp) {\n    case 1:\n        load = LOAD_BYTE;\n        store = STORE_BYTE;\n        break;\n    case 2:\n    case 4:\n        load = LOAD_WORD;\n        store = STORE_WORD;\n        break;\n    default:\n        return SDL_SetError(\"ASM stretch of %d bytes isn't supported\\n\", bpp);\n    }\n#ifdef HAVE_MPROTECT\n    /* Make the code writeable */\n    if (mprotect(copy_row, sizeof(copy_row), PROT_READ | PROT_WRITE) < 0) {\n        return SDL_SetError(\"Couldn't make copy buffer writeable\");\n    }\n#endif\n    pos = 0x10000;\n    inc = (src_w << 16) / dst_w;\n    eip = copy_row;\n    fence = copy_row + sizeof(copy_row)-2;\n    for (i = 0; i < dst_w; ++i) {\n        while (pos >= 0x10000L) {\n            if (eip == fence) {\n                return -1;\n            }\n            if (bpp == 2) {\n                *eip++ = PREFIX16;\n            }\n            *eip++ = load;\n            pos -= 0x10000L;\n        }\n        if (eip == fence) {\n            return -1;\n        }\n        if (bpp == 2) {\n            *eip++ = PREFIX16;\n        }\n        *eip++ = store;\n        pos += inc;\n    }\n    *eip++ = RETURN;\n\n#ifdef HAVE_MPROTECT\n    /* Make the code executable but not writeable */\n    if (mprotect(copy_row, sizeof(copy_row), PROT_READ | PROT_EXEC) < 0) {\n        return SDL_SetError(\"Couldn't make copy buffer executable\");\n    }\n#endif\n    last.status = 0;\n    return (0);\n}\n\n#endif /* USE_ASM_STRETCH */\n\n#define DEFINE_COPY_ROW(name, type)         \\\nstatic void name(type *src, int src_w, type *dst, int dst_w)    \\\n{                                           \\\n    int i;                                  \\\n    int pos, inc;                           \\\n    type pixel = 0;                         \\\n                                            \\\n    pos = 0x10000;                          \\\n    inc = (src_w << 16) / dst_w;            \\\n    for ( i=dst_w; i>0; --i ) {             \\\n        while ( pos >= 0x10000L ) {         \\\n            pixel = *src++;                 \\\n            pos -= 0x10000L;                \\\n        }                                   \\\n        *dst++ = pixel;                     \\\n        pos += inc;                         \\\n    }                                       \\\n}\n/* *INDENT-OFF* */\nDEFINE_COPY_ROW(copy_row1, Uint8)\nDEFINE_COPY_ROW(copy_row2, Uint16)\nDEFINE_COPY_ROW(copy_row4, Uint32)\n/* *INDENT-ON* */\n\n/* The ASM code doesn't handle 24-bpp stretch blits */\nstatic void\ncopy_row3(Uint8 * src, int src_w, Uint8 * dst, int dst_w)\n{\n    int i;\n    int pos, inc;\n    Uint8 pixel[3] = { 0, 0, 0 };\n\n    pos = 0x10000;\n    inc = (src_w << 16) / dst_w;\n    for (i = dst_w; i > 0; --i) {\n        while (pos >= 0x10000L) {\n            pixel[0] = *src++;\n            pixel[1] = *src++;\n            pixel[2] = *src++;\n            pos -= 0x10000L;\n        }\n        *dst++ = pixel[0];\n        *dst++ = pixel[1];\n        *dst++ = pixel[2];\n        pos += inc;\n    }\n}\n\n/* Perform a stretch blit between two surfaces of the same format.\n   NOTE:  This function is not safe to call from multiple threads!\n*/\nint\nSDL_SoftStretch(SDL_Surface * src, const SDL_Rect * srcrect,\n                SDL_Surface * dst, const SDL_Rect * dstrect)\n{\n    int src_locked;\n    int dst_locked;\n    int pos, inc;\n    int dst_maxrow;\n    int src_row, dst_row;\n    Uint8 *srcp = NULL;\n    Uint8 *dstp;\n    SDL_Rect full_src;\n    SDL_Rect full_dst;\n#ifdef USE_ASM_STRETCH\n    SDL_bool use_asm = SDL_TRUE;\n#ifdef __GNUC__\n    int u1, u2;\n#endif\n#endif /* USE_ASM_STRETCH */\n    const int bpp = dst->format->BytesPerPixel;\n\n    if (src->format->format != dst->format->format) {\n        return SDL_SetError(\"Only works with same format surfaces\");\n    }\n\n    /* Verify the blit rectangles */\n    if (srcrect) {\n        if ((srcrect->x < 0) || (srcrect->y < 0) ||\n            ((srcrect->x + srcrect->w) > src->w) ||\n            ((srcrect->y + srcrect->h) > src->h)) {\n            return SDL_SetError(\"Invalid source blit rectangle\");\n        }\n    } else {\n        full_src.x = 0;\n        full_src.y = 0;\n        full_src.w = src->w;\n        full_src.h = src->h;\n        srcrect = &full_src;\n    }\n    if (dstrect) {\n        if ((dstrect->x < 0) || (dstrect->y < 0) ||\n            ((dstrect->x + dstrect->w) > dst->w) ||\n            ((dstrect->y + dstrect->h) > dst->h)) {\n            return SDL_SetError(\"Invalid destination blit rectangle\");\n        }\n    } else {\n        full_dst.x = 0;\n        full_dst.y = 0;\n        full_dst.w = dst->w;\n        full_dst.h = dst->h;\n        dstrect = &full_dst;\n    }\n\n    /* Lock the destination if it's in hardware */\n    dst_locked = 0;\n    if (SDL_MUSTLOCK(dst)) {\n        if (SDL_LockSurface(dst) < 0) {\n            return SDL_SetError(\"Unable to lock destination surface\");\n        }\n        dst_locked = 1;\n    }\n    /* Lock the source if it's in hardware */\n    src_locked = 0;\n    if (SDL_MUSTLOCK(src)) {\n        if (SDL_LockSurface(src) < 0) {\n            if (dst_locked) {\n                SDL_UnlockSurface(dst);\n            }\n            return SDL_SetError(\"Unable to lock source surface\");\n        }\n        src_locked = 1;\n    }\n\n    /* Set up the data... */\n    pos = 0x10000;\n    inc = (srcrect->h << 16) / dstrect->h;\n    src_row = srcrect->y;\n    dst_row = dstrect->y;\n\n#ifdef USE_ASM_STRETCH\n    /* Write the opcodes for this stretch */\n    if ((bpp == 3) || (generate_rowbytes(srcrect->w, dstrect->w, bpp) < 0)) {\n        use_asm = SDL_FALSE;\n    }\n#endif\n\n    /* Perform the stretch blit */\n    for (dst_maxrow = dst_row + dstrect->h; dst_row < dst_maxrow; ++dst_row) {\n        dstp = (Uint8 *) dst->pixels + (dst_row * dst->pitch)\n            + (dstrect->x * bpp);\n        while (pos >= 0x10000L) {\n            srcp = (Uint8 *) src->pixels + (src_row * src->pitch)\n                + (srcrect->x * bpp);\n            ++src_row;\n            pos -= 0x10000L;\n        }\n#ifdef USE_ASM_STRETCH\n        if (use_asm) {\n#ifdef __GNUC__\n            __asm__ __volatile__(\"call *%4\":\"=&D\"(u1), \"=&S\"(u2)\n                                 :\"0\"(dstp), \"1\"(srcp), \"r\"(copy_row)\n                                 :\"memory\");\n#elif defined(_MSC_VER) || defined(__WATCOMC__)\n            /* *INDENT-OFF* */\n            {\n                void *code = copy_row;\n                __asm {\n                    push edi\n                    push esi\n                    mov edi, dstp\n                    mov esi, srcp\n                    call dword ptr code\n                    pop esi\n                    pop edi\n                }\n            }\n            /* *INDENT-ON* */\n#else\n#error Need inline assembly for this compiler\n#endif\n        } else\n#endif\n            switch (bpp) {\n            case 1:\n                copy_row1(srcp, srcrect->w, dstp, dstrect->w);\n                break;\n            case 2:\n                copy_row2((Uint16 *) srcp, srcrect->w,\n                          (Uint16 *) dstp, dstrect->w);\n                break;\n            case 3:\n                copy_row3(srcp, srcrect->w, dstp, dstrect->w);\n                break;\n            case 4:\n                copy_row4((Uint32 *) srcp, srcrect->w,\n                          (Uint32 *) dstp, dstrect->w);\n                break;\n            }\n        pos += inc;\n    }\n\n    /* We need to unlock the surfaces if they're locked */\n    if (dst_locked) {\n        SDL_UnlockSurface(dst);\n    }\n    if (src_locked) {\n        SDL_UnlockSurface(src);\n    }\n    return (0);\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../SDL_internal.h\"\n\n#include \"SDL_video.h\"\n#include \"SDL_sysvideo.h\"\n#include \"SDL_blit.h\"\n#include \"SDL_RLEaccel_c.h\"\n#include \"SDL_pixels_c.h\"\n\n/* Public routines */\n/*\n * Create an empty RGB surface of the appropriate depth\n */\nSDL_Surface *\nSDL_CreateRGBSurface(Uint32 flags,\n                     int width, int height, int depth,\n                     Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask)\n{\n    SDL_Surface *surface;\n    Uint32 format;\n\n    /* The flags are no longer used, make the compiler happy */\n    (void)flags;\n\n    /* Get the pixel format */\n    format = SDL_MasksToPixelFormatEnum(depth, Rmask, Gmask, Bmask, Amask);\n    if (format == SDL_PIXELFORMAT_UNKNOWN) {\n        SDL_SetError(\"Unknown pixel format\");\n        return NULL;\n    }\n\n    /* Allocate the surface */\n    surface = (SDL_Surface *) SDL_calloc(1, sizeof(*surface));\n    if (surface == NULL) {\n        SDL_OutOfMemory();\n        return NULL;\n    }\n\n    surface->format = SDL_AllocFormat(format);\n    if (!surface->format) {\n        SDL_FreeSurface(surface);\n        return NULL;\n    }\n    surface->w = width;\n    surface->h = height;\n    surface->pitch = SDL_CalculatePitch(surface);\n    SDL_SetClipRect(surface, NULL);\n\n    if (SDL_ISPIXELFORMAT_INDEXED(surface->format->format)) {\n        SDL_Palette *palette =\n            SDL_AllocPalette((1 << surface->format->BitsPerPixel));\n        if (!palette) {\n            SDL_FreeSurface(surface);\n            return NULL;\n        }\n        if (palette->ncolors == 2) {\n            /* Create a black and white bitmap palette */\n            palette->colors[0].r = 0xFF;\n            palette->colors[0].g = 0xFF;\n            palette->colors[0].b = 0xFF;\n            palette->colors[1].r = 0x00;\n            palette->colors[1].g = 0x00;\n            palette->colors[1].b = 0x00;\n        }\n        SDL_SetSurfacePalette(surface, palette);\n        SDL_FreePalette(palette);\n    }\n\n    /* Get the pixels */\n    if (surface->w && surface->h) {\n        surface->pixels = SDL_malloc(surface->h * surface->pitch);\n        if (!surface->pixels) {\n            SDL_FreeSurface(surface);\n            SDL_OutOfMemory();\n            return NULL;\n        }\n        /* This is important for bitmaps */\n        SDL_memset(surface->pixels, 0, surface->h * surface->pitch);\n    }\n\n    /* Allocate an empty mapping */\n    surface->map = SDL_AllocBlitMap();\n    if (!surface->map) {\n        SDL_FreeSurface(surface);\n        return NULL;\n    }\n\n    /* By default surface with an alpha mask are set up for blending */\n    if (Amask) {\n        SDL_SetSurfaceBlendMode(surface, SDL_BLENDMODE_BLEND);\n    }\n\n    /* The surface is ready to go */\n    surface->refcount = 1;\n    return surface;\n}\n\n/*\n * Create an RGB surface from an existing memory buffer\n */\nSDL_Surface *\nSDL_CreateRGBSurfaceFrom(void *pixels,\n                         int width, int height, int depth, int pitch,\n                         Uint32 Rmask, Uint32 Gmask, Uint32 Bmask,\n                         Uint32 Amask)\n{\n    SDL_Surface *surface;\n\n    surface =\n        SDL_CreateRGBSurface(0, 0, 0, depth, Rmask, Gmask, Bmask, Amask);\n    if (surface != NULL) {\n        surface->flags |= SDL_PREALLOC;\n        surface->pixels = pixels;\n        surface->w = width;\n        surface->h = height;\n        surface->pitch = pitch;\n        SDL_SetClipRect(surface, NULL);\n    }\n    return surface;\n}\n\nint\nSDL_SetSurfacePalette(SDL_Surface * surface, SDL_Palette * palette)\n{\n    if (!surface) {\n        return SDL_SetError(\"SDL_SetSurfacePalette() passed a NULL surface\");\n    }\n    if (SDL_SetPixelFormatPalette(surface->format, palette) < 0) {\n        return -1;\n    }\n    SDL_InvalidateMap(surface->map);\n\n    return 0;\n}\n\nint\nSDL_SetSurfaceRLE(SDL_Surface * surface, int flag)\n{\n    int flags;\n\n    if (!surface) {\n        return -1;\n    }\n\n    flags = surface->map->info.flags;\n    if (flag) {\n        surface->map->info.flags |= SDL_COPY_RLE_DESIRED;\n    } else {\n        surface->map->info.flags &= ~SDL_COPY_RLE_DESIRED;\n    }\n    if (surface->map->info.flags != flags) {\n        SDL_InvalidateMap(surface->map);\n    }\n    return 0;\n}\n\nint\nSDL_SetColorKey(SDL_Surface * surface, int flag, Uint32 key)\n{\n    int flags;\n\n    if (!surface) {\n        return SDL_InvalidParamError(\"surface\");\n    }\n\n    if (surface->format->palette && key >= ((Uint32) surface->format->palette->ncolors)) {\n        return SDL_InvalidParamError(\"key\");\n    }\n\n    if (flag & SDL_RLEACCEL) {\n        SDL_SetSurfaceRLE(surface, 1);\n    }\n\n    flags = surface->map->info.flags;\n    if (flag) {\n        surface->map->info.flags |= SDL_COPY_COLORKEY;\n        surface->map->info.colorkey = key;\n        if (surface->format->palette) {\n            surface->format->palette->colors[surface->map->info.colorkey].a = SDL_ALPHA_TRANSPARENT;\n            ++surface->format->palette->version;\n            if (!surface->format->palette->version) {\n                surface->format->palette->version = 1;\n            }\n        }\n    } else {\n        if (surface->format->palette) {\n            surface->format->palette->colors[surface->map->info.colorkey].a = SDL_ALPHA_OPAQUE;\n            ++surface->format->palette->version;\n            if (!surface->format->palette->version) {\n                surface->format->palette->version = 1;\n            }\n        }\n        surface->map->info.flags &= ~SDL_COPY_COLORKEY;\n    }\n    if (surface->map->info.flags != flags) {\n        SDL_InvalidateMap(surface->map);\n    }\n\n    return 0;\n}\n\nint\nSDL_GetColorKey(SDL_Surface * surface, Uint32 * key)\n{\n    if (!surface) {\n        return -1;\n    }\n\n    if (!(surface->map->info.flags & SDL_COPY_COLORKEY)) {\n        return -1;\n    }\n\n    if (key) {\n        *key = surface->map->info.colorkey;\n    }\n    return 0;\n}\n\n/* This is a fairly slow function to switch from colorkey to alpha */\nstatic void\nSDL_ConvertColorkeyToAlpha(SDL_Surface * surface)\n{\n    int x, y;\n\n    if (!surface) {\n        return;\n    }\n\n    if (!(surface->map->info.flags & SDL_COPY_COLORKEY) ||\n        !surface->format->Amask) {\n        return;\n    }\n\n    SDL_LockSurface(surface);\n\n    switch (surface->format->BytesPerPixel) {\n    case 2:\n        {\n            Uint16 *row, *spot;\n            Uint16 ckey = (Uint16) surface->map->info.colorkey;\n            Uint16 mask = (Uint16) (~surface->format->Amask);\n\n            /* Ignore alpha in colorkey comparison */\n            ckey &= mask;\n            row = (Uint16 *) surface->pixels;\n            for (y = surface->h; y--;) {\n                spot = row;\n                for (x = surface->w; x--;) {\n                    if ((*spot & mask) == ckey) {\n                        *spot &= mask;\n                    }\n                    ++spot;\n                }\n                row += surface->pitch / 2;\n            }\n        }\n        break;\n    case 3:\n        /* FIXME */\n        break;\n    case 4:\n        {\n            Uint32 *row, *spot;\n            Uint32 ckey = surface->map->info.colorkey;\n            Uint32 mask = ~surface->format->Amask;\n\n            /* Ignore alpha in colorkey comparison */\n            ckey &= mask;\n            row = (Uint32 *) surface->pixels;\n            for (y = surface->h; y--;) {\n                spot = row;\n                for (x = surface->w; x--;) {\n                    if ((*spot & mask) == ckey) {\n                        *spot &= mask;\n                    }\n                    ++spot;\n                }\n                row += surface->pitch / 4;\n            }\n        }\n        break;\n    }\n\n    SDL_UnlockSurface(surface);\n\n    SDL_SetColorKey(surface, 0, 0);\n    SDL_SetSurfaceBlendMode(surface, SDL_BLENDMODE_BLEND);\n}\n\nint\nSDL_SetSurfaceColorMod(SDL_Surface * surface, Uint8 r, Uint8 g, Uint8 b)\n{\n    int flags;\n\n    if (!surface) {\n        return -1;\n    }\n\n    surface->map->info.r = r;\n    surface->map->info.g = g;\n    surface->map->info.b = b;\n\n    flags = surface->map->info.flags;\n    if (r != 0xFF || g != 0xFF || b != 0xFF) {\n        surface->map->info.flags |= SDL_COPY_MODULATE_COLOR;\n    } else {\n        surface->map->info.flags &= ~SDL_COPY_MODULATE_COLOR;\n    }\n    if (surface->map->info.flags != flags) {\n        SDL_InvalidateMap(surface->map);\n    }\n    return 0;\n}\n\n\nint\nSDL_GetSurfaceColorMod(SDL_Surface * surface, Uint8 * r, Uint8 * g, Uint8 * b)\n{\n    if (!surface) {\n        return -1;\n    }\n\n    if (r) {\n        *r = surface->map->info.r;\n    }\n    if (g) {\n        *g = surface->map->info.g;\n    }\n    if (b) {\n        *b = surface->map->info.b;\n    }\n    return 0;\n}\n\nint\nSDL_SetSurfaceAlphaMod(SDL_Surface * surface, Uint8 alpha)\n{\n    int flags;\n\n    if (!surface) {\n        return -1;\n    }\n\n    surface->map->info.a = alpha;\n\n    flags = surface->map->info.flags;\n    if (alpha != 0xFF) {\n        surface->map->info.flags |= SDL_COPY_MODULATE_ALPHA;\n    } else {\n        surface->map->info.flags &= ~SDL_COPY_MODULATE_ALPHA;\n    }\n    if (surface->map->info.flags != flags) {\n        SDL_InvalidateMap(surface->map);\n    }\n    return 0;\n}\n\nint\nSDL_GetSurfaceAlphaMod(SDL_Surface * surface, Uint8 * alpha)\n{\n    if (!surface) {\n        return -1;\n    }\n\n    if (alpha) {\n        *alpha = surface->map->info.a;\n    }\n    return 0;\n}\n\nint\nSDL_SetSurfaceBlendMode(SDL_Surface * surface, SDL_BlendMode blendMode)\n{\n    int flags, status;\n\n    if (!surface) {\n        return -1;\n    }\n\n    status = 0;\n    flags = surface->map->info.flags;\n    surface->map->info.flags &=\n        ~(SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD);\n    switch (blendMode) {\n    case SDL_BLENDMODE_NONE:\n        break;\n    case SDL_BLENDMODE_BLEND:\n        surface->map->info.flags |= SDL_COPY_BLEND;\n        break;\n    case SDL_BLENDMODE_ADD:\n        surface->map->info.flags |= SDL_COPY_ADD;\n        break;\n    case SDL_BLENDMODE_MOD:\n        surface->map->info.flags |= SDL_COPY_MOD;\n        break;\n    default:\n        status = SDL_Unsupported();\n        break;\n    }\n\n    if (surface->map->info.flags != flags) {\n        SDL_InvalidateMap(surface->map);\n    }\n\n    return status;\n}\n\nint\nSDL_GetSurfaceBlendMode(SDL_Surface * surface, SDL_BlendMode *blendMode)\n{\n    if (!surface) {\n        return -1;\n    }\n\n    if (!blendMode) {\n        return 0;\n    }\n\n    switch (surface->map->\n            info.flags & (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD)) {\n    case SDL_COPY_BLEND:\n        *blendMode = SDL_BLENDMODE_BLEND;\n        break;\n    case SDL_COPY_ADD:\n        *blendMode = SDL_BLENDMODE_ADD;\n        break;\n    case SDL_COPY_MOD:\n        *blendMode = SDL_BLENDMODE_MOD;\n        break;\n    default:\n        *blendMode = SDL_BLENDMODE_NONE;\n        break;\n    }\n    return 0;\n}\n\nSDL_bool\nSDL_SetClipRect(SDL_Surface * surface, const SDL_Rect * rect)\n{\n    SDL_Rect full_rect;\n\n    /* Don't do anything if there's no surface to act on */\n    if (!surface) {\n        return SDL_FALSE;\n    }\n\n    /* Set up the full surface rectangle */\n    full_rect.x = 0;\n    full_rect.y = 0;\n    full_rect.w = surface->w;\n    full_rect.h = surface->h;\n\n    /* Set the clipping rectangle */\n    if (!rect) {\n        surface->clip_rect = full_rect;\n        return SDL_TRUE;\n    }\n    return SDL_IntersectRect(rect, &full_rect, &surface->clip_rect);\n}\n\nvoid\nSDL_GetClipRect(SDL_Surface * surface, SDL_Rect * rect)\n{\n    if (surface && rect) {\n        *rect = surface->clip_rect;\n    }\n}\n\n/*\n * Set up a blit between two surfaces -- split into three parts:\n * The upper part, SDL_UpperBlit(), performs clipping and rectangle\n * verification.  The lower part is a pointer to a low level\n * accelerated blitting function.\n *\n * These parts are separated out and each used internally by this\n * library in the optimimum places.  They are exported so that if\n * you know exactly what you are doing, you can optimize your code\n * by calling the one(s) you need.\n */\nint\nSDL_LowerBlit(SDL_Surface * src, SDL_Rect * srcrect,\n              SDL_Surface * dst, SDL_Rect * dstrect)\n{\n    /* Check to make sure the blit mapping is valid */\n    if ((src->map->dst != dst) ||\n        (dst->format->palette &&\n         src->map->dst_palette_version != dst->format->palette->version) ||\n        (src->format->palette &&\n         src->map->src_palette_version != src->format->palette->version)) {\n        if (SDL_MapSurface(src, dst) < 0) {\n            return (-1);\n        }\n        /* just here for debugging */\n/*         printf */\n/*             (\"src = 0x%08X src->flags = %08X src->map->info.flags = %08x\\ndst = 0x%08X dst->flags = %08X dst->map->info.flags = %08X\\nsrc->map->blit = 0x%08x\\n\", */\n/*              src, dst->flags, src->map->info.flags, dst, dst->flags, */\n/*              dst->map->info.flags, src->map->blit); */\n    }\n    return (src->map->blit(src, srcrect, dst, dstrect));\n}\n\n\nint\nSDL_UpperBlit(SDL_Surface * src, const SDL_Rect * srcrect,\n              SDL_Surface * dst, SDL_Rect * dstrect)\n{\n    SDL_Rect fulldst;\n    int srcx, srcy, w, h;\n\n    /* Make sure the surfaces aren't locked */\n    if (!src || !dst) {\n        return SDL_SetError(\"SDL_UpperBlit: passed a NULL surface\");\n    }\n    if (src->locked || dst->locked) {\n        return SDL_SetError(\"Surfaces must not be locked during blit\");\n    }\n\n    /* If the destination rectangle is NULL, use the entire dest surface */\n    if (dstrect == NULL) {\n        fulldst.x = fulldst.y = 0;\n        fulldst.w = dst->w;\n        fulldst.h = dst->h;\n        dstrect = &fulldst;\n    }\n\n    /* clip the source rectangle to the source surface */\n    if (srcrect) {\n        int maxw, maxh;\n\n        srcx = srcrect->x;\n        w = srcrect->w;\n        if (srcx < 0) {\n            w += srcx;\n            dstrect->x -= srcx;\n            srcx = 0;\n        }\n        maxw = src->w - srcx;\n        if (maxw < w)\n            w = maxw;\n\n        srcy = srcrect->y;\n        h = srcrect->h;\n        if (srcy < 0) {\n            h += srcy;\n            dstrect->y -= srcy;\n            srcy = 0;\n        }\n        maxh = src->h - srcy;\n        if (maxh < h)\n            h = maxh;\n\n    } else {\n        srcx = srcy = 0;\n        w = src->w;\n        h = src->h;\n    }\n\n    /* clip the destination rectangle against the clip rectangle */\n    {\n        SDL_Rect *clip = &dst->clip_rect;\n        int dx, dy;\n\n        dx = clip->x - dstrect->x;\n        if (dx > 0) {\n            w -= dx;\n            dstrect->x += dx;\n            srcx += dx;\n        }\n        dx = dstrect->x + w - clip->x - clip->w;\n        if (dx > 0)\n            w -= dx;\n\n        dy = clip->y - dstrect->y;\n        if (dy > 0) {\n            h -= dy;\n            dstrect->y += dy;\n            srcy += dy;\n        }\n        dy = dstrect->y + h - clip->y - clip->h;\n        if (dy > 0)\n            h -= dy;\n    }\n\n    /* Switch back to a fast blit if we were previously stretching */\n    if (src->map->info.flags & SDL_COPY_NEAREST) {\n        src->map->info.flags &= ~SDL_COPY_NEAREST;\n        SDL_InvalidateMap(src->map);\n    }\n\n    if (w > 0 && h > 0) {\n        SDL_Rect sr;\n        sr.x = srcx;\n        sr.y = srcy;\n        sr.w = dstrect->w = w;\n        sr.h = dstrect->h = h;\n        return SDL_LowerBlit(src, &sr, dst, dstrect);\n    }\n    dstrect->w = dstrect->h = 0;\n    return 0;\n}\n\nint\nSDL_UpperBlitScaled(SDL_Surface * src, const SDL_Rect * srcrect,\n              SDL_Surface * dst, SDL_Rect * dstrect)\n{\n    double src_x0, src_y0, src_x1, src_y1;\n    double dst_x0, dst_y0, dst_x1, dst_y1;\n    SDL_Rect final_src, final_dst;\n    double scaling_w, scaling_h;\n    int src_w, src_h;\n    int dst_w, dst_h;\n\n    /* Make sure the surfaces aren't locked */\n    if (!src || !dst) {\n        return SDL_SetError(\"SDL_UpperBlitScaled: passed a NULL surface\");\n    }\n    if (src->locked || dst->locked) {\n        return SDL_SetError(\"Surfaces must not be locked during blit\");\n    }\n\n    if (NULL == srcrect) {\n        src_w = src->w;\n        src_h = src->h;\n    } else {\n        src_w = srcrect->w;\n        src_h = srcrect->h;\n    }\n\n    if (NULL == dstrect) {\n        dst_w = dst->w;\n        dst_h = dst->h;\n    } else {\n        dst_w = dstrect->w;\n        dst_h = dstrect->h;\n    }\n\n    if (dst_w == src_w && dst_h == src_h) {\n        /* No scaling, defer to regular blit */\n        return SDL_BlitSurface(src, srcrect, dst, dstrect);\n    }\n\n    scaling_w = (double)dst_w / src_w;\n    scaling_h = (double)dst_h / src_h;\n\n    if (NULL == dstrect) {\n        dst_x0 = 0;\n        dst_y0 = 0;\n        dst_x1 = dst_w - 1;\n        dst_y1 = dst_h - 1;\n    } else {\n        dst_x0 = dstrect->x;\n        dst_y0 = dstrect->y;\n        dst_x1 = dst_x0 + dst_w - 1;\n        dst_y1 = dst_y0 + dst_h - 1;\n    }\n\n    if (NULL == srcrect) {\n        src_x0 = 0;\n        src_y0 = 0;\n        src_x1 = src_w - 1;\n        src_y1 = src_h - 1;\n    } else {\n        src_x0 = srcrect->x;\n        src_y0 = srcrect->y;\n        src_x1 = src_x0 + src_w - 1;\n        src_y1 = src_y0 + src_h - 1;\n\n        /* Clip source rectangle to the source surface */\n\n        if (src_x0 < 0) {\n            dst_x0 -= src_x0 * scaling_w;\n            src_x0 = 0;\n        }\n\n        if (src_x1 >= src->w) {\n            dst_x1 -= (src_x1 - src->w + 1) * scaling_w;\n            src_x1 = src->w - 1;\n        }\n\n        if (src_y0 < 0) {\n            dst_y0 -= src_y0 * scaling_h;\n            src_y0 = 0;\n        }\n\n        if (src_y1 >= src->h) {\n            dst_y1 -= (src_y1 - src->h + 1) * scaling_h;\n            src_y1 = src->h - 1;\n        }\n    }\n\n    /* Clip destination rectangle to the clip rectangle */\n\n    /* Translate to clip space for easier calculations */\n    dst_x0 -= dst->clip_rect.x;\n    dst_x1 -= dst->clip_rect.x;\n    dst_y0 -= dst->clip_rect.y;\n    dst_y1 -= dst->clip_rect.y;\n\n    if (dst_x0 < 0) {\n        src_x0 -= dst_x0 / scaling_w;\n        dst_x0 = 0;\n    }\n\n    if (dst_x1 >= dst->clip_rect.w) {\n        src_x1 -= (dst_x1 - dst->clip_rect.w + 1) / scaling_w;\n        dst_x1 = dst->clip_rect.w - 1;\n    }\n\n    if (dst_y0 < 0) {\n        src_y0 -= dst_y0 / scaling_h;\n        dst_y0 = 0;\n    }\n\n    if (dst_y1 >= dst->clip_rect.h) {\n        src_y1 -= (dst_y1 - dst->clip_rect.h + 1) / scaling_h;\n        dst_y1 = dst->clip_rect.h - 1;\n    }\n\n    /* Translate back to surface coordinates */\n    dst_x0 += dst->clip_rect.x;\n    dst_x1 += dst->clip_rect.x;\n    dst_y0 += dst->clip_rect.y;\n    dst_y1 += dst->clip_rect.y;\n\n    final_src.x = (int)SDL_floor(src_x0 + 0.5);\n    final_src.y = (int)SDL_floor(src_y0 + 0.5);\n    final_src.w = (int)SDL_floor(src_x1 - src_x0 + 1.5);\n    final_src.h = (int)SDL_floor(src_y1 - src_y0 + 1.5);\n\n    final_dst.x = (int)SDL_floor(dst_x0 + 0.5);\n    final_dst.y = (int)SDL_floor(dst_y0 + 0.5);\n    final_dst.w = (int)SDL_floor(dst_x1 - dst_x0 + 1.5);\n    final_dst.h = (int)SDL_floor(dst_y1 - dst_y0 + 1.5);\n\n    if (final_dst.w < 0)\n        final_dst.w = 0;\n    if (final_dst.h < 0)\n        final_dst.h = 0;\n\n    if (dstrect)\n        *dstrect = final_dst;\n\n    if (final_dst.w == 0 || final_dst.h == 0 ||\n        final_src.w <= 0 || final_src.h <= 0) {\n        /* No-op. */\n        return 0;\n    }\n\n    return SDL_LowerBlitScaled(src, &final_src, dst, &final_dst);\n}\n\n/**\n *  This is a semi-private blit function and it performs low-level surface\n *  scaled blitting only.\n */\nint\nSDL_LowerBlitScaled(SDL_Surface * src, SDL_Rect * srcrect,\n                SDL_Surface * dst, SDL_Rect * dstrect)\n{\n    static const Uint32 complex_copy_flags = (\n        SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA |\n        SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD |\n        SDL_COPY_COLORKEY\n    );\n\n    if (!(src->map->info.flags & SDL_COPY_NEAREST)) {\n        src->map->info.flags |= SDL_COPY_NEAREST;\n        SDL_InvalidateMap(src->map);\n    }\n\n    if ( !(src->map->info.flags & complex_copy_flags) &&\n         src->format->format == dst->format->format &&\n         !SDL_ISPIXELFORMAT_INDEXED(src->format->format) ) {\n        return SDL_SoftStretch( src, srcrect, dst, dstrect );\n    } else {\n        return SDL_LowerBlit( src, srcrect, dst, dstrect );\n    }\n}\n\n/*\n * Lock a surface to directly access the pixels\n */\nint\nSDL_LockSurface(SDL_Surface * surface)\n{\n    if (!surface->locked) {\n        /* Perform the lock */\n        if (surface->flags & SDL_RLEACCEL) {\n            SDL_UnRLESurface(surface, 1);\n            surface->flags |= SDL_RLEACCEL;     /* save accel'd state */\n        }\n    }\n\n    /* Increment the surface lock count, for recursive locks */\n    ++surface->locked;\n\n    /* Ready to go.. */\n    return (0);\n}\n\n/*\n * Unlock a previously locked surface\n */\nvoid\nSDL_UnlockSurface(SDL_Surface * surface)\n{\n    /* Only perform an unlock if we are locked */\n    if (!surface->locked || (--surface->locked > 0)) {\n        return;\n    }\n\n    /* Update RLE encoded surface with new data */\n    if ((surface->flags & SDL_RLEACCEL) == SDL_RLEACCEL) {\n        surface->flags &= ~SDL_RLEACCEL;        /* stop lying */\n        SDL_RLESurface(surface);\n    }\n}\n\n/*\n * Convert a surface into the specified pixel format.\n */\nSDL_Surface *\nSDL_ConvertSurface(SDL_Surface * surface, const SDL_PixelFormat * format,\n                   Uint32 flags)\n{\n    SDL_Surface *convert;\n    Uint32 copy_flags;\n    SDL_Color copy_color;\n    SDL_Rect bounds;\n\n    /* Check for empty destination palette! (results in empty image) */\n    if (format->palette != NULL) {\n        int i;\n        for (i = 0; i < format->palette->ncolors; ++i) {\n            if ((format->palette->colors[i].r != 0xFF) ||\n                (format->palette->colors[i].g != 0xFF) ||\n                (format->palette->colors[i].b != 0xFF))\n                break;\n        }\n        if (i == format->palette->ncolors) {\n            SDL_SetError(\"Empty destination palette\");\n            return (NULL);\n        }\n    }\n\n    /* Create a new surface with the desired format */\n    convert = SDL_CreateRGBSurface(flags, surface->w, surface->h,\n                                   format->BitsPerPixel, format->Rmask,\n                                   format->Gmask, format->Bmask,\n                                   format->Amask);\n    if (convert == NULL) {\n        return (NULL);\n    }\n\n    /* Copy the palette if any */\n    if (format->palette && convert->format->palette) {\n        SDL_memcpy(convert->format->palette->colors,\n                   format->palette->colors,\n                   format->palette->ncolors * sizeof(SDL_Color));\n        convert->format->palette->ncolors = format->palette->ncolors;\n    }\n\n    /* Save the original copy flags */\n    copy_flags = surface->map->info.flags;\n    copy_color.r = surface->map->info.r;\n    copy_color.g = surface->map->info.g;\n    copy_color.b = surface->map->info.b;\n    copy_color.a = surface->map->info.a;\n    surface->map->info.r = 0xFF;\n    surface->map->info.g = 0xFF;\n    surface->map->info.b = 0xFF;\n    surface->map->info.a = 0xFF;\n    surface->map->info.flags = 0;\n    SDL_InvalidateMap(surface->map);\n\n    /* Copy over the image data */\n    bounds.x = 0;\n    bounds.y = 0;\n    bounds.w = surface->w;\n    bounds.h = surface->h;\n    SDL_LowerBlit(surface, &bounds, convert, &bounds);\n\n    /* Clean up the original surface, and update converted surface */\n    convert->map->info.r = copy_color.r;\n    convert->map->info.g = copy_color.g;\n    convert->map->info.b = copy_color.b;\n    convert->map->info.a = copy_color.a;\n    convert->map->info.flags =\n        (copy_flags &\n         ~(SDL_COPY_COLORKEY | SDL_COPY_BLEND\n           | SDL_COPY_RLE_DESIRED | SDL_COPY_RLE_COLORKEY |\n           SDL_COPY_RLE_ALPHAKEY));\n    surface->map->info.r = copy_color.r;\n    surface->map->info.g = copy_color.g;\n    surface->map->info.b = copy_color.b;\n    surface->map->info.a = copy_color.a;\n    surface->map->info.flags = copy_flags;\n    SDL_InvalidateMap(surface->map);\n    if (copy_flags & SDL_COPY_COLORKEY) {\n        SDL_bool set_colorkey_by_color = SDL_FALSE;\n\n        if (surface->format->palette) {\n            if (format->palette &&\n                surface->format->palette->ncolors <= format->palette->ncolors &&\n                (SDL_memcmp(surface->format->palette->colors, format->palette->colors,\n                  surface->format->palette->ncolors * sizeof(SDL_Color)) == 0)) {\n                /* The palette is identical, just set the same colorkey */\n                SDL_SetColorKey(convert, 1, surface->map->info.colorkey);\n            } else if (format->Amask) {\n                /* The alpha was set in the destination from the palette */\n            } else {\n                set_colorkey_by_color = SDL_TRUE;\n            }\n        } else {\n            set_colorkey_by_color = SDL_TRUE;\n        }\n\n        if (set_colorkey_by_color) {\n            /* Set the colorkey by color, which needs to be unique */\n            Uint8 keyR, keyG, keyB, keyA;\n\n            SDL_GetRGBA(surface->map->info.colorkey, surface->format, &keyR,\n                        &keyG, &keyB, &keyA);\n            SDL_SetColorKey(convert, 1,\n                            SDL_MapRGBA(convert->format, keyR, keyG, keyB, keyA));\n            /* This is needed when converting for 3D texture upload */\n            SDL_ConvertColorkeyToAlpha(convert);\n        }\n    }\n    SDL_SetClipRect(convert, &surface->clip_rect);\n\n    /* Enable alpha blending by default if the new surface has an\n     * alpha channel or alpha modulation */\n    if ((surface->format->Amask && format->Amask) ||\n        (copy_flags & (SDL_COPY_COLORKEY|SDL_COPY_MODULATE_ALPHA))) {\n        SDL_SetSurfaceBlendMode(convert, SDL_BLENDMODE_BLEND);\n    }\n    if ((copy_flags & SDL_COPY_RLE_DESIRED) || (flags & SDL_RLEACCEL)) {\n        SDL_SetSurfaceRLE(convert, SDL_RLEACCEL);\n    }\n\n    /* We're ready to go! */\n    return (convert);\n}\n\nSDL_Surface *\nSDL_ConvertSurfaceFormat(SDL_Surface * surface, Uint32 pixel_format,\n                         Uint32 flags)\n{\n    SDL_PixelFormat *fmt;\n    SDL_Surface *convert = NULL;\n\n    fmt = SDL_AllocFormat(pixel_format);\n    if (fmt) {\n        convert = SDL_ConvertSurface(surface, fmt, flags);\n        SDL_FreeFormat(fmt);\n    }\n    return convert;\n}\n\n/*\n * Create a surface on the stack for quick blit operations\n */\nstatic SDL_INLINE SDL_bool\nSDL_CreateSurfaceOnStack(int width, int height, Uint32 pixel_format,\n                         void * pixels, int pitch, SDL_Surface * surface,\n                         SDL_PixelFormat * format, SDL_BlitMap * blitmap)\n{\n    if (SDL_ISPIXELFORMAT_INDEXED(pixel_format)) {\n        SDL_SetError(\"Indexed pixel formats not supported\");\n        return SDL_FALSE;\n    }\n    if (SDL_InitFormat(format, pixel_format) < 0) {\n        return SDL_FALSE;\n    }\n\n    SDL_zerop(surface);\n    surface->flags = SDL_PREALLOC;\n    surface->format = format;\n    surface->pixels = pixels;\n    surface->w = width;\n    surface->h = height;\n    surface->pitch = pitch;\n    /* We don't actually need to set up the clip rect for our purposes */\n    /* SDL_SetClipRect(surface, NULL); */\n\n    /* Allocate an empty mapping */\n    SDL_zerop(blitmap);\n    blitmap->info.r = 0xFF;\n    blitmap->info.g = 0xFF;\n    blitmap->info.b = 0xFF;\n    blitmap->info.a = 0xFF;\n    surface->map = blitmap;\n\n    /* The surface is ready to go */\n    surface->refcount = 1;\n    return SDL_TRUE;\n}\n\n/*\n * Copy a block of pixels of one format to another format\n */\nint SDL_ConvertPixels(int width, int height,\n                      Uint32 src_format, const void * src, int src_pitch,\n                      Uint32 dst_format, void * dst, int dst_pitch)\n{\n    SDL_Surface src_surface, dst_surface;\n    SDL_PixelFormat src_fmt, dst_fmt;\n    SDL_BlitMap src_blitmap, dst_blitmap;\n    SDL_Rect rect;\n    void *nonconst_src = (void *) src;\n\n    /* Check to make sure we are blitting somewhere, so we don't crash */\n    if (!dst) {\n        return SDL_InvalidParamError(\"dst\");\n    }\n    if (!dst_pitch) {\n        return SDL_InvalidParamError(\"dst_pitch\");\n    }\n\n    /* Fast path for same format copy */\n    if (src_format == dst_format) {\n        int bpp, i;\n\n        if (SDL_ISPIXELFORMAT_FOURCC(src_format)) {\n            switch (src_format) {\n            case SDL_PIXELFORMAT_YUY2:\n            case SDL_PIXELFORMAT_UYVY:\n            case SDL_PIXELFORMAT_YVYU:\n                bpp = 2;\n                break;\n            case SDL_PIXELFORMAT_YV12:\n            case SDL_PIXELFORMAT_IYUV:\n            case SDL_PIXELFORMAT_NV12:\n            case SDL_PIXELFORMAT_NV21:\n                bpp = 1;\n                break;\n            default:\n                return SDL_SetError(\"Unknown FOURCC pixel format\");\n            }\n        } else {\n            bpp = SDL_BYTESPERPIXEL(src_format);\n        }\n        width *= bpp;\n\n        for (i = height; i--;) {\n            SDL_memcpy(dst, src, width);\n            src = (Uint8*)src + src_pitch;\n            dst = (Uint8*)dst + dst_pitch;\n        }\n\n        if (src_format == SDL_PIXELFORMAT_YV12 || src_format == SDL_PIXELFORMAT_IYUV) {\n            /* U and V planes are a quarter the size of the Y plane */\n            width /= 2;\n            height /= 2;\n            src_pitch /= 2;\n            dst_pitch /= 2;\n            for (i = height * 2; i--;) {\n                SDL_memcpy(dst, src, width);\n                src = (Uint8*)src + src_pitch;\n                dst = (Uint8*)dst + dst_pitch;\n            }\n        } else if (src_format == SDL_PIXELFORMAT_NV12 || src_format == SDL_PIXELFORMAT_NV21) {\n            /* U/V plane is half the height of the Y plane */\n            height /= 2;\n            for (i = height; i--;) {\n                SDL_memcpy(dst, src, width);\n                src = (Uint8*)src + src_pitch;\n                dst = (Uint8*)dst + dst_pitch;\n            }\n        }\n        return 0;\n    }\n\n    if (!SDL_CreateSurfaceOnStack(width, height, src_format, nonconst_src,\n                                  src_pitch,\n                                  &src_surface, &src_fmt, &src_blitmap)) {\n        return -1;\n    }\n    if (!SDL_CreateSurfaceOnStack(width, height, dst_format, dst, dst_pitch,\n                                  &dst_surface, &dst_fmt, &dst_blitmap)) {\n        return -1;\n    }\n\n    /* Set up the rect and go! */\n    rect.x = 0;\n    rect.y = 0;\n    rect.w = width;\n    rect.h = height;\n    return SDL_LowerBlit(&src_surface, &rect, &dst_surface, &rect);\n}\n\n/*\n * Free a surface created by the above function.\n */\nvoid\nSDL_FreeSurface(SDL_Surface * surface)\n{\n    if (surface == NULL) {\n        return;\n    }\n    if (surface->flags & SDL_DONTFREE) {\n        return;\n    }\n    if (--surface->refcount > 0) {\n        return;\n    }\n    while (surface->locked > 0) {\n        SDL_UnlockSurface(surface);\n    }\n    if (surface->flags & SDL_RLEACCEL) {\n        SDL_UnRLESurface(surface, 0);\n    }\n    if (surface->format) {\n        SDL_SetSurfacePalette(surface, NULL);\n        SDL_FreeFormat(surface->format);\n        surface->format = NULL;\n    }\n    if (surface->map != NULL) {\n        SDL_FreeBlitMap(surface->map);\n        surface->map = NULL;\n    }\n    if (!(surface->flags & SDL_PREALLOC)) {\n        SDL_free(surface->pixels);\n    }\n    SDL_free(surface);\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../SDL_internal.h\"\n\n/* The high-level video driver subsystem */\n\n#include \"SDL.h\"\n#include \"SDL_video.h\"\n#include \"SDL_sysvideo.h\"\n#include \"SDL_blit.h\"\n#include \"SDL_pixels_c.h\"\n#include \"SDL_rect_c.h\"\n#include \"../events/SDL_events_c.h\"\n#include \"../timer/SDL_timer_c.h\"\n\n#include \"SDL_syswm.h\"\n\n#if SDL_VIDEO_OPENGL\n#include \"SDL_opengl.h\"\n#endif /* SDL_VIDEO_OPENGL */\n\n#if SDL_VIDEO_OPENGL_ES\n#include \"SDL_opengles.h\"\n#endif /* SDL_VIDEO_OPENGL_ES */\n\n/* GL and GLES2 headers conflict on Linux 32 bits */\n#if SDL_VIDEO_OPENGL_ES2 && !SDL_VIDEO_OPENGL\n#include \"SDL_opengles2.h\"\n#endif /* SDL_VIDEO_OPENGL_ES2 && !SDL_VIDEO_OPENGL */\n\n#ifndef GL_CONTEXT_RELEASE_BEHAVIOR_KHR\n#define GL_CONTEXT_RELEASE_BEHAVIOR_KHR 0x82FB\n#endif\n\n/* On Windows, windows.h defines CreateWindow */\n#ifdef CreateWindow\n#undef CreateWindow\n#endif\n\n/* Available video drivers */\nstatic VideoBootStrap *bootstrap[] = {\n#if SDL_VIDEO_DRIVER_COCOA\n    &COCOA_bootstrap,\n#endif\n#if SDL_VIDEO_DRIVER_X11\n    &X11_bootstrap,\n#endif\n#if SDL_VIDEO_DRIVER_MIR\n    &MIR_bootstrap,\n#endif\n#if SDL_VIDEO_DRIVER_WAYLAND\n    &Wayland_bootstrap,\n#endif\n#if SDL_VIDEO_DRIVER_VIVANTE\n    &VIVANTE_bootstrap,\n#endif\n#if SDL_VIDEO_DRIVER_DIRECTFB\n    &DirectFB_bootstrap,\n#endif\n#if SDL_VIDEO_DRIVER_WINDOWS\n    &WINDOWS_bootstrap,\n#endif\n#if SDL_VIDEO_DRIVER_WINRT\n    &WINRT_bootstrap,\n#endif\n#if SDL_VIDEO_DRIVER_HAIKU\n    &HAIKU_bootstrap,\n#endif\n#if SDL_VIDEO_DRIVER_PANDORA\n    &PND_bootstrap,\n#endif\n#if SDL_VIDEO_DRIVER_UIKIT\n    &UIKIT_bootstrap,\n#endif\n#if SDL_VIDEO_DRIVER_ANDROID\n    &Android_bootstrap,\n#endif\n#if SDL_VIDEO_DRIVER_PSP\n    &PSP_bootstrap,\n#endif\n#if SDL_VIDEO_DRIVER_RPI\n    &RPI_bootstrap,\n#endif \n#if SDL_VIDEO_DRIVER_NACL\n    &NACL_bootstrap,\n#endif\n#if SDL_VIDEO_DRIVER_EMSCRIPTEN\n    &Emscripten_bootstrap,\n#endif\n#if SDL_VIDEO_DRIVER_DUMMY\n    &DUMMY_bootstrap,\n#endif\n    NULL\n};\n\nstatic SDL_VideoDevice *_this = NULL;\n\n#define CHECK_WINDOW_MAGIC(window, retval) \\\n    if (!_this) { \\\n        SDL_UninitializedVideo(); \\\n        return retval; \\\n    } \\\n    if (!window || window->magic != &_this->window_magic) { \\\n        SDL_SetError(\"Invalid window\"); \\\n        return retval; \\\n    }\n\n#define CHECK_DISPLAY_INDEX(displayIndex, retval) \\\n    if (!_this) { \\\n        SDL_UninitializedVideo(); \\\n        return retval; \\\n    } \\\n    SDL_assert(_this->displays != NULL); \\\n    if (displayIndex < 0 || displayIndex >= _this->num_displays) { \\\n        SDL_SetError(\"displayIndex must be in the range 0 - %d\", \\\n                     _this->num_displays - 1); \\\n        return retval; \\\n    }\n\n#define FULLSCREEN_MASK (SDL_WINDOW_FULLSCREEN_DESKTOP | SDL_WINDOW_FULLSCREEN)\n\n#ifdef __MACOSX__\n/* Support for Mac OS X fullscreen spaces */\nextern SDL_bool Cocoa_IsWindowInFullscreenSpace(SDL_Window * window);\nextern SDL_bool Cocoa_SetWindowFullscreenSpace(SDL_Window * window, SDL_bool state);\n#endif\n\n\n/* Support for framebuffer emulation using an accelerated renderer */\n\n#define SDL_WINDOWTEXTUREDATA   \"_SDL_WindowTextureData\"\n\ntypedef struct {\n    SDL_Renderer *renderer;\n    SDL_Texture *texture;\n    void *pixels;\n    int pitch;\n    int bytes_per_pixel;\n} SDL_WindowTextureData;\n\nstatic SDL_bool\nShouldUseTextureFramebuffer()\n{\n    const char *hint;\n\n    /* If there's no native framebuffer support then there's no option */\n    if (!_this->CreateWindowFramebuffer) {\n        return SDL_TRUE;\n    }\n\n    /* If the user has specified a software renderer we can't use a\n       texture framebuffer, or renderer creation will go recursive.\n     */\n    hint = SDL_GetHint(SDL_HINT_RENDER_DRIVER);\n    if (hint && SDL_strcasecmp(hint, \"software\") == 0) {\n        return SDL_FALSE;\n    }\n\n    /* See if the user or application wants a specific behavior */\n    hint = SDL_GetHint(SDL_HINT_FRAMEBUFFER_ACCELERATION);\n    if (hint) {\n        if (*hint == '0') {\n            return SDL_FALSE;\n        } else {\n            return SDL_TRUE;\n        }\n    }\n\n    /* Each platform has different performance characteristics */\n#if defined(__WIN32__)\n    /* GDI BitBlt() is way faster than Direct3D dynamic textures right now.\n     */\n    return SDL_FALSE;\n\n#elif defined(__MACOSX__)\n    /* Mac OS X uses OpenGL as the native fast path */\n    return SDL_TRUE;\n\n#elif defined(__LINUX__)\n    /* Properly configured OpenGL drivers are faster than MIT-SHM */\n#if SDL_VIDEO_OPENGL\n    /* Ugh, find a way to cache this value! */\n    {\n        SDL_Window *window;\n        SDL_GLContext context;\n        SDL_bool hasAcceleratedOpenGL = SDL_FALSE;\n\n        window = SDL_CreateWindow(\"OpenGL test\", -32, -32, 32, 32, SDL_WINDOW_OPENGL|SDL_WINDOW_HIDDEN);\n        if (window) {\n            context = SDL_GL_CreateContext(window);\n            if (context) {\n                const GLubyte *(APIENTRY * glGetStringFunc) (GLenum);\n                const char *vendor = NULL;\n\n                glGetStringFunc = SDL_GL_GetProcAddress(\"glGetString\");\n                if (glGetStringFunc) {\n                    vendor = (const char *) glGetStringFunc(GL_VENDOR);\n                }\n                /* Add more vendors here at will... */\n                if (vendor &&\n                    (SDL_strstr(vendor, \"ATI Technologies\") ||\n                     SDL_strstr(vendor, \"NVIDIA\"))) {\n                    hasAcceleratedOpenGL = SDL_TRUE;\n                }\n                SDL_GL_DeleteContext(context);\n            }\n            SDL_DestroyWindow(window);\n        }\n        return hasAcceleratedOpenGL;\n    }\n#elif SDL_VIDEO_OPENGL_ES || SDL_VIDEO_OPENGL_ES2\n    /* Let's be optimistic about this! */\n    return SDL_TRUE;\n#else\n    return SDL_FALSE;\n#endif\n\n#else\n    /* Play it safe, assume that if there is a framebuffer driver that it's\n       optimized for the current platform.\n    */\n    return SDL_FALSE;\n#endif\n}\n\nstatic int\nSDL_CreateWindowTexture(SDL_VideoDevice *unused, SDL_Window * window, Uint32 * format, void ** pixels, int *pitch)\n{\n    SDL_WindowTextureData *data;\n\n    data = SDL_GetWindowData(window, SDL_WINDOWTEXTUREDATA);\n    if (!data) {\n        SDL_Renderer *renderer = NULL;\n        int i;\n        const char *hint = SDL_GetHint(SDL_HINT_FRAMEBUFFER_ACCELERATION);\n\n        /* Check to see if there's a specific driver requested */\n        if (hint && *hint != '0' && *hint != '1' &&\n            SDL_strcasecmp(hint, \"software\") != 0) {\n            for (i = 0; i < SDL_GetNumRenderDrivers(); ++i) {\n                SDL_RendererInfo info;\n                SDL_GetRenderDriverInfo(i, &info);\n                if (SDL_strcasecmp(info.name, hint) == 0) {\n                    renderer = SDL_CreateRenderer(window, i, 0);\n                    break;\n                }\n            }\n        }\n        \n        if (!renderer) {\n            for (i = 0; i < SDL_GetNumRenderDrivers(); ++i) {\n                SDL_RendererInfo info;\n                SDL_GetRenderDriverInfo(i, &info);\n                if (SDL_strcmp(info.name, \"software\") != 0) {\n                    renderer = SDL_CreateRenderer(window, i, 0);\n                    if (renderer) {\n                        break;\n                    }\n                }\n            }\n        }\n        if (!renderer) {\n            return SDL_SetError(\"No hardware accelerated renderers available\");\n        }\n\n        /* Create the data after we successfully create the renderer (bug #1116) */\n        data = (SDL_WindowTextureData *)SDL_calloc(1, sizeof(*data));\n        if (!data) {\n            SDL_DestroyRenderer(renderer);\n            return SDL_OutOfMemory();\n        }\n        SDL_SetWindowData(window, SDL_WINDOWTEXTUREDATA, data);\n\n        data->renderer = renderer;\n    }\n\n    /* Free any old texture and pixel data */\n    if (data->texture) {\n        SDL_DestroyTexture(data->texture);\n        data->texture = NULL;\n    }\n    SDL_free(data->pixels);\n    data->pixels = NULL;\n\n    {\n        SDL_RendererInfo info;\n        Uint32 i;\n\n        if (SDL_GetRendererInfo(data->renderer, &info) < 0) {\n            return -1;\n        }\n\n        /* Find the first format without an alpha channel */\n        *format = info.texture_formats[0];\n\n        for (i = 0; i < info.num_texture_formats; ++i) {\n            if (!SDL_ISPIXELFORMAT_FOURCC(info.texture_formats[i]) &&\n                    !SDL_ISPIXELFORMAT_ALPHA(info.texture_formats[i])) {\n                *format = info.texture_formats[i];\n                break;\n            }\n        }\n    }\n\n    data->texture = SDL_CreateTexture(data->renderer, *format,\n                                      SDL_TEXTUREACCESS_STREAMING,\n                                      window->w, window->h);\n    if (!data->texture) {\n        return -1;\n    }\n\n    /* Create framebuffer data */\n    data->bytes_per_pixel = SDL_BYTESPERPIXEL(*format);\n    data->pitch = (((window->w * data->bytes_per_pixel) + 3) & ~3);\n    data->pixels = SDL_malloc(window->h * data->pitch);\n    if (!data->pixels) {\n        return SDL_OutOfMemory();\n    }\n\n    *pixels = data->pixels;\n    *pitch = data->pitch;\n\n    /* Make sure we're not double-scaling the viewport */\n    SDL_RenderSetViewport(data->renderer, NULL);\n\n    return 0;\n}\n\nstatic int\nSDL_UpdateWindowTexture(SDL_VideoDevice *unused, SDL_Window * window, const SDL_Rect * rects, int numrects)\n{\n    SDL_WindowTextureData *data;\n    SDL_Rect rect;\n    void *src;\n\n    data = SDL_GetWindowData(window, SDL_WINDOWTEXTUREDATA);\n    if (!data || !data->texture) {\n        return SDL_SetError(\"No window texture data\");\n    }\n\n    /* Update a single rect that contains subrects for best DMA performance */\n    if (SDL_GetSpanEnclosingRect(window->w, window->h, numrects, rects, &rect)) {\n        src = (void *)((Uint8 *)data->pixels +\n                        rect.y * data->pitch +\n                        rect.x * data->bytes_per_pixel);\n        if (SDL_UpdateTexture(data->texture, &rect, src, data->pitch) < 0) {\n            return -1;\n        }\n\n        if (SDL_RenderCopy(data->renderer, data->texture, NULL, NULL) < 0) {\n            return -1;\n        }\n\n        SDL_RenderPresent(data->renderer);\n    }\n    return 0;\n}\n\nstatic void\nSDL_DestroyWindowTexture(SDL_VideoDevice *unused, SDL_Window * window)\n{\n    SDL_WindowTextureData *data;\n\n    data = SDL_SetWindowData(window, SDL_WINDOWTEXTUREDATA, NULL);\n    if (!data) {\n        return;\n    }\n    if (data->texture) {\n        SDL_DestroyTexture(data->texture);\n    }\n    if (data->renderer) {\n        SDL_DestroyRenderer(data->renderer);\n    }\n    SDL_free(data->pixels);\n    SDL_free(data);\n}\n\n\nstatic int\ncmpmodes(const void *A, const void *B)\n{\n    const SDL_DisplayMode *a = (const SDL_DisplayMode *) A;\n    const SDL_DisplayMode *b = (const SDL_DisplayMode *) B;\n    if (a == b) {\n        return 0;\n    } else if (a->w != b->w) {\n        return b->w - a->w;\n    } else if (a->h != b->h) {\n        return b->h - a->h;\n    } else if (SDL_BITSPERPIXEL(a->format) != SDL_BITSPERPIXEL(b->format)) {\n        return SDL_BITSPERPIXEL(b->format) - SDL_BITSPERPIXEL(a->format);\n    } else if (SDL_PIXELLAYOUT(a->format) != SDL_PIXELLAYOUT(b->format)) {\n        return SDL_PIXELLAYOUT(b->format) - SDL_PIXELLAYOUT(a->format);\n    } else if (a->refresh_rate != b->refresh_rate) {\n        return b->refresh_rate - a->refresh_rate;\n    }\n    return 0;\n}\n\nstatic int\nSDL_UninitializedVideo()\n{\n    return SDL_SetError(\"Video subsystem has not been initialized\");\n}\n\nint\nSDL_GetNumVideoDrivers(void)\n{\n    return SDL_arraysize(bootstrap) - 1;\n}\n\nconst char *\nSDL_GetVideoDriver(int index)\n{\n    if (index >= 0 && index < SDL_GetNumVideoDrivers()) {\n        return bootstrap[index]->name;\n    }\n    return NULL;\n}\n\n/*\n * Initialize the video and event subsystems -- determine native pixel format\n */\nint\nSDL_VideoInit(const char *driver_name)\n{\n    SDL_VideoDevice *video;\n    const char *hint;\n    int index;\n    int i;\n    SDL_bool allow_screensaver;\n\n    /* Check to make sure we don't overwrite '_this' */\n    if (_this != NULL) {\n        SDL_VideoQuit();\n    }\n\n#if !SDL_TIMERS_DISABLED\n    SDL_TicksInit();\n#endif\n\n    /* Start the event loop */\n    if (SDL_InitSubSystem(SDL_INIT_EVENTS) < 0 ||\n        SDL_KeyboardInit() < 0 ||\n        SDL_MouseInit() < 0 ||\n        SDL_TouchInit() < 0) {\n        return -1;\n    }\n\n    /* Select the proper video driver */\n    index = 0;\n    video = NULL;\n    if (driver_name == NULL) {\n        driver_name = SDL_getenv(\"SDL_VIDEODRIVER\");\n    }\n    if (driver_name != NULL) {\n        for (i = 0; bootstrap[i]; ++i) {\n            if (SDL_strncasecmp(bootstrap[i]->name, driver_name, SDL_strlen(driver_name)) == 0) {\n                if (bootstrap[i]->available()) {\n                    video = bootstrap[i]->create(index);\n                    break;\n                }\n            }\n        }\n    } else {\n        for (i = 0; bootstrap[i]; ++i) {\n            if (bootstrap[i]->available()) {\n                video = bootstrap[i]->create(index);\n                if (video != NULL) {\n                    break;\n                }\n            }\n        }\n    }\n    if (video == NULL) {\n        if (driver_name) {\n            return SDL_SetError(\"%s not available\", driver_name);\n        }\n        return SDL_SetError(\"No available video device\");\n    }\n    _this = video;\n    _this->name = bootstrap[i]->name;\n    _this->next_object_id = 1;\n\n\n    /* Set some very sane GL defaults */\n    _this->gl_config.driver_loaded = 0;\n    _this->gl_config.dll_handle = NULL;\n    SDL_GL_ResetAttributes();\n\n    _this->current_glwin_tls = SDL_TLSCreate();\n    _this->current_glctx_tls = SDL_TLSCreate();\n\n    /* Initialize the video subsystem */\n    if (_this->VideoInit(_this) < 0) {\n        SDL_VideoQuit();\n        return -1;\n    }\n\n    /* Make sure some displays were added */\n    if (_this->num_displays == 0) {\n        SDL_VideoQuit();\n        return SDL_SetError(\"The video driver did not add any displays\");\n    }\n\n    /* Add the renderer framebuffer emulation if desired */\n    if (ShouldUseTextureFramebuffer()) {\n        _this->CreateWindowFramebuffer = SDL_CreateWindowTexture;\n        _this->UpdateWindowFramebuffer = SDL_UpdateWindowTexture;\n        _this->DestroyWindowFramebuffer = SDL_DestroyWindowTexture;\n    }\n\n    /* Disable the screen saver by default. This is a change from <= 2.0.1,\n       but most things using SDL are games or media players; you wouldn't\n       want a screensaver to trigger if you're playing exclusively with a\n       joystick, or passively watching a movie. Things that use SDL but\n       function more like a normal desktop app should explicitly reenable the\n       screensaver. */\n    hint = SDL_GetHint(SDL_HINT_VIDEO_ALLOW_SCREENSAVER);\n    if (hint) {\n        allow_screensaver = SDL_atoi(hint) ? SDL_TRUE : SDL_FALSE;\n    } else {\n        allow_screensaver = SDL_FALSE;\n    }\n    if (!allow_screensaver) {\n        SDL_DisableScreenSaver();\n    }\n\n    /* If we don't use a screen keyboard, turn on text input by default,\n       otherwise programs that expect to get text events without enabling\n       UNICODE input won't get any events.\n\n       Actually, come to think of it, you needed to call SDL_EnableUNICODE(1)\n       in SDL 1.2 before you got text input events.  Hmm...\n     */\n    if (!SDL_HasScreenKeyboardSupport()) {\n        SDL_StartTextInput();\n    }\n\n    /* We're ready to go! */\n    return 0;\n}\n\nconst char *\nSDL_GetCurrentVideoDriver()\n{\n    if (!_this) {\n        SDL_UninitializedVideo();\n        return NULL;\n    }\n    return _this->name;\n}\n\nSDL_VideoDevice *\nSDL_GetVideoDevice(void)\n{\n    return _this;\n}\n\nint\nSDL_AddBasicVideoDisplay(const SDL_DisplayMode * desktop_mode)\n{\n    SDL_VideoDisplay display;\n\n    SDL_zero(display);\n    if (desktop_mode) {\n        display.desktop_mode = *desktop_mode;\n    }\n    display.current_mode = display.desktop_mode;\n\n    return SDL_AddVideoDisplay(&display);\n}\n\nint\nSDL_AddVideoDisplay(const SDL_VideoDisplay * display)\n{\n    SDL_VideoDisplay *displays;\n    int index = -1;\n\n    displays =\n        SDL_realloc(_this->displays,\n                    (_this->num_displays + 1) * sizeof(*displays));\n    if (displays) {\n        index = _this->num_displays++;\n        displays[index] = *display;\n        displays[index].device = _this;\n        _this->displays = displays;\n\n        if (display->name) {\n            displays[index].name = SDL_strdup(display->name);\n        } else {\n            char name[32];\n\n            SDL_itoa(index, name, 10);\n            displays[index].name = SDL_strdup(name);\n        }\n    } else {\n        SDL_OutOfMemory();\n    }\n    return index;\n}\n\nint\nSDL_GetNumVideoDisplays(void)\n{\n    if (!_this) {\n        SDL_UninitializedVideo();\n        return 0;\n    }\n    return _this->num_displays;\n}\n\nstatic int\nSDL_GetIndexOfDisplay(SDL_VideoDisplay *display)\n{\n    int displayIndex;\n\n    for (displayIndex = 0; displayIndex < _this->num_displays; ++displayIndex) {\n        if (display == &_this->displays[displayIndex]) {\n            return displayIndex;\n        }\n    }\n\n    /* Couldn't find the display, just use index 0 */\n    return 0;\n}\n\nvoid *\nSDL_GetDisplayDriverData(int displayIndex)\n{\n    CHECK_DISPLAY_INDEX(displayIndex, NULL);\n\n    return _this->displays[displayIndex].driverdata;\n}\n\nconst char *\nSDL_GetDisplayName(int displayIndex)\n{\n    CHECK_DISPLAY_INDEX(displayIndex, NULL);\n\n    return _this->displays[displayIndex].name;\n}\n\nint\nSDL_GetDisplayBounds(int displayIndex, SDL_Rect * rect)\n{\n    CHECK_DISPLAY_INDEX(displayIndex, -1);\n\n    if (rect) {\n        SDL_VideoDisplay *display = &_this->displays[displayIndex];\n\n        if (_this->GetDisplayBounds) {\n            if (_this->GetDisplayBounds(_this, display, rect) == 0) {\n                return 0;\n            }\n        }\n\n        /* Assume that the displays are left to right */\n        if (displayIndex == 0) {\n            rect->x = 0;\n            rect->y = 0;\n        } else {\n            SDL_GetDisplayBounds(displayIndex-1, rect);\n            rect->x += rect->w;\n        }\n        rect->w = display->current_mode.w;\n        rect->h = display->current_mode.h;\n    }\n    return 0;\n}\n\nSDL_bool\nSDL_AddDisplayMode(SDL_VideoDisplay * display,  const SDL_DisplayMode * mode)\n{\n    SDL_DisplayMode *modes;\n    int i, nmodes;\n\n    /* Make sure we don't already have the mode in the list */\n    modes = display->display_modes;\n    nmodes = display->num_display_modes;\n    for (i = 0; i < nmodes; ++i) {\n        if (cmpmodes(mode, &modes[i]) == 0) {\n            return SDL_FALSE;\n        }\n    }\n\n    /* Go ahead and add the new mode */\n    if (nmodes == display->max_display_modes) {\n        modes =\n            SDL_realloc(modes,\n                        (display->max_display_modes + 32) * sizeof(*modes));\n        if (!modes) {\n            return SDL_FALSE;\n        }\n        display->display_modes = modes;\n        display->max_display_modes += 32;\n    }\n    modes[nmodes] = *mode;\n    display->num_display_modes++;\n\n    /* Re-sort video modes */\n    SDL_qsort(display->display_modes, display->num_display_modes,\n              sizeof(SDL_DisplayMode), cmpmodes);\n\n    return SDL_TRUE;\n}\n\nstatic int\nSDL_GetNumDisplayModesForDisplay(SDL_VideoDisplay * display)\n{\n    if (!display->num_display_modes && _this->GetDisplayModes) {\n        _this->GetDisplayModes(_this, display);\n        SDL_qsort(display->display_modes, display->num_display_modes,\n                  sizeof(SDL_DisplayMode), cmpmodes);\n    }\n    return display->num_display_modes;\n}\n\nint\nSDL_GetNumDisplayModes(int displayIndex)\n{\n    CHECK_DISPLAY_INDEX(displayIndex, -1);\n\n    return SDL_GetNumDisplayModesForDisplay(&_this->displays[displayIndex]);\n}\n\nint\nSDL_GetDisplayMode(int displayIndex, int index, SDL_DisplayMode * mode)\n{\n    SDL_VideoDisplay *display;\n\n    CHECK_DISPLAY_INDEX(displayIndex, -1);\n\n    display = &_this->displays[displayIndex];\n    if (index < 0 || index >= SDL_GetNumDisplayModesForDisplay(display)) {\n        return SDL_SetError(\"index must be in the range of 0 - %d\",\n                            SDL_GetNumDisplayModesForDisplay(display) - 1);\n    }\n    if (mode) {\n        *mode = display->display_modes[index];\n    }\n    return 0;\n}\n\nint\nSDL_GetDesktopDisplayMode(int displayIndex, SDL_DisplayMode * mode)\n{\n    SDL_VideoDisplay *display;\n\n    CHECK_DISPLAY_INDEX(displayIndex, -1);\n\n    display = &_this->displays[displayIndex];\n    if (mode) {\n        *mode = display->desktop_mode;\n    }\n    return 0;\n}\n\nint\nSDL_GetCurrentDisplayMode(int displayIndex, SDL_DisplayMode * mode)\n{\n    SDL_VideoDisplay *display;\n\n    CHECK_DISPLAY_INDEX(displayIndex, -1);\n\n    display = &_this->displays[displayIndex];\n    if (mode) {\n        *mode = display->current_mode;\n    }\n    return 0;\n}\n\nstatic SDL_DisplayMode *\nSDL_GetClosestDisplayModeForDisplay(SDL_VideoDisplay * display,\n                                    const SDL_DisplayMode * mode,\n                                    SDL_DisplayMode * closest)\n{\n    Uint32 target_format;\n    int target_refresh_rate;\n    int i;\n    SDL_DisplayMode *current, *match;\n\n    if (!mode || !closest) {\n        SDL_SetError(\"Missing desired mode or closest mode parameter\");\n        return NULL;\n    }\n\n    /* Default to the desktop format */\n    if (mode->format) {\n        target_format = mode->format;\n    } else {\n        target_format = display->desktop_mode.format;\n    }\n\n    /* Default to the desktop refresh rate */\n    if (mode->refresh_rate) {\n        target_refresh_rate = mode->refresh_rate;\n    } else {\n        target_refresh_rate = display->desktop_mode.refresh_rate;\n    }\n\n    match = NULL;\n    for (i = 0; i < SDL_GetNumDisplayModesForDisplay(display); ++i) {\n        current = &display->display_modes[i];\n\n        if (current->w && (current->w < mode->w)) {\n            /* Out of sorted modes large enough here */\n            break;\n        }\n        if (current->h && (current->h < mode->h)) {\n            if (current->w && (current->w == mode->w)) {\n                /* Out of sorted modes large enough here */\n                break;\n            }\n            /* Wider, but not tall enough, due to a different\n               aspect ratio. This mode must be skipped, but closer\n               modes may still follow. */\n            continue;\n        }\n        if (!match || current->w < match->w || current->h < match->h) {\n            match = current;\n            continue;\n        }\n        if (current->format != match->format) {\n            /* Sorted highest depth to lowest */\n            if (current->format == target_format ||\n                (SDL_BITSPERPIXEL(current->format) >=\n                 SDL_BITSPERPIXEL(target_format)\n                 && SDL_PIXELTYPE(current->format) ==\n                 SDL_PIXELTYPE(target_format))) {\n                match = current;\n            }\n            continue;\n        }\n        if (current->refresh_rate != match->refresh_rate) {\n            /* Sorted highest refresh to lowest */\n            if (current->refresh_rate >= target_refresh_rate) {\n                match = current;\n            }\n        }\n    }\n    if (match) {\n        if (match->format) {\n            closest->format = match->format;\n        } else {\n            closest->format = mode->format;\n        }\n        if (match->w && match->h) {\n            closest->w = match->w;\n            closest->h = match->h;\n        } else {\n            closest->w = mode->w;\n            closest->h = mode->h;\n        }\n        if (match->refresh_rate) {\n            closest->refresh_rate = match->refresh_rate;\n        } else {\n            closest->refresh_rate = mode->refresh_rate;\n        }\n        closest->driverdata = match->driverdata;\n\n        /*\n         * Pick some reasonable defaults if the app and driver don't\n         * care\n         */\n        if (!closest->format) {\n            closest->format = SDL_PIXELFORMAT_RGB888;\n        }\n        if (!closest->w) {\n            closest->w = 640;\n        }\n        if (!closest->h) {\n            closest->h = 480;\n        }\n        return closest;\n    }\n    return NULL;\n}\n\nSDL_DisplayMode *\nSDL_GetClosestDisplayMode(int displayIndex,\n                          const SDL_DisplayMode * mode,\n                          SDL_DisplayMode * closest)\n{\n    SDL_VideoDisplay *display;\n\n    CHECK_DISPLAY_INDEX(displayIndex, NULL);\n\n    display = &_this->displays[displayIndex];\n    return SDL_GetClosestDisplayModeForDisplay(display, mode, closest);\n}\n\nstatic int\nSDL_SetDisplayModeForDisplay(SDL_VideoDisplay * display, const SDL_DisplayMode * mode)\n{\n    SDL_DisplayMode display_mode;\n    SDL_DisplayMode current_mode;\n\n    if (mode) {\n        display_mode = *mode;\n\n        /* Default to the current mode */\n        if (!display_mode.format) {\n            display_mode.format = display->current_mode.format;\n        }\n        if (!display_mode.w) {\n            display_mode.w = display->current_mode.w;\n        }\n        if (!display_mode.h) {\n            display_mode.h = display->current_mode.h;\n        }\n        if (!display_mode.refresh_rate) {\n            display_mode.refresh_rate = display->current_mode.refresh_rate;\n        }\n\n        /* Get a good video mode, the closest one possible */\n        if (!SDL_GetClosestDisplayModeForDisplay(display, &display_mode, &display_mode)) {\n            return SDL_SetError(\"No video mode large enough for %dx%d\",\n                                display_mode.w, display_mode.h);\n        }\n    } else {\n        display_mode = display->desktop_mode;\n    }\n\n    /* See if there's anything left to do */\n    current_mode = display->current_mode;\n    if (SDL_memcmp(&display_mode, &current_mode, sizeof(display_mode)) == 0) {\n        return 0;\n    }\n\n    /* Actually change the display mode */\n    if (!_this->SetDisplayMode) {\n        return SDL_SetError(\"Video driver doesn't support changing display mode\");\n    }\n    if (_this->SetDisplayMode(_this, display, &display_mode) < 0) {\n        return -1;\n    }\n    display->current_mode = display_mode;\n    return 0;\n}\n\nint\nSDL_GetWindowDisplayIndex(SDL_Window * window)\n{\n    int displayIndex;\n    int i, dist;\n    int closest = -1;\n    int closest_dist = 0x7FFFFFFF;\n    SDL_Point center;\n    SDL_Point delta;\n    SDL_Rect rect;\n\n    CHECK_WINDOW_MAGIC(window, -1);\n\n    if (SDL_WINDOWPOS_ISUNDEFINED(window->x) ||\n        SDL_WINDOWPOS_ISCENTERED(window->x)) {\n        displayIndex = (window->x & 0xFFFF);\n        if (displayIndex >= _this->num_displays) {\n            displayIndex = 0;\n        }\n        return displayIndex;\n    }\n    if (SDL_WINDOWPOS_ISUNDEFINED(window->y) ||\n        SDL_WINDOWPOS_ISCENTERED(window->y)) {\n        displayIndex = (window->y & 0xFFFF);\n        if (displayIndex >= _this->num_displays) {\n            displayIndex = 0;\n        }\n        return displayIndex;\n    }\n\n    /* Find the display containing the window */\n    for (i = 0; i < _this->num_displays; ++i) {\n        SDL_VideoDisplay *display = &_this->displays[i];\n\n        if (display->fullscreen_window == window) {\n            return i;\n        }\n    }\n    center.x = window->x + window->w / 2;\n    center.y = window->y + window->h / 2;\n    for (i = 0; i < _this->num_displays; ++i) {\n        SDL_GetDisplayBounds(i, &rect);\n        if (SDL_EnclosePoints(&center, 1, &rect, NULL)) {\n            return i;\n        }\n\n        delta.x = center.x - (rect.x + rect.w / 2);\n        delta.y = center.y - (rect.y + rect.h / 2);\n        dist = (delta.x*delta.x + delta.y*delta.y);\n        if (dist < closest_dist) {\n            closest = i;\n            closest_dist = dist;\n        }\n    }\n    if (closest < 0) {\n        SDL_SetError(\"Couldn't find any displays\");\n    }\n    return closest;\n}\n\nSDL_VideoDisplay *\nSDL_GetDisplayForWindow(SDL_Window *window)\n{\n    int displayIndex = SDL_GetWindowDisplayIndex(window);\n    if (displayIndex >= 0) {\n        return &_this->displays[displayIndex];\n    } else {\n        return NULL;\n    }\n}\n\nint\nSDL_SetWindowDisplayMode(SDL_Window * window, const SDL_DisplayMode * mode)\n{\n    CHECK_WINDOW_MAGIC(window, -1);\n\n    if (mode) {\n        window->fullscreen_mode = *mode;\n    } else {\n        SDL_zero(window->fullscreen_mode);\n    }\n\n    if (FULLSCREEN_VISIBLE(window) && (window->flags & SDL_WINDOW_FULLSCREEN_DESKTOP) != SDL_WINDOW_FULLSCREEN_DESKTOP) {\n        SDL_DisplayMode fullscreen_mode;\n        if (SDL_GetWindowDisplayMode(window, &fullscreen_mode) == 0) {\n            SDL_SetDisplayModeForDisplay(SDL_GetDisplayForWindow(window), &fullscreen_mode);\n        }\n    }\n    return 0;\n}\n\nint\nSDL_GetWindowDisplayMode(SDL_Window * window, SDL_DisplayMode * mode)\n{\n    SDL_DisplayMode fullscreen_mode;\n    SDL_VideoDisplay *display;\n\n    CHECK_WINDOW_MAGIC(window, -1);\n\n    if (!mode) {\n        return SDL_InvalidParamError(\"mode\");\n    }\n\n    fullscreen_mode = window->fullscreen_mode;\n    if (!fullscreen_mode.w) {\n        fullscreen_mode.w = window->windowed.w;\n    }\n    if (!fullscreen_mode.h) {\n        fullscreen_mode.h = window->windowed.h;\n    }\n\n    display = SDL_GetDisplayForWindow(window);\n\n    /* if in desktop size mode, just return the size of the desktop */\n    if ((window->flags & SDL_WINDOW_FULLSCREEN_DESKTOP) == SDL_WINDOW_FULLSCREEN_DESKTOP) {\n        fullscreen_mode = display->desktop_mode;\n    } else if (!SDL_GetClosestDisplayModeForDisplay(SDL_GetDisplayForWindow(window),\n                                             &fullscreen_mode,\n                                             &fullscreen_mode)) {\n        return SDL_SetError(\"Couldn't find display mode match\");\n    }\n\n    if (mode) {\n        *mode = fullscreen_mode;\n    }\n    return 0;\n}\n\nUint32\nSDL_GetWindowPixelFormat(SDL_Window * window)\n{\n    SDL_VideoDisplay *display;\n\n    CHECK_WINDOW_MAGIC(window, SDL_PIXELFORMAT_UNKNOWN);\n\n    display = SDL_GetDisplayForWindow(window);\n    return display->current_mode.format;\n}\n\nstatic void\nSDL_RestoreMousePosition(SDL_Window *window)\n{\n    int x, y;\n\n    if (window == SDL_GetMouseFocus()) {\n        SDL_GetMouseState(&x, &y);\n        SDL_WarpMouseInWindow(window, x, y);\n    }\n}\n\nstatic void\nSDL_UpdateFullscreenMode(SDL_Window * window, SDL_bool fullscreen)\n{\n    SDL_VideoDisplay *display;\n    SDL_Window *other;\n\n    CHECK_WINDOW_MAGIC(window,);\n\n    /* if we are in the process of hiding don't go back to fullscreen */\n    if ( window->is_hiding && fullscreen )\n        return;\n    \n#ifdef __MACOSX__\n    if (Cocoa_SetWindowFullscreenSpace(window, fullscreen)) {\n        window->last_fullscreen_flags = window->flags;\n        return;\n    }\n#endif\n\n    display = SDL_GetDisplayForWindow(window);\n\n    if (fullscreen) {\n        /* Hide any other fullscreen windows */\n        if (display->fullscreen_window &&\n            display->fullscreen_window != window) {\n            SDL_MinimizeWindow(display->fullscreen_window);\n        }\n    }\n\n    /* See if anything needs to be done now */\n    if ((display->fullscreen_window == window) == fullscreen) {\n        if ((window->last_fullscreen_flags & FULLSCREEN_MASK) == (window->flags & FULLSCREEN_MASK)) {\n            return;\n        }\n    }\n\n    /* See if there are any fullscreen windows */\n    for (other = _this->windows; other; other = other->next) {\n        SDL_bool setDisplayMode = SDL_FALSE;\n\n        if (other == window) {\n            setDisplayMode = fullscreen;\n        } else if (FULLSCREEN_VISIBLE(other) &&\n                   SDL_GetDisplayForWindow(other) == display) {\n            setDisplayMode = SDL_TRUE;\n        }\n\n        if (setDisplayMode) {\n            SDL_DisplayMode fullscreen_mode;\n\n            SDL_zero(fullscreen_mode);\n\n            if (SDL_GetWindowDisplayMode(other, &fullscreen_mode) == 0) {\n                SDL_bool resized = SDL_TRUE;\n\n                if (other->w == fullscreen_mode.w && other->h == fullscreen_mode.h) {\n                    resized = SDL_FALSE;\n                }\n\n                /* only do the mode change if we want exclusive fullscreen */\n                if ((window->flags & SDL_WINDOW_FULLSCREEN_DESKTOP) != SDL_WINDOW_FULLSCREEN_DESKTOP) {\n                    SDL_SetDisplayModeForDisplay(display, &fullscreen_mode);\n                } else {\n                    SDL_SetDisplayModeForDisplay(display, NULL);\n                }\n\n                if (_this->SetWindowFullscreen) {\n                    _this->SetWindowFullscreen(_this, other, display, SDL_TRUE);\n                }\n                display->fullscreen_window = other;\n\n                /* Generate a mode change event here */\n                if (resized) {\n                    SDL_SendWindowEvent(other, SDL_WINDOWEVENT_RESIZED,\n                                        fullscreen_mode.w, fullscreen_mode.h);\n                } else {\n                    SDL_OnWindowResized(other);\n                }\n\n                SDL_RestoreMousePosition(other);\n\n                window->last_fullscreen_flags = window->flags;\n                return;\n            }\n        }\n    }\n\n    /* Nope, restore the desktop mode */\n    SDL_SetDisplayModeForDisplay(display, NULL);\n\n    if (_this->SetWindowFullscreen) {\n        _this->SetWindowFullscreen(_this, window, display, SDL_FALSE);\n    }\n    display->fullscreen_window = NULL;\n\n    /* Generate a mode change event here */\n    SDL_OnWindowResized(window);\n\n    /* Restore the cursor position */\n    SDL_RestoreMousePosition(window);\n\n    window->last_fullscreen_flags = window->flags;\n}\n\n#define CREATE_FLAGS \\\n    (SDL_WINDOW_OPENGL | SDL_WINDOW_BORDERLESS | SDL_WINDOW_RESIZABLE | SDL_WINDOW_ALLOW_HIGHDPI)\n\nstatic void\nSDL_FinishWindowCreation(SDL_Window *window, Uint32 flags)\n{\n    window->windowed.x = window->x;\n    window->windowed.y = window->y;\n    window->windowed.w = window->w;\n    window->windowed.h = window->h;\n\n    if (flags & SDL_WINDOW_MAXIMIZED) {\n        SDL_MaximizeWindow(window);\n    }\n    if (flags & SDL_WINDOW_MINIMIZED) {\n        SDL_MinimizeWindow(window);\n    }\n    if (flags & SDL_WINDOW_FULLSCREEN) {\n        SDL_SetWindowFullscreen(window, flags);\n    }\n    if (flags & SDL_WINDOW_INPUT_GRABBED) {\n        SDL_SetWindowGrab(window, SDL_TRUE);\n    }\n    if (!(flags & SDL_WINDOW_HIDDEN)) {\n        SDL_ShowWindow(window);\n    }\n}\n\nSDL_Window *\nSDL_CreateWindow(const char *title, int x, int y, int w, int h, Uint32 flags)\n{\n    SDL_Window *window;\n    const char *hint;\n\n    if (!_this) {\n        /* Initialize the video system if needed */\n        if (SDL_VideoInit(NULL) < 0) {\n            return NULL;\n        }\n    }\n\n    /* Some platforms can't create zero-sized windows */\n    if (w < 1) {\n        w = 1;\n    }\n    if (h < 1) {\n        h = 1;\n    }\n\n    /* Some platforms have OpenGL enabled by default */\n#if (SDL_VIDEO_OPENGL && __MACOSX__) || __IPHONEOS__ || __ANDROID__ || __NACL__\n    flags |= SDL_WINDOW_OPENGL;\n#endif\n    if (flags & SDL_WINDOW_OPENGL) {\n        if (!_this->GL_CreateContext) {\n            SDL_SetError(\"No OpenGL support in video driver\");\n            return NULL;\n        }\n        if (SDL_GL_LoadLibrary(NULL) < 0) {\n            return NULL;\n        }\n    }\n\n    /* Unless the user has specified the high-DPI disabling hint, respect the\n     * SDL_WINDOW_ALLOW_HIGHDPI flag.\n     */\n    if (flags & SDL_WINDOW_ALLOW_HIGHDPI) {\n        hint = SDL_GetHint(SDL_HINT_VIDEO_HIGHDPI_DISABLED);\n        if (hint && SDL_atoi(hint) > 0) {\n            flags &= ~SDL_WINDOW_ALLOW_HIGHDPI;\n        }\n    }\n\n    window = (SDL_Window *)SDL_calloc(1, sizeof(*window));\n    if (!window) {\n        SDL_OutOfMemory();\n        return NULL;\n    }\n    window->magic = &_this->window_magic;\n    window->id = _this->next_object_id++;\n    window->x = x;\n    window->y = y;\n    window->w = w;\n    window->h = h;\n    if (SDL_WINDOWPOS_ISUNDEFINED(x) || SDL_WINDOWPOS_ISUNDEFINED(y) ||\n        SDL_WINDOWPOS_ISCENTERED(x) || SDL_WINDOWPOS_ISCENTERED(y)) {\n        SDL_VideoDisplay *display = SDL_GetDisplayForWindow(window);\n        int displayIndex;\n        SDL_Rect bounds;\n\n        displayIndex = SDL_GetIndexOfDisplay(display);\n        SDL_GetDisplayBounds(displayIndex, &bounds);\n        if (SDL_WINDOWPOS_ISUNDEFINED(x) || SDL_WINDOWPOS_ISCENTERED(x)) {\n            window->x = bounds.x + (bounds.w - w) / 2;\n        }\n        if (SDL_WINDOWPOS_ISUNDEFINED(y) || SDL_WINDOWPOS_ISCENTERED(y)) {\n            window->y = bounds.y + (bounds.h - h) / 2;\n        }\n    }\n    window->flags = ((flags & CREATE_FLAGS) | SDL_WINDOW_HIDDEN);\n    window->last_fullscreen_flags = window->flags;\n    window->brightness = 1.0f;\n    window->next = _this->windows;\n    window->is_destroying = SDL_FALSE;\n\n    if (_this->windows) {\n        _this->windows->prev = window;\n    }\n    _this->windows = window;\n\n    if (_this->CreateWindow && _this->CreateWindow(_this, window) < 0) {\n        SDL_DestroyWindow(window);\n        return NULL;\n    }\n\n    if (title) {\n        SDL_SetWindowTitle(window, title);\n    }\n    SDL_FinishWindowCreation(window, flags);\n\n    /* If the window was created fullscreen, make sure the mode code matches */\n    SDL_UpdateFullscreenMode(window, FULLSCREEN_VISIBLE(window));\n\n    return window;\n}\n\nSDL_Window *\nSDL_CreateWindowFrom(const void *data)\n{\n    SDL_Window *window;\n\n    if (!_this) {\n        SDL_UninitializedVideo();\n        return NULL;\n    }\n    if (!_this->CreateWindowFrom) {\n        SDL_Unsupported();\n        return NULL;\n    }\n    window = (SDL_Window *)SDL_calloc(1, sizeof(*window));\n    if (!window) {\n        SDL_OutOfMemory();\n        return NULL;\n    }\n    window->magic = &_this->window_magic;\n    window->id = _this->next_object_id++;\n    window->flags = SDL_WINDOW_FOREIGN;\n    window->last_fullscreen_flags = window->flags;\n    window->is_destroying = SDL_FALSE;\n    window->brightness = 1.0f;\n    window->next = _this->windows;\n    if (_this->windows) {\n        _this->windows->prev = window;\n    }\n    _this->windows = window;\n\n    if (_this->CreateWindowFrom(_this, window, data) < 0) {\n        SDL_DestroyWindow(window);\n        return NULL;\n    }\n    return window;\n}\n\nint\nSDL_RecreateWindow(SDL_Window * window, Uint32 flags)\n{\n    char *title = window->title;\n    SDL_Surface *icon = window->icon;\n    SDL_bool loaded_opengl = SDL_FALSE;\n\n    if ((flags & SDL_WINDOW_OPENGL) && !_this->GL_CreateContext) {\n        return SDL_SetError(\"No OpenGL support in video driver\");\n    }\n\n    if (window->flags & SDL_WINDOW_FOREIGN) {\n        /* Can't destroy and re-create foreign windows, hrm */\n        flags |= SDL_WINDOW_FOREIGN;\n    } else {\n        flags &= ~SDL_WINDOW_FOREIGN;\n    }\n\n    /* Restore video mode, etc. */\n    SDL_HideWindow(window);\n\n    /* Tear down the old native window */\n    if (window->surface) {\n        window->surface->flags &= ~SDL_DONTFREE;\n        SDL_FreeSurface(window->surface);\n    }\n    if (_this->DestroyWindowFramebuffer) {\n        _this->DestroyWindowFramebuffer(_this, window);\n    }\n    if (_this->DestroyWindow && !(flags & SDL_WINDOW_FOREIGN)) {\n        _this->DestroyWindow(_this, window);\n    }\n\n    if ((window->flags & SDL_WINDOW_OPENGL) != (flags & SDL_WINDOW_OPENGL)) {\n        if (flags & SDL_WINDOW_OPENGL) {\n            if (SDL_GL_LoadLibrary(NULL) < 0) {\n                return -1;\n            }\n            loaded_opengl = SDL_TRUE;\n        } else {\n            SDL_GL_UnloadLibrary();\n        }\n    }\n\n    window->title = NULL;\n    window->icon = NULL;\n    window->flags = ((flags & CREATE_FLAGS) | SDL_WINDOW_HIDDEN);\n    window->last_fullscreen_flags = window->flags;\n    window->is_destroying = SDL_FALSE;\n\n    if (_this->CreateWindow && !(flags & SDL_WINDOW_FOREIGN)) {\n        if (_this->CreateWindow(_this, window) < 0) {\n            if (loaded_opengl) {\n                SDL_GL_UnloadLibrary();\n                window->flags &= ~SDL_WINDOW_OPENGL;\n            }\n            return -1;\n        }\n    }\n    if (flags & SDL_WINDOW_FOREIGN) {\n        window->flags |= SDL_WINDOW_FOREIGN;\n    }\n\n    if (title) {\n        SDL_SetWindowTitle(window, title);\n        SDL_free(title);\n    }\n    if (icon) {\n        SDL_SetWindowIcon(window, icon);\n        SDL_FreeSurface(icon);\n    }\n\n    if (window->hit_test) {\n        _this->SetWindowHitTest(window, SDL_TRUE);\n    }\n\n    SDL_FinishWindowCreation(window, flags);\n\n    return 0;\n}\n\nUint32\nSDL_GetWindowID(SDL_Window * window)\n{\n    CHECK_WINDOW_MAGIC(window, 0);\n\n    return window->id;\n}\n\nSDL_Window *\nSDL_GetWindowFromID(Uint32 id)\n{\n    SDL_Window *window;\n\n    if (!_this) {\n        return NULL;\n    }\n    for (window = _this->windows; window; window = window->next) {\n        if (window->id == id) {\n            return window;\n        }\n    }\n    return NULL;\n}\n\nUint32\nSDL_GetWindowFlags(SDL_Window * window)\n{\n    CHECK_WINDOW_MAGIC(window, 0);\n\n    return window->flags;\n}\n\nvoid\nSDL_SetWindowTitle(SDL_Window * window, const char *title)\n{\n    CHECK_WINDOW_MAGIC(window,);\n\n    if (title == window->title) {\n        return;\n    }\n    SDL_free(window->title);\n    if (title && *title) {\n        window->title = SDL_strdup(title);\n    } else {\n        window->title = NULL;\n    }\n\n    if (_this->SetWindowTitle) {\n        _this->SetWindowTitle(_this, window);\n    }\n}\n\nconst char *\nSDL_GetWindowTitle(SDL_Window * window)\n{\n    CHECK_WINDOW_MAGIC(window, \"\");\n\n    return window->title ? window->title : \"\";\n}\n\nvoid\nSDL_SetWindowIcon(SDL_Window * window, SDL_Surface * icon)\n{\n    CHECK_WINDOW_MAGIC(window,);\n\n    if (!icon) {\n        return;\n    }\n\n    SDL_FreeSurface(window->icon);\n\n    /* Convert the icon into ARGB8888 */\n    window->icon = SDL_ConvertSurfaceFormat(icon, SDL_PIXELFORMAT_ARGB8888, 0);\n    if (!window->icon) {\n        return;\n    }\n\n    if (_this->SetWindowIcon) {\n        _this->SetWindowIcon(_this, window, window->icon);\n    }\n}\n\nvoid*\nSDL_SetWindowData(SDL_Window * window, const char *name, void *userdata)\n{\n    SDL_WindowUserData *prev, *data;\n\n    CHECK_WINDOW_MAGIC(window, NULL);\n\n    /* Input validation */\n    if (name == NULL || name[0] == '\\0') {\n      SDL_InvalidParamError(\"name\");\n      return NULL;\n    }\n\n    /* See if the named data already exists */\n    prev = NULL;\n    for (data = window->data; data; prev = data, data = data->next) {\n        if (data->name && SDL_strcmp(data->name, name) == 0) {\n            void *last_value = data->data;\n\n            if (userdata) {\n                /* Set the new value */\n                data->data = userdata;\n            } else {\n                /* Delete this value */\n                if (prev) {\n                    prev->next = data->next;\n                } else {\n                    window->data = data->next;\n                }\n                SDL_free(data->name);\n                SDL_free(data);\n            }\n            return last_value;\n        }\n    }\n\n    /* Add new data to the window */\n    if (userdata) {\n        data = (SDL_WindowUserData *)SDL_malloc(sizeof(*data));\n        data->name = SDL_strdup(name);\n        data->data = userdata;\n        data->next = window->data;\n        window->data = data;\n    }\n    return NULL;\n}\n\nvoid *\nSDL_GetWindowData(SDL_Window * window, const char *name)\n{\n    SDL_WindowUserData *data;\n\n    CHECK_WINDOW_MAGIC(window, NULL);\n\n    /* Input validation */\n    if (name == NULL || name[0] == '\\0') {\n      SDL_InvalidParamError(\"name\");\n      return NULL;\n    }\n\n    for (data = window->data; data; data = data->next) {\n        if (data->name && SDL_strcmp(data->name, name) == 0) {\n            return data->data;\n        }\n    }\n    return NULL;\n}\n\nvoid\nSDL_SetWindowPosition(SDL_Window * window, int x, int y)\n{\n    CHECK_WINDOW_MAGIC(window,);\n\n    if (SDL_WINDOWPOS_ISCENTERED(x) || SDL_WINDOWPOS_ISCENTERED(y)) {\n        int displayIndex = (x & 0xFFFF);\n        SDL_Rect bounds;\n        if (displayIndex > _this->num_displays) {\n            displayIndex = 0;\n        }\n\n        SDL_zero(bounds);\n\n        SDL_GetDisplayBounds(displayIndex, &bounds);\n        if (SDL_WINDOWPOS_ISCENTERED(x)) {\n            x = bounds.x + (bounds.w - window->w) / 2;\n        }\n        if (SDL_WINDOWPOS_ISCENTERED(y)) {\n            y = bounds.y + (bounds.h - window->h) / 2;\n        }\n    }\n\n    if ((window->flags & SDL_WINDOW_FULLSCREEN)) {\n        if (!SDL_WINDOWPOS_ISUNDEFINED(x)) {\n            window->windowed.x = x;\n        }\n        if (!SDL_WINDOWPOS_ISUNDEFINED(y)) {\n            window->windowed.y = y;\n        }\n    } else {\n        if (!SDL_WINDOWPOS_ISUNDEFINED(x)) {\n            window->x = x;\n        }\n        if (!SDL_WINDOWPOS_ISUNDEFINED(y)) {\n            window->y = y;\n        }\n\n        if (_this->SetWindowPosition) {\n            _this->SetWindowPosition(_this, window);\n        }\n        SDL_SendWindowEvent(window, SDL_WINDOWEVENT_MOVED, x, y);\n    }\n}\n\nvoid\nSDL_GetWindowPosition(SDL_Window * window, int *x, int *y)\n{\n    CHECK_WINDOW_MAGIC(window,);\n\n    /* Fullscreen windows are always at their display's origin */\n    if (window->flags & SDL_WINDOW_FULLSCREEN) {\n        if (x) {\n            *x = 0;\n        }\n        if (y) {\n            *y = 0;\n        }\n    } else {\n        if (x) {\n            *x = window->x;\n        }\n        if (y) {\n            *y = window->y;\n        }\n    }\n}\n\nvoid\nSDL_SetWindowBordered(SDL_Window * window, SDL_bool bordered)\n{\n    CHECK_WINDOW_MAGIC(window,);\n    if (!(window->flags & SDL_WINDOW_FULLSCREEN)) {\n        const int want = (bordered != SDL_FALSE);  /* normalize the flag. */\n        const int have = ((window->flags & SDL_WINDOW_BORDERLESS) == 0);\n        if ((want != have) && (_this->SetWindowBordered)) {\n            if (want) {\n                window->flags &= ~SDL_WINDOW_BORDERLESS;\n            } else {\n                window->flags |= SDL_WINDOW_BORDERLESS;\n            }\n            _this->SetWindowBordered(_this, window, (SDL_bool) want);\n        }\n    }\n}\n\nvoid\nSDL_SetWindowSize(SDL_Window * window, int w, int h)\n{\n    CHECK_WINDOW_MAGIC(window,);\n    if (w <= 0) {\n        SDL_InvalidParamError(\"w\");\n        return;\n    }\n    if (h <= 0) {\n        SDL_InvalidParamError(\"h\");\n        return;\n    }\n\n    /* Make sure we don't exceed any window size limits */\n    if (window->min_w && w < window->min_w)\n    {\n        w = window->min_w;\n    }\n    if (window->max_w && w > window->max_w)\n    {\n        w = window->max_w;\n    }\n    if (window->min_h && h < window->min_h)\n    {\n        h = window->min_h;\n    }\n    if (window->max_h && h > window->max_h)\n    {\n        h = window->max_h;\n    }\n\n    window->windowed.w = w;\n    window->windowed.h = h;\n\n    if (window->flags & SDL_WINDOW_FULLSCREEN) {\n        if (FULLSCREEN_VISIBLE(window) && (window->flags & SDL_WINDOW_FULLSCREEN_DESKTOP) != SDL_WINDOW_FULLSCREEN_DESKTOP) {\n            window->last_fullscreen_flags = 0;\n            SDL_UpdateFullscreenMode(window, SDL_TRUE);\n        }\n    } else {\n        window->w = w;\n        window->h = h;\n        if (_this->SetWindowSize) {\n            _this->SetWindowSize(_this, window);\n        }\n        if (window->w == w && window->h == h) {\n            /* We didn't get a SDL_WINDOWEVENT_RESIZED event (by design) */\n            SDL_OnWindowResized(window);\n        }\n    }\n}\n\nvoid\nSDL_GetWindowSize(SDL_Window * window, int *w, int *h)\n{\n    CHECK_WINDOW_MAGIC(window,);\n    if (w) {\n        *w = window->w;\n    }\n    if (h) {\n        *h = window->h;\n    }\n}\n\nvoid\nSDL_SetWindowMinimumSize(SDL_Window * window, int min_w, int min_h)\n{\n    CHECK_WINDOW_MAGIC(window,);\n    if (min_w <= 0) {\n        SDL_InvalidParamError(\"min_w\");\n        return;\n    }\n    if (min_h <= 0) {\n        SDL_InvalidParamError(\"min_h\");\n        return;\n    }\n\n    if (!(window->flags & SDL_WINDOW_FULLSCREEN)) {\n        window->min_w = min_w;\n        window->min_h = min_h;\n        if (_this->SetWindowMinimumSize) {\n            _this->SetWindowMinimumSize(_this, window);\n        }\n        /* Ensure that window is not smaller than minimal size */\n        SDL_SetWindowSize(window, SDL_max(window->w, window->min_w), SDL_max(window->h, window->min_h));\n    }\n}\n\nvoid\nSDL_GetWindowMinimumSize(SDL_Window * window, int *min_w, int *min_h)\n{\n    CHECK_WINDOW_MAGIC(window,);\n    if (min_w) {\n        *min_w = window->min_w;\n    }\n    if (min_h) {\n        *min_h = window->min_h;\n    }\n}\n\nvoid\nSDL_SetWindowMaximumSize(SDL_Window * window, int max_w, int max_h)\n{\n    CHECK_WINDOW_MAGIC(window,);\n    if (max_w <= 0) {\n        SDL_InvalidParamError(\"max_w\");\n        return;\n    }\n    if (max_h <= 0) {\n        SDL_InvalidParamError(\"max_h\");\n        return;\n    }\n\n    if (!(window->flags & SDL_WINDOW_FULLSCREEN)) {\n        window->max_w = max_w;\n        window->max_h = max_h;\n        if (_this->SetWindowMaximumSize) {\n            _this->SetWindowMaximumSize(_this, window);\n        }\n        /* Ensure that window is not larger than maximal size */\n        SDL_SetWindowSize(window, SDL_min(window->w, window->max_w), SDL_min(window->h, window->max_h));\n    }\n}\n\nvoid\nSDL_GetWindowMaximumSize(SDL_Window * window, int *max_w, int *max_h)\n{\n    CHECK_WINDOW_MAGIC(window,);\n    if (max_w) {\n        *max_w = window->max_w;\n    }\n    if (max_h) {\n        *max_h = window->max_h;\n    }\n}\n\nvoid\nSDL_ShowWindow(SDL_Window * window)\n{\n    CHECK_WINDOW_MAGIC(window,);\n\n    if (window->flags & SDL_WINDOW_SHOWN) {\n        return;\n    }\n\n    if (_this->ShowWindow) {\n        _this->ShowWindow(_this, window);\n    }\n    SDL_SendWindowEvent(window, SDL_WINDOWEVENT_SHOWN, 0, 0);\n}\n\nvoid\nSDL_HideWindow(SDL_Window * window)\n{\n    CHECK_WINDOW_MAGIC(window,);\n\n    if (!(window->flags & SDL_WINDOW_SHOWN)) {\n        return;\n    }\n\n\twindow->is_hiding = SDL_TRUE;\n    SDL_UpdateFullscreenMode(window, SDL_FALSE);\n\n    if (_this->HideWindow) {\n        _this->HideWindow(_this, window);\n    }\n\twindow->is_hiding = SDL_FALSE;\n    SDL_SendWindowEvent(window, SDL_WINDOWEVENT_HIDDEN, 0, 0);\n}\n\nvoid\nSDL_RaiseWindow(SDL_Window * window)\n{\n    CHECK_WINDOW_MAGIC(window,);\n\n    if (!(window->flags & SDL_WINDOW_SHOWN)) {\n        return;\n    }\n    if (_this->RaiseWindow) {\n        _this->RaiseWindow(_this, window);\n    }\n}\n\nvoid\nSDL_MaximizeWindow(SDL_Window * window)\n{\n    CHECK_WINDOW_MAGIC(window,);\n\n    if (window->flags & SDL_WINDOW_MAXIMIZED) {\n        return;\n    }\n\n    /* !!! FIXME: should this check if the window is resizable? */\n\n    if (_this->MaximizeWindow) {\n        _this->MaximizeWindow(_this, window);\n    }\n}\n\nvoid\nSDL_MinimizeWindow(SDL_Window * window)\n{\n    CHECK_WINDOW_MAGIC(window,);\n\n    if (window->flags & SDL_WINDOW_MINIMIZED) {\n        return;\n    }\n\n    SDL_UpdateFullscreenMode(window, SDL_FALSE);\n\n    if (_this->MinimizeWindow) {\n        _this->MinimizeWindow(_this, window);\n    }\n}\n\nvoid\nSDL_RestoreWindow(SDL_Window * window)\n{\n    CHECK_WINDOW_MAGIC(window,);\n\n    if (!(window->flags & (SDL_WINDOW_MAXIMIZED | SDL_WINDOW_MINIMIZED))) {\n        return;\n    }\n\n    if (_this->RestoreWindow) {\n        _this->RestoreWindow(_this, window);\n    }\n}\n\nint\nSDL_SetWindowFullscreen(SDL_Window * window, Uint32 flags)\n{\n    CHECK_WINDOW_MAGIC(window, -1);\n\n    flags &= FULLSCREEN_MASK;\n\n    if (flags == (window->flags & FULLSCREEN_MASK)) {\n        return 0;\n    }\n\n    /* clear the previous flags and OR in the new ones */\n    window->flags &= ~FULLSCREEN_MASK;\n    window->flags |= flags;\n\n    SDL_UpdateFullscreenMode(window, FULLSCREEN_VISIBLE(window));\n\n    return 0;\n}\n\nstatic SDL_Surface *\nSDL_CreateWindowFramebuffer(SDL_Window * window)\n{\n    Uint32 format;\n    void *pixels;\n    int pitch;\n    int bpp;\n    Uint32 Rmask, Gmask, Bmask, Amask;\n\n    if (!_this->CreateWindowFramebuffer || !_this->UpdateWindowFramebuffer) {\n        return NULL;\n    }\n\n    if (_this->CreateWindowFramebuffer(_this, window, &format, &pixels, &pitch) < 0) {\n        return NULL;\n    }\n\n    if (!SDL_PixelFormatEnumToMasks(format, &bpp, &Rmask, &Gmask, &Bmask, &Amask)) {\n        return NULL;\n    }\n\n    return SDL_CreateRGBSurfaceFrom(pixels, window->w, window->h, bpp, pitch, Rmask, Gmask, Bmask, Amask);\n}\n\nSDL_Surface *\nSDL_GetWindowSurface(SDL_Window * window)\n{\n    CHECK_WINDOW_MAGIC(window, NULL);\n\n    if (!window->surface_valid) {\n        if (window->surface) {\n            window->surface->flags &= ~SDL_DONTFREE;\n            SDL_FreeSurface(window->surface);\n        }\n        window->surface = SDL_CreateWindowFramebuffer(window);\n        if (window->surface) {\n            window->surface_valid = SDL_TRUE;\n            window->surface->flags |= SDL_DONTFREE;\n        }\n    }\n    return window->surface;\n}\n\nint\nSDL_UpdateWindowSurface(SDL_Window * window)\n{\n    SDL_Rect full_rect;\n\n    CHECK_WINDOW_MAGIC(window, -1);\n\n    full_rect.x = 0;\n    full_rect.y = 0;\n    full_rect.w = window->w;\n    full_rect.h = window->h;\n    return SDL_UpdateWindowSurfaceRects(window, &full_rect, 1);\n}\n\nint\nSDL_UpdateWindowSurfaceRects(SDL_Window * window, const SDL_Rect * rects,\n                             int numrects)\n{\n    CHECK_WINDOW_MAGIC(window, -1);\n\n    if (!window->surface_valid) {\n        return SDL_SetError(\"Window surface is invalid, please call SDL_GetWindowSurface() to get a new surface\");\n    }\n\n    return _this->UpdateWindowFramebuffer(_this, window, rects, numrects);\n}\n\nint\nSDL_SetWindowBrightness(SDL_Window * window, float brightness)\n{\n    Uint16 ramp[256];\n    int status;\n\n    CHECK_WINDOW_MAGIC(window, -1);\n\n    SDL_CalculateGammaRamp(brightness, ramp);\n    status = SDL_SetWindowGammaRamp(window, ramp, ramp, ramp);\n    if (status == 0) {\n        window->brightness = brightness;\n    }\n    return status;\n}\n\nfloat\nSDL_GetWindowBrightness(SDL_Window * window)\n{\n    CHECK_WINDOW_MAGIC(window, 1.0f);\n\n    return window->brightness;\n}\n\nint\nSDL_SetWindowGammaRamp(SDL_Window * window, const Uint16 * red,\n                                            const Uint16 * green,\n                                            const Uint16 * blue)\n{\n    CHECK_WINDOW_MAGIC(window, -1);\n\n    if (!_this->SetWindowGammaRamp) {\n        return SDL_Unsupported();\n    }\n\n    if (!window->gamma) {\n        if (SDL_GetWindowGammaRamp(window, NULL, NULL, NULL) < 0) {\n            return -1;\n        }\n    }\n\n    if (red) {\n        SDL_memcpy(&window->gamma[0*256], red, 256*sizeof(Uint16));\n    }\n    if (green) {\n        SDL_memcpy(&window->gamma[1*256], green, 256*sizeof(Uint16));\n    }\n    if (blue) {\n        SDL_memcpy(&window->gamma[2*256], blue, 256*sizeof(Uint16));\n    }\n    if (window->flags & SDL_WINDOW_INPUT_FOCUS) {\n        return _this->SetWindowGammaRamp(_this, window, window->gamma);\n    } else {\n        return 0;\n    }\n}\n\nint\nSDL_GetWindowGammaRamp(SDL_Window * window, Uint16 * red,\n                                            Uint16 * green,\n                                            Uint16 * blue)\n{\n    CHECK_WINDOW_MAGIC(window, -1);\n\n    if (!window->gamma) {\n        int i;\n\n        window->gamma = (Uint16 *)SDL_malloc(256*6*sizeof(Uint16));\n        if (!window->gamma) {\n            return SDL_OutOfMemory();\n        }\n        window->saved_gamma = window->gamma + 3*256;\n\n        if (_this->GetWindowGammaRamp) {\n            if (_this->GetWindowGammaRamp(_this, window, window->gamma) < 0) {\n                return -1;\n            }\n        } else {\n            /* Create an identity gamma ramp */\n            for (i = 0; i < 256; ++i) {\n                Uint16 value = (Uint16)((i << 8) | i);\n\n                window->gamma[0*256+i] = value;\n                window->gamma[1*256+i] = value;\n                window->gamma[2*256+i] = value;\n            }\n        }\n        SDL_memcpy(window->saved_gamma, window->gamma, 3*256*sizeof(Uint16));\n    }\n\n    if (red) {\n        SDL_memcpy(red, &window->gamma[0*256], 256*sizeof(Uint16));\n    }\n    if (green) {\n        SDL_memcpy(green, &window->gamma[1*256], 256*sizeof(Uint16));\n    }\n    if (blue) {\n        SDL_memcpy(blue, &window->gamma[2*256], 256*sizeof(Uint16));\n    }\n    return 0;\n}\n\nvoid\nSDL_UpdateWindowGrab(SDL_Window * window)\n{\n    if (_this->SetWindowGrab) {\n        SDL_bool grabbed;\n        if ((SDL_GetMouse()->relative_mode || (window->flags & SDL_WINDOW_INPUT_GRABBED)) &&\n             (window->flags & SDL_WINDOW_INPUT_FOCUS)) {\n            grabbed = SDL_TRUE;\n        } else {\n            grabbed = SDL_FALSE;\n        }\n        _this->SetWindowGrab(_this, window, grabbed);\n    }\n}\n\nvoid\nSDL_SetWindowGrab(SDL_Window * window, SDL_bool grabbed)\n{\n    CHECK_WINDOW_MAGIC(window,);\n\n    if (!!grabbed == !!(window->flags & SDL_WINDOW_INPUT_GRABBED)) {\n        return;\n    }\n    if (grabbed) {\n        window->flags |= SDL_WINDOW_INPUT_GRABBED;\n    } else {\n        window->flags &= ~SDL_WINDOW_INPUT_GRABBED;\n    }\n    SDL_UpdateWindowGrab(window);\n}\n\nSDL_bool\nSDL_GetWindowGrab(SDL_Window * window)\n{\n    CHECK_WINDOW_MAGIC(window, SDL_FALSE);\n\n    return ((window->flags & SDL_WINDOW_INPUT_GRABBED) != 0);\n}\n\nvoid\nSDL_OnWindowShown(SDL_Window * window)\n{\n    SDL_OnWindowRestored(window);\n}\n\nvoid\nSDL_OnWindowHidden(SDL_Window * window)\n{\n    SDL_UpdateFullscreenMode(window, SDL_FALSE);\n}\n\nvoid\nSDL_OnWindowResized(SDL_Window * window)\n{\n    window->surface_valid = SDL_FALSE;\n    SDL_SendWindowEvent(window, SDL_WINDOWEVENT_SIZE_CHANGED, window->w, window->h);\n}\n\nvoid\nSDL_OnWindowMinimized(SDL_Window * window)\n{\n    SDL_UpdateFullscreenMode(window, SDL_FALSE);\n}\n\nvoid\nSDL_OnWindowRestored(SDL_Window * window)\n{\n    /*\n     * FIXME: Is this fine to just remove this, or should it be preserved just\n     * for the fullscreen case? In principle it seems like just hiding/showing\n     * windows shouldn't affect the stacking order; maybe the right fix is to\n     * re-decouple OnWindowShown and OnWindowRestored.\n     */\n    /*SDL_RaiseWindow(window);*/\n\n    if (FULLSCREEN_VISIBLE(window)) {\n        SDL_UpdateFullscreenMode(window, SDL_TRUE);\n    }\n}\n\nvoid\nSDL_OnWindowEnter(SDL_Window * window)\n{\n    if (_this->OnWindowEnter) {\n        _this->OnWindowEnter(_this, window);\n    }\n}\n\nvoid\nSDL_OnWindowLeave(SDL_Window * window)\n{\n}\n\nvoid\nSDL_OnWindowFocusGained(SDL_Window * window)\n{\n    SDL_Mouse *mouse = SDL_GetMouse();\n\n    if (window->gamma && _this->SetWindowGammaRamp) {\n        _this->SetWindowGammaRamp(_this, window, window->gamma);\n    }\n\n    if (mouse && mouse->relative_mode) {\n        SDL_SetMouseFocus(window);\n        SDL_WarpMouseInWindow(window, window->w/2, window->h/2);\n    }\n\n    SDL_UpdateWindowGrab(window);\n}\n\nstatic SDL_bool\nShouldMinimizeOnFocusLoss(SDL_Window * window)\n{\n    const char *hint;\n\n    if (!(window->flags & SDL_WINDOW_FULLSCREEN) || window->is_destroying) {\n        return SDL_FALSE;\n    }\n\n#ifdef __MACOSX__\n    if (Cocoa_IsWindowInFullscreenSpace(window)) {\n        return SDL_FALSE;\n    }\n#endif\n\n    hint = SDL_GetHint(SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS);\n    if (hint) {\n        if (*hint == '0') {\n            return SDL_FALSE;\n        } else {\n            return SDL_TRUE;\n        }\n    }\n\n    return SDL_TRUE;\n}\n\nvoid\nSDL_OnWindowFocusLost(SDL_Window * window)\n{\n    if (window->gamma && _this->SetWindowGammaRamp) {\n        _this->SetWindowGammaRamp(_this, window, window->saved_gamma);\n    }\n\n    SDL_UpdateWindowGrab(window);\n\n    if (ShouldMinimizeOnFocusLoss(window)) {\n        SDL_MinimizeWindow(window);\n    }\n}\n\n/* !!! FIXME: is this different than SDL_GetKeyboardFocus()?\n   !!! FIXME:  Also, SDL_GetKeyboardFocus() is O(1), this isn't. */\nSDL_Window *\nSDL_GetFocusWindow(void)\n{\n    SDL_Window *window;\n\n    if (!_this) {\n        return NULL;\n    }\n    for (window = _this->windows; window; window = window->next) {\n        if (window->flags & SDL_WINDOW_INPUT_FOCUS) {\n            return window;\n        }\n    }\n    return NULL;\n}\n\nvoid\nSDL_DestroyWindow(SDL_Window * window)\n{\n    SDL_VideoDisplay *display;\n\n    CHECK_WINDOW_MAGIC(window,);\n\n    window->is_destroying = SDL_TRUE;\n\n    /* Restore video mode, etc. */\n    SDL_HideWindow(window);\n\n    /* Make sure this window no longer has focus */\n    if (SDL_GetKeyboardFocus() == window) {\n        SDL_SetKeyboardFocus(NULL);\n    }\n    if (SDL_GetMouseFocus() == window) {\n        SDL_SetMouseFocus(NULL);\n    }\n\n    /* make no context current if this is the current context window. */\n    if (window->flags & SDL_WINDOW_OPENGL) {\n        if (_this->current_glwin == window) {\n            SDL_GL_MakeCurrent(window, NULL);\n        }\n    }\n\n    if (window->surface) {\n        window->surface->flags &= ~SDL_DONTFREE;\n        SDL_FreeSurface(window->surface);\n    }\n    if (_this->DestroyWindowFramebuffer) {\n        _this->DestroyWindowFramebuffer(_this, window);\n    }\n    if (_this->DestroyWindow) {\n        _this->DestroyWindow(_this, window);\n    }\n    if (window->flags & SDL_WINDOW_OPENGL) {\n        SDL_GL_UnloadLibrary();\n    }\n\n    display = SDL_GetDisplayForWindow(window);\n    if (display->fullscreen_window == window) {\n        display->fullscreen_window = NULL;\n    }\n\n    /* Now invalidate magic */\n    window->magic = NULL;\n\n    /* Free memory associated with the window */\n    SDL_free(window->title);\n    SDL_FreeSurface(window->icon);\n    SDL_free(window->gamma);\n    while (window->data) {\n        SDL_WindowUserData *data = window->data;\n\n        window->data = data->next;\n        SDL_free(data->name);\n        SDL_free(data);\n    }\n\n    /* Unlink the window from the list */\n    if (window->next) {\n        window->next->prev = window->prev;\n    }\n    if (window->prev) {\n        window->prev->next = window->next;\n    } else {\n        _this->windows = window->next;\n    }\n\n    SDL_free(window);\n}\n\nSDL_bool\nSDL_IsScreenSaverEnabled()\n{\n    if (!_this) {\n        return SDL_TRUE;\n    }\n    return _this->suspend_screensaver ? SDL_FALSE : SDL_TRUE;\n}\n\nvoid\nSDL_EnableScreenSaver()\n{\n    if (!_this) {\n        return;\n    }\n    if (!_this->suspend_screensaver) {\n        return;\n    }\n    _this->suspend_screensaver = SDL_FALSE;\n    if (_this->SuspendScreenSaver) {\n        _this->SuspendScreenSaver(_this);\n    }\n}\n\nvoid\nSDL_DisableScreenSaver()\n{\n    if (!_this) {\n        return;\n    }\n    if (_this->suspend_screensaver) {\n        return;\n    }\n    _this->suspend_screensaver = SDL_TRUE;\n    if (_this->SuspendScreenSaver) {\n        _this->SuspendScreenSaver(_this);\n    }\n}\n\nvoid\nSDL_VideoQuit(void)\n{\n    int i, j;\n\n    if (!_this) {\n        return;\n    }\n\n    /* Halt event processing before doing anything else */\n    SDL_TouchQuit();\n    SDL_MouseQuit();\n    SDL_KeyboardQuit();\n    SDL_QuitSubSystem(SDL_INIT_EVENTS);\n\n    SDL_EnableScreenSaver();\n\n    /* Clean up the system video */\n    while (_this->windows) {\n        SDL_DestroyWindow(_this->windows);\n    }\n    _this->VideoQuit(_this);\n\n    for (i = 0; i < _this->num_displays; ++i) {\n        SDL_VideoDisplay *display = &_this->displays[i];\n        for (j = display->num_display_modes; j--;) {\n            SDL_free(display->display_modes[j].driverdata);\n            display->display_modes[j].driverdata = NULL;\n        }\n        SDL_free(display->display_modes);\n        display->display_modes = NULL;\n        SDL_free(display->desktop_mode.driverdata);\n        display->desktop_mode.driverdata = NULL;\n        SDL_free(display->driverdata);\n        display->driverdata = NULL;\n    }\n    if (_this->displays) {\n        for (i = 0; i < _this->num_displays; ++i) {\n            SDL_free(_this->displays[i].name);\n        }\n        SDL_free(_this->displays);\n        _this->displays = NULL;\n        _this->num_displays = 0;\n    }\n    SDL_free(_this->clipboard_text);\n    _this->clipboard_text = NULL;\n    _this->free(_this);\n    _this = NULL;\n}\n\nint\nSDL_GL_LoadLibrary(const char *path)\n{\n    int retval;\n\n    if (!_this) {\n        return SDL_UninitializedVideo();\n    }\n    if (_this->gl_config.driver_loaded) {\n        if (path && SDL_strcmp(path, _this->gl_config.driver_path) != 0) {\n            return SDL_SetError(\"OpenGL library already loaded\");\n        }\n        retval = 0;\n    } else {\n        if (!_this->GL_LoadLibrary) {\n            return SDL_SetError(\"No dynamic GL support in video driver\");\n        }\n        retval = _this->GL_LoadLibrary(_this, path);\n    }\n    if (retval == 0) {\n        ++_this->gl_config.driver_loaded;\n    } else {\n        if (_this->GL_UnloadLibrary) {\n            _this->GL_UnloadLibrary(_this);\n        }\n    }\n    return (retval);\n}\n\nvoid *\nSDL_GL_GetProcAddress(const char *proc)\n{\n    void *func;\n\n    if (!_this) {\n        SDL_UninitializedVideo();\n        return NULL;\n    }\n    func = NULL;\n    if (_this->GL_GetProcAddress) {\n        if (_this->gl_config.driver_loaded) {\n            func = _this->GL_GetProcAddress(_this, proc);\n        } else {\n            SDL_SetError(\"No GL driver has been loaded\");\n        }\n    } else {\n        SDL_SetError(\"No dynamic GL support in video driver\");\n    }\n    return func;\n}\n\nvoid\nSDL_GL_UnloadLibrary(void)\n{\n    if (!_this) {\n        SDL_UninitializedVideo();\n        return;\n    }\n    if (_this->gl_config.driver_loaded > 0) {\n        if (--_this->gl_config.driver_loaded > 0) {\n            return;\n        }\n        if (_this->GL_UnloadLibrary) {\n            _this->GL_UnloadLibrary(_this);\n        }\n    }\n}\n\nstatic SDL_INLINE SDL_bool\nisAtLeastGL3(const char *verstr)\n{\n    return (verstr && (SDL_atoi(verstr) >= 3));\n}\n\nSDL_bool\nSDL_GL_ExtensionSupported(const char *extension)\n{\n#if SDL_VIDEO_OPENGL || SDL_VIDEO_OPENGL_ES || SDL_VIDEO_OPENGL_ES2\n    const GLubyte *(APIENTRY * glGetStringFunc) (GLenum);\n    const char *extensions;\n    const char *start;\n    const char *where, *terminator;\n\n    /* Extension names should not have spaces. */\n    where = SDL_strchr(extension, ' ');\n    if (where || *extension == '\\0') {\n        return SDL_FALSE;\n    }\n    /* See if there's an environment variable override */\n    start = SDL_getenv(extension);\n    if (start && *start == '0') {\n        return SDL_FALSE;\n    }\n\n    /* Lookup the available extensions */\n\n    glGetStringFunc = SDL_GL_GetProcAddress(\"glGetString\");\n    if (!glGetStringFunc) {\n        return SDL_FALSE;\n    }\n\n    if (isAtLeastGL3((const char *) glGetStringFunc(GL_VERSION))) {\n        const GLubyte *(APIENTRY * glGetStringiFunc) (GLenum, GLuint);\n        void (APIENTRY * glGetIntegervFunc) (GLenum pname, GLint * params);\n        GLint num_exts = 0;\n        GLint i;\n\n        glGetStringiFunc = SDL_GL_GetProcAddress(\"glGetStringi\");\n        glGetIntegervFunc = SDL_GL_GetProcAddress(\"glGetIntegerv\");\n        if ((!glGetStringiFunc) || (!glGetIntegervFunc)) {\n            return SDL_FALSE;\n        }\n\n        #ifndef GL_NUM_EXTENSIONS\n        #define GL_NUM_EXTENSIONS 0x821D\n        #endif\n        glGetIntegervFunc(GL_NUM_EXTENSIONS, &num_exts);\n        for (i = 0; i < num_exts; i++) {\n            const char *thisext = (const char *) glGetStringiFunc(GL_EXTENSIONS, i);\n            if (SDL_strcmp(thisext, extension) == 0) {\n                return SDL_TRUE;\n            }\n        }\n\n        return SDL_FALSE;\n    }\n\n    /* Try the old way with glGetString(GL_EXTENSIONS) ... */\n\n    extensions = (const char *) glGetStringFunc(GL_EXTENSIONS);\n    if (!extensions) {\n        return SDL_FALSE;\n    }\n    /*\n     * It takes a bit of care to be fool-proof about parsing the OpenGL\n     * extensions string. Don't be fooled by sub-strings, etc.\n     */\n\n    start = extensions;\n\n    for (;;) {\n        where = SDL_strstr(start, extension);\n        if (!where)\n            break;\n\n        terminator = where + SDL_strlen(extension);\n        if (where == start || *(where - 1) == ' ')\n            if (*terminator == ' ' || *terminator == '\\0')\n                return SDL_TRUE;\n\n        start = terminator;\n    }\n    return SDL_FALSE;\n#else\n    return SDL_FALSE;\n#endif\n}\n\nvoid\nSDL_GL_ResetAttributes()\n{\n    if (!_this) {\n        return;\n    }\n\n    _this->gl_config.red_size = 3;\n    _this->gl_config.green_size = 3;\n    _this->gl_config.blue_size = 2;\n    _this->gl_config.alpha_size = 0;\n    _this->gl_config.buffer_size = 0;\n    _this->gl_config.depth_size = 16;\n    _this->gl_config.stencil_size = 0;\n    _this->gl_config.double_buffer = 1;\n    _this->gl_config.accum_red_size = 0;\n    _this->gl_config.accum_green_size = 0;\n    _this->gl_config.accum_blue_size = 0;\n    _this->gl_config.accum_alpha_size = 0;\n    _this->gl_config.stereo = 0;\n    _this->gl_config.multisamplebuffers = 0;\n    _this->gl_config.multisamplesamples = 0;\n    _this->gl_config.retained_backing = 1;\n    _this->gl_config.accelerated = -1;  /* accelerated or not, both are fine */\n    _this->gl_config.profile_mask = 0;\n#if SDL_VIDEO_OPENGL\n    _this->gl_config.major_version = 2;\n    _this->gl_config.minor_version = 1;\n#elif SDL_VIDEO_OPENGL_ES2\n    _this->gl_config.major_version = 2;\n    _this->gl_config.minor_version = 0;\n    _this->gl_config.profile_mask = SDL_GL_CONTEXT_PROFILE_ES;\n#elif SDL_VIDEO_OPENGL_ES\n    _this->gl_config.major_version = 1;\n    _this->gl_config.minor_version = 1;\n    _this->gl_config.profile_mask = SDL_GL_CONTEXT_PROFILE_ES;\n#endif\n    _this->gl_config.flags = 0;\n    _this->gl_config.framebuffer_srgb_capable = 0;\n    _this->gl_config.release_behavior = SDL_GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH;\n\n    _this->gl_config.share_with_current_context = 0;\n}\n\nint\nSDL_GL_SetAttribute(SDL_GLattr attr, int value)\n{\n#if SDL_VIDEO_OPENGL || SDL_VIDEO_OPENGL_ES || SDL_VIDEO_OPENGL_ES2\n    int retval;\n\n    if (!_this) {\n        return SDL_UninitializedVideo();\n    }\n    retval = 0;\n    switch (attr) {\n    case SDL_GL_RED_SIZE:\n        _this->gl_config.red_size = value;\n        break;\n    case SDL_GL_GREEN_SIZE:\n        _this->gl_config.green_size = value;\n        break;\n    case SDL_GL_BLUE_SIZE:\n        _this->gl_config.blue_size = value;\n        break;\n    case SDL_GL_ALPHA_SIZE:\n        _this->gl_config.alpha_size = value;\n        break;\n    case SDL_GL_DOUBLEBUFFER:\n        _this->gl_config.double_buffer = value;\n        break;\n    case SDL_GL_BUFFER_SIZE:\n        _this->gl_config.buffer_size = value;\n        break;\n    case SDL_GL_DEPTH_SIZE:\n        _this->gl_config.depth_size = value;\n        break;\n    case SDL_GL_STENCIL_SIZE:\n        _this->gl_config.stencil_size = value;\n        break;\n    case SDL_GL_ACCUM_RED_SIZE:\n        _this->gl_config.accum_red_size = value;\n        break;\n    case SDL_GL_ACCUM_GREEN_SIZE:\n        _this->gl_config.accum_green_size = value;\n        break;\n    case SDL_GL_ACCUM_BLUE_SIZE:\n        _this->gl_config.accum_blue_size = value;\n        break;\n    case SDL_GL_ACCUM_ALPHA_SIZE:\n        _this->gl_config.accum_alpha_size = value;\n        break;\n    case SDL_GL_STEREO:\n        _this->gl_config.stereo = value;\n        break;\n    case SDL_GL_MULTISAMPLEBUFFERS:\n        _this->gl_config.multisamplebuffers = value;\n        break;\n    case SDL_GL_MULTISAMPLESAMPLES:\n        _this->gl_config.multisamplesamples = value;\n        break;\n    case SDL_GL_ACCELERATED_VISUAL:\n        _this->gl_config.accelerated = value;\n        break;\n    case SDL_GL_RETAINED_BACKING:\n        _this->gl_config.retained_backing = value;\n        break;\n    case SDL_GL_CONTEXT_MAJOR_VERSION:\n        _this->gl_config.major_version = value;\n        break;\n    case SDL_GL_CONTEXT_MINOR_VERSION:\n        _this->gl_config.minor_version = value;\n        break;\n    case SDL_GL_CONTEXT_EGL:\n        /* FIXME: SDL_GL_CONTEXT_EGL to be deprecated in SDL 2.1 */\n        if (value != 0) {\n            SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_ES);\n        } else {\n            SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, 0);\n        };\n        break;\n    case SDL_GL_CONTEXT_FLAGS:\n        if (value & ~(SDL_GL_CONTEXT_DEBUG_FLAG |\n                      SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG |\n                      SDL_GL_CONTEXT_ROBUST_ACCESS_FLAG |\n                      SDL_GL_CONTEXT_RESET_ISOLATION_FLAG)) {\n            retval = SDL_SetError(\"Unknown OpenGL context flag %d\", value);\n            break;\n        }\n        _this->gl_config.flags = value;\n        break;\n    case SDL_GL_CONTEXT_PROFILE_MASK:\n        if (value != 0 &&\n            value != SDL_GL_CONTEXT_PROFILE_CORE &&\n            value != SDL_GL_CONTEXT_PROFILE_COMPATIBILITY &&\n            value != SDL_GL_CONTEXT_PROFILE_ES) {\n            retval = SDL_SetError(\"Unknown OpenGL context profile %d\", value);\n            break;\n        }\n        _this->gl_config.profile_mask = value;\n        break;\n    case SDL_GL_SHARE_WITH_CURRENT_CONTEXT:\n        _this->gl_config.share_with_current_context = value;\n        break;\n    case SDL_GL_FRAMEBUFFER_SRGB_CAPABLE:\n        _this->gl_config.framebuffer_srgb_capable = value;\n        break;\n    case SDL_GL_CONTEXT_RELEASE_BEHAVIOR:\n        _this->gl_config.release_behavior = value;\n        break;\n    default:\n        retval = SDL_SetError(\"Unknown OpenGL attribute\");\n        break;\n    }\n    return retval;\n#else\n    return SDL_Unsupported();\n#endif /* SDL_VIDEO_OPENGL */\n}\n\nint\nSDL_GL_GetAttribute(SDL_GLattr attr, int *value)\n{\n#if SDL_VIDEO_OPENGL || SDL_VIDEO_OPENGL_ES || SDL_VIDEO_OPENGL_ES2\n    void (APIENTRY * glGetIntegervFunc) (GLenum pname, GLint * params);\n    GLenum(APIENTRY * glGetErrorFunc) (void);\n    GLenum attrib = 0;\n    GLenum error = 0;\n\n    glGetIntegervFunc = SDL_GL_GetProcAddress(\"glGetIntegerv\");\n    if (!glGetIntegervFunc) {\n        return -1;\n    }\n\n    glGetErrorFunc = SDL_GL_GetProcAddress(\"glGetError\");\n    if (!glGetErrorFunc) {\n        return -1;\n    }\n\n    /* Clear value in any case */\n    *value = 0;\n\n    switch (attr) {\n    case SDL_GL_RED_SIZE:\n        attrib = GL_RED_BITS;\n        break;\n    case SDL_GL_BLUE_SIZE:\n        attrib = GL_BLUE_BITS;\n        break;\n    case SDL_GL_GREEN_SIZE:\n        attrib = GL_GREEN_BITS;\n        break;\n    case SDL_GL_ALPHA_SIZE:\n        attrib = GL_ALPHA_BITS;\n        break;\n    case SDL_GL_DOUBLEBUFFER:\n#if SDL_VIDEO_OPENGL\n        attrib = GL_DOUBLEBUFFER;\n        break;\n#else\n        /* OpenGL ES 1.0 and above specifications have EGL_SINGLE_BUFFER      */\n        /* parameter which switches double buffer to single buffer. OpenGL ES */\n        /* SDL driver must set proper value after initialization              */\n        *value = _this->gl_config.double_buffer;\n        return 0;\n#endif\n    case SDL_GL_DEPTH_SIZE:\n        attrib = GL_DEPTH_BITS;\n        break;\n    case SDL_GL_STENCIL_SIZE:\n        attrib = GL_STENCIL_BITS;\n        break;\n#if SDL_VIDEO_OPENGL\n    case SDL_GL_ACCUM_RED_SIZE:\n        attrib = GL_ACCUM_RED_BITS;\n        break;\n    case SDL_GL_ACCUM_GREEN_SIZE:\n        attrib = GL_ACCUM_GREEN_BITS;\n        break;\n    case SDL_GL_ACCUM_BLUE_SIZE:\n        attrib = GL_ACCUM_BLUE_BITS;\n        break;\n    case SDL_GL_ACCUM_ALPHA_SIZE:\n        attrib = GL_ACCUM_ALPHA_BITS;\n        break;\n    case SDL_GL_STEREO:\n        attrib = GL_STEREO;\n        break;\n#else\n    case SDL_GL_ACCUM_RED_SIZE:\n    case SDL_GL_ACCUM_GREEN_SIZE:\n    case SDL_GL_ACCUM_BLUE_SIZE:\n    case SDL_GL_ACCUM_ALPHA_SIZE:\n    case SDL_GL_STEREO:\n        /* none of these are supported in OpenGL ES */\n        *value = 0;\n        return 0;\n#endif\n    case SDL_GL_MULTISAMPLEBUFFERS:\n#if SDL_VIDEO_OPENGL\n        attrib = GL_SAMPLE_BUFFERS_ARB;\n#else\n        attrib = GL_SAMPLE_BUFFERS;\n#endif\n        break;\n    case SDL_GL_MULTISAMPLESAMPLES:\n#if SDL_VIDEO_OPENGL\n        attrib = GL_SAMPLES_ARB;\n#else\n        attrib = GL_SAMPLES;\n#endif\n        break;\n    case SDL_GL_CONTEXT_RELEASE_BEHAVIOR:\n#if SDL_VIDEO_OPENGL\n        attrib = GL_CONTEXT_RELEASE_BEHAVIOR;\n#else\n        attrib = GL_CONTEXT_RELEASE_BEHAVIOR_KHR;\n#endif\n        break;\n    case SDL_GL_BUFFER_SIZE:\n        {\n            GLint bits = 0;\n            GLint component;\n\n            /*\n             * there doesn't seem to be a single flag in OpenGL\n             * for this!\n             */\n            glGetIntegervFunc(GL_RED_BITS, &component);\n            bits += component;\n            glGetIntegervFunc(GL_GREEN_BITS, &component);\n            bits += component;\n            glGetIntegervFunc(GL_BLUE_BITS, &component);\n            bits += component;\n            glGetIntegervFunc(GL_ALPHA_BITS, &component);\n            bits += component;\n\n            *value = bits;\n            return 0;\n        }\n    case SDL_GL_ACCELERATED_VISUAL:\n        {\n            /* FIXME: How do we get this information? */\n            *value = (_this->gl_config.accelerated != 0);\n            return 0;\n        }\n    case SDL_GL_RETAINED_BACKING:\n        {\n            *value = _this->gl_config.retained_backing;\n            return 0;\n        }\n    case SDL_GL_CONTEXT_MAJOR_VERSION:\n        {\n            *value = _this->gl_config.major_version;\n            return 0;\n        }\n    case SDL_GL_CONTEXT_MINOR_VERSION:\n        {\n            *value = _this->gl_config.minor_version;\n            return 0;\n        }\n    case SDL_GL_CONTEXT_EGL:\n        /* FIXME: SDL_GL_CONTEXT_EGL to be deprecated in SDL 2.1 */\n        {\n            if (_this->gl_config.profile_mask == SDL_GL_CONTEXT_PROFILE_ES) {\n                *value = 1;\n            }\n            else {\n                *value = 0;\n            }\n            return 0;\n        }\n    case SDL_GL_CONTEXT_FLAGS:\n        {\n            *value = _this->gl_config.flags;\n            return 0;\n        }\n    case SDL_GL_CONTEXT_PROFILE_MASK:\n        {\n            *value = _this->gl_config.profile_mask;\n            return 0;\n        }\n    case SDL_GL_SHARE_WITH_CURRENT_CONTEXT:\n        {\n            *value = _this->gl_config.share_with_current_context;\n            return 0;\n        }\n    case SDL_GL_FRAMEBUFFER_SRGB_CAPABLE:\n        {\n            *value = _this->gl_config.framebuffer_srgb_capable;\n            return 0;\n        }\n    default:\n        return SDL_SetError(\"Unknown OpenGL attribute\");\n    }\n\n    glGetIntegervFunc(attrib, (GLint *) value);\n    error = glGetErrorFunc();\n    if (error != GL_NO_ERROR) {\n        if (error == GL_INVALID_ENUM) {\n            return SDL_SetError(\"OpenGL error: GL_INVALID_ENUM\");\n        } else if (error == GL_INVALID_VALUE) {\n            return SDL_SetError(\"OpenGL error: GL_INVALID_VALUE\");\n        }\n        return SDL_SetError(\"OpenGL error: %08X\", error);\n    }\n    return 0;\n#else\n    return SDL_Unsupported();\n#endif /* SDL_VIDEO_OPENGL */\n}\n\nSDL_GLContext\nSDL_GL_CreateContext(SDL_Window * window)\n{\n    SDL_GLContext ctx = NULL;\n    CHECK_WINDOW_MAGIC(window, NULL);\n\n    if (!(window->flags & SDL_WINDOW_OPENGL)) {\n        SDL_SetError(\"The specified window isn't an OpenGL window\");\n        return NULL;\n    }\n\n    ctx = _this->GL_CreateContext(_this, window);\n\n    /* Creating a context is assumed to make it current in the SDL driver. */\n    if (ctx) {\n        _this->current_glwin = window;\n        _this->current_glctx = ctx;\n        SDL_TLSSet(_this->current_glwin_tls, window, NULL);\n        SDL_TLSSet(_this->current_glctx_tls, ctx, NULL);\n    }\n    return ctx;\n}\n\nint\nSDL_GL_MakeCurrent(SDL_Window * window, SDL_GLContext ctx)\n{\n    int retval;\n\n    if (window == SDL_GL_GetCurrentWindow() &&\n        ctx == SDL_GL_GetCurrentContext()) {\n        /* We're already current. */\n        return 0;\n    }\n\n    if (!ctx) {\n        window = NULL;\n    } else {\n        CHECK_WINDOW_MAGIC(window, -1);\n\n        if (!(window->flags & SDL_WINDOW_OPENGL)) {\n            return SDL_SetError(\"The specified window isn't an OpenGL window\");\n        }\n    }\n\n    retval = _this->GL_MakeCurrent(_this, window, ctx);\n    if (retval == 0) {\n        _this->current_glwin = window;\n        _this->current_glctx = ctx;\n        SDL_TLSSet(_this->current_glwin_tls, window, NULL);\n        SDL_TLSSet(_this->current_glctx_tls, ctx, NULL);\n    }\n    return retval;\n}\n\nSDL_Window *\nSDL_GL_GetCurrentWindow(void)\n{\n    if (!_this) {\n        SDL_UninitializedVideo();\n        return NULL;\n    }\n    return (SDL_Window *)SDL_TLSGet(_this->current_glwin_tls);\n}\n\nSDL_GLContext\nSDL_GL_GetCurrentContext(void)\n{\n    if (!_this) {\n        SDL_UninitializedVideo();\n        return NULL;\n    }\n    return (SDL_GLContext)SDL_TLSGet(_this->current_glctx_tls);\n}\n\nvoid SDL_GL_GetDrawableSize(SDL_Window * window, int *w, int *h)\n{\n    CHECK_WINDOW_MAGIC(window,);\n\n    if (_this->GL_GetDrawableSize) {\n        _this->GL_GetDrawableSize(_this, window, w, h);\n    } else {\n        SDL_GetWindowSize(window, w, h);\n    }\n}\n\nint\nSDL_GL_SetSwapInterval(int interval)\n{\n    if (!_this) {\n        return SDL_UninitializedVideo();\n    } else if (SDL_GL_GetCurrentContext() == NULL) {\n        return SDL_SetError(\"No OpenGL context has been made current\");\n    } else if (_this->GL_SetSwapInterval) {\n        return _this->GL_SetSwapInterval(_this, interval);\n    } else {\n        return SDL_SetError(\"Setting the swap interval is not supported\");\n    }\n}\n\nint\nSDL_GL_GetSwapInterval(void)\n{\n    if (!_this) {\n        return 0;\n    } else if (SDL_GL_GetCurrentContext() == NULL) {\n        return 0;\n    } else if (_this->GL_GetSwapInterval) {\n        return _this->GL_GetSwapInterval(_this);\n    } else {\n        return 0;\n    }\n}\n\nvoid\nSDL_GL_SwapWindow(SDL_Window * window)\n{\n    CHECK_WINDOW_MAGIC(window,);\n\n    if (!(window->flags & SDL_WINDOW_OPENGL)) {\n        SDL_SetError(\"The specified window isn't an OpenGL window\");\n        return;\n    }\n\n    if (SDL_GL_GetCurrentWindow() != window) {\n        SDL_SetError(\"The specified window has not been made current\");\n        return;\n    }\n\n    _this->GL_SwapWindow(_this, window);\n}\n\nvoid\nSDL_GL_DeleteContext(SDL_GLContext context)\n{\n    if (!_this || !context) {\n        return;\n    }\n\n    if (SDL_GL_GetCurrentContext() == context) {\n        SDL_GL_MakeCurrent(NULL, NULL);\n    }\n\n    _this->GL_DeleteContext(_this, context);\n}\n\n#if 0                           /* FIXME */\n/*\n * Utility function used by SDL_WM_SetIcon(); flags & 1 for color key, flags\n * & 2 for alpha channel.\n */\nstatic void\nCreateMaskFromColorKeyOrAlpha(SDL_Surface * icon, Uint8 * mask, int flags)\n{\n    int x, y;\n    Uint32 colorkey;\n#define SET_MASKBIT(icon, x, y, mask) \\\n    mask[(y*((icon->w+7)/8))+(x/8)] &= ~(0x01<<(7-(x%8)))\n\n    colorkey = icon->format->colorkey;\n    switch (icon->format->BytesPerPixel) {\n    case 1:\n        {\n            Uint8 *pixels;\n            for (y = 0; y < icon->h; ++y) {\n                pixels = (Uint8 *) icon->pixels + y * icon->pitch;\n                for (x = 0; x < icon->w; ++x) {\n                    if (*pixels++ == colorkey) {\n                        SET_MASKBIT(icon, x, y, mask);\n                    }\n                }\n            }\n        }\n        break;\n\n    case 2:\n        {\n            Uint16 *pixels;\n            for (y = 0; y < icon->h; ++y) {\n                pixels = (Uint16 *) icon->pixels + y * icon->pitch / 2;\n                for (x = 0; x < icon->w; ++x) {\n                    if ((flags & 1) && *pixels == colorkey) {\n                        SET_MASKBIT(icon, x, y, mask);\n                    } else if ((flags & 2)\n                               && (*pixels & icon->format->Amask) == 0) {\n                        SET_MASKBIT(icon, x, y, mask);\n                    }\n                    pixels++;\n                }\n            }\n        }\n        break;\n\n    case 4:\n        {\n            Uint32 *pixels;\n            for (y = 0; y < icon->h; ++y) {\n                pixels = (Uint32 *) icon->pixels + y * icon->pitch / 4;\n                for (x = 0; x < icon->w; ++x) {\n                    if ((flags & 1) && *pixels == colorkey) {\n                        SET_MASKBIT(icon, x, y, mask);\n                    } else if ((flags & 2)\n                               && (*pixels & icon->format->Amask) == 0) {\n                        SET_MASKBIT(icon, x, y, mask);\n                    }\n                    pixels++;\n                }\n            }\n        }\n        break;\n    }\n}\n\n/*\n * Sets the window manager icon for the display window.\n */\nvoid\nSDL_WM_SetIcon(SDL_Surface * icon, Uint8 * mask)\n{\n    if (icon && _this->SetIcon) {\n        /* Generate a mask if necessary, and create the icon! */\n        if (mask == NULL) {\n            int mask_len = icon->h * (icon->w + 7) / 8;\n            int flags = 0;\n            mask = (Uint8 *) SDL_malloc(mask_len);\n            if (mask == NULL) {\n                return;\n            }\n            SDL_memset(mask, ~0, mask_len);\n            if (icon->flags & SDL_SRCCOLORKEY)\n                flags |= 1;\n            if (icon->flags & SDL_SRCALPHA)\n                flags |= 2;\n            if (flags) {\n                CreateMaskFromColorKeyOrAlpha(icon, mask, flags);\n            }\n            _this->SetIcon(_this, icon, mask);\n            SDL_free(mask);\n        } else {\n            _this->SetIcon(_this, icon, mask);\n        }\n    }\n}\n#endif\n\nSDL_bool\nSDL_GetWindowWMInfo(SDL_Window * window, struct SDL_SysWMinfo *info)\n{\n    CHECK_WINDOW_MAGIC(window, SDL_FALSE);\n\n    if (!info) {\n        SDL_InvalidParamError(\"info\");\n        return SDL_FALSE;\n    }\n    info->subsystem = SDL_SYSWM_UNKNOWN;\n\n    if (!_this->GetWindowWMInfo) {\n        SDL_Unsupported();\n        return SDL_FALSE;\n    }\n    return (_this->GetWindowWMInfo(_this, window, info));\n}\n\nvoid\nSDL_StartTextInput(void)\n{\n    SDL_Window *window;\n\n    /* First, enable text events */\n    SDL_EventState(SDL_TEXTINPUT, SDL_ENABLE);\n    SDL_EventState(SDL_TEXTEDITING, SDL_ENABLE);\n\n    /* Then show the on-screen keyboard, if any */\n    window = SDL_GetFocusWindow();\n    if (window && _this && _this->ShowScreenKeyboard) {\n        _this->ShowScreenKeyboard(_this, window);\n    }\n\n    /* Finally start the text input system */\n    if (_this && _this->StartTextInput) {\n        _this->StartTextInput(_this);\n    }\n}\n\nSDL_bool\nSDL_IsTextInputActive(void)\n{\n    return (SDL_GetEventState(SDL_TEXTINPUT) == SDL_ENABLE);\n}\n\nvoid\nSDL_StopTextInput(void)\n{\n    SDL_Window *window;\n\n    /* Stop the text input system */\n    if (_this && _this->StopTextInput) {\n        _this->StopTextInput(_this);\n    }\n\n    /* Hide the on-screen keyboard, if any */\n    window = SDL_GetFocusWindow();\n    if (window && _this && _this->HideScreenKeyboard) {\n        _this->HideScreenKeyboard(_this, window);\n    }\n\n    /* Finally disable text events */\n    SDL_EventState(SDL_TEXTINPUT, SDL_DISABLE);\n    SDL_EventState(SDL_TEXTEDITING, SDL_DISABLE);\n}\n\nvoid\nSDL_SetTextInputRect(SDL_Rect *rect)\n{\n    if (_this && _this->SetTextInputRect) {\n        _this->SetTextInputRect(_this, rect);\n    }\n}\n\nSDL_bool\nSDL_HasScreenKeyboardSupport(void)\n{\n    if (_this && _this->HasScreenKeyboardSupport) {\n        return _this->HasScreenKeyboardSupport(_this);\n    }\n    return SDL_FALSE;\n}\n\nSDL_bool\nSDL_IsScreenKeyboardShown(SDL_Window *window)\n{\n    if (window && _this && _this->IsScreenKeyboardShown) {\n        return _this->IsScreenKeyboardShown(_this, window);\n    }\n    return SDL_FALSE;\n}\n\n#if SDL_VIDEO_DRIVER_ANDROID\n#include \"android/SDL_androidmessagebox.h\"\n#endif\n#if SDL_VIDEO_DRIVER_WINDOWS\n#include \"windows/SDL_windowsmessagebox.h\"\n#endif\n#if SDL_VIDEO_DRIVER_WINRT\n#include \"winrt/SDL_winrtmessagebox.h\"\n#endif\n#if SDL_VIDEO_DRIVER_COCOA\n#include \"cocoa/SDL_cocoamessagebox.h\"\n#endif\n#if SDL_VIDEO_DRIVER_UIKIT\n#include \"uikit/SDL_uikitmessagebox.h\"\n#endif\n#if SDL_VIDEO_DRIVER_X11\n#include \"x11/SDL_x11messagebox.h\"\n#endif\n\n// This function will be unused if none of the above video drivers are present.\nSDL_UNUSED static SDL_bool SDL_MessageboxValidForDriver(const SDL_MessageBoxData *messageboxdata, SDL_SYSWM_TYPE drivertype)\n{\n    SDL_SysWMinfo info;\n    SDL_Window *window = messageboxdata->window;\n\n    if (!window) {\n        return SDL_TRUE;\n    }\n\n    SDL_VERSION(&info.version);\n    if (!SDL_GetWindowWMInfo(window, &info)) {\n        return SDL_TRUE;\n    } else {\n        return (info.subsystem == drivertype);\n    }\n}\n\nint\nSDL_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *buttonid)\n{\n    int dummybutton;\n    int retval = -1;\n    SDL_bool relative_mode;\n    int show_cursor_prev;\n    SDL_bool mouse_captured;\n    SDL_Window *current_window;\n\n    if (!messageboxdata) {\n        return SDL_InvalidParamError(\"messageboxdata\");\n    }\n\n    current_window = SDL_GetKeyboardFocus();\n    mouse_captured = current_window && ((SDL_GetWindowFlags(current_window) & SDL_WINDOW_MOUSE_CAPTURE) != 0);\n    relative_mode = SDL_GetRelativeMouseMode();\n    SDL_CaptureMouse(SDL_FALSE);\n    SDL_SetRelativeMouseMode(SDL_FALSE);\n    show_cursor_prev = SDL_ShowCursor(1);\n\n    if (!buttonid) {\n        buttonid = &dummybutton;\n    }\n\n    if (_this && _this->ShowMessageBox) {\n        retval = _this->ShowMessageBox(_this, messageboxdata, buttonid);\n    }\n\n    /* It's completely fine to call this function before video is initialized */\n#if SDL_VIDEO_DRIVER_ANDROID\n    if (retval == -1 &&\n        Android_ShowMessageBox(messageboxdata, buttonid) == 0) {\n        retval = 0;\n    }\n#endif\n#if SDL_VIDEO_DRIVER_WINDOWS\n    if (retval == -1 &&\n        SDL_MessageboxValidForDriver(messageboxdata, SDL_SYSWM_WINDOWS) &&\n        WIN_ShowMessageBox(messageboxdata, buttonid) == 0) {\n        retval = 0;\n    }\n#endif\n#if SDL_VIDEO_DRIVER_WINRT\n    if (retval == -1 &&\n        SDL_MessageboxValidForDriver(messageboxdata, SDL_SYSWM_WINRT) &&\n        WINRT_ShowMessageBox(messageboxdata, buttonid) == 0) {\n        retval = 0;\n    }\n#endif\n#if SDL_VIDEO_DRIVER_COCOA\n    if (retval == -1 &&\n        SDL_MessageboxValidForDriver(messageboxdata, SDL_SYSWM_COCOA) &&\n        Cocoa_ShowMessageBox(messageboxdata, buttonid) == 0) {\n        retval = 0;\n    }\n#endif\n#if SDL_VIDEO_DRIVER_UIKIT\n    if (retval == -1 &&\n        SDL_MessageboxValidForDriver(messageboxdata, SDL_SYSWM_UIKIT) &&\n        UIKit_ShowMessageBox(messageboxdata, buttonid) == 0) {\n        retval = 0;\n    }\n#endif\n#if SDL_VIDEO_DRIVER_X11\n    if (retval == -1 &&\n        SDL_MessageboxValidForDriver(messageboxdata, SDL_SYSWM_X11) &&\n        X11_ShowMessageBox(messageboxdata, buttonid) == 0) {\n        retval = 0;\n    }\n#endif\n    if (retval == -1) {\n        SDL_SetError(\"No message system available\");\n    }\n\n    if (current_window) {\n        SDL_RaiseWindow(current_window);\n        if (mouse_captured) {\n            SDL_CaptureMouse(SDL_TRUE);\n        }\n    }\n\n    SDL_ShowCursor(show_cursor_prev);\n    SDL_SetRelativeMouseMode(relative_mode);\n\n    return retval;\n}\n\nint\nSDL_ShowSimpleMessageBox(Uint32 flags, const char *title, const char *message, SDL_Window *window)\n{\n    SDL_MessageBoxData data;\n    SDL_MessageBoxButtonData button;\n\n    SDL_zero(data);\n    data.flags = flags;\n    data.title = title;\n    data.message = message;\n    data.numbuttons = 1;\n    data.buttons = &button;\n    data.window = window;\n\n    SDL_zero(button);\n    button.flags |= SDL_MESSAGEBOX_BUTTON_RETURNKEY_DEFAULT;\n    button.flags |= SDL_MESSAGEBOX_BUTTON_ESCAPEKEY_DEFAULT;\n    button.text = \"OK\";\n\n    return SDL_ShowMessageBox(&data, NULL);\n}\n\nSDL_bool\nSDL_ShouldAllowTopmost(void)\n{\n    const char *hint = SDL_GetHint(SDL_HINT_ALLOW_TOPMOST);\n    if (hint) {\n        if (*hint == '0') {\n            return SDL_FALSE;\n        } else {\n            return SDL_TRUE;\n        }\n    }\n    return SDL_TRUE;\n}\n\nint\nSDL_SetWindowHitTest(SDL_Window * window, SDL_HitTest callback, void *userdata)\n{\n    CHECK_WINDOW_MAGIC(window, -1);\n\n    if (!_this->SetWindowHitTest) {\n        return SDL_Unsupported();\n    } else if (_this->SetWindowHitTest(window, callback != NULL) == -1) {\n        return -1;\n    }\n\n    window->hit_test = callback;\n    window->hit_test_data = userdata;\n\n    return 0;\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../SDL_internal.h\"\n\n/* This is the joystick API for Simple DirectMedia Layer */\n\n#include \"SDL.h\"\n#include \"SDL_events.h\"\n#include \"SDL_sysjoystick.h\"\n#include \"SDL_assert.h\"\n#include \"SDL_hints.h\"\n\n#if !SDL_EVENTS_DISABLED\n#include \"../events/SDL_events_c.h\"\n#endif\n\nstatic SDL_bool SDL_joystick_allows_background_events = SDL_FALSE;\nstatic SDL_Joystick *SDL_joysticks = NULL;\nstatic SDL_Joystick *SDL_updating_joystick = NULL;\n\nstatic void\nSDL_JoystickAllowBackgroundEventsChanged(void *userdata, const char *name, const char *oldValue, const char *hint)\n{\n    if (hint && *hint == '1') {\n        SDL_joystick_allows_background_events = SDL_TRUE;\n    } else {\n        SDL_joystick_allows_background_events = SDL_FALSE;\n    }\n}\n\nint\nSDL_JoystickInit(void)\n{\n    int status;\n\n    /* See if we should allow joystick events while in the background */\n    SDL_AddHintCallback(SDL_HINT_JOYSTICK_ALLOW_BACKGROUND_EVENTS,\n                        SDL_JoystickAllowBackgroundEventsChanged, NULL);\n\n#if !SDL_EVENTS_DISABLED\n    if (SDL_InitSubSystem(SDL_INIT_EVENTS) < 0) {\n        return -1;\n    }\n#endif /* !SDL_EVENTS_DISABLED */\n\n    status = SDL_SYS_JoystickInit();\n    if (status >= 0) {\n        status = 0;\n    }\n    return (status);\n}\n\n/*\n * Count the number of joysticks attached to the system\n */\nint\nSDL_NumJoysticks(void)\n{\n    return SDL_SYS_NumJoysticks();\n}\n\n/*\n * Get the implementation dependent name of a joystick\n */\nconst char *\nSDL_JoystickNameForIndex(int device_index)\n{\n    if ((device_index < 0) || (device_index >= SDL_NumJoysticks())) {\n        SDL_SetError(\"There are %d joysticks available\", SDL_NumJoysticks());\n        return (NULL);\n    }\n    return (SDL_SYS_JoystickNameForDeviceIndex(device_index));\n}\n\n/*\n * Open a joystick for use - the index passed as an argument refers to\n * the N'th joystick on the system.  This index is the value which will\n * identify this joystick in future joystick events.\n *\n * This function returns a joystick identifier, or NULL if an error occurred.\n */\nSDL_Joystick *\nSDL_JoystickOpen(int device_index)\n{\n    SDL_Joystick *joystick;\n    SDL_Joystick *joysticklist;\n    const char *joystickname = NULL;\n\n    if ((device_index < 0) || (device_index >= SDL_NumJoysticks())) {\n        SDL_SetError(\"There are %d joysticks available\", SDL_NumJoysticks());\n        return (NULL);\n    }\n\n    joysticklist = SDL_joysticks;\n    /* If the joystick is already open, return it\n    * it is important that we have a single joystick * for each instance id\n    */\n    while (joysticklist) {\n        if (SDL_SYS_GetInstanceIdOfDeviceIndex(device_index) == joysticklist->instance_id) {\n                joystick = joysticklist;\n                ++joystick->ref_count;\n                return (joystick);\n        }\n        joysticklist = joysticklist->next;\n    }\n\n    /* Create and initialize the joystick */\n    joystick = (SDL_Joystick *) SDL_malloc((sizeof *joystick));\n    if (joystick == NULL) {\n        SDL_OutOfMemory();\n        return NULL;\n    }\n\n    SDL_memset(joystick, 0, (sizeof *joystick));\n    if (SDL_SYS_JoystickOpen(joystick, device_index) < 0) {\n        SDL_free(joystick);\n        return NULL;\n    }\n\n    joystickname = SDL_SYS_JoystickNameForDeviceIndex(device_index);\n    if (joystickname)\n        joystick->name = SDL_strdup(joystickname);\n    else\n        joystick->name = NULL;\n\n    if (joystick->naxes > 0) {\n        joystick->axes = (Sint16 *) SDL_malloc\n            (joystick->naxes * sizeof(Sint16));\n    }\n    if (joystick->nhats > 0) {\n        joystick->hats = (Uint8 *) SDL_malloc\n            (joystick->nhats * sizeof(Uint8));\n    }\n    if (joystick->nballs > 0) {\n        joystick->balls = (struct balldelta *) SDL_malloc\n            (joystick->nballs * sizeof(*joystick->balls));\n    }\n    if (joystick->nbuttons > 0) {\n        joystick->buttons = (Uint8 *) SDL_malloc\n            (joystick->nbuttons * sizeof(Uint8));\n    }\n    if (((joystick->naxes > 0) && !joystick->axes)\n        || ((joystick->nhats > 0) && !joystick->hats)\n        || ((joystick->nballs > 0) && !joystick->balls)\n        || ((joystick->nbuttons > 0) && !joystick->buttons)) {\n        SDL_OutOfMemory();\n        SDL_JoystickClose(joystick);\n        return NULL;\n    }\n    if (joystick->axes) {\n        SDL_memset(joystick->axes, 0, joystick->naxes * sizeof(Sint16));\n    }\n    if (joystick->hats) {\n        SDL_memset(joystick->hats, 0, joystick->nhats * sizeof(Uint8));\n    }\n    if (joystick->balls) {\n        SDL_memset(joystick->balls, 0,\n            joystick->nballs * sizeof(*joystick->balls));\n    }\n    if (joystick->buttons) {\n        SDL_memset(joystick->buttons, 0, joystick->nbuttons * sizeof(Uint8));\n    }\n\n    /* Add joystick to list */\n    ++joystick->ref_count;\n    /* Link the joystick in the list */\n    joystick->next = SDL_joysticks;\n    SDL_joysticks = joystick;\n\n    SDL_SYS_JoystickUpdate(joystick);\n\n    return (joystick);\n}\n\n\n/*\n * Checks to make sure the joystick is valid.\n */\nint\nSDL_PrivateJoystickValid(SDL_Joystick * joystick)\n{\n    int valid;\n\n    if (joystick == NULL) {\n        SDL_SetError(\"Joystick hasn't been opened yet\");\n        valid = 0;\n    } else {\n        valid = 1;\n    }\n\n    if (joystick && joystick->closed) {\n        valid = 0;\n    }\n\n    return valid;\n}\n\n/*\n * Get the number of multi-dimensional axis controls on a joystick\n */\nint\nSDL_JoystickNumAxes(SDL_Joystick * joystick)\n{\n    if (!SDL_PrivateJoystickValid(joystick)) {\n        return (-1);\n    }\n    return (joystick->naxes);\n}\n\n/*\n * Get the number of hats on a joystick\n */\nint\nSDL_JoystickNumHats(SDL_Joystick * joystick)\n{\n    if (!SDL_PrivateJoystickValid(joystick)) {\n        return (-1);\n    }\n    return (joystick->nhats);\n}\n\n/*\n * Get the number of trackballs on a joystick\n */\nint\nSDL_JoystickNumBalls(SDL_Joystick * joystick)\n{\n    if (!SDL_PrivateJoystickValid(joystick)) {\n        return (-1);\n    }\n    return (joystick->nballs);\n}\n\n/*\n * Get the number of buttons on a joystick\n */\nint\nSDL_JoystickNumButtons(SDL_Joystick * joystick)\n{\n    if (!SDL_PrivateJoystickValid(joystick)) {\n        return (-1);\n    }\n    return (joystick->nbuttons);\n}\n\n/*\n * Get the current state of an axis control on a joystick\n */\nSint16\nSDL_JoystickGetAxis(SDL_Joystick * joystick, int axis)\n{\n    Sint16 state;\n\n    if (!SDL_PrivateJoystickValid(joystick)) {\n        return (0);\n    }\n    if (axis < joystick->naxes) {\n        state = joystick->axes[axis];\n    } else {\n        SDL_SetError(\"Joystick only has %d axes\", joystick->naxes);\n        state = 0;\n    }\n    return (state);\n}\n\n/*\n * Get the current state of a hat on a joystick\n */\nUint8\nSDL_JoystickGetHat(SDL_Joystick * joystick, int hat)\n{\n    Uint8 state;\n\n    if (!SDL_PrivateJoystickValid(joystick)) {\n        return (0);\n    }\n    if (hat < joystick->nhats) {\n        state = joystick->hats[hat];\n    } else {\n        SDL_SetError(\"Joystick only has %d hats\", joystick->nhats);\n        state = 0;\n    }\n    return (state);\n}\n\n/*\n * Get the ball axis change since the last poll\n */\nint\nSDL_JoystickGetBall(SDL_Joystick * joystick, int ball, int *dx, int *dy)\n{\n    int retval;\n\n    if (!SDL_PrivateJoystickValid(joystick)) {\n        return (-1);\n    }\n\n    retval = 0;\n    if (ball < joystick->nballs) {\n        if (dx) {\n            *dx = joystick->balls[ball].dx;\n        }\n        if (dy) {\n            *dy = joystick->balls[ball].dy;\n        }\n        joystick->balls[ball].dx = 0;\n        joystick->balls[ball].dy = 0;\n    } else {\n        return SDL_SetError(\"Joystick only has %d balls\", joystick->nballs);\n    }\n    return (retval);\n}\n\n/*\n * Get the current state of a button on a joystick\n */\nUint8\nSDL_JoystickGetButton(SDL_Joystick * joystick, int button)\n{\n    Uint8 state;\n\n    if (!SDL_PrivateJoystickValid(joystick)) {\n        return (0);\n    }\n    if (button < joystick->nbuttons) {\n        state = joystick->buttons[button];\n    } else {\n        SDL_SetError(\"Joystick only has %d buttons\", joystick->nbuttons);\n        state = 0;\n    }\n    return (state);\n}\n\n/*\n * Return if the joystick in question is currently attached to the system,\n *  \\return SDL_FALSE if not plugged in, SDL_TRUE if still present.\n */\nSDL_bool\nSDL_JoystickGetAttached(SDL_Joystick * joystick)\n{\n    if (!SDL_PrivateJoystickValid(joystick)) {\n        return SDL_FALSE;\n    }\n\n    return SDL_SYS_JoystickAttached(joystick);\n}\n\n/*\n * Get the instance id for this opened joystick\n */\nSDL_JoystickID\nSDL_JoystickInstanceID(SDL_Joystick * joystick)\n{\n    if (!SDL_PrivateJoystickValid(joystick)) {\n        return (-1);\n    }\n\n    return (joystick->instance_id);\n}\n\n/*\n * Get the friendly name of this joystick\n */\nconst char *\nSDL_JoystickName(SDL_Joystick * joystick)\n{\n    if (!SDL_PrivateJoystickValid(joystick)) {\n        return (NULL);\n    }\n\n    return (joystick->name);\n}\n\n/*\n * Close a joystick previously opened with SDL_JoystickOpen()\n */\nvoid\nSDL_JoystickClose(SDL_Joystick * joystick)\n{\n    SDL_Joystick *joysticklist;\n    SDL_Joystick *joysticklistprev;\n\n    if (!joystick) {\n        return;\n    }\n\n    /* First decrement ref count */\n    if (--joystick->ref_count > 0) {\n        return;\n    }\n\n    if (joystick == SDL_updating_joystick) {\n        return;\n    }\n\n    SDL_SYS_JoystickClose(joystick);\n\n    joysticklist = SDL_joysticks;\n    joysticklistprev = NULL;\n    while (joysticklist) {\n        if (joystick == joysticklist) {\n            if (joysticklistprev) {\n                /* unlink this entry */\n                joysticklistprev->next = joysticklist->next;\n            } else {\n                SDL_joysticks = joystick->next;\n            }\n            break;\n        }\n        joysticklistprev = joysticklist;\n        joysticklist = joysticklist->next;\n    }\n\n    SDL_free(joystick->name);\n\n    /* Free the data associated with this joystick */\n    SDL_free(joystick->axes);\n    SDL_free(joystick->hats);\n    SDL_free(joystick->balls);\n    SDL_free(joystick->buttons);\n    SDL_free(joystick);\n}\n\nvoid\nSDL_JoystickQuit(void)\n{\n    /* Make sure we're not getting called in the middle of updating joysticks */\n    SDL_assert(!SDL_updating_joystick);\n\n    /* Stop the event polling */\n    while (SDL_joysticks) {\n        SDL_joysticks->ref_count = 1;\n        SDL_JoystickClose(SDL_joysticks);\n    }\n\n    /* Quit the joystick setup */\n    SDL_SYS_JoystickQuit();\n\n#if !SDL_EVENTS_DISABLED\n    SDL_QuitSubSystem(SDL_INIT_EVENTS);\n#endif\n}\n\n\nstatic SDL_bool\nSDL_PrivateJoystickShouldIgnoreEvent()\n{\n    if (SDL_joystick_allows_background_events) {\n        return SDL_FALSE;\n    }\n\n    if (SDL_WasInit(SDL_INIT_VIDEO)) {\n        if (SDL_GetKeyboardFocus() == NULL) {\n            /* Video is initialized and we don't have focus, ignore the event. */\n            return SDL_TRUE;\n        } else {\n            return SDL_FALSE;\n        }\n    }\n\n    /* Video subsystem wasn't initialized, always allow the event */\n    return SDL_FALSE;\n}\n\n/* These are global for SDL_sysjoystick.c and SDL_events.c */\n\nint\nSDL_PrivateJoystickAxis(SDL_Joystick * joystick, Uint8 axis, Sint16 value)\n{\n    int posted;\n\n    /* Make sure we're not getting garbage or duplicate events */\n    if (axis >= joystick->naxes) {\n        return 0;\n    }\n    if (value == joystick->axes[axis]) {\n        return 0;\n    }\n\n    /* We ignore events if we don't have keyboard focus, except for centering\n     * events.\n     */\n    if (SDL_PrivateJoystickShouldIgnoreEvent()) {\n        if ((value > 0 && value >= joystick->axes[axis]) ||\n            (value < 0 && value <= joystick->axes[axis])) {\n            return 0;\n        }\n    }\n\n    /* Update internal joystick state */\n    joystick->axes[axis] = value;\n\n    /* Post the event, if desired */\n    posted = 0;\n#if !SDL_EVENTS_DISABLED\n    if (SDL_GetEventState(SDL_JOYAXISMOTION) == SDL_ENABLE) {\n        SDL_Event event;\n        event.type = SDL_JOYAXISMOTION;\n        event.jaxis.which = joystick->instance_id;\n        event.jaxis.axis = axis;\n        event.jaxis.value = value;\n        posted = SDL_PushEvent(&event) == 1;\n    }\n#endif /* !SDL_EVENTS_DISABLED */\n    return (posted);\n}\n\nint\nSDL_PrivateJoystickHat(SDL_Joystick * joystick, Uint8 hat, Uint8 value)\n{\n    int posted;\n\n    /* Make sure we're not getting garbage or duplicate events */\n    if (hat >= joystick->nhats) {\n        return 0;\n    }\n    if (value == joystick->hats[hat]) {\n        return 0;\n    }\n\n    /* We ignore events if we don't have keyboard focus, except for centering\n     * events.\n     */\n    if (SDL_PrivateJoystickShouldIgnoreEvent()) {\n        if (value != SDL_HAT_CENTERED) {\n            return 0;\n        }\n    }\n\n    /* Update internal joystick state */\n    joystick->hats[hat] = value;\n\n    /* Post the event, if desired */\n    posted = 0;\n#if !SDL_EVENTS_DISABLED\n    if (SDL_GetEventState(SDL_JOYHATMOTION) == SDL_ENABLE) {\n        SDL_Event event;\n        event.jhat.type = SDL_JOYHATMOTION;\n        event.jhat.which = joystick->instance_id;\n        event.jhat.hat = hat;\n        event.jhat.value = value;\n        posted = SDL_PushEvent(&event) == 1;\n    }\n#endif /* !SDL_EVENTS_DISABLED */\n    return (posted);\n}\n\nint\nSDL_PrivateJoystickBall(SDL_Joystick * joystick, Uint8 ball,\n                        Sint16 xrel, Sint16 yrel)\n{\n    int posted;\n\n    /* Make sure we're not getting garbage events */\n    if (ball >= joystick->nballs) {\n        return 0;\n    }\n\n    /* We ignore events if we don't have keyboard focus. */\n    if (SDL_PrivateJoystickShouldIgnoreEvent()) {\n        return 0;\n    }\n\n    /* Update internal mouse state */\n    joystick->balls[ball].dx += xrel;\n    joystick->balls[ball].dy += yrel;\n\n    /* Post the event, if desired */\n    posted = 0;\n#if !SDL_EVENTS_DISABLED\n    if (SDL_GetEventState(SDL_JOYBALLMOTION) == SDL_ENABLE) {\n        SDL_Event event;\n        event.jball.type = SDL_JOYBALLMOTION;\n        event.jball.which = joystick->instance_id;\n        event.jball.ball = ball;\n        event.jball.xrel = xrel;\n        event.jball.yrel = yrel;\n        posted = SDL_PushEvent(&event) == 1;\n    }\n#endif /* !SDL_EVENTS_DISABLED */\n    return (posted);\n}\n\nint\nSDL_PrivateJoystickButton(SDL_Joystick * joystick, Uint8 button, Uint8 state)\n{\n    int posted;\n#if !SDL_EVENTS_DISABLED\n    SDL_Event event;\n\n    switch (state) {\n    case SDL_PRESSED:\n        event.type = SDL_JOYBUTTONDOWN;\n        break;\n    case SDL_RELEASED:\n        event.type = SDL_JOYBUTTONUP;\n        break;\n    default:\n        /* Invalid state -- bail */\n        return (0);\n    }\n#endif /* !SDL_EVENTS_DISABLED */\n\n    /* Make sure we're not getting garbage or duplicate events */\n    if (button >= joystick->nbuttons) {\n        return 0;\n\t}\n\tif (state == joystick->buttons[button]) {\n\t\treturn 0;\n\t}\n\n    /* We ignore events if we don't have keyboard focus, except for button\n     * release. */\n    if (SDL_PrivateJoystickShouldIgnoreEvent()) {\n        if (state == SDL_PRESSED) {\n            return 0;\n        }\n    }\n\n    /* Update internal joystick state */\n    joystick->buttons[button] = state;\n\n    /* Post the event, if desired */\n    posted = 0;\n#if !SDL_EVENTS_DISABLED\n    if (SDL_GetEventState(event.type) == SDL_ENABLE) {\n        event.jbutton.which = joystick->instance_id;\n        event.jbutton.button = button;\n        event.jbutton.state = state;\n        posted = SDL_PushEvent(&event) == 1;\n    }\n#endif /* !SDL_EVENTS_DISABLED */\n    return (posted);\n}\n\nvoid\nSDL_JoystickUpdate(void)\n{\n    SDL_Joystick *joystick;\n\n    joystick = SDL_joysticks;\n    while (joystick) {\n        SDL_Joystick *joysticknext;\n        /* save off the next pointer, the Update call may cause a joystick removed event\n         * and cause our joystick pointer to be freed\n         */\n        joysticknext = joystick->next;\n\n        SDL_updating_joystick = joystick;\n\n        SDL_SYS_JoystickUpdate(joystick);\n\n        if (joystick->closed && joystick->uncentered) {\n            int i;\n\n            /* Tell the app that everything is centered/unpressed...  */\n            for (i = 0; i < joystick->naxes; i++)\n                SDL_PrivateJoystickAxis(joystick, i, 0);\n\n            for (i = 0; i < joystick->nbuttons; i++)\n                SDL_PrivateJoystickButton(joystick, i, 0);\n\n            for (i = 0; i < joystick->nhats; i++)\n                SDL_PrivateJoystickHat(joystick, i, SDL_HAT_CENTERED);\n\n            joystick->uncentered = SDL_FALSE;\n        }\n\n        SDL_updating_joystick = NULL;\n\n        /* If the joystick was closed while updating, free it here */\n        if (joystick->ref_count <= 0) {\n            SDL_JoystickClose(joystick);\n        }\n\n        joystick = joysticknext;\n    }\n\n    /* this needs to happen AFTER walking the joystick list above, so that any\n       dangling hardware data from removed devices can be free'd\n     */\n    SDL_SYS_JoystickDetect();\n}\n\nint\nSDL_JoystickEventState(int state)\n{\n#if SDL_EVENTS_DISABLED\n    return SDL_DISABLE;\n#else\n    const Uint32 event_list[] = {\n        SDL_JOYAXISMOTION, SDL_JOYBALLMOTION, SDL_JOYHATMOTION,\n        SDL_JOYBUTTONDOWN, SDL_JOYBUTTONUP, SDL_JOYDEVICEADDED, SDL_JOYDEVICEREMOVED\n    };\n    unsigned int i;\n\n    switch (state) {\n    case SDL_QUERY:\n        state = SDL_DISABLE;\n        for (i = 0; i < SDL_arraysize(event_list); ++i) {\n            state = SDL_EventState(event_list[i], SDL_QUERY);\n            if (state == SDL_ENABLE) {\n                break;\n            }\n        }\n        break;\n    default:\n        for (i = 0; i < SDL_arraysize(event_list); ++i) {\n            SDL_EventState(event_list[i], state);\n        }\n        break;\n    }\n    return (state);\n#endif /* SDL_EVENTS_DISABLED */\n}\n\n/* return the guid for this index */\nSDL_JoystickGUID SDL_JoystickGetDeviceGUID(int device_index)\n{\n    if ((device_index < 0) || (device_index >= SDL_NumJoysticks())) {\n        SDL_JoystickGUID emptyGUID;\n        SDL_SetError(\"There are %d joysticks available\", SDL_NumJoysticks());\n        SDL_zero(emptyGUID);\n        return emptyGUID;\n    }\n    return SDL_SYS_JoystickGetDeviceGUID(device_index);\n}\n\n/* return the guid for this opened device */\nSDL_JoystickGUID SDL_JoystickGetGUID(SDL_Joystick * joystick)\n{\n    if (!SDL_PrivateJoystickValid(joystick)) {\n        SDL_JoystickGUID emptyGUID;\n        SDL_zero(emptyGUID);\n        return emptyGUID;\n    }\n    return SDL_SYS_JoystickGetGUID(joystick);\n}\n\n/* convert the guid to a printable string */\nvoid SDL_JoystickGetGUIDString(SDL_JoystickGUID guid, char *pszGUID, int cbGUID)\n{\n    static const char k_rgchHexToASCII[] = \"0123456789abcdef\";\n    int i;\n\n    if ((pszGUID == NULL) || (cbGUID <= 0)) {\n        return;\n    }\n\n    for (i = 0; i < sizeof(guid.data) && i < (cbGUID-1)/2; i++) {\n        /* each input byte writes 2 ascii chars, and might write a null byte. */\n        /* If we don't have room for next input byte, stop */\n        unsigned char c = guid.data[i];\n\n        *pszGUID++ = k_rgchHexToASCII[c >> 4];\n        *pszGUID++ = k_rgchHexToASCII[c & 0x0F];\n    }\n    *pszGUID = '\\0';\n}\n\n\n/*-----------------------------------------------------------------------------\n * Purpose: Returns the 4 bit nibble for a hex character\n * Input  : c -\n * Output : unsigned char\n *-----------------------------------------------------------------------------*/\nstatic unsigned char nibble(char c)\n{\n    if ((c >= '0') && (c <= '9')) {\n        return (unsigned char)(c - '0');\n    }\n\n    if ((c >= 'A') && (c <= 'F')) {\n        return (unsigned char)(c - 'A' + 0x0a);\n    }\n\n    if ((c >= 'a') && (c <= 'f')) {\n        return (unsigned char)(c - 'a' + 0x0a);\n    }\n\n    /* received an invalid character, and no real way to return an error */\n    /* AssertMsg1(false, \"Q_nibble invalid hex character '%c' \", c); */\n    return 0;\n}\n\n\n/* convert the string version of a joystick guid to the struct */\nSDL_JoystickGUID SDL_JoystickGetGUIDFromString(const char *pchGUID)\n{\n    SDL_JoystickGUID guid;\n    int maxoutputbytes= sizeof(guid);\n    size_t len = SDL_strlen(pchGUID);\n    Uint8 *p;\n    size_t i;\n\n    /* Make sure it's even */\n    len = (len) & ~0x1;\n\n    SDL_memset(&guid, 0x00, sizeof(guid));\n\n    p = (Uint8 *)&guid;\n    for (i = 0; (i < len) && ((p - (Uint8 *)&guid) < maxoutputbytes); i+=2, p++) {\n        *p = (nibble(pchGUID[i]) << 4) | nibble(pchGUID[i+1]);\n    }\n\n    return guid;\n}\n\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../../SDL_internal.h\"\n\n#if SDL_VIDEO_DRIVER_DUMMY\n\n/* Dummy SDL video driver implementation; this is just enough to make an\n *  SDL-based application THINK it's got a working video driver, for\n *  applications that call SDL_Init(SDL_INIT_VIDEO) when they don't need it,\n *  and also for use as a collection of stubs when porting SDL to a new\n *  platform for which you haven't yet written a valid video driver.\n *\n * This is also a great way to determine bottlenecks: if you think that SDL\n *  is a performance problem for a given platform, enable this driver, and\n *  then see if your application runs faster without video overhead.\n *\n * Initial work by Ryan C. Gordon (icculus@icculus.org). A good portion\n *  of this was cut-and-pasted from Stephane Peter's work in the AAlib\n *  SDL video driver.  Renamed to \"DUMMY\" by Sam Lantinga.\n */\n\n#include \"SDL_video.h\"\n#include \"SDL_mouse.h\"\n#include \"../SDL_sysvideo.h\"\n#include \"../SDL_pixels_c.h\"\n#include \"../../events/SDL_events_c.h\"\n\n#include \"SDL_nullvideo.h\"\n#include \"SDL_nullevents_c.h\"\n#include \"SDL_nullframebuffer_c.h\"\n\n#define DUMMYVID_DRIVER_NAME \"dummy\"\n\n/* Initialization/Query functions */\nstatic int DUMMY_VideoInit(_THIS);\nstatic int DUMMY_SetDisplayMode(_THIS, SDL_VideoDisplay * display, SDL_DisplayMode * mode);\nstatic void DUMMY_VideoQuit(_THIS);\n\n/* DUMMY driver bootstrap functions */\n\nstatic int\nDUMMY_Available(void)\n{\n    const char *envr = SDL_getenv(\"SDL_VIDEODRIVER\");\n    if ((envr) && (SDL_strcmp(envr, DUMMYVID_DRIVER_NAME) == 0)) {\n        return (1);\n    }\n\n    return (0);\n}\n\nstatic void\nDUMMY_DeleteDevice(SDL_VideoDevice * device)\n{\n    SDL_free(device);\n}\n\nstatic SDL_VideoDevice *\nDUMMY_CreateDevice(int devindex)\n{\n    SDL_VideoDevice *device;\n\n    /* Initialize all variables that we clean on shutdown */\n    device = (SDL_VideoDevice *) SDL_calloc(1, sizeof(SDL_VideoDevice));\n    if (!device) {\n        SDL_OutOfMemory();\n        SDL_free(device);\n        return (0);\n    }\n\n    /* Set the function pointers */\n    device->VideoInit = DUMMY_VideoInit;\n    device->VideoQuit = DUMMY_VideoQuit;\n    device->SetDisplayMode = DUMMY_SetDisplayMode;\n    device->PumpEvents = DUMMY_PumpEvents;\n    device->CreateWindowFramebuffer = SDL_DUMMY_CreateWindowFramebuffer;\n    device->UpdateWindowFramebuffer = SDL_DUMMY_UpdateWindowFramebuffer;\n    device->DestroyWindowFramebuffer = SDL_DUMMY_DestroyWindowFramebuffer;\n\n    device->free = DUMMY_DeleteDevice;\n\n    return device;\n}\n\nVideoBootStrap DUMMY_bootstrap = {\n    DUMMYVID_DRIVER_NAME, \"SDL dummy video driver\",\n    DUMMY_Available, DUMMY_CreateDevice\n};\n\n\nint\nDUMMY_VideoInit(_THIS)\n{\n    SDL_DisplayMode mode;\n\n    /* Use a fake 32-bpp desktop mode */\n    mode.format = SDL_PIXELFORMAT_RGB888;\n    mode.w = 1024;\n    mode.h = 768;\n    mode.refresh_rate = 0;\n    mode.driverdata = NULL;\n    if (SDL_AddBasicVideoDisplay(&mode) < 0) {\n        return -1;\n    }\n\n    SDL_zero(mode);\n    SDL_AddDisplayMode(&_this->displays[0], &mode);\n\n    /* We're done! */\n    return 0;\n}\n\nstatic int\nDUMMY_SetDisplayMode(_THIS, SDL_VideoDisplay * display, SDL_DisplayMode * mode)\n{\n    return 0;\n}\n\nvoid\nDUMMY_VideoQuit(_THIS)\n{\n}\n\n#endif /* SDL_VIDEO_DRIVER_DUMMY */\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n\n#include \"../../SDL_internal.h\"\n\n#ifdef SDL_JOYSTICK_EMSCRIPTEN\n\n#include <stdio.h>              /* For the definition of NULL */\n#include \"SDL_error.h\"\n#include \"SDL_events.h\"\n\n#if !SDL_EVENTS_DISABLED\n#include \"../../events/SDL_events_c.h\"\n#endif\n\n#include \"SDL_joystick.h\"\n#include \"SDL_hints.h\"\n#include \"SDL_assert.h\"\n#include \"SDL_timer.h\"\n#include \"SDL_log.h\"\n#include \"SDL_sysjoystick_c.h\"\n#include \"../SDL_joystick_c.h\"\n\nstatic SDL_joylist_item * JoystickByIndex(int index);\n\nstatic SDL_joylist_item *SDL_joylist = NULL;\nstatic SDL_joylist_item *SDL_joylist_tail = NULL;\nstatic int numjoysticks = 0;\nstatic int instance_counter = 0;\n\nEM_BOOL\nEmscripten_JoyStickConnected(int eventType, const EmscriptenGamepadEvent *gamepadEvent, void *userData)\n{\n    int i;\n\n    SDL_joylist_item *item;\n\n    if (JoystickByIndex(gamepadEvent->index) != NULL) {\n      return 1;\n    }\n\n#if !SDL_EVENTS_DISABLED\n    SDL_Event event;\n#endif\n\n    item = (SDL_joylist_item *) SDL_malloc(sizeof (SDL_joylist_item));\n    if (item == NULL) {\n        return 1;\n    }\n\n    SDL_zerop(item);\n    item->index = gamepadEvent->index;\n\n    item->name = SDL_strdup(gamepadEvent->id);\n    if ( item->name == NULL ) {\n        SDL_free(item);\n        return 1;\n    }\n\n    item->mapping = SDL_strdup(gamepadEvent->mapping);\n    if ( item->mapping == NULL ) {\n        SDL_free(item->name);\n        SDL_free(item);\n        return 1;\n    }\n\n    item->naxes = gamepadEvent->numAxes;\n    item->nbuttons = gamepadEvent->numButtons;\n    item->device_instance = instance_counter++;\n\n    item->timestamp = gamepadEvent->timestamp;\n\n    for( i = 0; i < item->naxes; i++) {\n        item->axis[i] = gamepadEvent->axis[i];\n    }\n\n    for( i = 0; i < item->nbuttons; i++) {\n        item->analogButton[i] = gamepadEvent->analogButton[i];\n        item->digitalButton[i] = gamepadEvent->digitalButton[i];\n    }\n\n    if (SDL_joylist_tail == NULL) {\n        SDL_joylist = SDL_joylist_tail = item;\n    } else {\n        SDL_joylist_tail->next = item;\n        SDL_joylist_tail = item;\n    }\n\n    ++numjoysticks;\n#ifdef DEBUG_JOYSTICK\n    SDL_Log(\"Number of joysticks is %d\", numjoysticks);\n#endif\n#if !SDL_EVENTS_DISABLED\n    event.type = SDL_JOYDEVICEADDED;\n\n    if (SDL_GetEventState(event.type) == SDL_ENABLE) {\n        event.jdevice.which = numjoysticks - 1;\n        if ( (SDL_EventOK == NULL) ||\n             (*SDL_EventOK) (SDL_EventOKParam, &event) ) {\n            SDL_PushEvent(&event);\n        }\n    }\n#endif /* !SDL_EVENTS_DISABLED */\n\n#ifdef DEBUG_JOYSTICK\n    SDL_Log(\"Added joystick with index %d\", item->index);\n#endif\n\n    return 1;\n}\n\nEM_BOOL\nEmscripten_JoyStickDisconnected(int eventType, const EmscriptenGamepadEvent *gamepadEvent, void *userData)\n{\n    SDL_joylist_item *item = SDL_joylist;\n    SDL_joylist_item *prev = NULL;\n#if !SDL_EVENTS_DISABLED\n    SDL_Event event;\n#endif\n\n    while (item != NULL) {\n        if (item->index == gamepadEvent->index) {\n            break;\n        }\n        prev = item;\n        item = item->next;\n    }\n\n    if (item == NULL) {\n        return 1;\n    }\n\n    if (item->joystick) {\n        item->joystick->hwdata = NULL;\n    }\n\n    if (prev != NULL) {\n        prev->next = item->next;\n    } else {\n        SDL_assert(SDL_joylist == item);\n        SDL_joylist = item->next;\n    }\n    if (item == SDL_joylist_tail) {\n        SDL_joylist_tail = prev;\n    }\n\n    /* Need to decrement the joystick count before we post the event */\n    --numjoysticks;\n\n#if !SDL_EVENTS_DISABLED\n    event.type = SDL_JOYDEVICEREMOVED;\n\n    if (SDL_GetEventState(event.type) == SDL_ENABLE) {\n        event.jdevice.which = item->device_instance;\n        if ( (SDL_EventOK == NULL) ||\n             (*SDL_EventOK) (SDL_EventOKParam, &event) ) {\n            SDL_PushEvent(&event);\n        }\n    }\n#endif /* !SDL_EVENTS_DISABLED */\n\n#ifdef DEBUG_JOYSTICK\n    SDL_Log(\"Removed joystick with id %d\", item->device_instance);\n#endif\n    SDL_free(item->name);\n    SDL_free(item->mapping);\n    SDL_free(item);\n    return 1;\n}\n\n/* Function to scan the system for joysticks.\n * It should return 0, or -1 on an unrecoverable fatal error.\n */\nint\nSDL_SYS_JoystickInit(void)\n{\n    int retval, i, numjs;\n    EmscriptenGamepadEvent gamepadState;\n\n    numjoysticks = 0;\n    numjs = emscripten_get_num_gamepads();\n\n    /* Check if gamepad is supported by browser */\n    if (numjs == EMSCRIPTEN_RESULT_NOT_SUPPORTED) {\n        return -1;\n    }\n\n    /* handle already connected gamepads */\n    if (numjs > 0) {\n        for(i = 0; i < numjs; i++) {\n            retval = emscripten_get_gamepad_status(i, &gamepadState);\n            if (retval == EMSCRIPTEN_RESULT_SUCCESS) {\n                Emscripten_JoyStickConnected(EMSCRIPTEN_EVENT_GAMEPADCONNECTED,\n                                             &gamepadState,\n                                             NULL);\n            }\n        }\n    }\n\n    retval = emscripten_set_gamepadconnected_callback(NULL,\n                                                      0,\n                                                      Emscripten_JoyStickConnected);\n\n    if(retval != EMSCRIPTEN_RESULT_SUCCESS) {\n        SDL_SYS_JoystickQuit();\n        return -1;\n    }\n\n    retval = emscripten_set_gamepaddisconnected_callback(NULL,\n                                                         0,\n                                                         Emscripten_JoyStickDisconnected);\n    if(retval != EMSCRIPTEN_RESULT_SUCCESS) {\n        SDL_SYS_JoystickQuit();\n        return -1;\n    }\n\n    return 0;\n}\n\n/* Returns item matching given SDL device index. */\nstatic SDL_joylist_item *\nJoystickByDeviceIndex(int device_index)\n{\n    SDL_joylist_item *item = SDL_joylist;\n\n    while (0 < device_index) {\n        --device_index;\n        item = item->next;\n    }\n\n    return item;\n}\n\n/* Returns item matching given HTML gamepad index. */\nstatic SDL_joylist_item *\nJoystickByIndex(int index)\n{\n    SDL_joylist_item *item = SDL_joylist;\n\n    if (index < 0) {\n        return NULL;\n    }\n\n    while (item != NULL) {\n        if (item->index == index) {\n            break;\n        }\n        item = item->next;\n    }\n\n    return item;\n}\n\nint SDL_SYS_NumJoysticks()\n{\n    return numjoysticks;\n}\n\nvoid SDL_SYS_JoystickDetect()\n{\n}\n\n/* Function to get the device-dependent name of a joystick */\nconst char *\nSDL_SYS_JoystickNameForDeviceIndex(int device_index)\n{\n    return JoystickByDeviceIndex(device_index)->name;\n}\n\n/* Function to perform the mapping from device index to the instance id for this index */\nSDL_JoystickID SDL_SYS_GetInstanceIdOfDeviceIndex(int device_index)\n{\n    return JoystickByDeviceIndex(device_index)->device_instance;\n}\n\n/* Function to open a joystick for use.\n   The joystick to open is specified by the device index.\n   This should fill the nbuttons and naxes fields of the joystick structure.\n   It returns 0, or -1 if there is an error.\n */\nint\nSDL_SYS_JoystickOpen(SDL_Joystick * joystick, int device_index)\n{\n    SDL_joylist_item *item = JoystickByDeviceIndex(device_index);\n\n    if (item == NULL ) {\n        return SDL_SetError(\"No such device\");\n    }\n\n    if (item->joystick != NULL) {\n        return SDL_SetError(\"Joystick already opened\");\n    }\n\n    joystick->instance_id = item->device_instance;\n    joystick->hwdata = (struct joystick_hwdata *) item;\n    item->joystick = joystick;\n\n    /* HTML5 Gamepad API doesn't say anything about these */\n    joystick->nhats = 0;\n    joystick->nballs = 0;\n\n    joystick->nbuttons = item->nbuttons;\n    joystick->naxes = item->naxes;\n\n    return (0);\n}\n\n/* Function to determine is this joystick is attached to the system right now */\nSDL_bool SDL_SYS_JoystickAttached(SDL_Joystick *joystick)\n{\n    return !joystick->closed && (joystick->hwdata != NULL);\n}\n\n/* Function to update the state of a joystick - called as a device poll.\n * This function shouldn't update the joystick structure directly,\n * but instead should call SDL_PrivateJoystick*() to deliver events\n * and update joystick device state.\n */\nvoid\nSDL_SYS_JoystickUpdate(SDL_Joystick * joystick)\n{\n    EmscriptenGamepadEvent gamepadState;\n    SDL_joylist_item *item = (SDL_joylist_item *) joystick->hwdata;\n    int i, result, buttonState;\n\n    if (item) {\n        result = emscripten_get_gamepad_status(item->index, &gamepadState);\n        if( result == EMSCRIPTEN_RESULT_SUCCESS) {\n            if(gamepadState.timestamp == 0 || gamepadState.timestamp != item->timestamp) {\n                for(i = 0; i < item->nbuttons; i++) {\n                    if(item->digitalButton[i] != gamepadState.digitalButton[i]) {\n                        buttonState = gamepadState.digitalButton[i]? SDL_PRESSED: SDL_RELEASED;\n                        SDL_PrivateJoystickButton(item->joystick, i, buttonState);\n                    }\n                }\n\n                for(i = 0; i < item->naxes; i++) {\n                    if(item->axis[i] != gamepadState.axis[i]) {\n                        // do we need to do conversion?\n                        SDL_PrivateJoystickAxis(item->joystick, i,\n                                                  (Sint16) (32767.*gamepadState.axis[i]));\n                    }\n                }\n\n                item->timestamp = gamepadState.timestamp;\n                for( i = 0; i < item->naxes; i++) {\n                    item->axis[i] = gamepadState.axis[i];\n                }\n\n                for( i = 0; i < item->nbuttons; i++) {\n                    item->analogButton[i] = gamepadState.analogButton[i];\n                    item->digitalButton[i] = gamepadState.digitalButton[i];\n                }\n            }\n        }\n    }\n}\n\n/* Function to close a joystick after use */\nvoid\nSDL_SYS_JoystickClose(SDL_Joystick * joystick)\n{\n    if (joystick->hwdata) {\n        ((SDL_joylist_item*)joystick->hwdata)->joystick = NULL;\n        joystick->hwdata = NULL;\n    }\n    joystick->closed = 1;\n}\n\n/* Function to perform any system-specific joystick related cleanup */\nvoid\nSDL_SYS_JoystickQuit(void)\n{\n    SDL_joylist_item *item = NULL;\n    SDL_joylist_item *next = NULL;\n\n    for (item = SDL_joylist; item; item = next) {\n        next = item->next;\n        SDL_free(item->mapping);\n        SDL_free(item->name);\n        SDL_free(item);\n    }\n\n    SDL_joylist = SDL_joylist_tail = NULL;\n\n    numjoysticks = 0;\n    instance_counter = 0;\n\n    emscripten_set_gamepadconnected_callback(NULL, 0, NULL);\n    emscripten_set_gamepaddisconnected_callback(NULL, 0, NULL);\n}\n\nSDL_JoystickGUID\nSDL_SYS_JoystickGetDeviceGUID(int device_index)\n{\n    SDL_JoystickGUID guid;\n    /* the GUID is just the first 16 chars of the name for now */\n    const char *name = SDL_SYS_JoystickNameForDeviceIndex(device_index);\n    SDL_zero(guid);\n    SDL_memcpy(&guid, name, SDL_min(sizeof(guid), SDL_strlen(name)));\n    return guid;\n}\n\nSDL_JoystickGUID\nSDL_SYS_JoystickGetGUID(SDL_Joystick * joystick)\n{\n    SDL_JoystickGUID guid;\n    /* the GUID is just the first 16 chars of the name for now */\n    const char *name = joystick->name;\n    SDL_zero(guid);\n    SDL_memcpy(&guid, name, SDL_min(sizeof(guid), SDL_strlen(name)));\n    return guid;\n}\n\n#endif /* SDL_JOYSTICK_EMSCRIPTEN */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../../SDL_internal.h\"\n\n#ifdef SDL_TIMER_UNIX\n\n#include <stdio.h>\n#include <sys/time.h>\n#include <unistd.h>\n#include <errno.h>\n\n#include \"SDL_timer.h\"\n#include \"SDL_assert.h\"\n\n/* The clock_gettime provides monotonous time, so we should use it if\n   it's available. The clock_gettime function is behind ifdef\n   for __USE_POSIX199309\n   Tommi Kyntola (tommi.kyntola@ray.fi) 27/09/2005\n*/\n/* Reworked monotonic clock to not assume the current system has one\n   as not all linux kernels provide a monotonic clock (yeah recent ones\n   probably do)\n   Also added OS X Monotonic clock support\n   Based on work in https://github.com/ThomasHabets/monotonic_clock\n */\n#if HAVE_NANOSLEEP || HAVE_CLOCK_GETTIME\n#include <time.h>\n#endif\n#ifdef __APPLE__\n#include <mach/mach_time.h>\n#endif\n\n/* The first ticks value of the application */\n#if HAVE_CLOCK_GETTIME\nstatic struct timespec start_ts;\n#elif defined(__APPLE__)\nstatic uint64_t start_mach;\nmach_timebase_info_data_t mach_base_info;\n#endif\nstatic SDL_bool has_monotonic_time = SDL_FALSE;\nstatic struct timeval start_tv;\nstatic SDL_bool ticks_started = SDL_FALSE;\n\nvoid\nSDL_TicksInit(void)\n{\n    if (ticks_started) {\n        return;\n    }\n    ticks_started = SDL_TRUE;\n\n    /* Set first ticks value */\n#if HAVE_CLOCK_GETTIME\n    if (clock_gettime(CLOCK_MONOTONIC, &start_ts) == 0) {\n        has_monotonic_time = SDL_TRUE;\n    } else\n#elif defined(__APPLE__)\n    kern_return_t ret = mach_timebase_info(&mach_base_info);\n    if (ret == 0) {\n        has_monotonic_time = SDL_TRUE;\n        start_mach = mach_absolute_time();\n    } else\n#endif\n    {\n        gettimeofday(&start_tv, NULL);\n    }\n}\n\nvoid\nSDL_TicksQuit(void)\n{\n    ticks_started = SDL_FALSE;\n}\n\nUint32\nSDL_GetTicks(void)\n{\n    Uint32 ticks;\n    if (!ticks_started) {\n        SDL_TicksInit();\n    }\n\n    if (has_monotonic_time) {\n#if HAVE_CLOCK_GETTIME\n        struct timespec now;\n        clock_gettime(CLOCK_MONOTONIC, &now);\n        ticks = (now.tv_sec - start_ts.tv_sec) * 1000 + (now.tv_nsec -\n                                                 start_ts.tv_nsec) / 1000000;\n#elif defined(__APPLE__)\n        uint64_t now = mach_absolute_time();\n        ticks = (Uint32)((((now - start_mach) * mach_base_info.numer) / mach_base_info.denom) / 1000000);\n#else\n        SDL_assert(SDL_FALSE);\n        ticks = 0;\n#endif\n    } else {\n        struct timeval now;\n\n        gettimeofday(&now, NULL);\n        ticks = (Uint32)((now.tv_sec - start_tv.tv_sec) * 1000 + (now.tv_usec - start_tv.tv_usec) / 1000);\n    }\n    return (ticks);\n}\n\nUint64\nSDL_GetPerformanceCounter(void)\n{\n    Uint64 ticks;\n    if (!ticks_started) {\n        SDL_TicksInit();\n    }\n\n    if (has_monotonic_time) {\n#if HAVE_CLOCK_GETTIME\n        struct timespec now;\n\n        clock_gettime(CLOCK_MONOTONIC, &now);\n        ticks = now.tv_sec;\n        ticks *= 1000000000;\n        ticks += now.tv_nsec;\n#elif defined(__APPLE__)\n        ticks = mach_absolute_time();\n#else\n        SDL_assert(SDL_FALSE);\n        ticks = 0;\n#endif\n    } else {\n        struct timeval now;\n\n        gettimeofday(&now, NULL);\n        ticks = now.tv_sec;\n        ticks *= 1000000;\n        ticks += now.tv_usec;\n    }\n    return (ticks);\n}\n\nUint64\nSDL_GetPerformanceFrequency(void)\n{\n    if (!ticks_started) {\n        SDL_TicksInit();\n    }\n\n    if (has_monotonic_time) {\n#if HAVE_CLOCK_GETTIME\n        return 1000000000;\n#elif defined(__APPLE__)\n        Uint64 freq = mach_base_info.denom;\n        freq *= 1000000000;\n        freq /= mach_base_info.numer;\n        return freq;\n#endif\n    } \n        \n    return 1000000;\n}\n\nvoid\nSDL_Delay(Uint32 ms)\n{\n    int was_error;\n\n#if HAVE_NANOSLEEP\n    struct timespec elapsed, tv;\n#else\n    struct timeval tv;\n    Uint32 then, now, elapsed;\n#endif\n\n    /* Set the timeout interval */\n#if HAVE_NANOSLEEP\n    elapsed.tv_sec = ms / 1000;\n    elapsed.tv_nsec = (ms % 1000) * 1000000;\n#else\n    then = SDL_GetTicks();\n#endif\n    do {\n        errno = 0;\n\n#if HAVE_NANOSLEEP\n        tv.tv_sec = elapsed.tv_sec;\n        tv.tv_nsec = elapsed.tv_nsec;\n        was_error = nanosleep(&tv, &elapsed);\n#else\n        /* Calculate the time interval left (in case of interrupt) */\n        now = SDL_GetTicks();\n        elapsed = (now - then);\n        then = now;\n        if (elapsed >= ms) {\n            break;\n        }\n        ms -= elapsed;\n        tv.tv_sec = ms / 1000;\n        tv.tv_usec = (ms % 1000) * 1000;\n\n        was_error = select(0, NULL, NULL, NULL, &tv);\n#endif /* HAVE_NANOSLEEP */\n    } while (was_error && (errno == EINTR));\n}\n\n#endif /* SDL_TIMER_UNIX */\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../../SDL_internal.h\"\n\n#if SDL_VIDEO_DRIVER_EMSCRIPTEN\n\n#include \"SDL_video.h\"\n#include \"SDL_mouse.h\"\n#include \"SDL_hints.h\"\n#include \"../SDL_sysvideo.h\"\n#include \"../SDL_pixels_c.h\"\n#include \"../SDL_egl_c.h\"\n#include \"../../events/SDL_events_c.h\"\n\n#include \"SDL_emscriptenvideo.h\"\n#include \"SDL_emscriptenopengles.h\"\n#include \"SDL_emscriptenframebuffer.h\"\n#include \"SDL_emscriptenevents.h\"\n#include \"SDL_emscriptenmouse.h\"\n\n#define EMSCRIPTENVID_DRIVER_NAME \"emscripten\"\n\n/* Initialization/Query functions */\nstatic int Emscripten_VideoInit(_THIS);\nstatic int Emscripten_SetDisplayMode(_THIS, SDL_VideoDisplay * display, SDL_DisplayMode * mode);\nstatic void Emscripten_VideoQuit(_THIS);\n\nstatic int Emscripten_CreateWindow(_THIS, SDL_Window * window);\nstatic void Emscripten_SetWindowSize(_THIS, SDL_Window * window);\nstatic void Emscripten_DestroyWindow(_THIS, SDL_Window * window);\nstatic void Emscripten_SetWindowFullscreen(_THIS, SDL_Window * window, SDL_VideoDisplay * display, SDL_bool fullscreen);\nstatic void Emscripten_PumpEvents(_THIS);\nstatic void Emscripten_SetWindowTitle(_THIS, SDL_Window * window);\n\n\n/* Emscripten driver bootstrap functions */\n\nstatic int\nEmscripten_Available(void)\n{\n    return (1);\n}\n\nstatic void\nEmscripten_DeleteDevice(SDL_VideoDevice * device)\n{\n    SDL_free(device);\n}\n\nstatic SDL_VideoDevice *\nEmscripten_CreateDevice(int devindex)\n{\n    SDL_VideoDevice *device;\n\n    /* Initialize all variables that we clean on shutdown */\n    device = (SDL_VideoDevice *) SDL_calloc(1, sizeof(SDL_VideoDevice));\n    if (!device) {\n        SDL_OutOfMemory();\n        return (0);\n    }\n\n    /* Firefox sends blur event which would otherwise prevent full screen\n     * when the user clicks to allow full screen.\n     * See https://bugzilla.mozilla.org/show_bug.cgi?id=1144964\n    */\n    SDL_SetHint(SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS, \"0\");\n\n    /* Set the function pointers */\n    device->VideoInit = Emscripten_VideoInit;\n    device->VideoQuit = Emscripten_VideoQuit;\n    device->SetDisplayMode = Emscripten_SetDisplayMode;\n\n\n    device->PumpEvents = Emscripten_PumpEvents;\n\n    device->CreateWindow = Emscripten_CreateWindow;\n    /*device->CreateWindowFrom = Emscripten_CreateWindowFrom;*/\n    device->SetWindowTitle = Emscripten_SetWindowTitle;\n    /*device->SetWindowIcon = Emscripten_SetWindowIcon;\n    device->SetWindowPosition = Emscripten_SetWindowPosition;*/\n    device->SetWindowSize = Emscripten_SetWindowSize;\n    /*device->ShowWindow = Emscripten_ShowWindow;\n    device->HideWindow = Emscripten_HideWindow;\n    device->RaiseWindow = Emscripten_RaiseWindow;\n    device->MaximizeWindow = Emscripten_MaximizeWindow;\n    device->MinimizeWindow = Emscripten_MinimizeWindow;\n    device->RestoreWindow = Emscripten_RestoreWindow;\n    device->SetWindowGrab = Emscripten_SetWindowGrab;*/\n    device->DestroyWindow = Emscripten_DestroyWindow;\n    device->SetWindowFullscreen = Emscripten_SetWindowFullscreen;\n\n    device->CreateWindowFramebuffer = Emscripten_CreateWindowFramebuffer;\n    device->UpdateWindowFramebuffer = Emscripten_UpdateWindowFramebuffer;\n    device->DestroyWindowFramebuffer = Emscripten_DestroyWindowFramebuffer;\n\n    device->GL_LoadLibrary = Emscripten_GLES_LoadLibrary;\n    device->GL_GetProcAddress = Emscripten_GLES_GetProcAddress;\n    device->GL_UnloadLibrary = Emscripten_GLES_UnloadLibrary;\n    device->GL_CreateContext = Emscripten_GLES_CreateContext;\n    device->GL_MakeCurrent = Emscripten_GLES_MakeCurrent;\n    device->GL_SetSwapInterval = Emscripten_GLES_SetSwapInterval;\n    device->GL_GetSwapInterval = Emscripten_GLES_GetSwapInterval;\n    device->GL_SwapWindow = Emscripten_GLES_SwapWindow;\n    device->GL_DeleteContext = Emscripten_GLES_DeleteContext;\n    device->GL_GetDrawableSize = Emscripten_GLES_GetDrawableSize;\n\n    device->free = Emscripten_DeleteDevice;\n\n    return device;\n}\n\nVideoBootStrap Emscripten_bootstrap = {\n    EMSCRIPTENVID_DRIVER_NAME, \"SDL emscripten video driver\",\n    Emscripten_Available, Emscripten_CreateDevice\n};\n\n\nint\nEmscripten_VideoInit(_THIS)\n{\n    SDL_DisplayMode mode;\n\n    /* Use a fake 32-bpp desktop mode */\n    mode.format = SDL_PIXELFORMAT_RGB888;\n\n    mode.w = EM_ASM_INT_V({\n        return screen.width;\n    });\n\n    mode.h = EM_ASM_INT_V({\n        return screen.height;\n    });\n\n    mode.refresh_rate = 0;\n    mode.driverdata = NULL;\n    if (SDL_AddBasicVideoDisplay(&mode) < 0) {\n        return -1;\n    }\n\n    SDL_zero(mode);\n    SDL_AddDisplayMode(&_this->displays[0], &mode);\n\n    Emscripten_InitMouse();\n\n    /* We're done! */\n    return 0;\n}\n\nstatic int\nEmscripten_SetDisplayMode(_THIS, SDL_VideoDisplay * display, SDL_DisplayMode * mode)\n{\n    /* can't do this */\n    return 0;\n}\n\nstatic void\nEmscripten_VideoQuit(_THIS)\n{\n    Emscripten_FiniMouse();\n}\n\nstatic void\nEmscripten_PumpEvents(_THIS)\n{\n    /* do nothing. */\n}\n\nstatic int\nEmscripten_CreateWindow(_THIS, SDL_Window * window)\n{\n    SDL_WindowData *wdata;\n    double scaled_w, scaled_h;\n    double css_w, css_h;\n\n    /* Allocate window internal data */\n    wdata = (SDL_WindowData *) SDL_calloc(1, sizeof(SDL_WindowData));\n    if (wdata == NULL) {\n        return SDL_OutOfMemory();\n    }\n\n    if (window->flags & SDL_WINDOW_ALLOW_HIGHDPI) {\n        wdata->pixel_ratio = emscripten_get_device_pixel_ratio();\n    } else {\n        wdata->pixel_ratio = 1.0f;\n    }\n\n    scaled_w = SDL_floor(window->w * wdata->pixel_ratio);\n    scaled_h = SDL_floor(window->h * wdata->pixel_ratio);\n\n    emscripten_set_canvas_size(scaled_w, scaled_h);\n\n    emscripten_get_element_css_size(NULL, &css_w, &css_h);\n\n    wdata->external_size = css_w != scaled_w || css_h != scaled_h;\n\n    if ((window->flags & SDL_WINDOW_RESIZABLE) && wdata->external_size) {\n        /* external css has resized us */\n        scaled_w = css_w * wdata->pixel_ratio;\n        scaled_h = css_h * wdata->pixel_ratio;\n\n        emscripten_set_canvas_size(scaled_w, scaled_h);\n        SDL_SendWindowEvent(window, SDL_WINDOWEVENT_RESIZED, css_w, css_h);\n    }\n\n    /* if the size is not being controlled by css, we need to scale down for hidpi */\n    if (!wdata->external_size) {\n        if (wdata->pixel_ratio != 1.0f) {\n            /*scale canvas down*/\n            emscripten_set_element_css_size(NULL, window->w, window->h);\n        }\n    }\n\n    if (window->flags & SDL_WINDOW_OPENGL) {\n        if (!_this->egl_data) {\n            if (SDL_GL_LoadLibrary(NULL) < 0) {\n                return -1;\n            }\n        }\n        wdata->egl_surface = SDL_EGL_CreateSurface(_this, 0);\n\n        if (wdata->egl_surface == EGL_NO_SURFACE) {\n            return SDL_SetError(\"Could not create GLES window surface\");\n        }\n    }\n\n    wdata->window = window;\n\n    /* Setup driver data for this window */\n    window->driverdata = wdata;\n\n    /* One window, it always has focus */\n    SDL_SetMouseFocus(window);\n    SDL_SetKeyboardFocus(window);\n\n    Emscripten_RegisterEventHandlers(wdata);\n\n    /* Window has been successfully created */\n    return 0;\n}\n\nstatic void Emscripten_SetWindowSize(_THIS, SDL_Window * window)\n{\n    SDL_WindowData *data;\n\n    if (window->driverdata) {\n        data = (SDL_WindowData *) window->driverdata;\n        emscripten_set_canvas_size(window->w * data->pixel_ratio, window->h * data->pixel_ratio);\n\n        /*scale canvas down*/\n        if (!data->external_size && data->pixel_ratio != 1.0f) {\n            emscripten_set_element_css_size(NULL, window->w, window->h);\n        }\n    }\n}\n\nstatic void\nEmscripten_DestroyWindow(_THIS, SDL_Window * window)\n{\n    SDL_WindowData *data;\n\n    if(window->driverdata) {\n        data = (SDL_WindowData *) window->driverdata;\n\n        Emscripten_UnregisterEventHandlers(data);\n        if (data->egl_surface != EGL_NO_SURFACE) {\n            SDL_EGL_DestroySurface(_this, data->egl_surface);\n            data->egl_surface = EGL_NO_SURFACE;\n        }\n        SDL_free(window->driverdata);\n        window->driverdata = NULL;\n    }\n}\n\nstatic void\nEmscripten_SetWindowFullscreen(_THIS, SDL_Window * window, SDL_VideoDisplay * display, SDL_bool fullscreen)\n{\n    SDL_WindowData *data;\n    if(window->driverdata) {\n        data = (SDL_WindowData *) window->driverdata;\n\n        if(fullscreen) {\n            EmscriptenFullscreenStrategy strategy;\n            SDL_bool is_desktop_fullscreen = (window->flags & SDL_WINDOW_FULLSCREEN_DESKTOP) == SDL_WINDOW_FULLSCREEN_DESKTOP;\n            int res;\n\n            strategy.scaleMode = is_desktop_fullscreen ? EMSCRIPTEN_FULLSCREEN_SCALE_STRETCH : EMSCRIPTEN_FULLSCREEN_SCALE_ASPECT;\n\n            if(!is_desktop_fullscreen) {\n                strategy.canvasResolutionScaleMode = EMSCRIPTEN_FULLSCREEN_CANVAS_SCALE_NONE;\n            } else if(window->flags & SDL_WINDOW_ALLOW_HIGHDPI) {\n                strategy.canvasResolutionScaleMode = EMSCRIPTEN_FULLSCREEN_CANVAS_SCALE_HIDEF;\n            } else {\n                strategy.canvasResolutionScaleMode = EMSCRIPTEN_FULLSCREEN_CANVAS_SCALE_STDDEF;\n            }\n\n            strategy.filteringMode = EMSCRIPTEN_FULLSCREEN_FILTERING_DEFAULT;\n\n            strategy.canvasResizedCallback = Emscripten_HandleCanvasResize;\n            strategy.canvasResizedCallbackUserData = data;\n\n            data->requested_fullscreen_mode = window->flags & (SDL_WINDOW_FULLSCREEN_DESKTOP | SDL_WINDOW_FULLSCREEN);\n            data->fullscreen_resize = is_desktop_fullscreen;\n\n            res = emscripten_request_fullscreen_strategy(NULL, 1, &strategy);\n            if(res != EMSCRIPTEN_RESULT_SUCCESS && res != EMSCRIPTEN_RESULT_DEFERRED) {\n                /* unset flags, fullscreen failed */\n                window->flags &= ~(SDL_WINDOW_FULLSCREEN_DESKTOP | SDL_WINDOW_FULLSCREEN);\n            }\n        }\n        else\n            emscripten_exit_fullscreen();\n    }\n}\n\nstatic void\nEmscripten_SetWindowTitle(_THIS, SDL_Window * window) {\n    EM_ASM_INT({\n      if (typeof Module['setWindowTitle'] !== 'undefined') {\n        Module['setWindowTitle'](Module['Pointer_stringify']($0));\n      }\n      return 0;\n    }, window->title);\n}\n\n#endif /* SDL_VIDEO_DRIVER_EMSCRIPTEN */\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../../SDL_internal.h\"\n\n/* An implementation of mutexes using semaphores */\n\n#include \"SDL_thread.h\"\n#include \"SDL_systhread_c.h\"\n\n\nstruct SDL_mutex\n{\n    int recursive;\n    SDL_threadID owner;\n    SDL_sem *sem;\n};\n\n/* Create a mutex */\nSDL_mutex *\nSDL_CreateMutex(void)\n{\n    SDL_mutex *mutex;\n\n    /* Allocate mutex memory */\n    mutex = (SDL_mutex *) SDL_malloc(sizeof(*mutex));\n    if (mutex) {\n        /* Create the mutex semaphore, with initial value 1 */\n        mutex->sem = SDL_CreateSemaphore(1);\n        mutex->recursive = 0;\n        mutex->owner = 0;\n        if (!mutex->sem) {\n            SDL_free(mutex);\n            mutex = NULL;\n        }\n    } else {\n        SDL_OutOfMemory();\n    }\n    return mutex;\n}\n\n/* Free the mutex */\nvoid\nSDL_DestroyMutex(SDL_mutex * mutex)\n{\n    if (mutex) {\n        if (mutex->sem) {\n            SDL_DestroySemaphore(mutex->sem);\n        }\n        SDL_free(mutex);\n    }\n}\n\n/* Lock the mutex */\nint\nSDL_LockMutex(SDL_mutex * mutex)\n{\n#if SDL_THREADS_DISABLED\n    return 0;\n#else\n    SDL_threadID this_thread;\n\n    if (mutex == NULL) {\n        return SDL_SetError(\"Passed a NULL mutex\");\n    }\n\n    this_thread = SDL_ThreadID();\n    if (mutex->owner == this_thread) {\n        ++mutex->recursive;\n    } else {\n        /* The order of operations is important.\n           We set the locking thread id after we obtain the lock\n           so unlocks from other threads will fail.\n         */\n        SDL_SemWait(mutex->sem);\n        mutex->owner = this_thread;\n        mutex->recursive = 0;\n    }\n\n    return 0;\n#endif /* SDL_THREADS_DISABLED */\n}\n\n/* try Lock the mutex */\nint\nSDL_TryLockMutex(SDL_mutex * mutex)\n{\n#if SDL_THREADS_DISABLED\n    return 0;\n#else\n    int retval = 0;\n    SDL_threadID this_thread;\n\n    if (mutex == NULL) {\n        return SDL_SetError(\"Passed a NULL mutex\");\n    }\n\n    this_thread = SDL_ThreadID();\n    if (mutex->owner == this_thread) {\n        ++mutex->recursive;\n    } else {\n        /* The order of operations is important.\n         We set the locking thread id after we obtain the lock\n         so unlocks from other threads will fail.\n         */\n        retval = SDL_SemWait(mutex->sem);\n        if (retval == 0) {\n            mutex->owner = this_thread;\n            mutex->recursive = 0;\n        }\n    }\n\n    return retval;\n#endif /* SDL_THREADS_DISABLED */\n}\n\n/* Unlock the mutex */\nint\nSDL_mutexV(SDL_mutex * mutex)\n{\n#if SDL_THREADS_DISABLED\n    return 0;\n#else\n    if (mutex == NULL) {\n        return SDL_SetError(\"Passed a NULL mutex\");\n    }\n\n    /* If we don't own the mutex, we can't unlock it */\n    if (SDL_ThreadID() != mutex->owner) {\n        return SDL_SetError(\"mutex not owned by this thread\");\n    }\n\n    if (mutex->recursive) {\n        --mutex->recursive;\n    } else {\n        /* The order of operations is important.\n           First reset the owner so another thread doesn't lock\n           the mutex and set the ownership before we reset it,\n           then release the lock semaphore.\n         */\n        mutex->owner = 0;\n        SDL_SemPost(mutex->sem);\n    }\n    return 0;\n#endif /* SDL_THREADS_DISABLED */\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../../SDL_internal.h\"\n\n/* An implementation of semaphores using mutexes and condition variables */\n\n#include \"SDL_timer.h\"\n#include \"SDL_thread.h\"\n#include \"SDL_systhread_c.h\"\n\n\n#if SDL_THREADS_DISABLED\n\nSDL_sem *\nSDL_CreateSemaphore(Uint32 initial_value)\n{\n    SDL_SetError(\"SDL not built with thread support\");\n    return (SDL_sem *) 0;\n}\n\nvoid\nSDL_DestroySemaphore(SDL_sem * sem)\n{\n}\n\nint\nSDL_SemTryWait(SDL_sem * sem)\n{\n    return SDL_SetError(\"SDL not built with thread support\");\n}\n\nint\nSDL_SemWaitTimeout(SDL_sem * sem, Uint32 timeout)\n{\n    return SDL_SetError(\"SDL not built with thread support\");\n}\n\nint\nSDL_SemWait(SDL_sem * sem)\n{\n    return SDL_SetError(\"SDL not built with thread support\");\n}\n\nUint32\nSDL_SemValue(SDL_sem * sem)\n{\n    return 0;\n}\n\nint\nSDL_SemPost(SDL_sem * sem)\n{\n    return SDL_SetError(\"SDL not built with thread support\");\n}\n\n#else\n\nstruct SDL_semaphore\n{\n    Uint32 count;\n    Uint32 waiters_count;\n    SDL_mutex *count_lock;\n    SDL_cond *count_nonzero;\n};\n\nSDL_sem *\nSDL_CreateSemaphore(Uint32 initial_value)\n{\n    SDL_sem *sem;\n\n    sem = (SDL_sem *) SDL_malloc(sizeof(*sem));\n    if (!sem) {\n        SDL_OutOfMemory();\n        return NULL;\n    }\n    sem->count = initial_value;\n    sem->waiters_count = 0;\n\n    sem->count_lock = SDL_CreateMutex();\n    sem->count_nonzero = SDL_CreateCond();\n    if (!sem->count_lock || !sem->count_nonzero) {\n        SDL_DestroySemaphore(sem);\n        return NULL;\n    }\n\n    return sem;\n}\n\n/* WARNING:\n   You cannot call this function when another thread is using the semaphore.\n*/\nvoid\nSDL_DestroySemaphore(SDL_sem * sem)\n{\n    if (sem) {\n        sem->count = 0xFFFFFFFF;\n        while (sem->waiters_count > 0) {\n            SDL_CondSignal(sem->count_nonzero);\n            SDL_Delay(10);\n        }\n        SDL_DestroyCond(sem->count_nonzero);\n        if (sem->count_lock) {\n            SDL_LockMutex(sem->count_lock);\n            SDL_UnlockMutex(sem->count_lock);\n            SDL_DestroyMutex(sem->count_lock);\n        }\n        SDL_free(sem);\n    }\n}\n\nint\nSDL_SemTryWait(SDL_sem * sem)\n{\n    int retval;\n\n    if (!sem) {\n        return SDL_SetError(\"Passed a NULL semaphore\");\n    }\n\n    retval = SDL_MUTEX_TIMEDOUT;\n    SDL_LockMutex(sem->count_lock);\n    if (sem->count > 0) {\n        --sem->count;\n        retval = 0;\n    }\n    SDL_UnlockMutex(sem->count_lock);\n\n    return retval;\n}\n\nint\nSDL_SemWaitTimeout(SDL_sem * sem, Uint32 timeout)\n{\n    int retval;\n\n    if (!sem) {\n        return SDL_SetError(\"Passed a NULL semaphore\");\n    }\n\n    /* A timeout of 0 is an easy case */\n    if (timeout == 0) {\n        return SDL_SemTryWait(sem);\n    }\n\n    SDL_LockMutex(sem->count_lock);\n    ++sem->waiters_count;\n    retval = 0;\n    while ((sem->count == 0) && (retval != SDL_MUTEX_TIMEDOUT)) {\n        retval = SDL_CondWaitTimeout(sem->count_nonzero,\n                                     sem->count_lock, timeout);\n    }\n    --sem->waiters_count;\n    if (retval == 0) {\n        --sem->count;\n    }\n    SDL_UnlockMutex(sem->count_lock);\n\n    return retval;\n}\n\nint\nSDL_SemWait(SDL_sem * sem)\n{\n    return SDL_SemWaitTimeout(sem, SDL_MUTEX_MAXWAIT);\n}\n\nUint32\nSDL_SemValue(SDL_sem * sem)\n{\n    Uint32 value;\n\n    value = 0;\n    if (sem) {\n        SDL_LockMutex(sem->count_lock);\n        value = sem->count;\n        SDL_UnlockMutex(sem->count_lock);\n    }\n    return value;\n}\n\nint\nSDL_SemPost(SDL_sem * sem)\n{\n    if (!sem) {\n        return SDL_SetError(\"Passed a NULL semaphore\");\n    }\n\n    SDL_LockMutex(sem->count_lock);\n    if (sem->waiters_count > 0) {\n        SDL_CondSignal(sem->count_nonzero);\n    }\n    ++sem->count;\n    SDL_UnlockMutex(sem->count_lock);\n\n    return 0;\n}\n\n#endif /* SDL_THREADS_DISABLED */\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"./SDL_internal.h\"\n\n#if defined(__WIN32__)\n#include \"core/windows/SDL_windows.h\"\n#endif\n\n/* Initialization code for SDL */\n\n#include \"SDL.h\"\n#include \"SDL_bits.h\"\n#include \"SDL_revision.h\"\n#include \"SDL_assert_c.h\"\n#include \"events/SDL_events_c.h\"\n#include \"haptic/SDL_haptic_c.h\"\n#include \"joystick/SDL_joystick_c.h\"\n\n/* Initialization/Cleanup routines */\n#if !SDL_TIMERS_DISABLED\nextern int SDL_TimerInit(void);\nextern void SDL_TimerQuit(void);\nextern void SDL_TicksInit(void);\nextern void SDL_TicksQuit(void);\n#endif\n#if SDL_VIDEO_DRIVER_WINDOWS\nextern int SDL_HelperWindowCreate(void);\nextern int SDL_HelperWindowDestroy(void);\n#endif\n\n\n/* The initialized subsystems */\n#ifdef SDL_MAIN_NEEDED\nstatic SDL_bool SDL_MainIsReady = SDL_FALSE;\n#else\nstatic SDL_bool SDL_MainIsReady = SDL_TRUE;\n#endif\nstatic SDL_bool SDL_bInMainQuit = SDL_FALSE;\nstatic Uint8 SDL_SubsystemRefCount[ 32 ];\n\n/* Private helper to increment a subsystem's ref counter. */\nstatic void\nSDL_PrivateSubsystemRefCountIncr(Uint32 subsystem)\n{\n    int subsystem_index = SDL_MostSignificantBitIndex32(subsystem);\n    SDL_assert(SDL_SubsystemRefCount[subsystem_index] < 255);\n    ++SDL_SubsystemRefCount[subsystem_index];\n}\n\n/* Private helper to decrement a subsystem's ref counter. */\nstatic void\nSDL_PrivateSubsystemRefCountDecr(Uint32 subsystem)\n{\n    int subsystem_index = SDL_MostSignificantBitIndex32(subsystem);\n    if (SDL_SubsystemRefCount[subsystem_index] > 0) {\n        --SDL_SubsystemRefCount[subsystem_index];\n    }\n}\n\n/* Private helper to check if a system needs init. */\nstatic SDL_bool\nSDL_PrivateShouldInitSubsystem(Uint32 subsystem)\n{\n    int subsystem_index = SDL_MostSignificantBitIndex32(subsystem);\n    SDL_assert(SDL_SubsystemRefCount[subsystem_index] < 255);\n    return (SDL_SubsystemRefCount[subsystem_index] == 0);\n}\n\n/* Private helper to check if a system needs to be quit. */\nstatic SDL_bool\nSDL_PrivateShouldQuitSubsystem(Uint32 subsystem) {\n    int subsystem_index = SDL_MostSignificantBitIndex32(subsystem);\n    if (SDL_SubsystemRefCount[subsystem_index] == 0) {\n      return SDL_FALSE;\n    }\n\n    /* If we're in SDL_Quit, we shut down every subsystem, even if refcount\n     * isn't zero.\n     */\n    return SDL_SubsystemRefCount[subsystem_index] == 1 || SDL_bInMainQuit;\n}\n\nvoid\nSDL_SetMainReady(void)\n{\n    SDL_MainIsReady = SDL_TRUE;\n}\n\nint\nSDL_InitSubSystem(Uint32 flags)\n{\n    if (!SDL_MainIsReady) {\n        SDL_SetError(\"Application didn't initialize properly, did you include SDL_main.h in the file containing your main() function?\");\n        return -1;\n    }\n\n    /* Clear the error message */\n    SDL_ClearError();\n\n#if SDL_VIDEO_DRIVER_WINDOWS\n\tif ((flags & (SDL_INIT_HAPTIC|SDL_INIT_JOYSTICK))) {\n\t\tif (SDL_HelperWindowCreate() < 0) {\n\t\t\treturn -1;\n\t\t}\n\t}\n#endif\n\n#if !SDL_TIMERS_DISABLED\n    SDL_TicksInit();\n#endif\n\n    if ((flags & SDL_INIT_GAMECONTROLLER)) {\n        /* game controller implies joystick */\n        flags |= SDL_INIT_JOYSTICK;\n    }\n\n    if ((flags & (SDL_INIT_VIDEO|SDL_INIT_JOYSTICK))) {\n        /* video or joystick implies events */\n        flags |= SDL_INIT_EVENTS;\n    }\n\n    /* Initialize the event subsystem */\n    if ((flags & SDL_INIT_EVENTS)) {\n#if !SDL_EVENTS_DISABLED\n        if (SDL_PrivateShouldInitSubsystem(SDL_INIT_EVENTS)) {\n            if (SDL_StartEventLoop() < 0) {\n                return (-1);\n            }\n            SDL_QuitInit();\n        }\n        SDL_PrivateSubsystemRefCountIncr(SDL_INIT_EVENTS);\n#else\n        return SDL_SetError(\"SDL not built with events support\");\n#endif\n    }\n\n    /* Initialize the timer subsystem */\n    if ((flags & SDL_INIT_TIMER)){\n#if !SDL_TIMERS_DISABLED\n        if (SDL_PrivateShouldInitSubsystem(SDL_INIT_TIMER)) {\n            if (SDL_TimerInit() < 0) {\n                return (-1);\n            }\n        }\n        SDL_PrivateSubsystemRefCountIncr(SDL_INIT_TIMER);\n#else\n        return SDL_SetError(\"SDL not built with timer support\");\n#endif\n    }\n\n    /* Initialize the video subsystem */\n    if ((flags & SDL_INIT_VIDEO)){\n#if !SDL_VIDEO_DISABLED\n        if (SDL_PrivateShouldInitSubsystem(SDL_INIT_VIDEO)) {\n            if (SDL_VideoInit(NULL) < 0) {\n                return (-1);\n            }\n        }\n        SDL_PrivateSubsystemRefCountIncr(SDL_INIT_VIDEO);\n#else\n        return SDL_SetError(\"SDL not built with video support\");\n#endif\n    }\n\n    /* Initialize the audio subsystem */\n    if ((flags & SDL_INIT_AUDIO)){\n#if !SDL_AUDIO_DISABLED\n        if (SDL_PrivateShouldInitSubsystem(SDL_INIT_AUDIO)) {\n            if (SDL_AudioInit(NULL) < 0) {\n                return (-1);\n            }\n        }\n        SDL_PrivateSubsystemRefCountIncr(SDL_INIT_AUDIO);\n#else\n        return SDL_SetError(\"SDL not built with audio support\");\n#endif\n    }\n\n    /* Initialize the joystick subsystem */\n    if ((flags & SDL_INIT_JOYSTICK)){\n#if !SDL_JOYSTICK_DISABLED\n        if (SDL_PrivateShouldInitSubsystem(SDL_INIT_JOYSTICK)) {\n           if (SDL_JoystickInit() < 0) {\n               return (-1);\n           }\n        }\n        SDL_PrivateSubsystemRefCountIncr(SDL_INIT_JOYSTICK);\n#else\n        return SDL_SetError(\"SDL not built with joystick support\");\n#endif\n    }\n\n    if ((flags & SDL_INIT_GAMECONTROLLER)){\n#if !SDL_JOYSTICK_DISABLED\n        if (SDL_PrivateShouldInitSubsystem(SDL_INIT_GAMECONTROLLER)) {\n            if (SDL_GameControllerInit() < 0) {\n                return (-1);\n            }\n        }\n        SDL_PrivateSubsystemRefCountIncr(SDL_INIT_GAMECONTROLLER);\n#else\n        return SDL_SetError(\"SDL not built with joystick support\");\n#endif\n    }\n\n    /* Initialize the haptic subsystem */\n    if ((flags & SDL_INIT_HAPTIC)){\n#if !SDL_HAPTIC_DISABLED\n        if (SDL_PrivateShouldInitSubsystem(SDL_INIT_HAPTIC)) {\n            if (SDL_HapticInit() < 0) {\n                return (-1);\n            }\n        }\n        SDL_PrivateSubsystemRefCountIncr(SDL_INIT_HAPTIC);\n#else\n        return SDL_SetError(\"SDL not built with haptic (force feedback) support\");\n#endif\n    }\n\n    return (0);\n}\n\nint\nSDL_Init(Uint32 flags)\n{\n    return SDL_InitSubSystem(flags);\n}\n\nvoid\nSDL_QuitSubSystem(Uint32 flags)\n{\n    /* Shut down requested initialized subsystems */\n#if !SDL_JOYSTICK_DISABLED\n    if ((flags & SDL_INIT_GAMECONTROLLER)) {\n        /* game controller implies joystick */\n        flags |= SDL_INIT_JOYSTICK;\n\n        if (SDL_PrivateShouldQuitSubsystem(SDL_INIT_GAMECONTROLLER)) {\n            SDL_GameControllerQuit();\n        }\n        SDL_PrivateSubsystemRefCountDecr(SDL_INIT_GAMECONTROLLER);\n    }\n\n    if ((flags & SDL_INIT_JOYSTICK)) {\n        /* joystick implies events */\n        flags |= SDL_INIT_EVENTS;\n\n        if (SDL_PrivateShouldQuitSubsystem(SDL_INIT_JOYSTICK)) {\n            SDL_JoystickQuit();\n        }\n        SDL_PrivateSubsystemRefCountDecr(SDL_INIT_JOYSTICK);\n    }\n#endif\n\n#if !SDL_HAPTIC_DISABLED\n    if ((flags & SDL_INIT_HAPTIC)) {\n        if (SDL_PrivateShouldQuitSubsystem(SDL_INIT_HAPTIC)) {\n            SDL_HapticQuit();\n        }\n        SDL_PrivateSubsystemRefCountDecr(SDL_INIT_HAPTIC);\n    }\n#endif\n\n#if !SDL_AUDIO_DISABLED\n    if ((flags & SDL_INIT_AUDIO)) {\n        if (SDL_PrivateShouldQuitSubsystem(SDL_INIT_AUDIO)) {\n            SDL_AudioQuit();\n        }\n        SDL_PrivateSubsystemRefCountDecr(SDL_INIT_AUDIO);\n    }\n#endif\n\n#if !SDL_VIDEO_DISABLED\n    if ((flags & SDL_INIT_VIDEO)) {\n        /* video implies events */\n        flags |= SDL_INIT_EVENTS;\n\n        if (SDL_PrivateShouldQuitSubsystem(SDL_INIT_VIDEO)) {\n            SDL_VideoQuit();\n        }\n        SDL_PrivateSubsystemRefCountDecr(SDL_INIT_VIDEO);\n    }\n#endif\n\n#if !SDL_TIMERS_DISABLED\n    if ((flags & SDL_INIT_TIMER)) {\n        if (SDL_PrivateShouldQuitSubsystem(SDL_INIT_TIMER)) {\n            SDL_TimerQuit();\n        }\n        SDL_PrivateSubsystemRefCountDecr(SDL_INIT_TIMER);\n    }\n#endif\n\n#if !SDL_EVENTS_DISABLED\n    if ((flags & SDL_INIT_EVENTS)) {\n        if (SDL_PrivateShouldQuitSubsystem(SDL_INIT_EVENTS)) {\n            SDL_QuitQuit();\n            SDL_StopEventLoop();\n        }\n        SDL_PrivateSubsystemRefCountDecr(SDL_INIT_EVENTS);\n    }\n#endif\n}\n\nUint32\nSDL_WasInit(Uint32 flags)\n{\n    int i;\n    int num_subsystems = SDL_arraysize(SDL_SubsystemRefCount);\n    Uint32 initialized = 0;\n\n    if (!flags) {\n        flags = SDL_INIT_EVERYTHING;\n    }\n\n    num_subsystems = SDL_min(num_subsystems, SDL_MostSignificantBitIndex32(flags) + 1);\n\n    /* Iterate over each bit in flags, and check the matching subsystem. */\n    for (i = 0; i < num_subsystems; ++i) {\n        if ((flags & 1) && SDL_SubsystemRefCount[i] > 0) {\n            initialized |= (1 << i);\n        }\n\n        flags >>= 1;\n    }\n\n    return initialized;\n}\n\nvoid\nSDL_Quit(void)\n{\n    SDL_bInMainQuit = SDL_TRUE;\n\n    /* Quit all subsystems */\n#if SDL_VIDEO_DRIVER_WINDOWS\n    SDL_HelperWindowDestroy();\n#endif\n    SDL_QuitSubSystem(SDL_INIT_EVERYTHING);\n\n#if !SDL_TIMERS_DISABLED\n    SDL_TicksQuit();\n#endif\n\n    SDL_ClearHints();\n    SDL_AssertionsQuit();\n    SDL_LogResetPriorities();\n\n    /* Now that every subsystem has been quit, we reset the subsystem refcount\n     * and the list of initialized subsystems.\n     */\n    SDL_memset( SDL_SubsystemRefCount, 0x0, sizeof(SDL_SubsystemRefCount) );\n\n    SDL_bInMainQuit = SDL_FALSE;\n}\n\n/* Get the library version number */\nvoid\nSDL_GetVersion(SDL_version * ver)\n{\n    SDL_VERSION(ver);\n}\n\n/* Get the library source revision */\nconst char *\nSDL_GetRevision(void)\n{\n    return SDL_REVISION;\n}\n\n/* Get the library source revision number */\nint\nSDL_GetRevisionNumber(void)\n{\n    return SDL_REVISION_NUMBER;\n}\n\n/* Get the name of the platform */\nconst char *\nSDL_GetPlatform()\n{\n#if __AIX__\n    return \"AIX\";\n#elif __ANDROID__\n    return \"Android\";\n#elif __BSDI__\n    return \"BSDI\";\n#elif __DREAMCAST__\n    return \"Dreamcast\";\n#elif __EMSCRIPTEN__\n    return \"Emscripten\";\n#elif __FREEBSD__\n    return \"FreeBSD\";\n#elif __HAIKU__\n    return \"Haiku\";\n#elif __HPUX__\n    return \"HP-UX\";\n#elif __IRIX__\n    return \"Irix\";\n#elif __LINUX__\n    return \"Linux\";\n#elif __MINT__\n    return \"Atari MiNT\";\n#elif __MACOS__\n    return \"MacOS Classic\";\n#elif __MACOSX__\n    return \"Mac OS X\";\n#elif __NACL__\n    return \"NaCl\";\n#elif __NETBSD__\n    return \"NetBSD\";\n#elif __OPENBSD__\n    return \"OpenBSD\";\n#elif __OS2__\n    return \"OS/2\";\n#elif __OSF__\n    return \"OSF/1\";\n#elif __QNXNTO__\n    return \"QNX Neutrino\";\n#elif __RISCOS__\n    return \"RISC OS\";\n#elif __SOLARIS__\n    return \"Solaris\";\n#elif __WIN32__\n    return \"Windows\";\n#elif __WINRT__\n    return \"WinRT\";\n#elif __IPHONEOS__\n    return \"iOS\";\n#elif __PSP__\n    return \"PlayStation Portable\";\n#else\n    return \"Unknown (see SDL_platform.h)\";\n#endif\n}\n\n#if defined(__WIN32__)\n\n#if !defined(HAVE_LIBC) || (defined(__WATCOMC__) && defined(BUILD_DLL))\n/* Need to include DllMain() on Watcom C for some reason.. */\n\nBOOL APIENTRY\n_DllMainCRTStartup(HANDLE hModule,\n                   DWORD ul_reason_for_call, LPVOID lpReserved)\n{\n    switch (ul_reason_for_call) {\n    case DLL_PROCESS_ATTACH:\n    case DLL_THREAD_ATTACH:\n    case DLL_THREAD_DETACH:\n    case DLL_PROCESS_DETACH:\n        break;\n    }\n    return TRUE;\n}\n#endif /* building DLL with Watcom C */\n\n#endif /* __WIN32__ */\n\n/* vi: set sts=4 ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n\n/**\n *  \\file SDL_bits.h\n *\n *  Functions for fiddling with bits and bitmasks.\n */\n\n#ifndef _SDL_bits_h\n#define _SDL_bits_h\n\n#include \"SDL_stdinc.h\"\n\n#include \"begin_code.h\"\n/* Set up for C function definitions, even when using C++ */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n *  \\file SDL_bits.h\n */\n\n/**\n *  Get the index of the most significant bit. Result is undefined when called\n *  with 0. This operation can also be stated as \"count leading zeroes\" and\n *  \"log base 2\".\n *\n *  \\return Index of the most significant bit, or -1 if the value is 0.\n */\nSDL_FORCE_INLINE int\nSDL_MostSignificantBitIndex32(Uint32 x)\n{\n#if defined(__GNUC__) && __GNUC__ >= 4\n    /* Count Leading Zeroes builtin in GCC.\n     * http://gcc.gnu.org/onlinedocs/gcc-4.3.4/gcc/Other-Builtins.html\n     */\n    if (x == 0) {\n        return -1;\n    }\n    return 31 - __builtin_clz(x);\n#else\n    /* Based off of Bit Twiddling Hacks by Sean Eron Anderson\n     * <seander@cs.stanford.edu>, released in the public domain.\n     * http://graphics.stanford.edu/~seander/bithacks.html#IntegerLog\n     */\n    const Uint32 b[] = {0x2, 0xC, 0xF0, 0xFF00, 0xFFFF0000};\n    const int    S[] = {1, 2, 4, 8, 16};\n\n    int msbIndex = 0;\n    int i;\n\n    if (x == 0) {\n        return -1;\n    }\n\n    for (i = 4; i >= 0; i--)\n    {\n        if (x & b[i])\n        {\n            x >>= S[i];\n            msbIndex |= S[i];\n        }\n    }\n\n    return msbIndex;\n#endif\n}\n\n/* Ends C function definitions when using C++ */\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif /* _SDL_bits_h */\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"./SDL_internal.h\"\n\n#if defined(__WIN32__)\n#include \"core/windows/SDL_windows.h\"\n#endif\n\n#include \"SDL.h\"\n#include \"SDL_atomic.h\"\n#include \"SDL_messagebox.h\"\n#include \"SDL_video.h\"\n#include \"SDL_assert.h\"\n#include \"SDL_assert_c.h\"\n#include \"video/SDL_sysvideo.h\"\n\n#ifdef __WIN32__\n#ifndef WS_OVERLAPPEDWINDOW\n#define WS_OVERLAPPEDWINDOW 0\n#endif\n#else  /* fprintf, _exit(), etc. */\n#include <stdio.h>\n#include <stdlib.h>\n#if ! defined(__WINRT__)\n#include <unistd.h>\n#endif\n#endif\n\nstatic SDL_assert_state\nSDL_PromptAssertion(const SDL_assert_data *data, void *userdata);\n\n/*\n * We keep all triggered assertions in a singly-linked list so we can\n *  generate a report later.\n */\nstatic SDL_assert_data *triggered_assertions = NULL;\n\nstatic SDL_mutex *assertion_mutex = NULL;\nstatic SDL_AssertionHandler assertion_handler = SDL_PromptAssertion;\nstatic void *assertion_userdata = NULL;\n\n#ifdef __GNUC__\nstatic void\ndebug_print(const char *fmt, ...) __attribute__((format (printf, 1, 2)));\n#endif\n\nstatic void\ndebug_print(const char *fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    SDL_LogMessageV(SDL_LOG_CATEGORY_ASSERT, SDL_LOG_PRIORITY_WARN, fmt, ap);\n    va_end(ap);\n}\n\n\nstatic void SDL_AddAssertionToReport(SDL_assert_data *data)\n{\n    /* (data) is always a static struct defined with the assert macros, so\n       we don't have to worry about copying or allocating them. */\n    data->trigger_count++;\n    if (data->trigger_count == 1) {  /* not yet added? */\n        data->next = triggered_assertions;\n        triggered_assertions = data;\n    }\n}\n\n\nstatic void SDL_GenerateAssertionReport(void)\n{\n    const SDL_assert_data *item = triggered_assertions;\n\n    /* only do this if the app hasn't assigned an assertion handler. */\n    if ((item != NULL) && (assertion_handler != SDL_PromptAssertion)) {\n        debug_print(\"\\n\\nSDL assertion report.\\n\");\n        debug_print(\"All SDL assertions between last init/quit:\\n\\n\");\n\n        while (item != NULL) {\n            debug_print(\n                \"'%s'\\n\"\n                \"    * %s (%s:%d)\\n\"\n                \"    * triggered %u time%s.\\n\"\n                \"    * always ignore: %s.\\n\",\n                item->condition, item->function, item->filename,\n                item->linenum, item->trigger_count,\n                (item->trigger_count == 1) ? \"\" : \"s\",\n                item->always_ignore ? \"yes\" : \"no\");\n            item = item->next;\n        }\n        debug_print(\"\\n\");\n\n        SDL_ResetAssertionReport();\n    }\n}\n\nstatic void SDL_ExitProcess(int exitcode)\n{\n#ifdef __WIN32__\n    ExitProcess(exitcode);\n#else\n    _exit(exitcode);\n#endif\n}\n\nstatic void SDL_AbortAssertion(void)\n{\n    SDL_Quit();\n    SDL_ExitProcess(42);\n}\n\n\nstatic SDL_assert_state\nSDL_PromptAssertion(const SDL_assert_data *data, void *userdata)\n{\n#ifdef __WIN32__\n    #define ENDLINE \"\\r\\n\"\n#else\n    #define ENDLINE \"\\n\"\n#endif\n\n    const char *envr;\n    SDL_assert_state state = SDL_ASSERTION_ABORT;\n    SDL_Window *window;\n    SDL_MessageBoxData messagebox;\n    SDL_MessageBoxButtonData buttons[] = {\n        {   0,  SDL_ASSERTION_RETRY,            \"Retry\" },\n        {   0,  SDL_ASSERTION_BREAK,            \"Break\" },\n        {   0,  SDL_ASSERTION_ABORT,            \"Abort\" },\n        {   SDL_MESSAGEBOX_BUTTON_ESCAPEKEY_DEFAULT,\n                SDL_ASSERTION_IGNORE,           \"Ignore\" },\n        {   SDL_MESSAGEBOX_BUTTON_RETURNKEY_DEFAULT,\n                SDL_ASSERTION_ALWAYS_IGNORE,    \"Always Ignore\" }\n    };\n    char *message;\n    int selected;\n\n    (void) userdata;  /* unused in default handler. */\n\n    message = SDL_stack_alloc(char, SDL_MAX_LOG_MESSAGE);\n    if (!message) {\n        /* Uh oh, we're in real trouble now... */\n        return SDL_ASSERTION_ABORT;\n    }\n    SDL_snprintf(message, SDL_MAX_LOG_MESSAGE,\n                 \"Assertion failure at %s (%s:%d), triggered %u %s:\" ENDLINE\n                    \"  '%s'\",\n                 data->function, data->filename, data->linenum,\n                 data->trigger_count, (data->trigger_count == 1) ? \"time\" : \"times\",\n                 data->condition);\n\n    debug_print(\"\\n\\n%s\\n\\n\", message);\n\n    /* let env. variable override, so unit tests won't block in a GUI. */\n    envr = SDL_getenv(\"SDL_ASSERT\");\n    if (envr != NULL) {\n        SDL_stack_free(message);\n\n        if (SDL_strcmp(envr, \"abort\") == 0) {\n            return SDL_ASSERTION_ABORT;\n        } else if (SDL_strcmp(envr, \"break\") == 0) {\n            return SDL_ASSERTION_BREAK;\n        } else if (SDL_strcmp(envr, \"retry\") == 0) {\n            return SDL_ASSERTION_RETRY;\n        } else if (SDL_strcmp(envr, \"ignore\") == 0) {\n            return SDL_ASSERTION_IGNORE;\n        } else if (SDL_strcmp(envr, \"always_ignore\") == 0) {\n            return SDL_ASSERTION_ALWAYS_IGNORE;\n        } else {\n            return SDL_ASSERTION_ABORT;  /* oh well. */\n        }\n    }\n\n    /* Leave fullscreen mode, if possible (scary!) */\n    window = SDL_GetFocusWindow();\n    if (window) {\n        if (SDL_GetWindowFlags(window) & SDL_WINDOW_FULLSCREEN) {\n            SDL_MinimizeWindow(window);\n        } else {\n            /* !!! FIXME: ungrab the input if we're not fullscreen? */\n            /* No need to mess with the window */\n            window = NULL;\n        }\n    }\n\n    /* Show a messagebox if we can, otherwise fall back to stdio */\n    SDL_zero(messagebox);\n    messagebox.flags = SDL_MESSAGEBOX_WARNING;\n    messagebox.window = window;\n    messagebox.title = \"Assertion Failed\";\n    messagebox.message = message;\n    messagebox.numbuttons = SDL_arraysize(buttons);\n    messagebox.buttons = buttons;\n\n    if (SDL_ShowMessageBox(&messagebox, &selected) == 0) {\n        if (selected == -1) {\n            state = SDL_ASSERTION_IGNORE;\n        } else {\n            state = (SDL_assert_state)selected;\n        }\n    }\n#ifdef HAVE_STDIO_H\n    else\n    {\n        /* this is a little hacky. */\n        for ( ; ; ) {\n            char buf[32];\n            fprintf(stderr, \"Abort/Break/Retry/Ignore/AlwaysIgnore? [abriA] : \");\n            fflush(stderr);\n            if (fgets(buf, sizeof (buf), stdin) == NULL) {\n                break;\n            }\n\n            if (SDL_strcmp(buf, \"a\") == 0) {\n                state = SDL_ASSERTION_ABORT;\n                break;\n            } else if (SDL_strcmp(buf, \"b\") == 0) {\n                state = SDL_ASSERTION_BREAK;\n                break;\n            } else if (SDL_strcmp(buf, \"r\") == 0) {\n                state = SDL_ASSERTION_RETRY;\n                break;\n            } else if (SDL_strcmp(buf, \"i\") == 0) {\n                state = SDL_ASSERTION_IGNORE;\n                break;\n            } else if (SDL_strcmp(buf, \"A\") == 0) {\n                state = SDL_ASSERTION_ALWAYS_IGNORE;\n                break;\n            }\n        }\n    }\n#endif /* HAVE_STDIO_H */\n\n    /* Re-enter fullscreen mode */\n    if (window) {\n        SDL_RestoreWindow(window);\n    }\n\n    SDL_stack_free(message);\n\n    return state;\n}\n\n\nSDL_assert_state\nSDL_ReportAssertion(SDL_assert_data *data, const char *func, const char *file,\n                    int line)\n{\n    static int assertion_running = 0;\n    static SDL_SpinLock spinlock = 0;\n    SDL_assert_state state = SDL_ASSERTION_IGNORE;\n\n    SDL_AtomicLock(&spinlock);\n    if (assertion_mutex == NULL) { /* never called SDL_Init()? */\n        assertion_mutex = SDL_CreateMutex();\n        if (assertion_mutex == NULL) {\n            SDL_AtomicUnlock(&spinlock);\n            return SDL_ASSERTION_IGNORE;   /* oh well, I guess. */\n        }\n    }\n    SDL_AtomicUnlock(&spinlock);\n\n    if (SDL_LockMutex(assertion_mutex) < 0) {\n        return SDL_ASSERTION_IGNORE;   /* oh well, I guess. */\n    }\n\n    /* doing this because Visual C is upset over assigning in the macro. */\n    if (data->trigger_count == 0) {\n        data->function = func;\n        data->filename = file;\n        data->linenum = line;\n    }\n\n    SDL_AddAssertionToReport(data);\n\n    assertion_running++;\n    if (assertion_running > 1) {   /* assert during assert! Abort. */\n        if (assertion_running == 2) {\n            SDL_AbortAssertion();\n        } else if (assertion_running == 3) {  /* Abort asserted! */\n            SDL_ExitProcess(42);\n        } else {\n            while (1) { /* do nothing but spin; what else can you do?! */ }\n        }\n    }\n\n    if (!data->always_ignore) {\n        state = assertion_handler(data, assertion_userdata);\n    }\n\n    switch (state)\n    {\n        case SDL_ASSERTION_ABORT:\n            SDL_AbortAssertion();\n            return SDL_ASSERTION_IGNORE;  /* shouldn't return, but oh well. */\n\n        case SDL_ASSERTION_ALWAYS_IGNORE:\n            state = SDL_ASSERTION_IGNORE;\n            data->always_ignore = 1;\n            break;\n\n        case SDL_ASSERTION_IGNORE:\n        case SDL_ASSERTION_RETRY:\n        case SDL_ASSERTION_BREAK:\n            break;  /* macro handles these. */\n    }\n\n    assertion_running--;\n    SDL_UnlockMutex(assertion_mutex);\n\n    return state;\n}\n\n\nvoid SDL_AssertionsQuit(void)\n{\n    SDL_GenerateAssertionReport();\n    if (assertion_mutex != NULL) {\n        SDL_DestroyMutex(assertion_mutex);\n        assertion_mutex = NULL;\n    }\n}\n\nvoid SDL_SetAssertionHandler(SDL_AssertionHandler handler, void *userdata)\n{\n    if (handler != NULL) {\n        assertion_handler = handler;\n        assertion_userdata = userdata;\n    } else {\n        assertion_handler = SDL_PromptAssertion;\n        assertion_userdata = NULL;\n    }\n}\n\nconst SDL_assert_data *SDL_GetAssertionReport(void)\n{\n    return triggered_assertions;\n}\n\nvoid SDL_ResetAssertionReport(void)\n{\n    SDL_assert_data *next = NULL;\n    SDL_assert_data *item;\n    for (item = triggered_assertions; item != NULL; item = next) {\n        next = (SDL_assert_data *) item->next;\n        item->always_ignore = SDL_FALSE;\n        item->trigger_count = 0;\n        item->next = NULL;\n    }\n\n    triggered_assertions = NULL;\n}\n\nSDL_AssertionHandler SDL_GetDefaultAssertionHandler(void)\n{\n    return SDL_PromptAssertion;\n}\n\nSDL_AssertionHandler SDL_GetAssertionHandler(void **userdata)\n{\n    if (userdata != NULL) {\n        *userdata = assertion_userdata;\n    }\n    return assertion_handler;\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"./SDL_internal.h\"\n\n/* Simple error handling in SDL */\n\n#include \"SDL_log.h\"\n#include \"SDL_error.h\"\n#include \"SDL_error_c.h\"\n\n\n/* Routine to get the thread-specific error variable */\n#if SDL_THREADS_DISABLED\n/* The default (non-thread-safe) global error variable */\nstatic SDL_error SDL_global_error;\n#define SDL_GetErrBuf() (&SDL_global_error)\n#else\nextern SDL_error *SDL_GetErrBuf(void);\n#endif /* SDL_THREADS_DISABLED */\n\n#define SDL_ERRBUFIZE   1024\n\n/* Private functions */\n\nstatic const char *\nSDL_LookupString(const char *key)\n{\n    /* FIXME: Add code to lookup key in language string hash-table */\n    return key;\n}\n\n/* Public functions */\n\nint\nSDL_SetError(SDL_PRINTF_FORMAT_STRING const char *fmt, ...)\n{\n    va_list ap;\n    SDL_error *error;\n\n    /* Ignore call if invalid format pointer was passed */\n    if (fmt == NULL) return -1;\n\n    /* Copy in the key, mark error as valid */\n    error = SDL_GetErrBuf();\n    error->error = 1;\n    SDL_strlcpy((char *) error->key, fmt, sizeof(error->key));\n\n    va_start(ap, fmt);\n    error->argc = 0;\n    while (*fmt) {\n        if (*fmt++ == '%') {\n            while (*fmt == '.' || (*fmt >= '0' && *fmt <= '9')) {\n                ++fmt;\n            }\n            switch (*fmt++) {\n            case 0:            /* Malformed format string.. */\n                --fmt;\n                break;\n            case 'c':\n            case 'i':\n            case 'd':\n            case 'u':\n            case 'o':\n            case 'x':\n            case 'X':\n                error->args[error->argc++].value_i = va_arg(ap, int);\n                break;\n            case 'f':\n                error->args[error->argc++].value_f = va_arg(ap, double);\n                break;\n            case 'p':\n                error->args[error->argc++].value_ptr = va_arg(ap, void *);\n                break;\n            case 's':\n                {\n                    int i = error->argc;\n                    const char *str = va_arg(ap, const char *);\n                    if (str == NULL)\n                        str = \"(null)\";\n                    SDL_strlcpy((char *) error->args[i].buf, str,\n                                ERR_MAX_STRLEN);\n                    error->argc++;\n                }\n                break;\n            default:\n                break;\n            }\n            if (error->argc >= ERR_MAX_ARGS) {\n                break;\n            }\n        }\n    }\n    va_end(ap);\n\n    /* If we are in debug mode, print out an error message */\n    SDL_LogError(SDL_LOG_CATEGORY_ERROR, \"%s\", SDL_GetError());\n\n    return -1;\n}\n\n/* This function has a bit more overhead than most error functions\n   so that it supports internationalization and thread-safe errors.\n*/\nstatic char *\nSDL_GetErrorMsg(char *errstr, unsigned int maxlen)\n{\n    SDL_error *error;\n\n    /* Clear the error string */\n    *errstr = '\\0';\n    --maxlen;\n\n    /* Get the thread-safe error, and print it out */\n    error = SDL_GetErrBuf();\n    if (error->error) {\n        const char *fmt;\n        char *msg = errstr;\n        int len;\n        int argi;\n\n        fmt = SDL_LookupString(error->key);\n        argi = 0;\n        while (*fmt && (maxlen > 0)) {\n            if (*fmt == '%') {\n                char tmp[32], *spot = tmp;\n                *spot++ = *fmt++;\n                while ((*fmt == '.' || (*fmt >= '0' && *fmt <= '9'))\n                       && spot < (tmp + SDL_arraysize(tmp) - 2)) {\n                    *spot++ = *fmt++;\n                }\n                *spot++ = *fmt++;\n                *spot++ = '\\0';\n                switch (spot[-2]) {\n                case '%':\n                    *msg++ = '%';\n                    maxlen -= 1;\n                    break;\n                case 'c':\n                case 'i':\n                case 'd':\n                case 'u':\n                case 'o':\n                case 'x':\n                case 'X':\n                    len =\n                        SDL_snprintf(msg, maxlen, tmp,\n                                     error->args[argi++].value_i);\n                    msg += len;\n                    maxlen -= len;\n                    break;\n                case 'f':\n                    len =\n                        SDL_snprintf(msg, maxlen, tmp,\n                                     error->args[argi++].value_f);\n                    msg += len;\n                    maxlen -= len;\n                    break;\n                case 'p':\n                    len =\n                        SDL_snprintf(msg, maxlen, tmp,\n                                     error->args[argi++].value_ptr);\n                    msg += len;\n                    maxlen -= len;\n                    break;\n                case 's':\n                    len =\n                        SDL_snprintf(msg, maxlen, tmp,\n                                     SDL_LookupString(error->args[argi++].\n                                                      buf));\n                    msg += len;\n                    maxlen -= len;\n                    break;\n                }\n            } else {\n                *msg++ = *fmt++;\n                maxlen -= 1;\n            }\n        }\n        *msg = 0;               /* NULL terminate the string */\n    }\n    return (errstr);\n}\n\n/* Available for backwards compatibility */\nconst char *\nSDL_GetError(void)\n{\n    static char errmsg[SDL_ERRBUFIZE];\n\n    return SDL_GetErrorMsg(errmsg, SDL_ERRBUFIZE);\n}\n\nvoid\nSDL_ClearError(void)\n{\n    SDL_error *error;\n\n    error = SDL_GetErrBuf();\n    error->error = 0;\n}\n\n/* Very common errors go here */\nint\nSDL_Error(SDL_errorcode code)\n{\n    switch (code) {\n    case SDL_ENOMEM:\n        return SDL_SetError(\"Out of memory\");\n    case SDL_EFREAD:\n        return SDL_SetError(\"Error reading from datastream\");\n    case SDL_EFWRITE:\n        return SDL_SetError(\"Error writing to datastream\");\n    case SDL_EFSEEK:\n        return SDL_SetError(\"Error seeking in datastream\");\n    case SDL_UNSUPPORTED:\n        return SDL_SetError(\"That operation is not supported\");\n    default:\n        return SDL_SetError(\"Unknown SDL error\");\n    }\n}\n\n#ifdef TEST_ERROR\nint\nmain(int argc, char *argv[])\n{\n    char buffer[BUFSIZ + 1];\n\n    SDL_SetError(\"Hi there!\");\n    printf(\"Error 1: %s\\n\", SDL_GetError());\n    SDL_ClearError();\n    SDL_memset(buffer, '1', BUFSIZ);\n    buffer[BUFSIZ] = 0;\n    SDL_SetError(\"This is the error: %s (%f)\", buffer, 1.0);\n    printf(\"Error 2: %s\\n\", SDL_GetError());\n    exit(0);\n}\n#endif\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"./SDL_internal.h\"\n\n#include \"SDL_hints.h\"\n#include \"SDL_error.h\"\n\n\n/* Assuming there aren't many hints set and they aren't being queried in\n   critical performance paths, we'll just use linked lists here.\n */\ntypedef struct SDL_HintWatch {\n    SDL_HintCallback callback;\n    void *userdata;\n    struct SDL_HintWatch *next;\n} SDL_HintWatch;\n\ntypedef struct SDL_Hint {\n    char *name;\n    char *value;\n    SDL_HintPriority priority;\n    SDL_HintWatch *callbacks;\n    struct SDL_Hint *next;\n} SDL_Hint;\n\nstatic SDL_Hint *SDL_hints;\n\nSDL_bool\nSDL_SetHintWithPriority(const char *name, const char *value,\n                        SDL_HintPriority priority)\n{\n    const char *env;\n    SDL_Hint *hint;\n    SDL_HintWatch *entry;\n\n    if (!name || !value) {\n        return SDL_FALSE;\n    }\n\n    env = SDL_getenv(name);\n    if (env && priority < SDL_HINT_OVERRIDE) {\n        return SDL_FALSE;\n    }\n\n    for (hint = SDL_hints; hint; hint = hint->next) {\n        if (SDL_strcmp(name, hint->name) == 0) {\n            if (priority < hint->priority) {\n                return SDL_FALSE;\n            }\n            if (!hint->value || !value || SDL_strcmp(hint->value, value) != 0) {\n                for (entry = hint->callbacks; entry; ) {\n                    /* Save the next entry in case this one is deleted */\n                    SDL_HintWatch *next = entry->next;\n                    entry->callback(entry->userdata, name, hint->value, value);\n                    entry = next;\n                }\n                SDL_free(hint->value);\n                hint->value = value ? SDL_strdup(value) : NULL;\n            }\n            hint->priority = priority;\n            return SDL_TRUE;\n        }\n    }\n\n    /* Couldn't find the hint, add a new one */\n    hint = (SDL_Hint *)SDL_malloc(sizeof(*hint));\n    if (!hint) {\n        return SDL_FALSE;\n    }\n    hint->name = SDL_strdup(name);\n    hint->value = value ? SDL_strdup(value) : NULL;\n    hint->priority = priority;\n    hint->callbacks = NULL;\n    hint->next = SDL_hints;\n    SDL_hints = hint;\n    return SDL_TRUE;\n}\n\nSDL_bool\nSDL_SetHint(const char *name, const char *value)\n{\n    return SDL_SetHintWithPriority(name, value, SDL_HINT_NORMAL);\n}\n\nconst char *\nSDL_GetHint(const char *name)\n{\n    const char *env;\n    SDL_Hint *hint;\n\n    env = SDL_getenv(name);\n    for (hint = SDL_hints; hint; hint = hint->next) {\n        if (SDL_strcmp(name, hint->name) == 0) {\n            if (!env || hint->priority == SDL_HINT_OVERRIDE) {\n                return hint->value;\n            }\n            break;\n        }\n    }\n    return env;\n}\n\nvoid\nSDL_AddHintCallback(const char *name, SDL_HintCallback callback, void *userdata)\n{\n    SDL_Hint *hint;\n    SDL_HintWatch *entry;\n    const char *value;\n\n    if (!name || !*name) {\n        SDL_InvalidParamError(\"name\");\n        return;\n    }\n    if (!callback) {\n        SDL_InvalidParamError(\"callback\");\n        return;\n    }\n\n    SDL_DelHintCallback(name, callback, userdata);\n\n    entry = (SDL_HintWatch *)SDL_malloc(sizeof(*entry));\n    if (!entry) {\n        SDL_OutOfMemory();\n        return;\n    }\n    entry->callback = callback;\n    entry->userdata = userdata;\n\n    for (hint = SDL_hints; hint; hint = hint->next) {\n        if (SDL_strcmp(name, hint->name) == 0) {\n            break;\n        }\n    }\n    if (!hint) {\n        /* Need to add a hint entry for this watcher */\n        hint = (SDL_Hint *)SDL_malloc(sizeof(*hint));\n        if (!hint) {\n            SDL_OutOfMemory();\n            SDL_free(entry);\n            return;\n        }\n        hint->name = SDL_strdup(name);\n        hint->value = NULL;\n        hint->priority = SDL_HINT_DEFAULT;\n        hint->callbacks = NULL;\n        hint->next = SDL_hints;\n        SDL_hints = hint;\n    }\n\n    /* Add it to the callbacks for this hint */\n    entry->next = hint->callbacks;\n    hint->callbacks = entry;\n\n    /* Now call it with the current value */\n    value = SDL_GetHint(name);\n    callback(userdata, name, value, value);\n}\n\nvoid\nSDL_DelHintCallback(const char *name, SDL_HintCallback callback, void *userdata)\n{\n    SDL_Hint *hint;\n    SDL_HintWatch *entry, *prev;\n\n    for (hint = SDL_hints; hint; hint = hint->next) {\n        if (SDL_strcmp(name, hint->name) == 0) {\n            prev = NULL;\n            for (entry = hint->callbacks; entry; entry = entry->next) {\n                if (callback == entry->callback && userdata == entry->userdata) {\n                    if (prev) {\n                        prev->next = entry->next;\n                    } else {\n                        hint->callbacks = entry->next;\n                    }\n                    SDL_free(entry);\n                    break;\n                }\n                prev = entry;\n            }\n            return;\n        }\n    }\n}\n\nvoid SDL_ClearHints(void)\n{\n    SDL_Hint *hint;\n    SDL_HintWatch *entry;\n\n    while (SDL_hints) {\n        hint = SDL_hints;\n        SDL_hints = hint->next;\n\n        SDL_free(hint->name);\n        SDL_free(hint->value);\n        for (entry = hint->callbacks; entry; ) {\n            SDL_HintWatch *freeable = entry;\n            entry = entry->next;\n            SDL_free(freeable);\n        }\n        SDL_free(hint);\n    }\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../SDL_internal.h\"\n\n#if defined(__WIN32__) || defined(__WINRT__)\n#include \"../core/windows/SDL_windows.h\"\n#endif\n\n#include \"SDL_atomic.h\"\n#include \"SDL_mutex.h\"\n#include \"SDL_timer.h\"\n\n#if !defined(HAVE_GCC_ATOMICS) && defined(__SOLARIS__)\n#include <atomic.h>\n#endif\n\n/* This function is where all the magic happens... */\nSDL_bool\nSDL_AtomicTryLock(SDL_SpinLock *lock)\n{\n#if SDL_ATOMIC_DISABLED\n    /* Terrible terrible damage */\n    static SDL_mutex *_spinlock_mutex;\n\n    if (!_spinlock_mutex) {\n        /* Race condition on first lock... */\n        _spinlock_mutex = SDL_CreateMutex();\n    }\n    SDL_LockMutex(_spinlock_mutex);\n    if (*lock == 0) {\n        *lock = 1;\n        SDL_UnlockMutex(_spinlock_mutex);\n        return SDL_TRUE;\n    } else {\n        SDL_UnlockMutex(_spinlock_mutex);\n        return SDL_FALSE;\n    }\n\n#elif defined(_MSC_VER)\n    SDL_COMPILE_TIME_ASSERT(locksize, sizeof(*lock) == sizeof(long));\n    return (InterlockedExchange((long*)lock, 1) == 0);\n\n#elif HAVE_GCC_ATOMICS || HAVE_GCC_SYNC_LOCK_TEST_AND_SET\n    return (__sync_lock_test_and_set(lock, 1) == 0);\n\n#elif defined(__GNUC__) && defined(__arm__) && \\\n        (defined(__ARM_ARCH_4__) || defined(__ARM_ARCH_4T__) || \\\n         defined(__ARM_ARCH_5__) || defined(__ARM_ARCH_5TE__) || \\\n         defined(__ARM_ARCH_5TEJ__))\n    int result;\n    __asm__ __volatile__ (\n        \"swp %0, %1, [%2]\\n\"\n        : \"=&r,&r\" (result) : \"r,0\" (1), \"r,r\" (lock) : \"memory\");\n    return (result == 0);\n\n#elif defined(__GNUC__) && defined(__arm__)\n    int result;\n    __asm__ __volatile__ (\n        \"ldrex %0, [%2]\\nteq   %0, #0\\nstrexeq %0, %1, [%2]\"\n        : \"=&r\" (result) : \"r\" (1), \"r\" (lock) : \"cc\", \"memory\");\n    return (result == 0);\n\n#elif defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))\n    int result;\n    __asm__ __volatile__(\n        \"lock ; xchgl %0, (%1)\\n\"\n        : \"=r\" (result) : \"r\" (lock), \"0\" (1) : \"cc\", \"memory\");\n    return (result == 0);\n\n#elif defined(__MACOSX__) || defined(__IPHONEOS__)\n    /* Maybe used for PowerPC, but the Intel asm or gcc atomics are favored. */\n    return OSAtomicCompareAndSwap32Barrier(0, 1, lock);\n\n#elif defined(__SOLARIS__) && defined(_LP64)\n    /* Used for Solaris with non-gcc compilers. */\n    return (SDL_bool) ((int) atomic_cas_64((volatile uint64_t*)lock, 0, 1) == 0);\n\n#elif defined(__SOLARIS__) && !defined(_LP64)\n    /* Used for Solaris with non-gcc compilers. */\n    return (SDL_bool) ((int) atomic_cas_32((volatile uint32_t*)lock, 0, 1) == 0);\n\n#else\n#error Please implement for your platform.\n    return SDL_FALSE;\n#endif\n}\n\nvoid\nSDL_AtomicLock(SDL_SpinLock *lock)\n{\n    /* FIXME: Should we have an eventual timeout? */\n    while (!SDL_AtomicTryLock(lock)) {\n        SDL_Delay(0);\n    }\n}\n\nvoid\nSDL_AtomicUnlock(SDL_SpinLock *lock)\n{\n#if defined(_MSC_VER)\n    _ReadWriteBarrier();\n    *lock = 0;\n\n#elif HAVE_GCC_ATOMICS || HAVE_GCC_SYNC_LOCK_TEST_AND_SET\n    __sync_lock_release(lock);\n\n#elif defined(__SOLARIS__)\n    /* Used for Solaris when not using gcc. */\n    *lock = 0;\n    membar_producer();\n\n#else\n    *lock = 0;\n#endif\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../SDL_internal.h\"\n\n/* Allow access to a raw mixing buffer */\n\n#include \"SDL.h\"\n#include \"SDL_audio.h\"\n#include \"SDL_audio_c.h\"\n#include \"SDL_audiomem.h\"\n#include \"SDL_sysaudio.h\"\n\n#define _THIS SDL_AudioDevice *_this\n\nstatic SDL_AudioDriver current_audio;\nstatic SDL_AudioDevice *open_devices[16];\n\n/* !!! FIXME: These are wordy and unlocalized... */\n#define DEFAULT_OUTPUT_DEVNAME \"System audio output device\"\n#define DEFAULT_INPUT_DEVNAME \"System audio capture device\"\n\n\n/*\n * Not all of these will be compiled and linked in, but it's convenient\n *  to have a complete list here and saves yet-another block of #ifdefs...\n *  Please see bootstrap[], below, for the actual #ifdef mess.\n */\nextern AudioBootStrap BSD_AUDIO_bootstrap;\nextern AudioBootStrap DSP_bootstrap;\nextern AudioBootStrap ALSA_bootstrap;\nextern AudioBootStrap PULSEAUDIO_bootstrap;\nextern AudioBootStrap QSAAUDIO_bootstrap;\nextern AudioBootStrap SUNAUDIO_bootstrap;\nextern AudioBootStrap ARTS_bootstrap;\nextern AudioBootStrap ESD_bootstrap;\nextern AudioBootStrap NACLAUD_bootstrap;\nextern AudioBootStrap NAS_bootstrap;\nextern AudioBootStrap XAUDIO2_bootstrap;\nextern AudioBootStrap DSOUND_bootstrap;\nextern AudioBootStrap WINMM_bootstrap;\nextern AudioBootStrap PAUDIO_bootstrap;\nextern AudioBootStrap HAIKUAUDIO_bootstrap;\nextern AudioBootStrap COREAUDIO_bootstrap;\nextern AudioBootStrap SNDMGR_bootstrap;\nextern AudioBootStrap DISKAUD_bootstrap;\nextern AudioBootStrap DUMMYAUD_bootstrap;\nextern AudioBootStrap DCAUD_bootstrap;\nextern AudioBootStrap DART_bootstrap;\nextern AudioBootStrap NDSAUD_bootstrap;\nextern AudioBootStrap FUSIONSOUND_bootstrap;\nextern AudioBootStrap ANDROIDAUD_bootstrap;\nextern AudioBootStrap PSPAUD_bootstrap;\nextern AudioBootStrap SNDIO_bootstrap;\nextern AudioBootStrap EmscriptenAudio_bootstrap;\n\n\n/* Available audio drivers */\nstatic const AudioBootStrap *const bootstrap[] = {\n#if SDL_AUDIO_DRIVER_PULSEAUDIO\n    &PULSEAUDIO_bootstrap,\n#endif\n#if SDL_AUDIO_DRIVER_ALSA\n    &ALSA_bootstrap,\n#endif\n#if SDL_AUDIO_DRIVER_SNDIO\n    &SNDIO_bootstrap,\n#endif\n#if SDL_AUDIO_DRIVER_BSD\n    &BSD_AUDIO_bootstrap,\n#endif\n#if SDL_AUDIO_DRIVER_OSS\n    &DSP_bootstrap,\n#endif\n#if SDL_AUDIO_DRIVER_QSA\n    &QSAAUDIO_bootstrap,\n#endif\n#if SDL_AUDIO_DRIVER_SUNAUDIO\n    &SUNAUDIO_bootstrap,\n#endif\n#if SDL_AUDIO_DRIVER_ARTS\n    &ARTS_bootstrap,\n#endif\n#if SDL_AUDIO_DRIVER_ESD\n    &ESD_bootstrap,\n#endif\n#if SDL_AUDIO_DRIVER_NACL\n   &NACLAUD_bootstrap,\n#endif\n#if SDL_AUDIO_DRIVER_NAS\n    &NAS_bootstrap,\n#endif\n#if SDL_AUDIO_DRIVER_XAUDIO2\n    &XAUDIO2_bootstrap,\n#endif\n#if SDL_AUDIO_DRIVER_DSOUND\n    &DSOUND_bootstrap,\n#endif\n#if SDL_AUDIO_DRIVER_WINMM\n    &WINMM_bootstrap,\n#endif\n#if SDL_AUDIO_DRIVER_PAUDIO\n    &PAUDIO_bootstrap,\n#endif\n#if SDL_AUDIO_DRIVER_HAIKU\n    &HAIKUAUDIO_bootstrap,\n#endif\n#if SDL_AUDIO_DRIVER_COREAUDIO\n    &COREAUDIO_bootstrap,\n#endif\n#if SDL_AUDIO_DRIVER_DISK\n    &DISKAUD_bootstrap,\n#endif\n#if SDL_AUDIO_DRIVER_DUMMY\n    &DUMMYAUD_bootstrap,\n#endif\n#if SDL_AUDIO_DRIVER_FUSIONSOUND\n    &FUSIONSOUND_bootstrap,\n#endif\n#if SDL_AUDIO_DRIVER_ANDROID\n    &ANDROIDAUD_bootstrap,\n#endif\n#if SDL_AUDIO_DRIVER_PSP\n    &PSPAUD_bootstrap,\n#endif\n#if SDL_AUDIO_DRIVER_EMSCRIPTEN\n    &EmscriptenAudio_bootstrap,\n#endif\n    NULL\n};\n\nstatic SDL_AudioDevice *\nget_audio_device(SDL_AudioDeviceID id)\n{\n    id--;\n    if ((id >= SDL_arraysize(open_devices)) || (open_devices[id] == NULL)) {\n        SDL_SetError(\"Invalid audio device ID\");\n        return NULL;\n    }\n\n    return open_devices[id];\n}\n\n\n/* stubs for audio drivers that don't need a specific entry point... */\nstatic void\nSDL_AudioDetectDevices_Default(void)\n{\n    /* you have to write your own implementation if these assertions fail. */\n    SDL_assert(current_audio.impl.OnlyHasDefaultOutputDevice);\n    SDL_assert(current_audio.impl.OnlyHasDefaultInputDevice || !current_audio.impl.HasCaptureSupport);\n\n    SDL_AddAudioDevice(SDL_FALSE, DEFAULT_OUTPUT_DEVNAME, (void *) ((size_t) 0x1));\n    if (current_audio.impl.HasCaptureSupport) {\n        SDL_AddAudioDevice(SDL_TRUE, DEFAULT_INPUT_DEVNAME, (void *) ((size_t) 0x2));\n    }\n}\n\nstatic void\nSDL_AudioThreadInit_Default(_THIS)\n{                               /* no-op. */\n}\n\nstatic void\nSDL_AudioWaitDevice_Default(_THIS)\n{                               /* no-op. */\n}\n\nstatic void\nSDL_AudioPlayDevice_Default(_THIS)\n{                               /* no-op. */\n}\n\nstatic int\nSDL_AudioGetPendingBytes_Default(_THIS)\n{\n    return 0;\n}\n\nstatic Uint8 *\nSDL_AudioGetDeviceBuf_Default(_THIS)\n{\n    return NULL;\n}\n\nstatic void\nSDL_AudioWaitDone_Default(_THIS)\n{                               /* no-op. */\n}\n\nstatic void\nSDL_AudioCloseDevice_Default(_THIS)\n{                               /* no-op. */\n}\n\nstatic void\nSDL_AudioDeinitialize_Default(void)\n{                               /* no-op. */\n}\n\nstatic void\nSDL_AudioFreeDeviceHandle_Default(void *handle)\n{                               /* no-op. */\n}\n\n\nstatic int\nSDL_AudioOpenDevice_Default(_THIS, void *handle, const char *devname, int iscapture)\n{\n    return SDL_Unsupported();\n}\n\nstatic SDL_INLINE SDL_bool\nis_in_audio_device_thread(SDL_AudioDevice * device)\n{\n    /* The device thread locks the same mutex, but not through the public API.\n       This check is in case the application, in the audio callback,\n       tries to lock the thread that we've already locked from the\n       device thread...just in case we only have non-recursive mutexes. */\n    if (device->thread && (SDL_ThreadID() == device->threadid)) {\n        return SDL_TRUE;\n    }\n\n    return SDL_FALSE;\n}\n\nstatic void\nSDL_AudioLockDevice_Default(SDL_AudioDevice * device)\n{\n    if (!is_in_audio_device_thread(device)) {\n        SDL_LockMutex(device->mixer_lock);\n    }\n}\n\nstatic void\nSDL_AudioUnlockDevice_Default(SDL_AudioDevice * device)\n{\n    if (!is_in_audio_device_thread(device)) {\n        SDL_UnlockMutex(device->mixer_lock);\n    }\n}\n\n\nstatic void\nfinalize_audio_entry_points(void)\n{\n    /*\n     * Fill in stub functions for unused driver entry points. This lets us\n     *  blindly call them without having to check for validity first.\n     */\n\n#define FILL_STUB(x) \\\n        if (current_audio.impl.x == NULL) { \\\n            current_audio.impl.x = SDL_Audio##x##_Default; \\\n        }\n    FILL_STUB(DetectDevices);\n    FILL_STUB(OpenDevice);\n    FILL_STUB(ThreadInit);\n    FILL_STUB(WaitDevice);\n    FILL_STUB(PlayDevice);\n    FILL_STUB(GetPendingBytes);\n    FILL_STUB(GetDeviceBuf);\n    FILL_STUB(WaitDone);\n    FILL_STUB(CloseDevice);\n    FILL_STUB(LockDevice);\n    FILL_STUB(UnlockDevice);\n    FILL_STUB(FreeDeviceHandle);\n    FILL_STUB(Deinitialize);\n#undef FILL_STUB\n}\n\n\n/* device hotplug support... */\n\nstatic int\nadd_audio_device(const char *name, void *handle, SDL_AudioDeviceItem **devices, int *devCount)\n{\n    int retval = -1;\n    const size_t size = sizeof (SDL_AudioDeviceItem) + SDL_strlen(name) + 1;\n    SDL_AudioDeviceItem *item = (SDL_AudioDeviceItem *) SDL_malloc(size);\n    if (item == NULL) {\n        return -1;\n    }\n\n    SDL_assert(handle != NULL);  /* we reserve NULL, audio backends can't use it. */\n\n    item->handle = handle;\n    SDL_strlcpy(item->name, name, size - sizeof (SDL_AudioDeviceItem));\n\n    SDL_LockMutex(current_audio.detectionLock);\n    item->next = *devices;\n    *devices = item;\n    retval = (*devCount)++;\n    SDL_UnlockMutex(current_audio.detectionLock);\n\n    return retval;\n}\n\nstatic SDL_INLINE int\nadd_capture_device(const char *name, void *handle)\n{\n    /* !!! FIXME: add this later. SDL_assert(current_audio.impl.HasCaptureSupport);*/\n    return add_audio_device(name, handle, &current_audio.inputDevices, &current_audio.inputDeviceCount);\n}\n\nstatic SDL_INLINE int\nadd_output_device(const char *name, void *handle)\n{\n    return add_audio_device(name, handle, &current_audio.outputDevices, &current_audio.outputDeviceCount);\n}\n\nstatic void\nfree_device_list(SDL_AudioDeviceItem **devices, int *devCount)\n{\n    SDL_AudioDeviceItem *item, *next;\n    for (item = *devices; item != NULL; item = next) {\n        next = item->next;\n        if (item->handle != NULL) {\n            current_audio.impl.FreeDeviceHandle(item->handle);\n        }\n        SDL_free(item);\n    }\n    *devices = NULL;\n    *devCount = 0;\n}\n\n\n/* The audio backends call this when a new device is plugged in. */\nvoid\nSDL_AddAudioDevice(const int iscapture, const char *name, void *handle)\n{\n    const int device_index = iscapture ? add_capture_device(name, handle) : add_output_device(name, handle);\n    if (device_index != -1) {\n        /* Post the event, if desired */\n        if (SDL_GetEventState(SDL_AUDIODEVICEADDED) == SDL_ENABLE) {\n            SDL_Event event;\n            SDL_zero(event);\n            event.adevice.type = SDL_AUDIODEVICEADDED;\n            event.adevice.which = device_index;\n            event.adevice.iscapture = iscapture;\n            SDL_PushEvent(&event);\n        }\n    }\n}\n\n/* The audio backends call this when a currently-opened device is lost. */\nvoid SDL_OpenedAudioDeviceDisconnected(SDL_AudioDevice *device)\n{\n    SDL_assert(get_audio_device(device->id) == device);\n\n    if (!device->enabled) {\n        return;\n    }\n\n    /* Ends the audio callback and mark the device as STOPPED, but the\n       app still needs to close the device to free resources. */\n    current_audio.impl.LockDevice(device);\n    device->enabled = 0;\n    current_audio.impl.UnlockDevice(device);\n\n    /* Post the event, if desired */\n    if (SDL_GetEventState(SDL_AUDIODEVICEREMOVED) == SDL_ENABLE) {\n        SDL_Event event;\n        SDL_zero(event);\n        event.adevice.type = SDL_AUDIODEVICEREMOVED;\n        event.adevice.which = device->id;\n        event.adevice.iscapture = device->iscapture ? 1 : 0;\n        SDL_PushEvent(&event);\n    }\n}\n\nstatic void\nmark_device_removed(void *handle, SDL_AudioDeviceItem *devices, SDL_bool *removedFlag)\n{\n    SDL_AudioDeviceItem *item;\n    SDL_assert(handle != NULL);\n    for (item = devices; item != NULL; item = item->next) {\n        if (item->handle == handle) {\n            item->handle = NULL;\n            *removedFlag = SDL_TRUE;\n            return;\n        }\n    }\n}\n\n/* The audio backends call this when a device is removed from the system. */\nvoid\nSDL_RemoveAudioDevice(const int iscapture, void *handle)\n{\n    SDL_LockMutex(current_audio.detectionLock);\n    if (iscapture) {\n        mark_device_removed(handle, current_audio.inputDevices, &current_audio.captureDevicesRemoved);\n    } else {\n        mark_device_removed(handle, current_audio.outputDevices, &current_audio.outputDevicesRemoved);\n    }\n    SDL_UnlockMutex(current_audio.detectionLock);\n    current_audio.impl.FreeDeviceHandle(handle);\n}\n\n\n\n/* buffer queueing support... */\n\n/* this expects that you managed thread safety elsewhere. */\nstatic void\nfree_audio_queue(SDL_AudioBufferQueue *buffer)\n{\n    while (buffer) {\n        SDL_AudioBufferQueue *next = buffer->next;\n        SDL_free(buffer);\n        buffer = next;\n    }\n}\n\nstatic void SDLCALL\nSDL_BufferQueueDrainCallback(void *userdata, Uint8 *stream, int _len)\n{\n    /* this function always holds the mixer lock before being called. */\n    Uint32 len = (Uint32) _len;\n    SDL_AudioDevice *device = (SDL_AudioDevice *) userdata;\n    SDL_AudioBufferQueue *buffer;\n\n    SDL_assert(device != NULL);  /* this shouldn't ever happen, right?! */\n    SDL_assert(_len >= 0);  /* this shouldn't ever happen, right?! */\n\n    while ((len > 0) && ((buffer = device->buffer_queue_head) != NULL)) {\n        const Uint32 avail = buffer->datalen - buffer->startpos;\n        const Uint32 cpy = SDL_min(len, avail);\n        SDL_assert(device->queued_bytes >= avail);\n\n        SDL_memcpy(stream, buffer->data + buffer->startpos, cpy);\n        buffer->startpos += cpy;\n        stream += cpy;\n        device->queued_bytes -= cpy;\n        len -= cpy;\n\n        if (buffer->startpos == buffer->datalen) {  /* packet is done, put it in the pool. */\n            device->buffer_queue_head = buffer->next;\n            SDL_assert((buffer->next != NULL) || (buffer == device->buffer_queue_tail));\n            buffer->next = device->buffer_queue_pool;\n            device->buffer_queue_pool = buffer;\n        }\n    }\n\n    SDL_assert((device->buffer_queue_head != NULL) == (device->queued_bytes != 0));\n\n    if (len > 0) {  /* fill any remaining space in the stream with silence. */\n        SDL_assert(device->buffer_queue_head == NULL);\n        SDL_memset(stream, device->spec.silence, len);\n    }\n\n    if (device->buffer_queue_head == NULL) {\n        device->buffer_queue_tail = NULL;  /* in case we drained the queue entirely. */\n    }\n}\n\nint\nSDL_QueueAudio(SDL_AudioDeviceID devid, const void *_data, Uint32 len)\n{\n    SDL_AudioDevice *device = get_audio_device(devid);\n    const Uint8 *data = (const Uint8 *) _data;\n    SDL_AudioBufferQueue *orighead;\n    SDL_AudioBufferQueue *origtail;\n    Uint32 origlen;\n    Uint32 datalen;\n\n    if (!device) {\n        return -1;  /* get_audio_device() will have set the error state */\n    }\n\n    if (device->spec.callback != SDL_BufferQueueDrainCallback) {\n        return SDL_SetError(\"Audio device has a callback, queueing not allowed\");\n    }\n\n    current_audio.impl.LockDevice(device);\n\n    orighead = device->buffer_queue_head;\n    origtail = device->buffer_queue_tail;\n    origlen = origtail ? origtail->datalen : 0;\n\n    while (len > 0) {\n        SDL_AudioBufferQueue *packet = device->buffer_queue_tail;\n        SDL_assert(!packet || (packet->datalen <= SDL_AUDIOBUFFERQUEUE_PACKETLEN));\n        if (!packet || (packet->datalen >= SDL_AUDIOBUFFERQUEUE_PACKETLEN)) {\n            /* tail packet missing or completely full; we need a new packet. */\n            packet = device->buffer_queue_pool;\n            if (packet != NULL) {\n                /* we have one available in the pool. */\n                device->buffer_queue_pool = packet->next;\n            } else {\n                /* Have to allocate a new one! */\n                packet = (SDL_AudioBufferQueue *) SDL_malloc(sizeof (SDL_AudioBufferQueue));\n                if (packet == NULL) {\n                    /* uhoh, reset so we've queued nothing new, free what we can. */\n                    if (!origtail) {\n                        packet = device->buffer_queue_head;  /* whole queue. */\n                    } else {\n                        packet = origtail->next;  /* what we added to existing queue. */\n                        origtail->next = NULL;\n                        origtail->datalen = origlen;\n                    }\n                    device->buffer_queue_head = orighead;\n                    device->buffer_queue_tail = origtail;\n                    device->buffer_queue_pool = NULL;\n\n                    current_audio.impl.UnlockDevice(device);\n\n                    free_audio_queue(packet);  /* give back what we can. */\n\n                    return SDL_OutOfMemory();\n                }\n            }\n            packet->datalen = 0;\n            packet->startpos = 0;\n            packet->next = NULL;\n\n            SDL_assert((device->buffer_queue_head != NULL) == (device->queued_bytes != 0));\n            if (device->buffer_queue_tail == NULL) {\n                device->buffer_queue_head = packet;\n            } else {\n                device->buffer_queue_tail->next = packet;\n            }\n            device->buffer_queue_tail = packet;\n        }\n\n        datalen = SDL_min(len, SDL_AUDIOBUFFERQUEUE_PACKETLEN - packet->datalen);\n        SDL_memcpy(packet->data + packet->datalen, data, datalen);\n        data += datalen;\n        len -= datalen;\n        packet->datalen += datalen;\n        device->queued_bytes += datalen;\n    }\n\n    current_audio.impl.UnlockDevice(device);\n\n    return 0;\n}\n\nUint32\nSDL_GetQueuedAudioSize(SDL_AudioDeviceID devid)\n{\n    Uint32 retval = 0;\n    SDL_AudioDevice *device = get_audio_device(devid);\n\n    /* Nothing to do unless we're set up for queueing. */\n    if (device && (device->spec.callback == SDL_BufferQueueDrainCallback)) {\n        current_audio.impl.LockDevice(device);\n        retval = device->queued_bytes + current_audio.impl.GetPendingBytes(device);\n        current_audio.impl.UnlockDevice(device);\n    }\n\n    return retval;\n}\n\nvoid\nSDL_ClearQueuedAudio(SDL_AudioDeviceID devid)\n{\n    SDL_AudioDevice *device = get_audio_device(devid);\n    SDL_AudioBufferQueue *buffer = NULL;\n    if (!device) {\n        return;  /* nothing to do. */\n    }\n\n    /* Blank out the device and release the mutex. Free it afterwards. */\n    current_audio.impl.LockDevice(device);\n    buffer = device->buffer_queue_head;\n    device->buffer_queue_tail = NULL;\n    device->buffer_queue_head = NULL;\n    device->queued_bytes = 0;\n    current_audio.impl.UnlockDevice(device);\n\n    free_audio_queue(buffer);\n}\n\n\n#if defined(__ANDROID__)\n#include <android/log.h>\n#endif\n\n/* The general mixing thread function */\nint SDLCALL\nSDL_RunAudio(void *devicep)\n{\n    SDL_AudioDevice *device = (SDL_AudioDevice *) devicep;\n    const int silence = (int) device->spec.silence;\n    const Uint32 delay = ((device->spec.samples * 1000) / device->spec.freq);\n    const int stream_len = (device->convert.needed) ? device->convert.len : device->spec.size;\n    Uint8 *stream;\n    void *udata = device->spec.userdata;\n    void (SDLCALL *fill) (void *, Uint8 *, int) = device->spec.callback;\n\n    /* The audio mixing is always a high priority thread */\n    SDL_SetThreadPriority(SDL_THREAD_PRIORITY_HIGH);\n\n    /* Perform any thread setup */\n    device->threadid = SDL_ThreadID();\n    current_audio.impl.ThreadInit(device);\n\n    /* Loop, filling the audio buffers */\n    while (!device->shutdown) {\n        /* Fill the current buffer with sound */\n        if (device->convert.needed) {\n            stream = device->convert.buf;\n        } else if (device->enabled) {\n            stream = current_audio.impl.GetDeviceBuf(device);\n        } else {\n            /* if the device isn't enabled, we still write to the\n               fake_stream, so the app's callback will fire with\n               a regular frequency, in case they depend on that\n               for timing or progress. They can use hotplug\n               now to know if the device failed. */\n            stream = NULL;\n        }\n\n        if (stream == NULL) {\n            stream = device->fake_stream;\n        }\n\n        /* !!! FIXME: this should be LockDevice. */\n        SDL_LockMutex(device->mixer_lock);\n        if (device->paused) {\n            SDL_memset(stream, silence, stream_len);\n        } else {\n            (*fill) (udata, stream, stream_len);\n        }\n        SDL_UnlockMutex(device->mixer_lock);\n\n        /* Convert the audio if necessary */\n        if (device->enabled && device->convert.needed) {\n            SDL_ConvertAudio(&device->convert);\n            stream = current_audio.impl.GetDeviceBuf(device);\n            if (stream == NULL) {\n                stream = device->fake_stream;\n            } else {\n                SDL_memcpy(stream, device->convert.buf,\n                           device->convert.len_cvt);\n            }\n        }\n\n        /* Ready current buffer for play and change current buffer */\n        if (stream == device->fake_stream) {\n            SDL_Delay(delay);\n        } else {\n            current_audio.impl.PlayDevice(device);\n            current_audio.impl.WaitDevice(device);\n        }\n    }\n\n    /* Wait for the audio to drain. */\n    current_audio.impl.WaitDone(device);\n\n    return 0;\n}\n\n\nstatic SDL_AudioFormat\nSDL_ParseAudioFormat(const char *string)\n{\n#define CHECK_FMT_STRING(x) if (SDL_strcmp(string, #x) == 0) return AUDIO_##x\n    CHECK_FMT_STRING(U8);\n    CHECK_FMT_STRING(S8);\n    CHECK_FMT_STRING(U16LSB);\n    CHECK_FMT_STRING(S16LSB);\n    CHECK_FMT_STRING(U16MSB);\n    CHECK_FMT_STRING(S16MSB);\n    CHECK_FMT_STRING(U16SYS);\n    CHECK_FMT_STRING(S16SYS);\n    CHECK_FMT_STRING(U16);\n    CHECK_FMT_STRING(S16);\n    CHECK_FMT_STRING(S32LSB);\n    CHECK_FMT_STRING(S32MSB);\n    CHECK_FMT_STRING(S32SYS);\n    CHECK_FMT_STRING(S32);\n    CHECK_FMT_STRING(F32LSB);\n    CHECK_FMT_STRING(F32MSB);\n    CHECK_FMT_STRING(F32SYS);\n    CHECK_FMT_STRING(F32);\n#undef CHECK_FMT_STRING\n    return 0;\n}\n\nint\nSDL_GetNumAudioDrivers(void)\n{\n    return SDL_arraysize(bootstrap) - 1;\n}\n\nconst char *\nSDL_GetAudioDriver(int index)\n{\n    if (index >= 0 && index < SDL_GetNumAudioDrivers()) {\n        return bootstrap[index]->name;\n    }\n    return NULL;\n}\n\nint\nSDL_AudioInit(const char *driver_name)\n{\n    int i = 0;\n    int initialized = 0;\n    int tried_to_init = 0;\n\n    if (SDL_WasInit(SDL_INIT_AUDIO)) {\n        SDL_AudioQuit();        /* shutdown driver if already running. */\n    }\n\n    SDL_zero(current_audio);\n    SDL_zero(open_devices);\n\n    /* Select the proper audio driver */\n    if (driver_name == NULL) {\n        driver_name = SDL_getenv(\"SDL_AUDIODRIVER\");\n    }\n\n    for (i = 0; (!initialized) && (bootstrap[i]); ++i) {\n        /* make sure we should even try this driver before doing so... */\n        const AudioBootStrap *backend = bootstrap[i];\n        if ((driver_name && (SDL_strncasecmp(backend->name, driver_name, SDL_strlen(driver_name)) != 0)) ||\n            (!driver_name && backend->demand_only)) {\n            continue;\n        }\n\n        tried_to_init = 1;\n        SDL_zero(current_audio);\n        current_audio.name = backend->name;\n        current_audio.desc = backend->desc;\n        initialized = backend->init(&current_audio.impl);\n    }\n\n    if (!initialized) {\n        /* specific drivers will set the error message if they fail... */\n        if (!tried_to_init) {\n            if (driver_name) {\n                SDL_SetError(\"Audio target '%s' not available\", driver_name);\n            } else {\n                SDL_SetError(\"No available audio device\");\n            }\n        }\n\n        SDL_zero(current_audio);\n        return -1;            /* No driver was available, so fail. */\n    }\n\n    current_audio.detectionLock = SDL_CreateMutex();\n\n    finalize_audio_entry_points();\n\n    /* Make sure we have a list of devices available at startup. */\n    current_audio.impl.DetectDevices();\n\n    return 0;\n}\n\n/*\n * Get the current audio driver name\n */\nconst char *\nSDL_GetCurrentAudioDriver()\n{\n    return current_audio.name;\n}\n\n/* Clean out devices that we've removed but had to keep around for stability. */\nstatic void\nclean_out_device_list(SDL_AudioDeviceItem **devices, int *devCount, SDL_bool *removedFlag)\n{\n    SDL_AudioDeviceItem *item = *devices;\n    SDL_AudioDeviceItem *prev = NULL;\n    int total = 0;\n\n    while (item) {\n        SDL_AudioDeviceItem *next = item->next;\n        if (item->handle != NULL) {\n            total++;\n            prev = item;\n        } else {\n            if (prev) {\n                prev->next = next;\n            } else {\n                *devices = next;\n            }\n            SDL_free(item);\n        }\n        item = next;\n    }\n\n    *devCount = total;\n    *removedFlag = SDL_FALSE;\n}\n\n\nint\nSDL_GetNumAudioDevices(int iscapture)\n{\n    int retval = 0;\n\n    if (!SDL_WasInit(SDL_INIT_AUDIO)) {\n        return -1;\n    }\n\n    SDL_LockMutex(current_audio.detectionLock);\n    if (iscapture && current_audio.captureDevicesRemoved) {\n        clean_out_device_list(&current_audio.inputDevices, &current_audio.inputDeviceCount, &current_audio.captureDevicesRemoved);\n    }\n\n    if (!iscapture && current_audio.outputDevicesRemoved) {\n        clean_out_device_list(&current_audio.outputDevices, &current_audio.outputDeviceCount, &current_audio.outputDevicesRemoved);\n        current_audio.outputDevicesRemoved = SDL_FALSE;\n    }\n\n    retval = iscapture ? current_audio.inputDeviceCount : current_audio.outputDeviceCount;\n    SDL_UnlockMutex(current_audio.detectionLock);\n\n    return retval;\n}\n\n\nconst char *\nSDL_GetAudioDeviceName(int index, int iscapture)\n{\n    const char *retval = NULL;\n\n    if (!SDL_WasInit(SDL_INIT_AUDIO)) {\n        SDL_SetError(\"Audio subsystem is not initialized\");\n        return NULL;\n    }\n\n    if ((iscapture) && (!current_audio.impl.HasCaptureSupport)) {\n        SDL_SetError(\"No capture support\");\n        return NULL;\n    }\n\n    if (index >= 0) {\n        SDL_AudioDeviceItem *item;\n        int i;\n\n        SDL_LockMutex(current_audio.detectionLock);\n        item = iscapture ? current_audio.inputDevices : current_audio.outputDevices;\n        i = iscapture ? current_audio.inputDeviceCount : current_audio.outputDeviceCount;\n        if (index < i) {\n            for (i--; i > index; i--, item = item->next) {\n                SDL_assert(item != NULL);\n            }\n            SDL_assert(item != NULL);\n            retval = item->name;\n        }\n        SDL_UnlockMutex(current_audio.detectionLock);\n    }\n\n    if (retval == NULL) {\n        SDL_SetError(\"No such device\");\n    }\n\n    return retval;\n}\n\n\nstatic void\nclose_audio_device(SDL_AudioDevice * device)\n{\n    device->enabled = 0;\n    device->shutdown = 1;\n    if (device->thread != NULL) {\n        SDL_WaitThread(device->thread, NULL);\n    }\n    if (device->mixer_lock != NULL) {\n        SDL_DestroyMutex(device->mixer_lock);\n    }\n    SDL_FreeAudioMem(device->fake_stream);\n    if (device->convert.needed) {\n        SDL_FreeAudioMem(device->convert.buf);\n    }\n    if (device->opened) {\n        current_audio.impl.CloseDevice(device);\n        device->opened = 0;\n    }\n\n    free_audio_queue(device->buffer_queue_head);\n    free_audio_queue(device->buffer_queue_pool);\n\n    SDL_FreeAudioMem(device);\n}\n\n\n/*\n * Sanity check desired AudioSpec for SDL_OpenAudio() in (orig).\n *  Fills in a sanitized copy in (prepared).\n *  Returns non-zero if okay, zero on fatal parameters in (orig).\n */\nstatic int\nprepare_audiospec(const SDL_AudioSpec * orig, SDL_AudioSpec * prepared)\n{\n    SDL_memcpy(prepared, orig, sizeof(SDL_AudioSpec));\n\n    if (orig->freq == 0) {\n        const char *env = SDL_getenv(\"SDL_AUDIO_FREQUENCY\");\n        if ((!env) || ((prepared->freq = SDL_atoi(env)) == 0)) {\n            prepared->freq = 22050;     /* a reasonable default */\n        }\n    }\n\n    if (orig->format == 0) {\n        const char *env = SDL_getenv(\"SDL_AUDIO_FORMAT\");\n        if ((!env) || ((prepared->format = SDL_ParseAudioFormat(env)) == 0)) {\n            prepared->format = AUDIO_S16;       /* a reasonable default */\n        }\n    }\n\n    switch (orig->channels) {\n    case 0:{\n            const char *env = SDL_getenv(\"SDL_AUDIO_CHANNELS\");\n            if ((!env) || ((prepared->channels = (Uint8) SDL_atoi(env)) == 0)) {\n                prepared->channels = 2; /* a reasonable default */\n            }\n            break;\n        }\n    case 1:                    /* Mono */\n    case 2:                    /* Stereo */\n    case 4:                    /* surround */\n    case 6:                    /* surround with center and lfe */\n        break;\n    default:\n        SDL_SetError(\"Unsupported number of audio channels.\");\n        return 0;\n    }\n\n    if (orig->samples == 0) {\n        const char *env = SDL_getenv(\"SDL_AUDIO_SAMPLES\");\n        if ((!env) || ((prepared->samples = (Uint16) SDL_atoi(env)) == 0)) {\n            /* Pick a default of ~46 ms at desired frequency */\n            /* !!! FIXME: remove this when the non-Po2 resampling is in. */\n            const int samples = (prepared->freq / 1000) * 46;\n            int power2 = 1;\n            while (power2 < samples) {\n                power2 *= 2;\n            }\n            prepared->samples = power2;\n        }\n    }\n\n    /* Calculate the silence and size of the audio specification */\n    SDL_CalculateAudioSpec(prepared);\n\n    return 1;\n}\n\nstatic SDL_AudioDeviceID\nopen_audio_device(const char *devname, int iscapture,\n                  const SDL_AudioSpec * desired, SDL_AudioSpec * obtained,\n                  int allowed_changes, int min_id)\n{\n    SDL_AudioDeviceID id = 0;\n    SDL_AudioSpec _obtained;\n    SDL_AudioDevice *device;\n    SDL_bool build_cvt;\n    void *handle = NULL;\n    Uint32 stream_len;\n    int i = 0;\n\n    if (!SDL_WasInit(SDL_INIT_AUDIO)) {\n        SDL_SetError(\"Audio subsystem is not initialized\");\n        return 0;\n    }\n\n    if ((iscapture) && (!current_audio.impl.HasCaptureSupport)) {\n        SDL_SetError(\"No capture support\");\n        return 0;\n    }\n\n    /* Find an available device ID... */\n    for (id = min_id - 1; id < SDL_arraysize(open_devices); id++) {\n        if (open_devices[id] == NULL) {\n            break;\n        }\n    }\n\n    if (id == SDL_arraysize(open_devices)) {\n        SDL_SetError(\"Too many open audio devices\");\n        return 0;\n    }\n\n    if (!obtained) {\n        obtained = &_obtained;\n    }\n    if (!prepare_audiospec(desired, obtained)) {\n        return 0;\n    }\n\n    /* If app doesn't care about a specific device, let the user override. */\n    if (devname == NULL) {\n        devname = SDL_getenv(\"SDL_AUDIO_DEVICE_NAME\");\n    }\n\n    /*\n     * Catch device names at the high level for the simple case...\n     * This lets us have a basic \"device enumeration\" for systems that\n     *  don't have multiple devices, but makes sure the device name is\n     *  always NULL when it hits the low level.\n     *\n     * Also make sure that the simple case prevents multiple simultaneous\n     *  opens of the default system device.\n     */\n\n    if ((iscapture) && (current_audio.impl.OnlyHasDefaultInputDevice)) {\n        if ((devname) && (SDL_strcmp(devname, DEFAULT_INPUT_DEVNAME) != 0)) {\n            SDL_SetError(\"No such device\");\n            return 0;\n        }\n        devname = NULL;\n\n        for (i = 0; i < SDL_arraysize(open_devices); i++) {\n            if ((open_devices[i]) && (open_devices[i]->iscapture)) {\n                SDL_SetError(\"Audio device already open\");\n                return 0;\n            }\n        }\n    } else if ((!iscapture) && (current_audio.impl.OnlyHasDefaultOutputDevice)) {\n        if ((devname) && (SDL_strcmp(devname, DEFAULT_OUTPUT_DEVNAME) != 0)) {\n            SDL_SetError(\"No such device\");\n            return 0;\n        }\n        devname = NULL;\n\n        for (i = 0; i < SDL_arraysize(open_devices); i++) {\n            if ((open_devices[i]) && (!open_devices[i]->iscapture)) {\n                SDL_SetError(\"Audio device already open\");\n                return 0;\n            }\n        }\n    } else if (devname != NULL) {\n        /* if the app specifies an exact string, we can pass the backend\n           an actual device handle thingey, which saves them the effort of\n           figuring out what device this was (such as, reenumerating\n           everything again to find the matching human-readable name).\n           It might still need to open a device based on the string for,\n           say, a network audio server, but this optimizes some cases. */\n        SDL_AudioDeviceItem *item;\n        SDL_LockMutex(current_audio.detectionLock);\n        for (item = iscapture ? current_audio.inputDevices : current_audio.outputDevices; item; item = item->next) {\n            if ((item->handle != NULL) && (SDL_strcmp(item->name, devname) == 0)) {\n                handle = item->handle;\n                break;\n            }\n        }\n        SDL_UnlockMutex(current_audio.detectionLock);\n    }\n\n    if (!current_audio.impl.AllowsArbitraryDeviceNames) {\n        /* has to be in our device list, or the default device. */\n        if ((handle == NULL) && (devname != NULL)) {\n            SDL_SetError(\"No such device.\");\n            return 0;\n        }\n    }\n\n    device = (SDL_AudioDevice *) SDL_AllocAudioMem(sizeof(SDL_AudioDevice));\n    if (device == NULL) {\n        SDL_OutOfMemory();\n        return 0;\n    }\n    SDL_zerop(device);\n    device->id = id + 1;\n    device->spec = *obtained;\n    device->enabled = 1;\n    device->paused = 1;\n    device->iscapture = iscapture;\n\n    /* Create a mutex for locking the sound buffers */\n    if (!current_audio.impl.SkipMixerLock) {\n        device->mixer_lock = SDL_CreateMutex();\n        if (device->mixer_lock == NULL) {\n            close_audio_device(device);\n            SDL_SetError(\"Couldn't create mixer lock\");\n            return 0;\n        }\n    }\n\n    if (current_audio.impl.OpenDevice(device, handle, devname, iscapture) < 0) {\n        close_audio_device(device);\n        return 0;\n    }\n    device->opened = 1;\n\n    /* See if we need to do any conversion */\n    build_cvt = SDL_FALSE;\n    if (obtained->freq != device->spec.freq) {\n        if (allowed_changes & SDL_AUDIO_ALLOW_FREQUENCY_CHANGE) {\n            obtained->freq = device->spec.freq;\n        } else {\n            build_cvt = SDL_TRUE;\n        }\n    }\n    if (obtained->format != device->spec.format) {\n        if (allowed_changes & SDL_AUDIO_ALLOW_FORMAT_CHANGE) {\n            obtained->format = device->spec.format;\n        } else {\n            build_cvt = SDL_TRUE;\n        }\n    }\n    if (obtained->channels != device->spec.channels) {\n        if (allowed_changes & SDL_AUDIO_ALLOW_CHANNELS_CHANGE) {\n            obtained->channels = device->spec.channels;\n        } else {\n            build_cvt = SDL_TRUE;\n        }\n    }\n\n    /* If the audio driver changes the buffer size, accept it.\n       This needs to be done after the format is modified above,\n       otherwise it might not have the correct buffer size.\n     */\n    if (device->spec.samples != obtained->samples) {\n        obtained->samples = device->spec.samples;\n        SDL_CalculateAudioSpec(obtained);\n    }\n\n    if (build_cvt) {\n        /* Build an audio conversion block */\n        if (SDL_BuildAudioCVT(&device->convert,\n                              obtained->format, obtained->channels,\n                              obtained->freq,\n                              device->spec.format, device->spec.channels,\n                              device->spec.freq) < 0) {\n            close_audio_device(device);\n            return 0;\n        }\n        if (device->convert.needed) {\n            device->convert.len = (int) (((double) device->spec.size) /\n                                         device->convert.len_ratio);\n\n            device->convert.buf =\n                (Uint8 *) SDL_AllocAudioMem(device->convert.len *\n                                            device->convert.len_mult);\n            if (device->convert.buf == NULL) {\n                close_audio_device(device);\n                SDL_OutOfMemory();\n                return 0;\n            }\n        }\n    }\n\n    /* Allocate a fake audio memory buffer */\n    stream_len = (device->convert.needed) ? device->convert.len_cvt : 0;\n    if (device->spec.size > stream_len) {\n        stream_len = device->spec.size;\n    }\n    SDL_assert(stream_len > 0);\n    device->fake_stream = (Uint8 *)SDL_AllocAudioMem(stream_len);\n    if (device->fake_stream == NULL) {\n        close_audio_device(device);\n        SDL_OutOfMemory();\n        return 0;\n    }\n\n    if (device->spec.callback == NULL) {  /* use buffer queueing? */\n        /* pool a few packets to start. Enough for two callbacks. */\n        const int packetlen = SDL_AUDIOBUFFERQUEUE_PACKETLEN;\n        const int wantbytes = ((device->convert.needed) ? device->convert.len : device->spec.size) * 2;\n        const int wantpackets = (wantbytes / packetlen) + ((wantbytes % packetlen) ? packetlen : 0);\n        for (i = 0; i < wantpackets; i++) {\n            SDL_AudioBufferQueue *packet = (SDL_AudioBufferQueue *) SDL_malloc(sizeof (SDL_AudioBufferQueue));\n            if (packet) { /* don't care if this fails, we'll deal later. */\n                packet->datalen = 0;\n                packet->startpos = 0;\n                packet->next = device->buffer_queue_pool;\n                device->buffer_queue_pool = packet;\n            }\n        }\n\n        device->spec.callback = SDL_BufferQueueDrainCallback;\n        device->spec.userdata = device;\n    }\n\n    /* add it to our list of open devices. */\n    open_devices[id] = device;\n\n    /* Start the audio thread if necessary */\n    if (!current_audio.impl.ProvidesOwnCallbackThread) {\n        /* Start the audio thread */\n        char name[64];\n        SDL_snprintf(name, sizeof (name), \"SDLAudioDev%d\", (int) device->id);\n/* !!! FIXME: this is nasty. */\n#if defined(__WIN32__) && !defined(HAVE_LIBC)\n#undef SDL_CreateThread\n#if SDL_DYNAMIC_API\n        device->thread = SDL_CreateThread_REAL(SDL_RunAudio, name, device, NULL, NULL);\n#else\n        device->thread = SDL_CreateThread(SDL_RunAudio, name, device, NULL, NULL);\n#endif\n#else\n        device->thread = SDL_CreateThread(SDL_RunAudio, name, device);\n#endif\n        if (device->thread == NULL) {\n            SDL_CloseAudioDevice(device->id);\n            SDL_SetError(\"Couldn't create audio thread\");\n            return 0;\n        }\n    }\n\n    return device->id;\n}\n\n\nint\nSDL_OpenAudio(SDL_AudioSpec * desired, SDL_AudioSpec * obtained)\n{\n    SDL_AudioDeviceID id = 0;\n\n    /* Start up the audio driver, if necessary. This is legacy behaviour! */\n    if (!SDL_WasInit(SDL_INIT_AUDIO)) {\n        if (SDL_InitSubSystem(SDL_INIT_AUDIO) < 0) {\n            return -1;\n        }\n    }\n\n    /* SDL_OpenAudio() is legacy and can only act on Device ID #1. */\n    if (open_devices[0] != NULL) {\n        SDL_SetError(\"Audio device is already opened\");\n        return -1;\n    }\n\n    if (obtained) {\n        id = open_audio_device(NULL, 0, desired, obtained,\n                               SDL_AUDIO_ALLOW_ANY_CHANGE, 1);\n    } else {\n        id = open_audio_device(NULL, 0, desired, NULL, 0, 1);\n    }\n\n    SDL_assert((id == 0) || (id == 1));\n    return (id == 0) ? -1 : 0;\n}\n\nSDL_AudioDeviceID\nSDL_OpenAudioDevice(const char *device, int iscapture,\n                    const SDL_AudioSpec * desired, SDL_AudioSpec * obtained,\n                    int allowed_changes)\n{\n    return open_audio_device(device, iscapture, desired, obtained,\n                             allowed_changes, 2);\n}\n\nSDL_AudioStatus\nSDL_GetAudioDeviceStatus(SDL_AudioDeviceID devid)\n{\n    SDL_AudioDevice *device = get_audio_device(devid);\n    SDL_AudioStatus status = SDL_AUDIO_STOPPED;\n    if (device && device->enabled) {\n        if (device->paused) {\n            status = SDL_AUDIO_PAUSED;\n        } else {\n            status = SDL_AUDIO_PLAYING;\n        }\n    }\n    return status;\n}\n\n\nSDL_AudioStatus\nSDL_GetAudioStatus(void)\n{\n    return SDL_GetAudioDeviceStatus(1);\n}\n\nvoid\nSDL_PauseAudioDevice(SDL_AudioDeviceID devid, int pause_on)\n{\n    SDL_AudioDevice *device = get_audio_device(devid);\n    if (device) {\n        current_audio.impl.LockDevice(device);\n        device->paused = pause_on;\n        current_audio.impl.UnlockDevice(device);\n    }\n}\n\nvoid\nSDL_PauseAudio(int pause_on)\n{\n    SDL_PauseAudioDevice(1, pause_on);\n}\n\n\nvoid\nSDL_LockAudioDevice(SDL_AudioDeviceID devid)\n{\n    /* Obtain a lock on the mixing buffers */\n    SDL_AudioDevice *device = get_audio_device(devid);\n    if (device) {\n        current_audio.impl.LockDevice(device);\n    }\n}\n\nvoid\nSDL_LockAudio(void)\n{\n    SDL_LockAudioDevice(1);\n}\n\nvoid\nSDL_UnlockAudioDevice(SDL_AudioDeviceID devid)\n{\n    /* Obtain a lock on the mixing buffers */\n    SDL_AudioDevice *device = get_audio_device(devid);\n    if (device) {\n        current_audio.impl.UnlockDevice(device);\n    }\n}\n\nvoid\nSDL_UnlockAudio(void)\n{\n    SDL_UnlockAudioDevice(1);\n}\n\nvoid\nSDL_CloseAudioDevice(SDL_AudioDeviceID devid)\n{\n    SDL_AudioDevice *device = get_audio_device(devid);\n    if (device) {\n        close_audio_device(device);\n        open_devices[devid - 1] = NULL;\n    }\n}\n\nvoid\nSDL_CloseAudio(void)\n{\n    SDL_CloseAudioDevice(1);\n}\n\nvoid\nSDL_AudioQuit(void)\n{\n    SDL_AudioDeviceID i;\n\n    if (!current_audio.name) {  /* not initialized?! */\n        return;\n    }\n\n    for (i = 0; i < SDL_arraysize(open_devices); i++) {\n        if (open_devices[i] != NULL) {\n            SDL_CloseAudioDevice(i+1);\n        }\n    }\n\n    free_device_list(&current_audio.outputDevices, &current_audio.outputDeviceCount);\n    free_device_list(&current_audio.inputDevices, &current_audio.inputDeviceCount);\n\n    /* Free the driver data */\n    current_audio.impl.Deinitialize();\n\n    SDL_DestroyMutex(current_audio.detectionLock);\n\n    SDL_zero(current_audio);\n    SDL_zero(open_devices);\n}\n\n#define NUM_FORMATS 10\nstatic int format_idx;\nstatic int format_idx_sub;\nstatic SDL_AudioFormat format_list[NUM_FORMATS][NUM_FORMATS] = {\n    {AUDIO_U8, AUDIO_S8, AUDIO_S16LSB, AUDIO_S16MSB, AUDIO_U16LSB,\n     AUDIO_U16MSB, AUDIO_S32LSB, AUDIO_S32MSB, AUDIO_F32LSB, AUDIO_F32MSB},\n    {AUDIO_S8, AUDIO_U8, AUDIO_S16LSB, AUDIO_S16MSB, AUDIO_U16LSB,\n     AUDIO_U16MSB, AUDIO_S32LSB, AUDIO_S32MSB, AUDIO_F32LSB, AUDIO_F32MSB},\n    {AUDIO_S16LSB, AUDIO_S16MSB, AUDIO_U16LSB, AUDIO_U16MSB, AUDIO_S32LSB,\n     AUDIO_S32MSB, AUDIO_F32LSB, AUDIO_F32MSB, AUDIO_U8, AUDIO_S8},\n    {AUDIO_S16MSB, AUDIO_S16LSB, AUDIO_U16MSB, AUDIO_U16LSB, AUDIO_S32MSB,\n     AUDIO_S32LSB, AUDIO_F32MSB, AUDIO_F32LSB, AUDIO_U8, AUDIO_S8},\n    {AUDIO_U16LSB, AUDIO_U16MSB, AUDIO_S16LSB, AUDIO_S16MSB, AUDIO_S32LSB,\n     AUDIO_S32MSB, AUDIO_F32LSB, AUDIO_F32MSB, AUDIO_U8, AUDIO_S8},\n    {AUDIO_U16MSB, AUDIO_U16LSB, AUDIO_S16MSB, AUDIO_S16LSB, AUDIO_S32MSB,\n     AUDIO_S32LSB, AUDIO_F32MSB, AUDIO_F32LSB, AUDIO_U8, AUDIO_S8},\n    {AUDIO_S32LSB, AUDIO_S32MSB, AUDIO_F32LSB, AUDIO_F32MSB, AUDIO_S16LSB,\n     AUDIO_S16MSB, AUDIO_U16LSB, AUDIO_U16MSB, AUDIO_U8, AUDIO_S8},\n    {AUDIO_S32MSB, AUDIO_S32LSB, AUDIO_F32MSB, AUDIO_F32LSB, AUDIO_S16MSB,\n     AUDIO_S16LSB, AUDIO_U16MSB, AUDIO_U16LSB, AUDIO_U8, AUDIO_S8},\n    {AUDIO_F32LSB, AUDIO_F32MSB, AUDIO_S32LSB, AUDIO_S32MSB, AUDIO_S16LSB,\n     AUDIO_S16MSB, AUDIO_U16LSB, AUDIO_U16MSB, AUDIO_U8, AUDIO_S8},\n    {AUDIO_F32MSB, AUDIO_F32LSB, AUDIO_S32MSB, AUDIO_S32LSB, AUDIO_S16MSB,\n     AUDIO_S16LSB, AUDIO_U16MSB, AUDIO_U16LSB, AUDIO_U8, AUDIO_S8},\n};\n\nSDL_AudioFormat\nSDL_FirstAudioFormat(SDL_AudioFormat format)\n{\n    for (format_idx = 0; format_idx < NUM_FORMATS; ++format_idx) {\n        if (format_list[format_idx][0] == format) {\n            break;\n        }\n    }\n    format_idx_sub = 0;\n    return SDL_NextAudioFormat();\n}\n\nSDL_AudioFormat\nSDL_NextAudioFormat(void)\n{\n    if ((format_idx == NUM_FORMATS) || (format_idx_sub == NUM_FORMATS)) {\n        return 0;\n    }\n    return format_list[format_idx][format_idx_sub++];\n}\n\nvoid\nSDL_CalculateAudioSpec(SDL_AudioSpec * spec)\n{\n    switch (spec->format) {\n    case AUDIO_U8:\n        spec->silence = 0x80;\n        break;\n    default:\n        spec->silence = 0x00;\n        break;\n    }\n    spec->size = SDL_AUDIO_BITSIZE(spec->format) / 8;\n    spec->size *= spec->channels;\n    spec->size *= spec->samples;\n}\n\n\n/*\n * Moved here from SDL_mixer.c, since it relies on internals of an opened\n *  audio device (and is deprecated, by the way!).\n */\nvoid\nSDL_MixAudio(Uint8 * dst, const Uint8 * src, Uint32 len, int volume)\n{\n    /* Mix the user-level audio format */\n    SDL_AudioDevice *device = get_audio_device(1);\n    if (device != NULL) {\n        SDL_AudioFormat format;\n        if (device->convert.needed) {\n            format = device->convert.src_format;\n        } else {\n            format = device->spec.format;\n        }\n        SDL_MixAudioFormat(dst, src, format, len, volume);\n    }\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../SDL_internal.h\"\n\n/* Functions for audio drivers to perform runtime conversion of audio format */\n\n#include \"SDL_audio.h\"\n#include \"SDL_audio_c.h\"\n\n#include \"SDL_assert.h\"\n\n/* #define DEBUG_CONVERT */\n\n/* Effectively mix right and left channels into a single channel */\nstatic void SDLCALL\nSDL_ConvertMono(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    Sint32 sample;\n\n#ifdef DEBUG_CONVERT\n    fprintf(stderr, \"Converting to mono\\n\");\n#endif\n\tswitch (format & (SDL_AUDIO_MASK_SIGNED |\n                      SDL_AUDIO_MASK_BITSIZE |\n                      SDL_AUDIO_MASK_DATATYPE)) {\n    case AUDIO_U8:\n        {\n            Uint8 *src, *dst;\n\n            src = cvt->buf;\n            dst = cvt->buf;\n            for (i = cvt->len_cvt / 2; i; --i) {\n                sample = src[0] + src[1];\n                *dst = (Uint8) (sample / 2);\n                src += 2;\n                dst += 1;\n            }\n        }\n        break;\n\n    case AUDIO_S8:\n        {\n            Sint8 *src, *dst;\n\n            src = (Sint8 *) cvt->buf;\n            dst = (Sint8 *) cvt->buf;\n            for (i = cvt->len_cvt / 2; i; --i) {\n                sample = src[0] + src[1];\n                *dst = (Sint8) (sample / 2);\n                src += 2;\n                dst += 1;\n            }\n        }\n        break;\n\n    case AUDIO_U16:\n        {\n            Uint8 *src, *dst;\n\n            src = cvt->buf;\n            dst = cvt->buf;\n            if (SDL_AUDIO_ISBIGENDIAN(format)) {\n                for (i = cvt->len_cvt / 4; i; --i) {\n                    sample = (Uint16) ((src[0] << 8) | src[1]) +\n                        (Uint16) ((src[2] << 8) | src[3]);\n                    sample /= 2;\n                    dst[1] = (sample & 0xFF);\n                    sample >>= 8;\n                    dst[0] = (sample & 0xFF);\n                    src += 4;\n                    dst += 2;\n                }\n            } else {\n                for (i = cvt->len_cvt / 4; i; --i) {\n                    sample = (Uint16) ((src[1] << 8) | src[0]) +\n                        (Uint16) ((src[3] << 8) | src[2]);\n                    sample /= 2;\n                    dst[0] = (sample & 0xFF);\n                    sample >>= 8;\n                    dst[1] = (sample & 0xFF);\n                    src += 4;\n                    dst += 2;\n                }\n            }\n        }\n        break;\n\n    case AUDIO_S16:\n        {\n            Uint8 *src, *dst;\n\n            src = cvt->buf;\n            dst = cvt->buf;\n            if (SDL_AUDIO_ISBIGENDIAN(format)) {\n                for (i = cvt->len_cvt / 4; i; --i) {\n                    sample = (Sint16) ((src[0] << 8) | src[1]) +\n                        (Sint16) ((src[2] << 8) | src[3]);\n                    sample /= 2;\n                    dst[1] = (sample & 0xFF);\n                    sample >>= 8;\n                    dst[0] = (sample & 0xFF);\n                    src += 4;\n                    dst += 2;\n                }\n            } else {\n                for (i = cvt->len_cvt / 4; i; --i) {\n                    sample = (Sint16) ((src[1] << 8) | src[0]) +\n                        (Sint16) ((src[3] << 8) | src[2]);\n                    sample /= 2;\n                    dst[0] = (sample & 0xFF);\n                    sample >>= 8;\n                    dst[1] = (sample & 0xFF);\n                    src += 4;\n                    dst += 2;\n                }\n            }\n        }\n        break;\n\n    case AUDIO_S32:\n        {\n            const Uint32 *src = (const Uint32 *) cvt->buf;\n            Uint32 *dst = (Uint32 *) cvt->buf;\n            if (SDL_AUDIO_ISBIGENDIAN(format)) {\n                for (i = cvt->len_cvt / 8; i; --i, src += 2) {\n                    const Sint64 added =\n                        (((Sint64) (Sint32) SDL_SwapBE32(src[0])) +\n                         ((Sint64) (Sint32) SDL_SwapBE32(src[1])));\n                    *(dst++) = SDL_SwapBE32((Uint32) ((Sint32) (added / 2)));\n                }\n            } else {\n                for (i = cvt->len_cvt / 8; i; --i, src += 2) {\n                    const Sint64 added =\n                        (((Sint64) (Sint32) SDL_SwapLE32(src[0])) +\n                         ((Sint64) (Sint32) SDL_SwapLE32(src[1])));\n                    *(dst++) = SDL_SwapLE32((Uint32) ((Sint32) (added / 2)));\n                }\n            }\n        }\n        break;\n\n    case AUDIO_F32:\n        {\n            const float *src = (const float *) cvt->buf;\n            float *dst = (float *) cvt->buf;\n            if (SDL_AUDIO_ISBIGENDIAN(format)) {\n                for (i = cvt->len_cvt / 8; i; --i, src += 2) {\n                    const float src1 = SDL_SwapFloatBE(src[0]);\n                    const float src2 = SDL_SwapFloatBE(src[1]);\n                    const double added = ((double) src1) + ((double) src2);\n                    const float halved = (float) (added * 0.5);\n                    *(dst++) = SDL_SwapFloatBE(halved);\n                }\n            } else {\n                for (i = cvt->len_cvt / 8; i; --i, src += 2) {\n                    const float src1 = SDL_SwapFloatLE(src[0]);\n                    const float src2 = SDL_SwapFloatLE(src[1]);\n                    const double added = ((double) src1) + ((double) src2);\n                    const float halved = (float) (added * 0.5);\n                    *(dst++) = SDL_SwapFloatLE(halved);\n                }\n            }\n        }\n        break;\n    }\n\n    cvt->len_cvt /= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\n\n/* Discard top 4 channels */\nstatic void SDLCALL\nSDL_ConvertStrip(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n\n#ifdef DEBUG_CONVERT\n    fprintf(stderr, \"Converting down from 6 channels to stereo\\n\");\n#endif\n\n#define strip_chans_6_to_2(type) \\\n    { \\\n        const type *src = (const type *) cvt->buf; \\\n        type *dst = (type *) cvt->buf; \\\n        for (i = cvt->len_cvt / (sizeof (type) * 6); i; --i) { \\\n            dst[0] = src[0]; \\\n            dst[1] = src[1]; \\\n            src += 6; \\\n            dst += 2; \\\n        } \\\n    }\n\n    /* this function only cares about typesize, and data as a block of bits. */\n    switch (SDL_AUDIO_BITSIZE(format)) {\n    case 8:\n        strip_chans_6_to_2(Uint8);\n        break;\n    case 16:\n        strip_chans_6_to_2(Uint16);\n        break;\n    case 32:\n        strip_chans_6_to_2(Uint32);\n        break;\n    }\n\n#undef strip_chans_6_to_2\n\n    cvt->len_cvt /= 3;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\n\n/* Discard top 2 channels of 6 */\nstatic void SDLCALL\nSDL_ConvertStrip_2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n\n#ifdef DEBUG_CONVERT\n    fprintf(stderr, \"Converting 6 down to quad\\n\");\n#endif\n\n#define strip_chans_6_to_4(type) \\\n    { \\\n        const type *src = (const type *) cvt->buf; \\\n        type *dst = (type *) cvt->buf; \\\n        for (i = cvt->len_cvt / (sizeof (type) * 6); i; --i) { \\\n            dst[0] = src[0]; \\\n            dst[1] = src[1]; \\\n            dst[2] = src[2]; \\\n            dst[3] = src[3]; \\\n            src += 6; \\\n            dst += 4; \\\n        } \\\n    }\n\n    /* this function only cares about typesize, and data as a block of bits. */\n    switch (SDL_AUDIO_BITSIZE(format)) {\n    case 8:\n        strip_chans_6_to_4(Uint8);\n        break;\n    case 16:\n        strip_chans_6_to_4(Uint16);\n        break;\n    case 32:\n        strip_chans_6_to_4(Uint32);\n        break;\n    }\n\n#undef strip_chans_6_to_4\n\n    cvt->len_cvt /= 6;\n    cvt->len_cvt *= 4;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\n/* Duplicate a mono channel to both stereo channels */\nstatic void SDLCALL\nSDL_ConvertStereo(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n\n#ifdef DEBUG_CONVERT\n    fprintf(stderr, \"Converting to stereo\\n\");\n#endif\n\n#define dup_chans_1_to_2(type) \\\n    { \\\n        const type *src = (const type *) (cvt->buf + cvt->len_cvt); \\\n        type *dst = (type *) (cvt->buf + cvt->len_cvt * 2); \\\n        for (i = cvt->len_cvt / sizeof(type); i; --i) { \\\n            src -= 1; \\\n            dst -= 2; \\\n            dst[0] = dst[1] = *src; \\\n        } \\\n    }\n\n    /* this function only cares about typesize, and data as a block of bits. */\n    switch (SDL_AUDIO_BITSIZE(format)) {\n    case 8:\n        dup_chans_1_to_2(Uint8);\n        break;\n    case 16:\n        dup_chans_1_to_2(Uint16);\n        break;\n    case 32:\n        dup_chans_1_to_2(Uint32);\n        break;\n    }\n\n#undef dup_chans_1_to_2\n\n    cvt->len_cvt *= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\n\n/* Duplicate a stereo channel to a pseudo-5.1 stream */\nstatic void SDLCALL\nSDL_ConvertSurround(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n\n#ifdef DEBUG_CONVERT\n    fprintf(stderr, \"Converting stereo to surround\\n\");\n#endif\n\n    switch (format & (SDL_AUDIO_MASK_SIGNED  |\n                      SDL_AUDIO_MASK_BITSIZE |\n                      SDL_AUDIO_MASK_DATATYPE)) {\n    case AUDIO_U8:\n        {\n            Uint8 *src, *dst, lf, rf, ce;\n\n            src = (Uint8 *) (cvt->buf + cvt->len_cvt);\n            dst = (Uint8 *) (cvt->buf + cvt->len_cvt * 3);\n            for (i = cvt->len_cvt; i; --i) {\n                dst -= 6;\n                src -= 2;\n                lf = src[0];\n                rf = src[1];\n                ce = (lf / 2) + (rf / 2);\n                dst[0] = lf;\n                dst[1] = rf;\n                dst[2] = lf - ce;\n                dst[3] = rf - ce;\n                dst[4] = ce;\n                dst[5] = ce;\n            }\n        }\n        break;\n\n    case AUDIO_S8:\n        {\n            Sint8 *src, *dst, lf, rf, ce;\n\n            src = (Sint8 *) cvt->buf + cvt->len_cvt;\n            dst = (Sint8 *) cvt->buf + cvt->len_cvt * 3;\n            for (i = cvt->len_cvt; i; --i) {\n                dst -= 6;\n                src -= 2;\n                lf = src[0];\n                rf = src[1];\n                ce = (lf / 2) + (rf / 2);\n                dst[0] = lf;\n                dst[1] = rf;\n                dst[2] = lf - ce;\n                dst[3] = rf - ce;\n                dst[4] = ce;\n                dst[5] = ce;\n            }\n        }\n        break;\n\n    case AUDIO_U16:\n        {\n            Uint8 *src, *dst;\n            Uint16 lf, rf, ce, lr, rr;\n\n            src = cvt->buf + cvt->len_cvt;\n            dst = cvt->buf + cvt->len_cvt * 3;\n\n            if (SDL_AUDIO_ISBIGENDIAN(format)) {\n                for (i = cvt->len_cvt / 4; i; --i) {\n                    dst -= 12;\n                    src -= 4;\n                    lf = (Uint16) ((src[0] << 8) | src[1]);\n                    rf = (Uint16) ((src[2] << 8) | src[3]);\n                    ce = (lf / 2) + (rf / 2);\n                    rr = lf - ce;\n                    lr = rf - ce;\n                    dst[1] = (lf & 0xFF);\n                    dst[0] = ((lf >> 8) & 0xFF);\n                    dst[3] = (rf & 0xFF);\n                    dst[2] = ((rf >> 8) & 0xFF);\n\n                    dst[1 + 4] = (lr & 0xFF);\n                    dst[0 + 4] = ((lr >> 8) & 0xFF);\n                    dst[3 + 4] = (rr & 0xFF);\n                    dst[2 + 4] = ((rr >> 8) & 0xFF);\n\n                    dst[1 + 8] = (ce & 0xFF);\n                    dst[0 + 8] = ((ce >> 8) & 0xFF);\n                    dst[3 + 8] = (ce & 0xFF);\n                    dst[2 + 8] = ((ce >> 8) & 0xFF);\n                }\n            } else {\n                for (i = cvt->len_cvt / 4; i; --i) {\n                    dst -= 12;\n                    src -= 4;\n                    lf = (Uint16) ((src[1] << 8) | src[0]);\n                    rf = (Uint16) ((src[3] << 8) | src[2]);\n                    ce = (lf / 2) + (rf / 2);\n                    rr = lf - ce;\n                    lr = rf - ce;\n                    dst[0] = (lf & 0xFF);\n                    dst[1] = ((lf >> 8) & 0xFF);\n                    dst[2] = (rf & 0xFF);\n                    dst[3] = ((rf >> 8) & 0xFF);\n\n                    dst[0 + 4] = (lr & 0xFF);\n                    dst[1 + 4] = ((lr >> 8) & 0xFF);\n                    dst[2 + 4] = (rr & 0xFF);\n                    dst[3 + 4] = ((rr >> 8) & 0xFF);\n\n                    dst[0 + 8] = (ce & 0xFF);\n                    dst[1 + 8] = ((ce >> 8) & 0xFF);\n                    dst[2 + 8] = (ce & 0xFF);\n                    dst[3 + 8] = ((ce >> 8) & 0xFF);\n                }\n            }\n        }\n        break;\n\n    case AUDIO_S16:\n        {\n            Uint8 *src, *dst;\n            Sint16 lf, rf, ce, lr, rr;\n\n            src = cvt->buf + cvt->len_cvt;\n            dst = cvt->buf + cvt->len_cvt * 3;\n\n            if (SDL_AUDIO_ISBIGENDIAN(format)) {\n                for (i = cvt->len_cvt / 4; i; --i) {\n                    dst -= 12;\n                    src -= 4;\n                    lf = (Sint16) ((src[0] << 8) | src[1]);\n                    rf = (Sint16) ((src[2] << 8) | src[3]);\n                    ce = (lf / 2) + (rf / 2);\n                    rr = lf - ce;\n                    lr = rf - ce;\n                    dst[1] = (lf & 0xFF);\n                    dst[0] = ((lf >> 8) & 0xFF);\n                    dst[3] = (rf & 0xFF);\n                    dst[2] = ((rf >> 8) & 0xFF);\n\n                    dst[1 + 4] = (lr & 0xFF);\n                    dst[0 + 4] = ((lr >> 8) & 0xFF);\n                    dst[3 + 4] = (rr & 0xFF);\n                    dst[2 + 4] = ((rr >> 8) & 0xFF);\n\n                    dst[1 + 8] = (ce & 0xFF);\n                    dst[0 + 8] = ((ce >> 8) & 0xFF);\n                    dst[3 + 8] = (ce & 0xFF);\n                    dst[2 + 8] = ((ce >> 8) & 0xFF);\n                }\n            } else {\n                for (i = cvt->len_cvt / 4; i; --i) {\n                    dst -= 12;\n                    src -= 4;\n                    lf = (Sint16) ((src[1] << 8) | src[0]);\n                    rf = (Sint16) ((src[3] << 8) | src[2]);\n                    ce = (lf / 2) + (rf / 2);\n                    rr = lf - ce;\n                    lr = rf - ce;\n                    dst[0] = (lf & 0xFF);\n                    dst[1] = ((lf >> 8) & 0xFF);\n                    dst[2] = (rf & 0xFF);\n                    dst[3] = ((rf >> 8) & 0xFF);\n\n                    dst[0 + 4] = (lr & 0xFF);\n                    dst[1 + 4] = ((lr >> 8) & 0xFF);\n                    dst[2 + 4] = (rr & 0xFF);\n                    dst[3 + 4] = ((rr >> 8) & 0xFF);\n\n                    dst[0 + 8] = (ce & 0xFF);\n                    dst[1 + 8] = ((ce >> 8) & 0xFF);\n                    dst[2 + 8] = (ce & 0xFF);\n                    dst[3 + 8] = ((ce >> 8) & 0xFF);\n                }\n            }\n        }\n        break;\n\n    case AUDIO_S32:\n        {\n            Sint32 lf, rf, ce;\n            const Uint32 *src = (const Uint32 *) (cvt->buf + cvt->len_cvt);\n            Uint32 *dst = (Uint32 *) (cvt->buf + cvt->len_cvt * 3);\n\n            if (SDL_AUDIO_ISBIGENDIAN(format)) {\n                for (i = cvt->len_cvt / 8; i; --i) {\n                    dst -= 6;\n                    src -= 2;\n                    lf = (Sint32) SDL_SwapBE32(src[0]);\n                    rf = (Sint32) SDL_SwapBE32(src[1]);\n                    ce = (lf / 2) + (rf / 2);\n                    dst[0] = SDL_SwapBE32((Uint32) lf);\n                    dst[1] = SDL_SwapBE32((Uint32) rf);\n                    dst[2] = SDL_SwapBE32((Uint32) (lf - ce));\n                    dst[3] = SDL_SwapBE32((Uint32) (rf - ce));\n                    dst[4] = SDL_SwapBE32((Uint32) ce);\n                    dst[5] = SDL_SwapBE32((Uint32) ce);\n                }\n            } else {\n                for (i = cvt->len_cvt / 8; i; --i) {\n                    dst -= 6;\n                    src -= 2;\n                    lf = (Sint32) SDL_SwapLE32(src[0]);\n                    rf = (Sint32) SDL_SwapLE32(src[1]);\n                    ce = (lf / 2) + (rf / 2);\n                    dst[0] = src[0];\n                    dst[1] = src[1];\n                    dst[2] = SDL_SwapLE32((Uint32) (lf - ce));\n                    dst[3] = SDL_SwapLE32((Uint32) (rf - ce));\n                    dst[4] = SDL_SwapLE32((Uint32) ce);\n                    dst[5] = SDL_SwapLE32((Uint32) ce);\n                }\n            }\n        }\n        break;\n\n    case AUDIO_F32:\n        {\n            float lf, rf, ce;\n            const float *src = (const float *) (cvt->buf + cvt->len_cvt);\n            float *dst = (float *) (cvt->buf + cvt->len_cvt * 3);\n\n            if (SDL_AUDIO_ISBIGENDIAN(format)) {\n                for (i = cvt->len_cvt / 8; i; --i) {\n                    dst -= 6;\n                    src -= 2;\n                    lf = SDL_SwapFloatBE(src[0]);\n                    rf = SDL_SwapFloatBE(src[1]);\n                    ce = (lf * 0.5f) + (rf * 0.5f);\n                    dst[0] = src[0];\n                    dst[1] = src[1];\n                    dst[2] = SDL_SwapFloatBE(lf - ce);\n                    dst[3] = SDL_SwapFloatBE(rf - ce);\n                    dst[4] = dst[5] = SDL_SwapFloatBE(ce);\n                }\n            } else {\n                for (i = cvt->len_cvt / 8; i; --i) {\n                    dst -= 6;\n                    src -= 2;\n                    lf = SDL_SwapFloatLE(src[0]);\n                    rf = SDL_SwapFloatLE(src[1]);\n                    ce = (lf * 0.5f) + (rf * 0.5f);\n                    dst[0] = src[0];\n                    dst[1] = src[1];\n                    dst[2] = SDL_SwapFloatLE(lf - ce);\n                    dst[3] = SDL_SwapFloatLE(rf - ce);\n                    dst[4] = dst[5] = SDL_SwapFloatLE(ce);\n                }\n            }\n        }\n        break;\n\n    }\n    cvt->len_cvt *= 3;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\n\n/* Duplicate a stereo channel to a pseudo-4.0 stream */\nstatic void SDLCALL\nSDL_ConvertSurround_4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n\n#ifdef DEBUG_CONVERT\n    fprintf(stderr, \"Converting stereo to quad\\n\");\n#endif\n\n    switch (format & (SDL_AUDIO_MASK_SIGNED |\n                      SDL_AUDIO_MASK_BITSIZE |\n                      SDL_AUDIO_MASK_DATATYPE)) {\n    case AUDIO_U8:\n        {\n            Uint8 *src, *dst, lf, rf, ce;\n\n            src = (Uint8 *) (cvt->buf + cvt->len_cvt);\n            dst = (Uint8 *) (cvt->buf + cvt->len_cvt * 2);\n            for (i = cvt->len_cvt; i; --i) {\n                dst -= 4;\n                src -= 2;\n                lf = src[0];\n                rf = src[1];\n                ce = (lf / 2) + (rf / 2);\n                dst[0] = lf;\n                dst[1] = rf;\n                dst[2] = lf - ce;\n                dst[3] = rf - ce;\n            }\n        }\n        break;\n\n    case AUDIO_S8:\n        {\n            Sint8 *src, *dst, lf, rf, ce;\n\n            src = (Sint8 *) cvt->buf + cvt->len_cvt;\n            dst = (Sint8 *) cvt->buf + cvt->len_cvt * 2;\n            for (i = cvt->len_cvt; i; --i) {\n                dst -= 4;\n                src -= 2;\n                lf = src[0];\n                rf = src[1];\n                ce = (lf / 2) + (rf / 2);\n                dst[0] = lf;\n                dst[1] = rf;\n                dst[2] = lf - ce;\n                dst[3] = rf - ce;\n            }\n        }\n        break;\n\n    case AUDIO_U16:\n        {\n            Uint8 *src, *dst;\n            Uint16 lf, rf, ce, lr, rr;\n\n            src = cvt->buf + cvt->len_cvt;\n            dst = cvt->buf + cvt->len_cvt * 2;\n\n            if (SDL_AUDIO_ISBIGENDIAN(format)) {\n                for (i = cvt->len_cvt / 4; i; --i) {\n                    dst -= 8;\n                    src -= 4;\n                    lf = (Uint16) ((src[0] << 8) | src[1]);\n                    rf = (Uint16) ((src[2] << 8) | src[3]);\n                    ce = (lf / 2) + (rf / 2);\n                    rr = lf - ce;\n                    lr = rf - ce;\n                    dst[1] = (lf & 0xFF);\n                    dst[0] = ((lf >> 8) & 0xFF);\n                    dst[3] = (rf & 0xFF);\n                    dst[2] = ((rf >> 8) & 0xFF);\n\n                    dst[1 + 4] = (lr & 0xFF);\n                    dst[0 + 4] = ((lr >> 8) & 0xFF);\n                    dst[3 + 4] = (rr & 0xFF);\n                    dst[2 + 4] = ((rr >> 8) & 0xFF);\n                }\n            } else {\n                for (i = cvt->len_cvt / 4; i; --i) {\n                    dst -= 8;\n                    src -= 4;\n                    lf = (Uint16) ((src[1] << 8) | src[0]);\n                    rf = (Uint16) ((src[3] << 8) | src[2]);\n                    ce = (lf / 2) + (rf / 2);\n                    rr = lf - ce;\n                    lr = rf - ce;\n                    dst[0] = (lf & 0xFF);\n                    dst[1] = ((lf >> 8) & 0xFF);\n                    dst[2] = (rf & 0xFF);\n                    dst[3] = ((rf >> 8) & 0xFF);\n\n                    dst[0 + 4] = (lr & 0xFF);\n                    dst[1 + 4] = ((lr >> 8) & 0xFF);\n                    dst[2 + 4] = (rr & 0xFF);\n                    dst[3 + 4] = ((rr >> 8) & 0xFF);\n                }\n            }\n        }\n        break;\n\n    case AUDIO_S16:\n        {\n            Uint8 *src, *dst;\n            Sint16 lf, rf, ce, lr, rr;\n\n            src = cvt->buf + cvt->len_cvt;\n            dst = cvt->buf + cvt->len_cvt * 2;\n\n            if (SDL_AUDIO_ISBIGENDIAN(format)) {\n                for (i = cvt->len_cvt / 4; i; --i) {\n                    dst -= 8;\n                    src -= 4;\n                    lf = (Sint16) ((src[0] << 8) | src[1]);\n                    rf = (Sint16) ((src[2] << 8) | src[3]);\n                    ce = (lf / 2) + (rf / 2);\n                    rr = lf - ce;\n                    lr = rf - ce;\n                    dst[1] = (lf & 0xFF);\n                    dst[0] = ((lf >> 8) & 0xFF);\n                    dst[3] = (rf & 0xFF);\n                    dst[2] = ((rf >> 8) & 0xFF);\n\n                    dst[1 + 4] = (lr & 0xFF);\n                    dst[0 + 4] = ((lr >> 8) & 0xFF);\n                    dst[3 + 4] = (rr & 0xFF);\n                    dst[2 + 4] = ((rr >> 8) & 0xFF);\n                }\n            } else {\n                for (i = cvt->len_cvt / 4; i; --i) {\n                    dst -= 8;\n                    src -= 4;\n                    lf = (Sint16) ((src[1] << 8) | src[0]);\n                    rf = (Sint16) ((src[3] << 8) | src[2]);\n                    ce = (lf / 2) + (rf / 2);\n                    rr = lf - ce;\n                    lr = rf - ce;\n                    dst[0] = (lf & 0xFF);\n                    dst[1] = ((lf >> 8) & 0xFF);\n                    dst[2] = (rf & 0xFF);\n                    dst[3] = ((rf >> 8) & 0xFF);\n\n                    dst[0 + 4] = (lr & 0xFF);\n                    dst[1 + 4] = ((lr >> 8) & 0xFF);\n                    dst[2 + 4] = (rr & 0xFF);\n                    dst[3 + 4] = ((rr >> 8) & 0xFF);\n                }\n            }\n        }\n        break;\n\n    case AUDIO_S32:\n        {\n            const Uint32 *src = (const Uint32 *) (cvt->buf + cvt->len_cvt);\n            Uint32 *dst = (Uint32 *) (cvt->buf + cvt->len_cvt * 2);\n            Sint32 lf, rf, ce;\n\n            if (SDL_AUDIO_ISBIGENDIAN(format)) {\n                for (i = cvt->len_cvt / 8; i; --i) {\n                    dst -= 4;\n                    src -= 2;\n                    lf = (Sint32) SDL_SwapBE32(src[0]);\n                    rf = (Sint32) SDL_SwapBE32(src[1]);\n                    ce = (lf / 2) + (rf / 2);\n                    dst[0] = src[0];\n                    dst[1] = src[1];\n                    dst[2] = SDL_SwapBE32((Uint32) (lf - ce));\n                    dst[3] = SDL_SwapBE32((Uint32) (rf - ce));\n                }\n            } else {\n                for (i = cvt->len_cvt / 8; i; --i) {\n                    dst -= 4;\n                    src -= 2;\n                    lf = (Sint32) SDL_SwapLE32(src[0]);\n                    rf = (Sint32) SDL_SwapLE32(src[1]);\n                    ce = (lf / 2) + (rf / 2);\n                    dst[0] = src[0];\n                    dst[1] = src[1];\n                    dst[2] = SDL_SwapLE32((Uint32) (lf - ce));\n                    dst[3] = SDL_SwapLE32((Uint32) (rf - ce));\n                }\n            }\n        }\n        break;\n\n    case AUDIO_F32:\n        {\n            const float *src = (const float *) (cvt->buf + cvt->len_cvt);\n            float *dst = (float *) (cvt->buf + cvt->len_cvt * 2);\n            float lf, rf, ce;\n\n            if (SDL_AUDIO_ISBIGENDIAN(format)) {\n                for (i = cvt->len_cvt / 8; i; --i) {\n                    dst -= 4;\n                    src -= 2;\n                    lf = SDL_SwapFloatBE(src[0]);\n                    rf = SDL_SwapFloatBE(src[1]);\n                    ce = (lf / 2) + (rf / 2);\n                    dst[0] = src[0];\n                    dst[1] = src[1];\n                    dst[2] = SDL_SwapFloatBE(lf - ce);\n                    dst[3] = SDL_SwapFloatBE(rf - ce);\n                }\n            } else {\n                for (i = cvt->len_cvt / 8; i; --i) {\n                    dst -= 4;\n                    src -= 2;\n                    lf = SDL_SwapFloatLE(src[0]);\n                    rf = SDL_SwapFloatLE(src[1]);\n                    ce = (lf / 2) + (rf / 2);\n                    dst[0] = src[0];\n                    dst[1] = src[1];\n                    dst[2] = SDL_SwapFloatLE(lf - ce);\n                    dst[3] = SDL_SwapFloatLE(rf - ce);\n                }\n            }\n        }\n        break;\n    }\n    cvt->len_cvt *= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\n\nint\nSDL_ConvertAudio(SDL_AudioCVT * cvt)\n{\n    /* !!! FIXME: (cvt) should be const; stack-copy it here. */\n    /* !!! FIXME: (actually, we can't...len_cvt needs to be updated. Grr.) */\n\n    /* Make sure there's data to convert */\n    if (cvt->buf == NULL) {\n        SDL_SetError(\"No buffer allocated for conversion\");\n        return (-1);\n    }\n    /* Return okay if no conversion is necessary */\n    cvt->len_cvt = cvt->len;\n    if (cvt->filters[0] == NULL) {\n        return (0);\n    }\n\n    /* Set up the conversion and go! */\n    cvt->filter_index = 0;\n    cvt->filters[0] (cvt, cvt->src_format);\n    return (0);\n}\n\n\nstatic SDL_AudioFilter\nSDL_HandTunedTypeCVT(SDL_AudioFormat src_fmt, SDL_AudioFormat dst_fmt)\n{\n    /*\n     * Fill in any future conversions that are specialized to a\n     *  processor, platform, compiler, or library here.\n     */\n\n    return NULL;                /* no specialized converter code available. */\n}\n\n\n/*\n * Find a converter between two data types. We try to select a hand-tuned\n *  asm/vectorized/optimized function first, and then fallback to an\n *  autogenerated function that is customized to convert between two\n *  specific data types.\n */\nstatic int\nSDL_BuildAudioTypeCVT(SDL_AudioCVT * cvt,\n                      SDL_AudioFormat src_fmt, SDL_AudioFormat dst_fmt)\n{\n    if (src_fmt != dst_fmt) {\n        const Uint16 src_bitsize = SDL_AUDIO_BITSIZE(src_fmt);\n        const Uint16 dst_bitsize = SDL_AUDIO_BITSIZE(dst_fmt);\n        SDL_AudioFilter filter = SDL_HandTunedTypeCVT(src_fmt, dst_fmt);\n\n        /* No hand-tuned converter? Try the autogenerated ones. */\n        if (filter == NULL) {\n            int i;\n            for (i = 0; sdl_audio_type_filters[i].filter != NULL; i++) {\n                const SDL_AudioTypeFilters *filt = &sdl_audio_type_filters[i];\n                if ((filt->src_fmt == src_fmt) && (filt->dst_fmt == dst_fmt)) {\n                    filter = filt->filter;\n                    break;\n                }\n            }\n\n            if (filter == NULL) {\n                SDL_SetError(\"No conversion available for these formats\");\n                return -1;\n            }\n        }\n\n        /* Update (cvt) with filter details... */\n        cvt->filters[cvt->filter_index++] = filter;\n        if (src_bitsize < dst_bitsize) {\n            const int mult = (dst_bitsize / src_bitsize);\n            cvt->len_mult *= mult;\n            cvt->len_ratio *= mult;\n        } else if (src_bitsize > dst_bitsize) {\n            cvt->len_ratio /= (src_bitsize / dst_bitsize);\n        }\n\n        return 1;               /* added a converter. */\n    }\n\n    return 0;                   /* no conversion necessary. */\n}\n\n\nstatic SDL_AudioFilter\nSDL_HandTunedResampleCVT(SDL_AudioCVT * cvt, int dst_channels,\n                         int src_rate, int dst_rate)\n{\n    /*\n     * Fill in any future conversions that are specialized to a\n     *  processor, platform, compiler, or library here.\n     */\n\n    return NULL;                /* no specialized converter code available. */\n}\n\nstatic int\nSDL_FindFrequencyMultiple(const int src_rate, const int dst_rate)\n{\n    int retval = 0;\n\n    /* If we only built with the arbitrary resamplers, ignore multiples. */\n#if !LESS_RESAMPLERS\n    int lo, hi;\n    int div;\n\n    SDL_assert(src_rate != 0);\n    SDL_assert(dst_rate != 0);\n    SDL_assert(src_rate != dst_rate);\n\n    if (src_rate < dst_rate) {\n        lo = src_rate;\n        hi = dst_rate;\n    } else {\n        lo = dst_rate;\n        hi = src_rate;\n    }\n\n    /* zero means \"not a supported multiple\" ... we only do 2x and 4x. */\n    if ((hi % lo) != 0)\n        return 0;               /* not a multiple. */\n\n    div = hi / lo;\n    retval = ((div == 2) || (div == 4)) ? div : 0;\n#endif\n\n    return retval;\n}\n\nstatic int\nSDL_BuildAudioResampleCVT(SDL_AudioCVT * cvt, int dst_channels,\n                          int src_rate, int dst_rate)\n{\n    if (src_rate != dst_rate) {\n        SDL_AudioFilter filter = SDL_HandTunedResampleCVT(cvt, dst_channels,\n                                                          src_rate, dst_rate);\n\n        /* No hand-tuned converter? Try the autogenerated ones. */\n        if (filter == NULL) {\n            int i;\n            const int upsample = (src_rate < dst_rate) ? 1 : 0;\n            const int multiple =\n                SDL_FindFrequencyMultiple(src_rate, dst_rate);\n\n            for (i = 0; sdl_audio_rate_filters[i].filter != NULL; i++) {\n                const SDL_AudioRateFilters *filt = &sdl_audio_rate_filters[i];\n                if ((filt->fmt == cvt->dst_format) &&\n                    (filt->channels == dst_channels) &&\n                    (filt->upsample == upsample) &&\n                    (filt->multiple == multiple)) {\n                    filter = filt->filter;\n                    break;\n                }\n            }\n\n            if (filter == NULL) {\n                SDL_SetError(\"No conversion available for these rates\");\n                return -1;\n            }\n        }\n\n        /* Update (cvt) with filter details... */\n        cvt->filters[cvt->filter_index++] = filter;\n        if (src_rate < dst_rate) {\n            const double mult = ((double) dst_rate) / ((double) src_rate);\n            cvt->len_mult *= (int) SDL_ceil(mult);\n            cvt->len_ratio *= mult;\n        } else {\n            cvt->len_ratio /= ((double) src_rate) / ((double) dst_rate);\n        }\n\n        return 1;               /* added a converter. */\n    }\n\n    return 0;                   /* no conversion necessary. */\n}\n\n\n/* Creates a set of audio filters to convert from one format to another.\n   Returns -1 if the format conversion is not supported, 0 if there's\n   no conversion needed, or 1 if the audio filter is set up.\n*/\n\nint\nSDL_BuildAudioCVT(SDL_AudioCVT * cvt,\n                  SDL_AudioFormat src_fmt, Uint8 src_channels, int src_rate,\n                  SDL_AudioFormat dst_fmt, Uint8 dst_channels, int dst_rate)\n{\n    /*\n     * !!! FIXME: reorder filters based on which grow/shrink the buffer.\n     * !!! FIXME: ideally, we should do everything that shrinks the buffer\n     * !!! FIXME: first, so we don't have to process as many bytes in a given\n     * !!! FIXME: filter and abuse the CPU cache less. This might not be as\n     * !!! FIXME: good in practice as it sounds in theory, though.\n     */\n\n    /* Sanity check target pointer */\n    if (cvt == NULL) {\n        return SDL_InvalidParamError(\"cvt\");\n    }\n\n    /* there are no unsigned types over 16 bits, so catch this up front. */\n    if ((SDL_AUDIO_BITSIZE(src_fmt) > 16) && (!SDL_AUDIO_ISSIGNED(src_fmt))) {\n        return SDL_SetError(\"Invalid source format\");\n    }\n    if ((SDL_AUDIO_BITSIZE(dst_fmt) > 16) && (!SDL_AUDIO_ISSIGNED(dst_fmt))) {\n        return SDL_SetError(\"Invalid destination format\");\n    }\n\n    /* prevent possible divisions by zero, etc. */\n    if ((src_channels == 0) || (dst_channels == 0)) {\n        return SDL_SetError(\"Source or destination channels is zero\");\n    }\n    if ((src_rate == 0) || (dst_rate == 0)) {\n        return SDL_SetError(\"Source or destination rate is zero\");\n    }\n#ifdef DEBUG_CONVERT\n    printf(\"Build format %04x->%04x, channels %u->%u, rate %d->%d\\n\",\n           src_fmt, dst_fmt, src_channels, dst_channels, src_rate, dst_rate);\n#endif\n\n    /* Start off with no conversion necessary */\n    SDL_zerop(cvt);\n    cvt->src_format = src_fmt;\n    cvt->dst_format = dst_fmt;\n    cvt->needed = 0;\n    cvt->filter_index = 0;\n    cvt->filters[0] = NULL;\n    cvt->len_mult = 1;\n    cvt->len_ratio = 1.0;\n    cvt->rate_incr = ((double) dst_rate) / ((double) src_rate);\n\n    /* Convert data types, if necessary. Updates (cvt). */\n    if (SDL_BuildAudioTypeCVT(cvt, src_fmt, dst_fmt) == -1) {\n        return -1;              /* shouldn't happen, but just in case... */\n    }\n\n    /* Channel conversion */\n    if (src_channels != dst_channels) {\n        if ((src_channels == 1) && (dst_channels > 1)) {\n            cvt->filters[cvt->filter_index++] = SDL_ConvertStereo;\n            cvt->len_mult *= 2;\n            src_channels = 2;\n            cvt->len_ratio *= 2;\n        }\n        if ((src_channels == 2) && (dst_channels == 6)) {\n            cvt->filters[cvt->filter_index++] = SDL_ConvertSurround;\n            src_channels = 6;\n            cvt->len_mult *= 3;\n            cvt->len_ratio *= 3;\n        }\n        if ((src_channels == 2) && (dst_channels == 4)) {\n            cvt->filters[cvt->filter_index++] = SDL_ConvertSurround_4;\n            src_channels = 4;\n            cvt->len_mult *= 2;\n            cvt->len_ratio *= 2;\n        }\n        while ((src_channels * 2) <= dst_channels) {\n            cvt->filters[cvt->filter_index++] = SDL_ConvertStereo;\n            cvt->len_mult *= 2;\n            src_channels *= 2;\n            cvt->len_ratio *= 2;\n        }\n        if ((src_channels == 6) && (dst_channels <= 2)) {\n            cvt->filters[cvt->filter_index++] = SDL_ConvertStrip;\n            src_channels = 2;\n            cvt->len_ratio /= 3;\n        }\n        if ((src_channels == 6) && (dst_channels == 4)) {\n            cvt->filters[cvt->filter_index++] = SDL_ConvertStrip_2;\n            src_channels = 4;\n            cvt->len_ratio /= 2;\n        }\n        /* This assumes that 4 channel audio is in the format:\n           Left {front/back} + Right {front/back}\n           so converting to L/R stereo works properly.\n         */\n        while (((src_channels % 2) == 0) &&\n               ((src_channels / 2) >= dst_channels)) {\n            cvt->filters[cvt->filter_index++] = SDL_ConvertMono;\n            src_channels /= 2;\n            cvt->len_ratio /= 2;\n        }\n        if (src_channels != dst_channels) {\n            /* Uh oh.. */ ;\n        }\n    }\n\n    /* Do rate conversion, if necessary. Updates (cvt). */\n    if (SDL_BuildAudioResampleCVT(cvt, dst_channels, src_rate, dst_rate) ==\n        -1) {\n        return -1;              /* shouldn't happen, but just in case... */\n    }\n\n    /* Set up the filter information */\n    if (cvt->filter_index != 0) {\n        cvt->needed = 1;\n        cvt->src_format = src_fmt;\n        cvt->dst_format = dst_fmt;\n        cvt->len = 0;\n        cvt->buf = NULL;\n        cvt->filters[cvt->filter_index] = NULL;\n    }\n    return (cvt->needed);\n}\n\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n\n/**\n *  \\file SDL_endian.h\n *\n *  Functions for reading and writing endian-specific values\n */\n\n#ifndef _SDL_endian_h\n#define _SDL_endian_h\n\n#include \"SDL_stdinc.h\"\n\n/**\n *  \\name The two types of endianness\n */\n/* @{ */\n#define SDL_LIL_ENDIAN  1234\n#define SDL_BIG_ENDIAN  4321\n/* @} */\n\n#ifndef SDL_BYTEORDER           /* Not defined in SDL_config.h? */\n#ifdef __linux__\n#include <endian.h>\n#define SDL_BYTEORDER  __BYTE_ORDER\n#else /* __linux __ */\n#if defined(__hppa__) || \\\n    defined(__m68k__) || defined(mc68000) || defined(_M_M68K) || \\\n    (defined(__MIPS__) && defined(__MISPEB__)) || \\\n    defined(__ppc__) || defined(__POWERPC__) || defined(_M_PPC) || \\\n    defined(__sparc__)\n#define SDL_BYTEORDER   SDL_BIG_ENDIAN\n#else\n#define SDL_BYTEORDER   SDL_LIL_ENDIAN\n#endif\n#endif /* __linux __ */\n#endif /* !SDL_BYTEORDER */\n\n\n#include \"begin_code.h\"\n/* Set up for C function definitions, even when using C++ */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n *  \\file SDL_endian.h\n */\n#if defined(__GNUC__) && defined(__i386__) && \\\n   !(__GNUC__ == 2 && __GNUC_MINOR__ == 95 /* broken gcc version */)\nSDL_FORCE_INLINE Uint16\nSDL_Swap16(Uint16 x)\n{\n  __asm__(\"xchgb %b0,%h0\": \"=q\"(x):\"0\"(x));\n    return x;\n}\n#elif defined(__GNUC__) && defined(__x86_64__)\nSDL_FORCE_INLINE Uint16\nSDL_Swap16(Uint16 x)\n{\n  __asm__(\"xchgb %b0,%h0\": \"=Q\"(x):\"0\"(x));\n    return x;\n}\n#elif defined(__GNUC__) && (defined(__powerpc__) || defined(__ppc__))\nSDL_FORCE_INLINE Uint16\nSDL_Swap16(Uint16 x)\n{\n    int result;\n\n  __asm__(\"rlwimi %0,%2,8,16,23\": \"=&r\"(result):\"0\"(x >> 8), \"r\"(x));\n    return (Uint16)result;\n}\n#elif defined(__GNUC__) && (defined(__M68000__) || defined(__M68020__)) && !defined(__mcoldfire__)\nSDL_FORCE_INLINE Uint16\nSDL_Swap16(Uint16 x)\n{\n  __asm__(\"rorw #8,%0\": \"=d\"(x): \"0\"(x):\"cc\");\n    return x;\n}\n#else\nSDL_FORCE_INLINE Uint16\nSDL_Swap16(Uint16 x)\n{\n    return SDL_static_cast(Uint16, ((x << 8) | (x >> 8)));\n}\n#endif\n\n#if defined(__GNUC__) && defined(__i386__)\nSDL_FORCE_INLINE Uint32\nSDL_Swap32(Uint32 x)\n{\n  __asm__(\"bswap %0\": \"=r\"(x):\"0\"(x));\n    return x;\n}\n#elif defined(__GNUC__) && defined(__x86_64__)\nSDL_FORCE_INLINE Uint32\nSDL_Swap32(Uint32 x)\n{\n  __asm__(\"bswapl %0\": \"=r\"(x):\"0\"(x));\n    return x;\n}\n#elif defined(__GNUC__) && (defined(__powerpc__) || defined(__ppc__))\nSDL_FORCE_INLINE Uint32\nSDL_Swap32(Uint32 x)\n{\n    Uint32 result;\n\n  __asm__(\"rlwimi %0,%2,24,16,23\": \"=&r\"(result):\"0\"(x >> 24), \"r\"(x));\n  __asm__(\"rlwimi %0,%2,8,8,15\": \"=&r\"(result):\"0\"(result), \"r\"(x));\n  __asm__(\"rlwimi %0,%2,24,0,7\": \"=&r\"(result):\"0\"(result), \"r\"(x));\n    return result;\n}\n#elif defined(__GNUC__) && (defined(__M68000__) || defined(__M68020__)) && !defined(__mcoldfire__)\nSDL_FORCE_INLINE Uint32\nSDL_Swap32(Uint32 x)\n{\n  __asm__(\"rorw #8,%0\\n\\tswap %0\\n\\trorw #8,%0\": \"=d\"(x): \"0\"(x):\"cc\");\n    return x;\n}\n#else\nSDL_FORCE_INLINE Uint32\nSDL_Swap32(Uint32 x)\n{\n    return SDL_static_cast(Uint32, ((x << 24) | ((x << 8) & 0x00FF0000) |\n                                    ((x >> 8) & 0x0000FF00) | (x >> 24)));\n}\n#endif\n\n#if defined(__GNUC__) && defined(__i386__)\nSDL_FORCE_INLINE Uint64\nSDL_Swap64(Uint64 x)\n{\n    union\n    {\n        struct\n        {\n            Uint32 a, b;\n        } s;\n        Uint64 u;\n    } v;\n    v.u = x;\n  __asm__(\"bswapl %0 ; bswapl %1 ; xchgl %0,%1\": \"=r\"(v.s.a), \"=r\"(v.s.b):\"0\"(v.s.a),\n            \"1\"(v.s.\n                b));\n    return v.u;\n}\n#elif defined(__GNUC__) && defined(__x86_64__)\nSDL_FORCE_INLINE Uint64\nSDL_Swap64(Uint64 x)\n{\n  __asm__(\"bswapq %0\": \"=r\"(x):\"0\"(x));\n    return x;\n}\n#else\nSDL_FORCE_INLINE Uint64\nSDL_Swap64(Uint64 x)\n{\n    Uint32 hi, lo;\n\n    /* Separate into high and low 32-bit values and swap them */\n    lo = SDL_static_cast(Uint32, x & 0xFFFFFFFF);\n    x >>= 32;\n    hi = SDL_static_cast(Uint32, x & 0xFFFFFFFF);\n    x = SDL_Swap32(lo);\n    x <<= 32;\n    x |= SDL_Swap32(hi);\n    return (x);\n}\n#endif\n\n\nSDL_FORCE_INLINE float\nSDL_SwapFloat(float x)\n{\n    union\n    {\n        float f;\n        Uint32 ui32;\n    } swapper;\n    swapper.f = x;\n    swapper.ui32 = SDL_Swap32(swapper.ui32);\n    return swapper.f;\n}\n\n\n/**\n *  \\name Swap to native\n *  Byteswap item from the specified endianness to the native endianness.\n */\n/* @{ */\n#if SDL_BYTEORDER == SDL_LIL_ENDIAN\n#define SDL_SwapLE16(X) (X)\n#define SDL_SwapLE32(X) (X)\n#define SDL_SwapLE64(X) (X)\n#define SDL_SwapFloatLE(X)  (X)\n#define SDL_SwapBE16(X) SDL_Swap16(X)\n#define SDL_SwapBE32(X) SDL_Swap32(X)\n#define SDL_SwapBE64(X) SDL_Swap64(X)\n#define SDL_SwapFloatBE(X)  SDL_SwapFloat(X)\n#else\n#define SDL_SwapLE16(X) SDL_Swap16(X)\n#define SDL_SwapLE32(X) SDL_Swap32(X)\n#define SDL_SwapLE64(X) SDL_Swap64(X)\n#define SDL_SwapFloatLE(X)  SDL_SwapFloat(X)\n#define SDL_SwapBE16(X) (X)\n#define SDL_SwapBE32(X) (X)\n#define SDL_SwapBE64(X) (X)\n#define SDL_SwapFloatBE(X)  (X)\n#endif\n/* @} *//* Swap to native */\n\n/* Ends C function definitions when using C++ */\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif /* _SDL_endian_h */\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/* DO NOT EDIT!  This file is generated by sdlgenaudiocvt.pl */\n/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n\n#include \"../SDL_internal.h\"\n#include \"SDL_audio.h\"\n#include \"SDL_audio_c.h\"\n\n#ifndef DEBUG_CONVERT\n#define DEBUG_CONVERT 0\n#endif\n\n\n/* If you can guarantee your data and need space, you can eliminate code... */\n\n/* Just build the arbitrary resamplers if you're saving code space. */\n#ifndef LESS_RESAMPLERS\n#define LESS_RESAMPLERS 0\n#endif\n\n/* Don't build any resamplers if you're REALLY saving code space. */\n#ifndef NO_RESAMPLERS\n#define NO_RESAMPLERS 0\n#endif\n\n/* Don't build any type converters if you're saving code space. */\n#ifndef NO_CONVERTERS\n#define NO_CONVERTERS 0\n#endif\n\n\n/* *INDENT-OFF* */\n\n#define DIVBY127 0.0078740157480315f\n#define DIVBY32767 3.05185094759972e-05f\n#define DIVBY2147483647 4.6566128752458e-10f\n\n#if !NO_CONVERTERS\n\nstatic void SDLCALL\nSDL_Convert_U8_to_S8(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint8 *src;\n    Sint8 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_U8 to AUDIO_S8.\\n\");\n#endif\n\n    src = (const Uint8 *) cvt->buf;\n    dst = (Sint8 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint8); i; --i, ++src, ++dst) {\n        const Sint8 val = ((*src) ^ 0x80);\n        *dst = ((Sint8) val);\n    }\n\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S8);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_U8_to_U16LSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint8 *src;\n    Uint16 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_U8 to AUDIO_U16LSB.\\n\");\n#endif\n\n    src = ((const Uint8 *) (cvt->buf + cvt->len_cvt)) - 1;\n    dst = ((Uint16 *) (cvt->buf + cvt->len_cvt * 2)) - 1;\n    for (i = cvt->len_cvt / sizeof (Uint8); i; --i, --src, --dst) {\n        const Uint16 val = (((Uint16) *src) << 8);\n        *dst = SDL_SwapLE16(val);\n    }\n\n    cvt->len_cvt *= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_U16LSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_U8_to_S16LSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint8 *src;\n    Sint16 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_U8 to AUDIO_S16LSB.\\n\");\n#endif\n\n    src = ((const Uint8 *) (cvt->buf + cvt->len_cvt)) - 1;\n    dst = ((Sint16 *) (cvt->buf + cvt->len_cvt * 2)) - 1;\n    for (i = cvt->len_cvt / sizeof (Uint8); i; --i, --src, --dst) {\n        const Sint16 val = (((Sint16) ((*src) ^ 0x80)) << 8);\n        *dst = ((Sint16) SDL_SwapLE16(val));\n    }\n\n    cvt->len_cvt *= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S16LSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_U8_to_U16MSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint8 *src;\n    Uint16 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_U8 to AUDIO_U16MSB.\\n\");\n#endif\n\n    src = ((const Uint8 *) (cvt->buf + cvt->len_cvt)) - 1;\n    dst = ((Uint16 *) (cvt->buf + cvt->len_cvt * 2)) - 1;\n    for (i = cvt->len_cvt / sizeof (Uint8); i; --i, --src, --dst) {\n        const Uint16 val = (((Uint16) *src) << 8);\n        *dst = SDL_SwapBE16(val);\n    }\n\n    cvt->len_cvt *= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_U16MSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_U8_to_S16MSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint8 *src;\n    Sint16 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_U8 to AUDIO_S16MSB.\\n\");\n#endif\n\n    src = ((const Uint8 *) (cvt->buf + cvt->len_cvt)) - 1;\n    dst = ((Sint16 *) (cvt->buf + cvt->len_cvt * 2)) - 1;\n    for (i = cvt->len_cvt / sizeof (Uint8); i; --i, --src, --dst) {\n        const Sint16 val = (((Sint16) ((*src) ^ 0x80)) << 8);\n        *dst = ((Sint16) SDL_SwapBE16(val));\n    }\n\n    cvt->len_cvt *= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S16MSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_U8_to_S32LSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint8 *src;\n    Sint32 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_U8 to AUDIO_S32LSB.\\n\");\n#endif\n\n    src = ((const Uint8 *) (cvt->buf + cvt->len_cvt)) - 1;\n    dst = ((Sint32 *) (cvt->buf + cvt->len_cvt * 4)) - 1;\n    for (i = cvt->len_cvt / sizeof (Uint8); i; --i, --src, --dst) {\n        const Sint32 val = (((Sint32) ((*src) ^ 0x80)) << 24);\n        *dst = ((Sint32) SDL_SwapLE32(val));\n    }\n\n    cvt->len_cvt *= 4;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S32LSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_U8_to_S32MSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint8 *src;\n    Sint32 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_U8 to AUDIO_S32MSB.\\n\");\n#endif\n\n    src = ((const Uint8 *) (cvt->buf + cvt->len_cvt)) - 1;\n    dst = ((Sint32 *) (cvt->buf + cvt->len_cvt * 4)) - 1;\n    for (i = cvt->len_cvt / sizeof (Uint8); i; --i, --src, --dst) {\n        const Sint32 val = (((Sint32) ((*src) ^ 0x80)) << 24);\n        *dst = ((Sint32) SDL_SwapBE32(val));\n    }\n\n    cvt->len_cvt *= 4;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S32MSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_U8_to_F32LSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint8 *src;\n    float *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_U8 to AUDIO_F32LSB.\\n\");\n#endif\n\n    src = ((const Uint8 *) (cvt->buf + cvt->len_cvt)) - 1;\n    dst = ((float *) (cvt->buf + cvt->len_cvt * 4)) - 1;\n    for (i = cvt->len_cvt / sizeof (Uint8); i; --i, --src, --dst) {\n        const float val = ((((float) *src) * DIVBY127) - 1.0f);\n        *dst = SDL_SwapFloatLE(val);\n    }\n\n    cvt->len_cvt *= 4;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_F32LSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_U8_to_F32MSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint8 *src;\n    float *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_U8 to AUDIO_F32MSB.\\n\");\n#endif\n\n    src = ((const Uint8 *) (cvt->buf + cvt->len_cvt)) - 1;\n    dst = ((float *) (cvt->buf + cvt->len_cvt * 4)) - 1;\n    for (i = cvt->len_cvt / sizeof (Uint8); i; --i, --src, --dst) {\n        const float val = ((((float) *src) * DIVBY127) - 1.0f);\n        *dst = SDL_SwapFloatBE(val);\n    }\n\n    cvt->len_cvt *= 4;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_F32MSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S8_to_U8(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint8 *src;\n    Uint8 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S8 to AUDIO_U8.\\n\");\n#endif\n\n    src = (const Uint8 *) cvt->buf;\n    dst = (Uint8 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint8); i; --i, ++src, ++dst) {\n        const Uint8 val = ((((Sint8) *src)) ^ 0x80);\n        *dst = val;\n    }\n\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_U8);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S8_to_U16LSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint8 *src;\n    Uint16 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S8 to AUDIO_U16LSB.\\n\");\n#endif\n\n    src = ((const Uint8 *) (cvt->buf + cvt->len_cvt)) - 1;\n    dst = ((Uint16 *) (cvt->buf + cvt->len_cvt * 2)) - 1;\n    for (i = cvt->len_cvt / sizeof (Uint8); i; --i, --src, --dst) {\n        const Uint16 val = (((Uint16) ((((Sint8) *src)) ^ 0x80)) << 8);\n        *dst = SDL_SwapLE16(val);\n    }\n\n    cvt->len_cvt *= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_U16LSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S8_to_S16LSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint8 *src;\n    Sint16 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S8 to AUDIO_S16LSB.\\n\");\n#endif\n\n    src = ((const Uint8 *) (cvt->buf + cvt->len_cvt)) - 1;\n    dst = ((Sint16 *) (cvt->buf + cvt->len_cvt * 2)) - 1;\n    for (i = cvt->len_cvt / sizeof (Uint8); i; --i, --src, --dst) {\n        const Sint16 val = (((Sint16) ((Sint8) *src)) << 8);\n        *dst = ((Sint16) SDL_SwapLE16(val));\n    }\n\n    cvt->len_cvt *= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S16LSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S8_to_U16MSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint8 *src;\n    Uint16 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S8 to AUDIO_U16MSB.\\n\");\n#endif\n\n    src = ((const Uint8 *) (cvt->buf + cvt->len_cvt)) - 1;\n    dst = ((Uint16 *) (cvt->buf + cvt->len_cvt * 2)) - 1;\n    for (i = cvt->len_cvt / sizeof (Uint8); i; --i, --src, --dst) {\n        const Uint16 val = (((Uint16) ((((Sint8) *src)) ^ 0x80)) << 8);\n        *dst = SDL_SwapBE16(val);\n    }\n\n    cvt->len_cvt *= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_U16MSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S8_to_S16MSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint8 *src;\n    Sint16 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S8 to AUDIO_S16MSB.\\n\");\n#endif\n\n    src = ((const Uint8 *) (cvt->buf + cvt->len_cvt)) - 1;\n    dst = ((Sint16 *) (cvt->buf + cvt->len_cvt * 2)) - 1;\n    for (i = cvt->len_cvt / sizeof (Uint8); i; --i, --src, --dst) {\n        const Sint16 val = (((Sint16) ((Sint8) *src)) << 8);\n        *dst = ((Sint16) SDL_SwapBE16(val));\n    }\n\n    cvt->len_cvt *= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S16MSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S8_to_S32LSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint8 *src;\n    Sint32 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S8 to AUDIO_S32LSB.\\n\");\n#endif\n\n    src = ((const Uint8 *) (cvt->buf + cvt->len_cvt)) - 1;\n    dst = ((Sint32 *) (cvt->buf + cvt->len_cvt * 4)) - 1;\n    for (i = cvt->len_cvt / sizeof (Uint8); i; --i, --src, --dst) {\n        const Sint32 val = (((Sint32) ((Sint8) *src)) << 24);\n        *dst = ((Sint32) SDL_SwapLE32(val));\n    }\n\n    cvt->len_cvt *= 4;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S32LSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S8_to_S32MSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint8 *src;\n    Sint32 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S8 to AUDIO_S32MSB.\\n\");\n#endif\n\n    src = ((const Uint8 *) (cvt->buf + cvt->len_cvt)) - 1;\n    dst = ((Sint32 *) (cvt->buf + cvt->len_cvt * 4)) - 1;\n    for (i = cvt->len_cvt / sizeof (Uint8); i; --i, --src, --dst) {\n        const Sint32 val = (((Sint32) ((Sint8) *src)) << 24);\n        *dst = ((Sint32) SDL_SwapBE32(val));\n    }\n\n    cvt->len_cvt *= 4;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S32MSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S8_to_F32LSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint8 *src;\n    float *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S8 to AUDIO_F32LSB.\\n\");\n#endif\n\n    src = ((const Uint8 *) (cvt->buf + cvt->len_cvt)) - 1;\n    dst = ((float *) (cvt->buf + cvt->len_cvt * 4)) - 1;\n    for (i = cvt->len_cvt / sizeof (Uint8); i; --i, --src, --dst) {\n        const float val = (((float) ((Sint8) *src)) * DIVBY127);\n        *dst = SDL_SwapFloatLE(val);\n    }\n\n    cvt->len_cvt *= 4;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_F32LSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S8_to_F32MSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint8 *src;\n    float *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S8 to AUDIO_F32MSB.\\n\");\n#endif\n\n    src = ((const Uint8 *) (cvt->buf + cvt->len_cvt)) - 1;\n    dst = ((float *) (cvt->buf + cvt->len_cvt * 4)) - 1;\n    for (i = cvt->len_cvt / sizeof (Uint8); i; --i, --src, --dst) {\n        const float val = (((float) ((Sint8) *src)) * DIVBY127);\n        *dst = SDL_SwapFloatBE(val);\n    }\n\n    cvt->len_cvt *= 4;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_F32MSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_U16LSB_to_U8(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint16 *src;\n    Uint8 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_U16LSB to AUDIO_U8.\\n\");\n#endif\n\n    src = (const Uint16 *) cvt->buf;\n    dst = (Uint8 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint16); i; --i, ++src, ++dst) {\n        const Uint8 val = ((Uint8) (SDL_SwapLE16(*src) >> 8));\n        *dst = val;\n    }\n\n    cvt->len_cvt /= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_U8);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_U16LSB_to_S8(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint16 *src;\n    Sint8 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_U16LSB to AUDIO_S8.\\n\");\n#endif\n\n    src = (const Uint16 *) cvt->buf;\n    dst = (Sint8 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint16); i; --i, ++src, ++dst) {\n        const Sint8 val = ((Sint8) (((SDL_SwapLE16(*src)) ^ 0x8000) >> 8));\n        *dst = ((Sint8) val);\n    }\n\n    cvt->len_cvt /= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S8);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_U16LSB_to_S16LSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint16 *src;\n    Sint16 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_U16LSB to AUDIO_S16LSB.\\n\");\n#endif\n\n    src = (const Uint16 *) cvt->buf;\n    dst = (Sint16 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint16); i; --i, ++src, ++dst) {\n        const Sint16 val = ((SDL_SwapLE16(*src)) ^ 0x8000);\n        *dst = ((Sint16) SDL_SwapLE16(val));\n    }\n\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S16LSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_U16LSB_to_U16MSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint16 *src;\n    Uint16 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_U16LSB to AUDIO_U16MSB.\\n\");\n#endif\n\n    src = (const Uint16 *) cvt->buf;\n    dst = (Uint16 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint16); i; --i, ++src, ++dst) {\n        const Uint16 val = SDL_SwapLE16(*src);\n        *dst = SDL_SwapBE16(val);\n    }\n\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_U16MSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_U16LSB_to_S16MSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint16 *src;\n    Sint16 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_U16LSB to AUDIO_S16MSB.\\n\");\n#endif\n\n    src = (const Uint16 *) cvt->buf;\n    dst = (Sint16 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint16); i; --i, ++src, ++dst) {\n        const Sint16 val = ((SDL_SwapLE16(*src)) ^ 0x8000);\n        *dst = ((Sint16) SDL_SwapBE16(val));\n    }\n\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S16MSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_U16LSB_to_S32LSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint16 *src;\n    Sint32 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_U16LSB to AUDIO_S32LSB.\\n\");\n#endif\n\n    src = ((const Uint16 *) (cvt->buf + cvt->len_cvt)) - 1;\n    dst = ((Sint32 *) (cvt->buf + cvt->len_cvt * 2)) - 1;\n    for (i = cvt->len_cvt / sizeof (Uint16); i; --i, --src, --dst) {\n        const Sint32 val = (((Sint32) ((SDL_SwapLE16(*src)) ^ 0x8000)) << 16);\n        *dst = ((Sint32) SDL_SwapLE32(val));\n    }\n\n    cvt->len_cvt *= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S32LSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_U16LSB_to_S32MSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint16 *src;\n    Sint32 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_U16LSB to AUDIO_S32MSB.\\n\");\n#endif\n\n    src = ((const Uint16 *) (cvt->buf + cvt->len_cvt)) - 1;\n    dst = ((Sint32 *) (cvt->buf + cvt->len_cvt * 2)) - 1;\n    for (i = cvt->len_cvt / sizeof (Uint16); i; --i, --src, --dst) {\n        const Sint32 val = (((Sint32) ((SDL_SwapLE16(*src)) ^ 0x8000)) << 16);\n        *dst = ((Sint32) SDL_SwapBE32(val));\n    }\n\n    cvt->len_cvt *= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S32MSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_U16LSB_to_F32LSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint16 *src;\n    float *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_U16LSB to AUDIO_F32LSB.\\n\");\n#endif\n\n    src = ((const Uint16 *) (cvt->buf + cvt->len_cvt)) - 1;\n    dst = ((float *) (cvt->buf + cvt->len_cvt * 2)) - 1;\n    for (i = cvt->len_cvt / sizeof (Uint16); i; --i, --src, --dst) {\n        const float val = ((((float) SDL_SwapLE16(*src)) * DIVBY32767) - 1.0f);\n        *dst = SDL_SwapFloatLE(val);\n    }\n\n    cvt->len_cvt *= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_F32LSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_U16LSB_to_F32MSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint16 *src;\n    float *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_U16LSB to AUDIO_F32MSB.\\n\");\n#endif\n\n    src = ((const Uint16 *) (cvt->buf + cvt->len_cvt)) - 1;\n    dst = ((float *) (cvt->buf + cvt->len_cvt * 2)) - 1;\n    for (i = cvt->len_cvt / sizeof (Uint16); i; --i, --src, --dst) {\n        const float val = ((((float) SDL_SwapLE16(*src)) * DIVBY32767) - 1.0f);\n        *dst = SDL_SwapFloatBE(val);\n    }\n\n    cvt->len_cvt *= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_F32MSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S16LSB_to_U8(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint16 *src;\n    Uint8 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S16LSB to AUDIO_U8.\\n\");\n#endif\n\n    src = (const Uint16 *) cvt->buf;\n    dst = (Uint8 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint16); i; --i, ++src, ++dst) {\n        const Uint8 val = ((Uint8) (((((Sint16) SDL_SwapLE16(*src))) ^ 0x8000) >> 8));\n        *dst = val;\n    }\n\n    cvt->len_cvt /= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_U8);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S16LSB_to_S8(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint16 *src;\n    Sint8 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S16LSB to AUDIO_S8.\\n\");\n#endif\n\n    src = (const Uint16 *) cvt->buf;\n    dst = (Sint8 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint16); i; --i, ++src, ++dst) {\n        const Sint8 val = ((Sint8) (((Sint16) SDL_SwapLE16(*src)) >> 8));\n        *dst = ((Sint8) val);\n    }\n\n    cvt->len_cvt /= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S8);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S16LSB_to_U16LSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint16 *src;\n    Uint16 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S16LSB to AUDIO_U16LSB.\\n\");\n#endif\n\n    src = (const Uint16 *) cvt->buf;\n    dst = (Uint16 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint16); i; --i, ++src, ++dst) {\n        const Uint16 val = ((((Sint16) SDL_SwapLE16(*src))) ^ 0x8000);\n        *dst = SDL_SwapLE16(val);\n    }\n\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_U16LSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S16LSB_to_U16MSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint16 *src;\n    Uint16 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S16LSB to AUDIO_U16MSB.\\n\");\n#endif\n\n    src = (const Uint16 *) cvt->buf;\n    dst = (Uint16 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint16); i; --i, ++src, ++dst) {\n        const Uint16 val = ((((Sint16) SDL_SwapLE16(*src))) ^ 0x8000);\n        *dst = SDL_SwapBE16(val);\n    }\n\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_U16MSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S16LSB_to_S16MSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint16 *src;\n    Sint16 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S16LSB to AUDIO_S16MSB.\\n\");\n#endif\n\n    src = (const Uint16 *) cvt->buf;\n    dst = (Sint16 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint16); i; --i, ++src, ++dst) {\n        const Sint16 val = ((Sint16) SDL_SwapLE16(*src));\n        *dst = ((Sint16) SDL_SwapBE16(val));\n    }\n\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S16MSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S16LSB_to_S32LSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint16 *src;\n    Sint32 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S16LSB to AUDIO_S32LSB.\\n\");\n#endif\n\n    src = ((const Uint16 *) (cvt->buf + cvt->len_cvt)) - 1;\n    dst = ((Sint32 *) (cvt->buf + cvt->len_cvt * 2)) - 1;\n    for (i = cvt->len_cvt / sizeof (Uint16); i; --i, --src, --dst) {\n        const Sint32 val = (((Sint32) ((Sint16) SDL_SwapLE16(*src))) << 16);\n        *dst = ((Sint32) SDL_SwapLE32(val));\n    }\n\n    cvt->len_cvt *= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S32LSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S16LSB_to_S32MSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint16 *src;\n    Sint32 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S16LSB to AUDIO_S32MSB.\\n\");\n#endif\n\n    src = ((const Uint16 *) (cvt->buf + cvt->len_cvt)) - 1;\n    dst = ((Sint32 *) (cvt->buf + cvt->len_cvt * 2)) - 1;\n    for (i = cvt->len_cvt / sizeof (Uint16); i; --i, --src, --dst) {\n        const Sint32 val = (((Sint32) ((Sint16) SDL_SwapLE16(*src))) << 16);\n        *dst = ((Sint32) SDL_SwapBE32(val));\n    }\n\n    cvt->len_cvt *= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S32MSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S16LSB_to_F32LSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint16 *src;\n    float *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S16LSB to AUDIO_F32LSB.\\n\");\n#endif\n\n    src = ((const Uint16 *) (cvt->buf + cvt->len_cvt)) - 1;\n    dst = ((float *) (cvt->buf + cvt->len_cvt * 2)) - 1;\n    for (i = cvt->len_cvt / sizeof (Uint16); i; --i, --src, --dst) {\n        const float val = (((float) ((Sint16) SDL_SwapLE16(*src))) * DIVBY32767);\n        *dst = SDL_SwapFloatLE(val);\n    }\n\n    cvt->len_cvt *= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_F32LSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S16LSB_to_F32MSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint16 *src;\n    float *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S16LSB to AUDIO_F32MSB.\\n\");\n#endif\n\n    src = ((const Uint16 *) (cvt->buf + cvt->len_cvt)) - 1;\n    dst = ((float *) (cvt->buf + cvt->len_cvt * 2)) - 1;\n    for (i = cvt->len_cvt / sizeof (Uint16); i; --i, --src, --dst) {\n        const float val = (((float) ((Sint16) SDL_SwapLE16(*src))) * DIVBY32767);\n        *dst = SDL_SwapFloatBE(val);\n    }\n\n    cvt->len_cvt *= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_F32MSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_U16MSB_to_U8(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint16 *src;\n    Uint8 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_U16MSB to AUDIO_U8.\\n\");\n#endif\n\n    src = (const Uint16 *) cvt->buf;\n    dst = (Uint8 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint16); i; --i, ++src, ++dst) {\n        const Uint8 val = ((Uint8) (SDL_SwapBE16(*src) >> 8));\n        *dst = val;\n    }\n\n    cvt->len_cvt /= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_U8);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_U16MSB_to_S8(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint16 *src;\n    Sint8 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_U16MSB to AUDIO_S8.\\n\");\n#endif\n\n    src = (const Uint16 *) cvt->buf;\n    dst = (Sint8 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint16); i; --i, ++src, ++dst) {\n        const Sint8 val = ((Sint8) (((SDL_SwapBE16(*src)) ^ 0x8000) >> 8));\n        *dst = ((Sint8) val);\n    }\n\n    cvt->len_cvt /= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S8);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_U16MSB_to_U16LSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint16 *src;\n    Uint16 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_U16MSB to AUDIO_U16LSB.\\n\");\n#endif\n\n    src = (const Uint16 *) cvt->buf;\n    dst = (Uint16 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint16); i; --i, ++src, ++dst) {\n        const Uint16 val = SDL_SwapBE16(*src);\n        *dst = SDL_SwapLE16(val);\n    }\n\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_U16LSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_U16MSB_to_S16LSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint16 *src;\n    Sint16 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_U16MSB to AUDIO_S16LSB.\\n\");\n#endif\n\n    src = (const Uint16 *) cvt->buf;\n    dst = (Sint16 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint16); i; --i, ++src, ++dst) {\n        const Sint16 val = ((SDL_SwapBE16(*src)) ^ 0x8000);\n        *dst = ((Sint16) SDL_SwapLE16(val));\n    }\n\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S16LSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_U16MSB_to_S16MSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint16 *src;\n    Sint16 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_U16MSB to AUDIO_S16MSB.\\n\");\n#endif\n\n    src = (const Uint16 *) cvt->buf;\n    dst = (Sint16 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint16); i; --i, ++src, ++dst) {\n        const Sint16 val = ((SDL_SwapBE16(*src)) ^ 0x8000);\n        *dst = ((Sint16) SDL_SwapBE16(val));\n    }\n\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S16MSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_U16MSB_to_S32LSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint16 *src;\n    Sint32 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_U16MSB to AUDIO_S32LSB.\\n\");\n#endif\n\n    src = ((const Uint16 *) (cvt->buf + cvt->len_cvt)) - 1;\n    dst = ((Sint32 *) (cvt->buf + cvt->len_cvt * 2)) - 1;\n    for (i = cvt->len_cvt / sizeof (Uint16); i; --i, --src, --dst) {\n        const Sint32 val = (((Sint32) ((SDL_SwapBE16(*src)) ^ 0x8000)) << 16);\n        *dst = ((Sint32) SDL_SwapLE32(val));\n    }\n\n    cvt->len_cvt *= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S32LSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_U16MSB_to_S32MSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint16 *src;\n    Sint32 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_U16MSB to AUDIO_S32MSB.\\n\");\n#endif\n\n    src = ((const Uint16 *) (cvt->buf + cvt->len_cvt)) - 1;\n    dst = ((Sint32 *) (cvt->buf + cvt->len_cvt * 2)) - 1;\n    for (i = cvt->len_cvt / sizeof (Uint16); i; --i, --src, --dst) {\n        const Sint32 val = (((Sint32) ((SDL_SwapBE16(*src)) ^ 0x8000)) << 16);\n        *dst = ((Sint32) SDL_SwapBE32(val));\n    }\n\n    cvt->len_cvt *= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S32MSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_U16MSB_to_F32LSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint16 *src;\n    float *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_U16MSB to AUDIO_F32LSB.\\n\");\n#endif\n\n    src = ((const Uint16 *) (cvt->buf + cvt->len_cvt)) - 1;\n    dst = ((float *) (cvt->buf + cvt->len_cvt * 2)) - 1;\n    for (i = cvt->len_cvt / sizeof (Uint16); i; --i, --src, --dst) {\n        const float val = ((((float) SDL_SwapBE16(*src)) * DIVBY32767) - 1.0f);\n        *dst = SDL_SwapFloatLE(val);\n    }\n\n    cvt->len_cvt *= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_F32LSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_U16MSB_to_F32MSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint16 *src;\n    float *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_U16MSB to AUDIO_F32MSB.\\n\");\n#endif\n\n    src = ((const Uint16 *) (cvt->buf + cvt->len_cvt)) - 1;\n    dst = ((float *) (cvt->buf + cvt->len_cvt * 2)) - 1;\n    for (i = cvt->len_cvt / sizeof (Uint16); i; --i, --src, --dst) {\n        const float val = ((((float) SDL_SwapBE16(*src)) * DIVBY32767) - 1.0f);\n        *dst = SDL_SwapFloatBE(val);\n    }\n\n    cvt->len_cvt *= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_F32MSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S16MSB_to_U8(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint16 *src;\n    Uint8 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S16MSB to AUDIO_U8.\\n\");\n#endif\n\n    src = (const Uint16 *) cvt->buf;\n    dst = (Uint8 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint16); i; --i, ++src, ++dst) {\n        const Uint8 val = ((Uint8) (((((Sint16) SDL_SwapBE16(*src))) ^ 0x8000) >> 8));\n        *dst = val;\n    }\n\n    cvt->len_cvt /= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_U8);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S16MSB_to_S8(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint16 *src;\n    Sint8 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S16MSB to AUDIO_S8.\\n\");\n#endif\n\n    src = (const Uint16 *) cvt->buf;\n    dst = (Sint8 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint16); i; --i, ++src, ++dst) {\n        const Sint8 val = ((Sint8) (((Sint16) SDL_SwapBE16(*src)) >> 8));\n        *dst = ((Sint8) val);\n    }\n\n    cvt->len_cvt /= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S8);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S16MSB_to_U16LSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint16 *src;\n    Uint16 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S16MSB to AUDIO_U16LSB.\\n\");\n#endif\n\n    src = (const Uint16 *) cvt->buf;\n    dst = (Uint16 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint16); i; --i, ++src, ++dst) {\n        const Uint16 val = ((((Sint16) SDL_SwapBE16(*src))) ^ 0x8000);\n        *dst = SDL_SwapLE16(val);\n    }\n\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_U16LSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S16MSB_to_S16LSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint16 *src;\n    Sint16 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S16MSB to AUDIO_S16LSB.\\n\");\n#endif\n\n    src = (const Uint16 *) cvt->buf;\n    dst = (Sint16 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint16); i; --i, ++src, ++dst) {\n        const Sint16 val = ((Sint16) SDL_SwapBE16(*src));\n        *dst = ((Sint16) SDL_SwapLE16(val));\n    }\n\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S16LSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S16MSB_to_U16MSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint16 *src;\n    Uint16 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S16MSB to AUDIO_U16MSB.\\n\");\n#endif\n\n    src = (const Uint16 *) cvt->buf;\n    dst = (Uint16 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint16); i; --i, ++src, ++dst) {\n        const Uint16 val = ((((Sint16) SDL_SwapBE16(*src))) ^ 0x8000);\n        *dst = SDL_SwapBE16(val);\n    }\n\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_U16MSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S16MSB_to_S32LSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint16 *src;\n    Sint32 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S16MSB to AUDIO_S32LSB.\\n\");\n#endif\n\n    src = ((const Uint16 *) (cvt->buf + cvt->len_cvt)) - 1;\n    dst = ((Sint32 *) (cvt->buf + cvt->len_cvt * 2)) - 1;\n    for (i = cvt->len_cvt / sizeof (Uint16); i; --i, --src, --dst) {\n        const Sint32 val = (((Sint32) ((Sint16) SDL_SwapBE16(*src))) << 16);\n        *dst = ((Sint32) SDL_SwapLE32(val));\n    }\n\n    cvt->len_cvt *= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S32LSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S16MSB_to_S32MSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint16 *src;\n    Sint32 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S16MSB to AUDIO_S32MSB.\\n\");\n#endif\n\n    src = ((const Uint16 *) (cvt->buf + cvt->len_cvt)) - 1;\n    dst = ((Sint32 *) (cvt->buf + cvt->len_cvt * 2)) - 1;\n    for (i = cvt->len_cvt / sizeof (Uint16); i; --i, --src, --dst) {\n        const Sint32 val = (((Sint32) ((Sint16) SDL_SwapBE16(*src))) << 16);\n        *dst = ((Sint32) SDL_SwapBE32(val));\n    }\n\n    cvt->len_cvt *= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S32MSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S16MSB_to_F32LSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint16 *src;\n    float *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S16MSB to AUDIO_F32LSB.\\n\");\n#endif\n\n    src = ((const Uint16 *) (cvt->buf + cvt->len_cvt)) - 1;\n    dst = ((float *) (cvt->buf + cvt->len_cvt * 2)) - 1;\n    for (i = cvt->len_cvt / sizeof (Uint16); i; --i, --src, --dst) {\n        const float val = (((float) ((Sint16) SDL_SwapBE16(*src))) * DIVBY32767);\n        *dst = SDL_SwapFloatLE(val);\n    }\n\n    cvt->len_cvt *= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_F32LSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S16MSB_to_F32MSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint16 *src;\n    float *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S16MSB to AUDIO_F32MSB.\\n\");\n#endif\n\n    src = ((const Uint16 *) (cvt->buf + cvt->len_cvt)) - 1;\n    dst = ((float *) (cvt->buf + cvt->len_cvt * 2)) - 1;\n    for (i = cvt->len_cvt / sizeof (Uint16); i; --i, --src, --dst) {\n        const float val = (((float) ((Sint16) SDL_SwapBE16(*src))) * DIVBY32767);\n        *dst = SDL_SwapFloatBE(val);\n    }\n\n    cvt->len_cvt *= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_F32MSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S32LSB_to_U8(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint32 *src;\n    Uint8 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S32LSB to AUDIO_U8.\\n\");\n#endif\n\n    src = (const Uint32 *) cvt->buf;\n    dst = (Uint8 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint32); i; --i, ++src, ++dst) {\n        const Uint8 val = ((Uint8) (((((Sint32) SDL_SwapLE32(*src))) ^ 0x80000000) >> 24));\n        *dst = val;\n    }\n\n    cvt->len_cvt /= 4;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_U8);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S32LSB_to_S8(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint32 *src;\n    Sint8 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S32LSB to AUDIO_S8.\\n\");\n#endif\n\n    src = (const Uint32 *) cvt->buf;\n    dst = (Sint8 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint32); i; --i, ++src, ++dst) {\n        const Sint8 val = ((Sint8) (((Sint32) SDL_SwapLE32(*src)) >> 24));\n        *dst = ((Sint8) val);\n    }\n\n    cvt->len_cvt /= 4;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S8);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S32LSB_to_U16LSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint32 *src;\n    Uint16 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S32LSB to AUDIO_U16LSB.\\n\");\n#endif\n\n    src = (const Uint32 *) cvt->buf;\n    dst = (Uint16 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint32); i; --i, ++src, ++dst) {\n        const Uint16 val = ((Uint16) (((((Sint32) SDL_SwapLE32(*src))) ^ 0x80000000) >> 16));\n        *dst = SDL_SwapLE16(val);\n    }\n\n    cvt->len_cvt /= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_U16LSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S32LSB_to_S16LSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint32 *src;\n    Sint16 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S32LSB to AUDIO_S16LSB.\\n\");\n#endif\n\n    src = (const Uint32 *) cvt->buf;\n    dst = (Sint16 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint32); i; --i, ++src, ++dst) {\n        const Sint16 val = ((Sint16) (((Sint32) SDL_SwapLE32(*src)) >> 16));\n        *dst = ((Sint16) SDL_SwapLE16(val));\n    }\n\n    cvt->len_cvt /= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S16LSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S32LSB_to_U16MSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint32 *src;\n    Uint16 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S32LSB to AUDIO_U16MSB.\\n\");\n#endif\n\n    src = (const Uint32 *) cvt->buf;\n    dst = (Uint16 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint32); i; --i, ++src, ++dst) {\n        const Uint16 val = ((Uint16) (((((Sint32) SDL_SwapLE32(*src))) ^ 0x80000000) >> 16));\n        *dst = SDL_SwapBE16(val);\n    }\n\n    cvt->len_cvt /= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_U16MSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S32LSB_to_S16MSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint32 *src;\n    Sint16 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S32LSB to AUDIO_S16MSB.\\n\");\n#endif\n\n    src = (const Uint32 *) cvt->buf;\n    dst = (Sint16 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint32); i; --i, ++src, ++dst) {\n        const Sint16 val = ((Sint16) (((Sint32) SDL_SwapLE32(*src)) >> 16));\n        *dst = ((Sint16) SDL_SwapBE16(val));\n    }\n\n    cvt->len_cvt /= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S16MSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S32LSB_to_S32MSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint32 *src;\n    Sint32 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S32LSB to AUDIO_S32MSB.\\n\");\n#endif\n\n    src = (const Uint32 *) cvt->buf;\n    dst = (Sint32 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint32); i; --i, ++src, ++dst) {\n        const Sint32 val = ((Sint32) SDL_SwapLE32(*src));\n        *dst = ((Sint32) SDL_SwapBE32(val));\n    }\n\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S32MSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S32LSB_to_F32LSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint32 *src;\n    float *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S32LSB to AUDIO_F32LSB.\\n\");\n#endif\n\n    src = (const Uint32 *) cvt->buf;\n    dst = (float *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint32); i; --i, ++src, ++dst) {\n        const float val = (((float) ((Sint32) SDL_SwapLE32(*src))) * DIVBY2147483647);\n        *dst = SDL_SwapFloatLE(val);\n    }\n\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_F32LSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S32LSB_to_F32MSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint32 *src;\n    float *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S32LSB to AUDIO_F32MSB.\\n\");\n#endif\n\n    src = (const Uint32 *) cvt->buf;\n    dst = (float *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint32); i; --i, ++src, ++dst) {\n        const float val = (((float) ((Sint32) SDL_SwapLE32(*src))) * DIVBY2147483647);\n        *dst = SDL_SwapFloatBE(val);\n    }\n\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_F32MSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S32MSB_to_U8(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint32 *src;\n    Uint8 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S32MSB to AUDIO_U8.\\n\");\n#endif\n\n    src = (const Uint32 *) cvt->buf;\n    dst = (Uint8 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint32); i; --i, ++src, ++dst) {\n        const Uint8 val = ((Uint8) (((((Sint32) SDL_SwapBE32(*src))) ^ 0x80000000) >> 24));\n        *dst = val;\n    }\n\n    cvt->len_cvt /= 4;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_U8);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S32MSB_to_S8(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint32 *src;\n    Sint8 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S32MSB to AUDIO_S8.\\n\");\n#endif\n\n    src = (const Uint32 *) cvt->buf;\n    dst = (Sint8 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint32); i; --i, ++src, ++dst) {\n        const Sint8 val = ((Sint8) (((Sint32) SDL_SwapBE32(*src)) >> 24));\n        *dst = ((Sint8) val);\n    }\n\n    cvt->len_cvt /= 4;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S8);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S32MSB_to_U16LSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint32 *src;\n    Uint16 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S32MSB to AUDIO_U16LSB.\\n\");\n#endif\n\n    src = (const Uint32 *) cvt->buf;\n    dst = (Uint16 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint32); i; --i, ++src, ++dst) {\n        const Uint16 val = ((Uint16) (((((Sint32) SDL_SwapBE32(*src))) ^ 0x80000000) >> 16));\n        *dst = SDL_SwapLE16(val);\n    }\n\n    cvt->len_cvt /= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_U16LSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S32MSB_to_S16LSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint32 *src;\n    Sint16 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S32MSB to AUDIO_S16LSB.\\n\");\n#endif\n\n    src = (const Uint32 *) cvt->buf;\n    dst = (Sint16 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint32); i; --i, ++src, ++dst) {\n        const Sint16 val = ((Sint16) (((Sint32) SDL_SwapBE32(*src)) >> 16));\n        *dst = ((Sint16) SDL_SwapLE16(val));\n    }\n\n    cvt->len_cvt /= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S16LSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S32MSB_to_U16MSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint32 *src;\n    Uint16 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S32MSB to AUDIO_U16MSB.\\n\");\n#endif\n\n    src = (const Uint32 *) cvt->buf;\n    dst = (Uint16 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint32); i; --i, ++src, ++dst) {\n        const Uint16 val = ((Uint16) (((((Sint32) SDL_SwapBE32(*src))) ^ 0x80000000) >> 16));\n        *dst = SDL_SwapBE16(val);\n    }\n\n    cvt->len_cvt /= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_U16MSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S32MSB_to_S16MSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint32 *src;\n    Sint16 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S32MSB to AUDIO_S16MSB.\\n\");\n#endif\n\n    src = (const Uint32 *) cvt->buf;\n    dst = (Sint16 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint32); i; --i, ++src, ++dst) {\n        const Sint16 val = ((Sint16) (((Sint32) SDL_SwapBE32(*src)) >> 16));\n        *dst = ((Sint16) SDL_SwapBE16(val));\n    }\n\n    cvt->len_cvt /= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S16MSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S32MSB_to_S32LSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint32 *src;\n    Sint32 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S32MSB to AUDIO_S32LSB.\\n\");\n#endif\n\n    src = (const Uint32 *) cvt->buf;\n    dst = (Sint32 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint32); i; --i, ++src, ++dst) {\n        const Sint32 val = ((Sint32) SDL_SwapBE32(*src));\n        *dst = ((Sint32) SDL_SwapLE32(val));\n    }\n\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S32LSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S32MSB_to_F32LSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint32 *src;\n    float *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S32MSB to AUDIO_F32LSB.\\n\");\n#endif\n\n    src = (const Uint32 *) cvt->buf;\n    dst = (float *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint32); i; --i, ++src, ++dst) {\n        const float val = (((float) ((Sint32) SDL_SwapBE32(*src))) * DIVBY2147483647);\n        *dst = SDL_SwapFloatLE(val);\n    }\n\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_F32LSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_S32MSB_to_F32MSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const Uint32 *src;\n    float *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_S32MSB to AUDIO_F32MSB.\\n\");\n#endif\n\n    src = (const Uint32 *) cvt->buf;\n    dst = (float *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (Uint32); i; --i, ++src, ++dst) {\n        const float val = (((float) ((Sint32) SDL_SwapBE32(*src))) * DIVBY2147483647);\n        *dst = SDL_SwapFloatBE(val);\n    }\n\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_F32MSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_F32LSB_to_U8(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const float *src;\n    Uint8 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_F32LSB to AUDIO_U8.\\n\");\n#endif\n\n    src = (const float *) cvt->buf;\n    dst = (Uint8 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (float); i; --i, ++src, ++dst) {\n        const Uint8 val = ((Uint8) ((SDL_SwapFloatLE(*src) + 1.0f) * 127.0f));\n        *dst = val;\n    }\n\n    cvt->len_cvt /= 4;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_U8);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_F32LSB_to_S8(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const float *src;\n    Sint8 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_F32LSB to AUDIO_S8.\\n\");\n#endif\n\n    src = (const float *) cvt->buf;\n    dst = (Sint8 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (float); i; --i, ++src, ++dst) {\n        const Sint8 val = ((Sint8) (SDL_SwapFloatLE(*src) * 127.0f));\n        *dst = ((Sint8) val);\n    }\n\n    cvt->len_cvt /= 4;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S8);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_F32LSB_to_U16LSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const float *src;\n    Uint16 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_F32LSB to AUDIO_U16LSB.\\n\");\n#endif\n\n    src = (const float *) cvt->buf;\n    dst = (Uint16 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (float); i; --i, ++src, ++dst) {\n        const Uint16 val = ((Uint16) ((SDL_SwapFloatLE(*src) + 1.0f) * 32767.0f));\n        *dst = SDL_SwapLE16(val);\n    }\n\n    cvt->len_cvt /= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_U16LSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_F32LSB_to_S16LSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const float *src;\n    Sint16 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_F32LSB to AUDIO_S16LSB.\\n\");\n#endif\n\n    src = (const float *) cvt->buf;\n    dst = (Sint16 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (float); i; --i, ++src, ++dst) {\n        const Sint16 val = ((Sint16) (SDL_SwapFloatLE(*src) * 32767.0f));\n        *dst = ((Sint16) SDL_SwapLE16(val));\n    }\n\n    cvt->len_cvt /= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S16LSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_F32LSB_to_U16MSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const float *src;\n    Uint16 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_F32LSB to AUDIO_U16MSB.\\n\");\n#endif\n\n    src = (const float *) cvt->buf;\n    dst = (Uint16 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (float); i; --i, ++src, ++dst) {\n        const Uint16 val = ((Uint16) ((SDL_SwapFloatLE(*src) + 1.0f) * 32767.0f));\n        *dst = SDL_SwapBE16(val);\n    }\n\n    cvt->len_cvt /= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_U16MSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_F32LSB_to_S16MSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const float *src;\n    Sint16 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_F32LSB to AUDIO_S16MSB.\\n\");\n#endif\n\n    src = (const float *) cvt->buf;\n    dst = (Sint16 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (float); i; --i, ++src, ++dst) {\n        const Sint16 val = ((Sint16) (SDL_SwapFloatLE(*src) * 32767.0f));\n        *dst = ((Sint16) SDL_SwapBE16(val));\n    }\n\n    cvt->len_cvt /= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S16MSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_F32LSB_to_S32LSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const float *src;\n    Sint32 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_F32LSB to AUDIO_S32LSB.\\n\");\n#endif\n\n    src = (const float *) cvt->buf;\n    dst = (Sint32 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (float); i; --i, ++src, ++dst) {\n        const Sint32 val = ((Sint32) (SDL_SwapFloatLE(*src) * 2147483647.0));\n        *dst = ((Sint32) SDL_SwapLE32(val));\n    }\n\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S32LSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_F32LSB_to_S32MSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const float *src;\n    Sint32 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_F32LSB to AUDIO_S32MSB.\\n\");\n#endif\n\n    src = (const float *) cvt->buf;\n    dst = (Sint32 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (float); i; --i, ++src, ++dst) {\n        const Sint32 val = ((Sint32) (SDL_SwapFloatLE(*src) * 2147483647.0));\n        *dst = ((Sint32) SDL_SwapBE32(val));\n    }\n\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S32MSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_F32LSB_to_F32MSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const float *src;\n    float *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_F32LSB to AUDIO_F32MSB.\\n\");\n#endif\n\n    src = (const float *) cvt->buf;\n    dst = (float *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (float); i; --i, ++src, ++dst) {\n        const float val = SDL_SwapFloatLE(*src);\n        *dst = SDL_SwapFloatBE(val);\n    }\n\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_F32MSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_F32MSB_to_U8(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const float *src;\n    Uint8 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_F32MSB to AUDIO_U8.\\n\");\n#endif\n\n    src = (const float *) cvt->buf;\n    dst = (Uint8 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (float); i; --i, ++src, ++dst) {\n        const Uint8 val = ((Uint8) ((SDL_SwapFloatBE(*src) + 1.0f) * 127.0f));\n        *dst = val;\n    }\n\n    cvt->len_cvt /= 4;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_U8);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_F32MSB_to_S8(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const float *src;\n    Sint8 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_F32MSB to AUDIO_S8.\\n\");\n#endif\n\n    src = (const float *) cvt->buf;\n    dst = (Sint8 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (float); i; --i, ++src, ++dst) {\n        const Sint8 val = ((Sint8) (SDL_SwapFloatBE(*src) * 127.0f));\n        *dst = ((Sint8) val);\n    }\n\n    cvt->len_cvt /= 4;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S8);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_F32MSB_to_U16LSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const float *src;\n    Uint16 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_F32MSB to AUDIO_U16LSB.\\n\");\n#endif\n\n    src = (const float *) cvt->buf;\n    dst = (Uint16 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (float); i; --i, ++src, ++dst) {\n        const Uint16 val = ((Uint16) ((SDL_SwapFloatBE(*src) + 1.0f) * 32767.0f));\n        *dst = SDL_SwapLE16(val);\n    }\n\n    cvt->len_cvt /= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_U16LSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_F32MSB_to_S16LSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const float *src;\n    Sint16 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_F32MSB to AUDIO_S16LSB.\\n\");\n#endif\n\n    src = (const float *) cvt->buf;\n    dst = (Sint16 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (float); i; --i, ++src, ++dst) {\n        const Sint16 val = ((Sint16) (SDL_SwapFloatBE(*src) * 32767.0f));\n        *dst = ((Sint16) SDL_SwapLE16(val));\n    }\n\n    cvt->len_cvt /= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S16LSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_F32MSB_to_U16MSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const float *src;\n    Uint16 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_F32MSB to AUDIO_U16MSB.\\n\");\n#endif\n\n    src = (const float *) cvt->buf;\n    dst = (Uint16 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (float); i; --i, ++src, ++dst) {\n        const Uint16 val = ((Uint16) ((SDL_SwapFloatBE(*src) + 1.0f) * 32767.0f));\n        *dst = SDL_SwapBE16(val);\n    }\n\n    cvt->len_cvt /= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_U16MSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_F32MSB_to_S16MSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const float *src;\n    Sint16 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_F32MSB to AUDIO_S16MSB.\\n\");\n#endif\n\n    src = (const float *) cvt->buf;\n    dst = (Sint16 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (float); i; --i, ++src, ++dst) {\n        const Sint16 val = ((Sint16) (SDL_SwapFloatBE(*src) * 32767.0f));\n        *dst = ((Sint16) SDL_SwapBE16(val));\n    }\n\n    cvt->len_cvt /= 2;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S16MSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_F32MSB_to_S32LSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const float *src;\n    Sint32 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_F32MSB to AUDIO_S32LSB.\\n\");\n#endif\n\n    src = (const float *) cvt->buf;\n    dst = (Sint32 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (float); i; --i, ++src, ++dst) {\n        const Sint32 val = ((Sint32) (SDL_SwapFloatBE(*src) * 2147483647.0));\n        *dst = ((Sint32) SDL_SwapLE32(val));\n    }\n\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S32LSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_F32MSB_to_S32MSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const float *src;\n    Sint32 *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_F32MSB to AUDIO_S32MSB.\\n\");\n#endif\n\n    src = (const float *) cvt->buf;\n    dst = (Sint32 *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (float); i; --i, ++src, ++dst) {\n        const Sint32 val = ((Sint32) (SDL_SwapFloatBE(*src) * 2147483647.0));\n        *dst = ((Sint32) SDL_SwapBE32(val));\n    }\n\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_S32MSB);\n    }\n}\n\nstatic void SDLCALL\nSDL_Convert_F32MSB_to_F32LSB(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n    int i;\n    const float *src;\n    float *dst;\n\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Converting AUDIO_F32MSB to AUDIO_F32LSB.\\n\");\n#endif\n\n    src = (const float *) cvt->buf;\n    dst = (float *) cvt->buf;\n    for (i = cvt->len_cvt / sizeof (float); i; --i, ++src, ++dst) {\n        const float val = SDL_SwapFloatBE(*src);\n        *dst = SDL_SwapFloatLE(val);\n    }\n\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, AUDIO_F32LSB);\n    }\n}\n\n#endif  /* !NO_CONVERTERS */\n\n\nconst SDL_AudioTypeFilters sdl_audio_type_filters[] =\n{\n#if !NO_CONVERTERS\n    { AUDIO_U8, AUDIO_S8, SDL_Convert_U8_to_S8 },\n    { AUDIO_U8, AUDIO_U16LSB, SDL_Convert_U8_to_U16LSB },\n    { AUDIO_U8, AUDIO_S16LSB, SDL_Convert_U8_to_S16LSB },\n    { AUDIO_U8, AUDIO_U16MSB, SDL_Convert_U8_to_U16MSB },\n    { AUDIO_U8, AUDIO_S16MSB, SDL_Convert_U8_to_S16MSB },\n    { AUDIO_U8, AUDIO_S32LSB, SDL_Convert_U8_to_S32LSB },\n    { AUDIO_U8, AUDIO_S32MSB, SDL_Convert_U8_to_S32MSB },\n    { AUDIO_U8, AUDIO_F32LSB, SDL_Convert_U8_to_F32LSB },\n    { AUDIO_U8, AUDIO_F32MSB, SDL_Convert_U8_to_F32MSB },\n    { AUDIO_S8, AUDIO_U8, SDL_Convert_S8_to_U8 },\n    { AUDIO_S8, AUDIO_U16LSB, SDL_Convert_S8_to_U16LSB },\n    { AUDIO_S8, AUDIO_S16LSB, SDL_Convert_S8_to_S16LSB },\n    { AUDIO_S8, AUDIO_U16MSB, SDL_Convert_S8_to_U16MSB },\n    { AUDIO_S8, AUDIO_S16MSB, SDL_Convert_S8_to_S16MSB },\n    { AUDIO_S8, AUDIO_S32LSB, SDL_Convert_S8_to_S32LSB },\n    { AUDIO_S8, AUDIO_S32MSB, SDL_Convert_S8_to_S32MSB },\n    { AUDIO_S8, AUDIO_F32LSB, SDL_Convert_S8_to_F32LSB },\n    { AUDIO_S8, AUDIO_F32MSB, SDL_Convert_S8_to_F32MSB },\n    { AUDIO_U16LSB, AUDIO_U8, SDL_Convert_U16LSB_to_U8 },\n    { AUDIO_U16LSB, AUDIO_S8, SDL_Convert_U16LSB_to_S8 },\n    { AUDIO_U16LSB, AUDIO_S16LSB, SDL_Convert_U16LSB_to_S16LSB },\n    { AUDIO_U16LSB, AUDIO_U16MSB, SDL_Convert_U16LSB_to_U16MSB },\n    { AUDIO_U16LSB, AUDIO_S16MSB, SDL_Convert_U16LSB_to_S16MSB },\n    { AUDIO_U16LSB, AUDIO_S32LSB, SDL_Convert_U16LSB_to_S32LSB },\n    { AUDIO_U16LSB, AUDIO_S32MSB, SDL_Convert_U16LSB_to_S32MSB },\n    { AUDIO_U16LSB, AUDIO_F32LSB, SDL_Convert_U16LSB_to_F32LSB },\n    { AUDIO_U16LSB, AUDIO_F32MSB, SDL_Convert_U16LSB_to_F32MSB },\n    { AUDIO_S16LSB, AUDIO_U8, SDL_Convert_S16LSB_to_U8 },\n    { AUDIO_S16LSB, AUDIO_S8, SDL_Convert_S16LSB_to_S8 },\n    { AUDIO_S16LSB, AUDIO_U16LSB, SDL_Convert_S16LSB_to_U16LSB },\n    { AUDIO_S16LSB, AUDIO_U16MSB, SDL_Convert_S16LSB_to_U16MSB },\n    { AUDIO_S16LSB, AUDIO_S16MSB, SDL_Convert_S16LSB_to_S16MSB },\n    { AUDIO_S16LSB, AUDIO_S32LSB, SDL_Convert_S16LSB_to_S32LSB },\n    { AUDIO_S16LSB, AUDIO_S32MSB, SDL_Convert_S16LSB_to_S32MSB },\n    { AUDIO_S16LSB, AUDIO_F32LSB, SDL_Convert_S16LSB_to_F32LSB },\n    { AUDIO_S16LSB, AUDIO_F32MSB, SDL_Convert_S16LSB_to_F32MSB },\n    { AUDIO_U16MSB, AUDIO_U8, SDL_Convert_U16MSB_to_U8 },\n    { AUDIO_U16MSB, AUDIO_S8, SDL_Convert_U16MSB_to_S8 },\n    { AUDIO_U16MSB, AUDIO_U16LSB, SDL_Convert_U16MSB_to_U16LSB },\n    { AUDIO_U16MSB, AUDIO_S16LSB, SDL_Convert_U16MSB_to_S16LSB },\n    { AUDIO_U16MSB, AUDIO_S16MSB, SDL_Convert_U16MSB_to_S16MSB },\n    { AUDIO_U16MSB, AUDIO_S32LSB, SDL_Convert_U16MSB_to_S32LSB },\n    { AUDIO_U16MSB, AUDIO_S32MSB, SDL_Convert_U16MSB_to_S32MSB },\n    { AUDIO_U16MSB, AUDIO_F32LSB, SDL_Convert_U16MSB_to_F32LSB },\n    { AUDIO_U16MSB, AUDIO_F32MSB, SDL_Convert_U16MSB_to_F32MSB },\n    { AUDIO_S16MSB, AUDIO_U8, SDL_Convert_S16MSB_to_U8 },\n    { AUDIO_S16MSB, AUDIO_S8, SDL_Convert_S16MSB_to_S8 },\n    { AUDIO_S16MSB, AUDIO_U16LSB, SDL_Convert_S16MSB_to_U16LSB },\n    { AUDIO_S16MSB, AUDIO_S16LSB, SDL_Convert_S16MSB_to_S16LSB },\n    { AUDIO_S16MSB, AUDIO_U16MSB, SDL_Convert_S16MSB_to_U16MSB },\n    { AUDIO_S16MSB, AUDIO_S32LSB, SDL_Convert_S16MSB_to_S32LSB },\n    { AUDIO_S16MSB, AUDIO_S32MSB, SDL_Convert_S16MSB_to_S32MSB },\n    { AUDIO_S16MSB, AUDIO_F32LSB, SDL_Convert_S16MSB_to_F32LSB },\n    { AUDIO_S16MSB, AUDIO_F32MSB, SDL_Convert_S16MSB_to_F32MSB },\n    { AUDIO_S32LSB, AUDIO_U8, SDL_Convert_S32LSB_to_U8 },\n    { AUDIO_S32LSB, AUDIO_S8, SDL_Convert_S32LSB_to_S8 },\n    { AUDIO_S32LSB, AUDIO_U16LSB, SDL_Convert_S32LSB_to_U16LSB },\n    { AUDIO_S32LSB, AUDIO_S16LSB, SDL_Convert_S32LSB_to_S16LSB },\n    { AUDIO_S32LSB, AUDIO_U16MSB, SDL_Convert_S32LSB_to_U16MSB },\n    { AUDIO_S32LSB, AUDIO_S16MSB, SDL_Convert_S32LSB_to_S16MSB },\n    { AUDIO_S32LSB, AUDIO_S32MSB, SDL_Convert_S32LSB_to_S32MSB },\n    { AUDIO_S32LSB, AUDIO_F32LSB, SDL_Convert_S32LSB_to_F32LSB },\n    { AUDIO_S32LSB, AUDIO_F32MSB, SDL_Convert_S32LSB_to_F32MSB },\n    { AUDIO_S32MSB, AUDIO_U8, SDL_Convert_S32MSB_to_U8 },\n    { AUDIO_S32MSB, AUDIO_S8, SDL_Convert_S32MSB_to_S8 },\n    { AUDIO_S32MSB, AUDIO_U16LSB, SDL_Convert_S32MSB_to_U16LSB },\n    { AUDIO_S32MSB, AUDIO_S16LSB, SDL_Convert_S32MSB_to_S16LSB },\n    { AUDIO_S32MSB, AUDIO_U16MSB, SDL_Convert_S32MSB_to_U16MSB },\n    { AUDIO_S32MSB, AUDIO_S16MSB, SDL_Convert_S32MSB_to_S16MSB },\n    { AUDIO_S32MSB, AUDIO_S32LSB, SDL_Convert_S32MSB_to_S32LSB },\n    { AUDIO_S32MSB, AUDIO_F32LSB, SDL_Convert_S32MSB_to_F32LSB },\n    { AUDIO_S32MSB, AUDIO_F32MSB, SDL_Convert_S32MSB_to_F32MSB },\n    { AUDIO_F32LSB, AUDIO_U8, SDL_Convert_F32LSB_to_U8 },\n    { AUDIO_F32LSB, AUDIO_S8, SDL_Convert_F32LSB_to_S8 },\n    { AUDIO_F32LSB, AUDIO_U16LSB, SDL_Convert_F32LSB_to_U16LSB },\n    { AUDIO_F32LSB, AUDIO_S16LSB, SDL_Convert_F32LSB_to_S16LSB },\n    { AUDIO_F32LSB, AUDIO_U16MSB, SDL_Convert_F32LSB_to_U16MSB },\n    { AUDIO_F32LSB, AUDIO_S16MSB, SDL_Convert_F32LSB_to_S16MSB },\n    { AUDIO_F32LSB, AUDIO_S32LSB, SDL_Convert_F32LSB_to_S32LSB },\n    { AUDIO_F32LSB, AUDIO_S32MSB, SDL_Convert_F32LSB_to_S32MSB },\n    { AUDIO_F32LSB, AUDIO_F32MSB, SDL_Convert_F32LSB_to_F32MSB },\n    { AUDIO_F32MSB, AUDIO_U8, SDL_Convert_F32MSB_to_U8 },\n    { AUDIO_F32MSB, AUDIO_S8, SDL_Convert_F32MSB_to_S8 },\n    { AUDIO_F32MSB, AUDIO_U16LSB, SDL_Convert_F32MSB_to_U16LSB },\n    { AUDIO_F32MSB, AUDIO_S16LSB, SDL_Convert_F32MSB_to_S16LSB },\n    { AUDIO_F32MSB, AUDIO_U16MSB, SDL_Convert_F32MSB_to_U16MSB },\n    { AUDIO_F32MSB, AUDIO_S16MSB, SDL_Convert_F32MSB_to_S16MSB },\n    { AUDIO_F32MSB, AUDIO_S32LSB, SDL_Convert_F32MSB_to_S32LSB },\n    { AUDIO_F32MSB, AUDIO_S32MSB, SDL_Convert_F32MSB_to_S32MSB },\n    { AUDIO_F32MSB, AUDIO_F32LSB, SDL_Convert_F32MSB_to_F32LSB },\n#endif  /* !NO_CONVERTERS */\n    { 0, 0, NULL }\n};\n\n\n#if !NO_RESAMPLERS\n\nstatic void SDLCALL\nSDL_Upsample_U8_1c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_U8, 1 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 16;\n    const int dstsize = (int) (((double)(cvt->len_cvt/1)) * cvt->rate_incr) * 1;\n    register int eps = 0;\n    Uint8 *dst = ((Uint8 *) (cvt->buf + dstsize)) - 1;\n    const Uint8 *src = ((Uint8 *) (cvt->buf + cvt->len_cvt)) - 1;\n    const Uint8 *target = ((const Uint8 *) cvt->buf);\n    Uint8 sample0 = src[0];\n    Uint8 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[0] = sample0;\n        dst--;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src--;\n            sample0 = (Uint8) ((((Sint16) src[0]) + ((Sint16) last_sample0)) >> 1);\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U8_1c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_U8, 1 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 16;\n    const int dstsize = (int) (((double)(cvt->len_cvt/1)) * cvt->rate_incr) * 1;\n    register int eps = 0;\n    Uint8 *dst = (Uint8 *) cvt->buf;\n    const Uint8 *src = (Uint8 *) cvt->buf;\n    const Uint8 *target = (const Uint8 *) (cvt->buf + dstsize);\n    Uint8 sample0 = src[0];\n    Uint8 last_sample0 = sample0;\n    while (dst < target) {\n        src++;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = sample0;\n            dst++;\n            sample0 = (Uint8) ((((Sint16) src[0]) + ((Sint16) last_sample0)) >> 1);\n            last_sample0 = sample0;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U8_2c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_U8, 2 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 32;\n    const int dstsize = (int) (((double)(cvt->len_cvt/2)) * cvt->rate_incr) * 2;\n    register int eps = 0;\n    Uint8 *dst = ((Uint8 *) (cvt->buf + dstsize)) - 2;\n    const Uint8 *src = ((Uint8 *) (cvt->buf + cvt->len_cvt)) - 2;\n    const Uint8 *target = ((const Uint8 *) cvt->buf);\n    Uint8 sample1 = src[1];\n    Uint8 sample0 = src[0];\n    Uint8 last_sample1 = sample1;\n    Uint8 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[1] = sample1;\n        dst[0] = sample0;\n        dst -= 2;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 2;\n            sample1 = (Uint8) ((((Sint16) src[1]) + ((Sint16) last_sample1)) >> 1);\n            sample0 = (Uint8) ((((Sint16) src[0]) + ((Sint16) last_sample0)) >> 1);\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U8_2c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_U8, 2 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 32;\n    const int dstsize = (int) (((double)(cvt->len_cvt/2)) * cvt->rate_incr) * 2;\n    register int eps = 0;\n    Uint8 *dst = (Uint8 *) cvt->buf;\n    const Uint8 *src = (Uint8 *) cvt->buf;\n    const Uint8 *target = (const Uint8 *) (cvt->buf + dstsize);\n    Uint8 sample0 = src[0];\n    Uint8 sample1 = src[1];\n    Uint8 last_sample0 = sample0;\n    Uint8 last_sample1 = sample1;\n    while (dst < target) {\n        src += 2;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = sample0;\n            dst[1] = sample1;\n            dst += 2;\n            sample0 = (Uint8) ((((Sint16) src[0]) + ((Sint16) last_sample0)) >> 1);\n            sample1 = (Uint8) ((((Sint16) src[1]) + ((Sint16) last_sample1)) >> 1);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U8_4c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_U8, 4 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 64;\n    const int dstsize = (int) (((double)(cvt->len_cvt/4)) * cvt->rate_incr) * 4;\n    register int eps = 0;\n    Uint8 *dst = ((Uint8 *) (cvt->buf + dstsize)) - 4;\n    const Uint8 *src = ((Uint8 *) (cvt->buf + cvt->len_cvt)) - 4;\n    const Uint8 *target = ((const Uint8 *) cvt->buf);\n    Uint8 sample3 = src[3];\n    Uint8 sample2 = src[2];\n    Uint8 sample1 = src[1];\n    Uint8 sample0 = src[0];\n    Uint8 last_sample3 = sample3;\n    Uint8 last_sample2 = sample2;\n    Uint8 last_sample1 = sample1;\n    Uint8 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[3] = sample3;\n        dst[2] = sample2;\n        dst[1] = sample1;\n        dst[0] = sample0;\n        dst -= 4;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 4;\n            sample3 = (Uint8) ((((Sint16) src[3]) + ((Sint16) last_sample3)) >> 1);\n            sample2 = (Uint8) ((((Sint16) src[2]) + ((Sint16) last_sample2)) >> 1);\n            sample1 = (Uint8) ((((Sint16) src[1]) + ((Sint16) last_sample1)) >> 1);\n            sample0 = (Uint8) ((((Sint16) src[0]) + ((Sint16) last_sample0)) >> 1);\n            last_sample3 = sample3;\n            last_sample2 = sample2;\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U8_4c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_U8, 4 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 64;\n    const int dstsize = (int) (((double)(cvt->len_cvt/4)) * cvt->rate_incr) * 4;\n    register int eps = 0;\n    Uint8 *dst = (Uint8 *) cvt->buf;\n    const Uint8 *src = (Uint8 *) cvt->buf;\n    const Uint8 *target = (const Uint8 *) (cvt->buf + dstsize);\n    Uint8 sample0 = src[0];\n    Uint8 sample1 = src[1];\n    Uint8 sample2 = src[2];\n    Uint8 sample3 = src[3];\n    Uint8 last_sample0 = sample0;\n    Uint8 last_sample1 = sample1;\n    Uint8 last_sample2 = sample2;\n    Uint8 last_sample3 = sample3;\n    while (dst < target) {\n        src += 4;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = sample0;\n            dst[1] = sample1;\n            dst[2] = sample2;\n            dst[3] = sample3;\n            dst += 4;\n            sample0 = (Uint8) ((((Sint16) src[0]) + ((Sint16) last_sample0)) >> 1);\n            sample1 = (Uint8) ((((Sint16) src[1]) + ((Sint16) last_sample1)) >> 1);\n            sample2 = (Uint8) ((((Sint16) src[2]) + ((Sint16) last_sample2)) >> 1);\n            sample3 = (Uint8) ((((Sint16) src[3]) + ((Sint16) last_sample3)) >> 1);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            last_sample2 = sample2;\n            last_sample3 = sample3;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U8_6c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_U8, 6 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 96;\n    const int dstsize = (int) (((double)(cvt->len_cvt/6)) * cvt->rate_incr) * 6;\n    register int eps = 0;\n    Uint8 *dst = ((Uint8 *) (cvt->buf + dstsize)) - 6;\n    const Uint8 *src = ((Uint8 *) (cvt->buf + cvt->len_cvt)) - 6;\n    const Uint8 *target = ((const Uint8 *) cvt->buf);\n    Uint8 sample5 = src[5];\n    Uint8 sample4 = src[4];\n    Uint8 sample3 = src[3];\n    Uint8 sample2 = src[2];\n    Uint8 sample1 = src[1];\n    Uint8 sample0 = src[0];\n    Uint8 last_sample5 = sample5;\n    Uint8 last_sample4 = sample4;\n    Uint8 last_sample3 = sample3;\n    Uint8 last_sample2 = sample2;\n    Uint8 last_sample1 = sample1;\n    Uint8 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[5] = sample5;\n        dst[4] = sample4;\n        dst[3] = sample3;\n        dst[2] = sample2;\n        dst[1] = sample1;\n        dst[0] = sample0;\n        dst -= 6;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 6;\n            sample5 = (Uint8) ((((Sint16) src[5]) + ((Sint16) last_sample5)) >> 1);\n            sample4 = (Uint8) ((((Sint16) src[4]) + ((Sint16) last_sample4)) >> 1);\n            sample3 = (Uint8) ((((Sint16) src[3]) + ((Sint16) last_sample3)) >> 1);\n            sample2 = (Uint8) ((((Sint16) src[2]) + ((Sint16) last_sample2)) >> 1);\n            sample1 = (Uint8) ((((Sint16) src[1]) + ((Sint16) last_sample1)) >> 1);\n            sample0 = (Uint8) ((((Sint16) src[0]) + ((Sint16) last_sample0)) >> 1);\n            last_sample5 = sample5;\n            last_sample4 = sample4;\n            last_sample3 = sample3;\n            last_sample2 = sample2;\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U8_6c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_U8, 6 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 96;\n    const int dstsize = (int) (((double)(cvt->len_cvt/6)) * cvt->rate_incr) * 6;\n    register int eps = 0;\n    Uint8 *dst = (Uint8 *) cvt->buf;\n    const Uint8 *src = (Uint8 *) cvt->buf;\n    const Uint8 *target = (const Uint8 *) (cvt->buf + dstsize);\n    Uint8 sample0 = src[0];\n    Uint8 sample1 = src[1];\n    Uint8 sample2 = src[2];\n    Uint8 sample3 = src[3];\n    Uint8 sample4 = src[4];\n    Uint8 sample5 = src[5];\n    Uint8 last_sample0 = sample0;\n    Uint8 last_sample1 = sample1;\n    Uint8 last_sample2 = sample2;\n    Uint8 last_sample3 = sample3;\n    Uint8 last_sample4 = sample4;\n    Uint8 last_sample5 = sample5;\n    while (dst < target) {\n        src += 6;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = sample0;\n            dst[1] = sample1;\n            dst[2] = sample2;\n            dst[3] = sample3;\n            dst[4] = sample4;\n            dst[5] = sample5;\n            dst += 6;\n            sample0 = (Uint8) ((((Sint16) src[0]) + ((Sint16) last_sample0)) >> 1);\n            sample1 = (Uint8) ((((Sint16) src[1]) + ((Sint16) last_sample1)) >> 1);\n            sample2 = (Uint8) ((((Sint16) src[2]) + ((Sint16) last_sample2)) >> 1);\n            sample3 = (Uint8) ((((Sint16) src[3]) + ((Sint16) last_sample3)) >> 1);\n            sample4 = (Uint8) ((((Sint16) src[4]) + ((Sint16) last_sample4)) >> 1);\n            sample5 = (Uint8) ((((Sint16) src[5]) + ((Sint16) last_sample5)) >> 1);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            last_sample2 = sample2;\n            last_sample3 = sample3;\n            last_sample4 = sample4;\n            last_sample5 = sample5;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U8_8c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_U8, 8 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 128;\n    const int dstsize = (int) (((double)(cvt->len_cvt/8)) * cvt->rate_incr) * 8;\n    register int eps = 0;\n    Uint8 *dst = ((Uint8 *) (cvt->buf + dstsize)) - 8;\n    const Uint8 *src = ((Uint8 *) (cvt->buf + cvt->len_cvt)) - 8;\n    const Uint8 *target = ((const Uint8 *) cvt->buf);\n    Uint8 sample7 = src[7];\n    Uint8 sample6 = src[6];\n    Uint8 sample5 = src[5];\n    Uint8 sample4 = src[4];\n    Uint8 sample3 = src[3];\n    Uint8 sample2 = src[2];\n    Uint8 sample1 = src[1];\n    Uint8 sample0 = src[0];\n    Uint8 last_sample7 = sample7;\n    Uint8 last_sample6 = sample6;\n    Uint8 last_sample5 = sample5;\n    Uint8 last_sample4 = sample4;\n    Uint8 last_sample3 = sample3;\n    Uint8 last_sample2 = sample2;\n    Uint8 last_sample1 = sample1;\n    Uint8 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[7] = sample7;\n        dst[6] = sample6;\n        dst[5] = sample5;\n        dst[4] = sample4;\n        dst[3] = sample3;\n        dst[2] = sample2;\n        dst[1] = sample1;\n        dst[0] = sample0;\n        dst -= 8;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 8;\n            sample7 = (Uint8) ((((Sint16) src[7]) + ((Sint16) last_sample7)) >> 1);\n            sample6 = (Uint8) ((((Sint16) src[6]) + ((Sint16) last_sample6)) >> 1);\n            sample5 = (Uint8) ((((Sint16) src[5]) + ((Sint16) last_sample5)) >> 1);\n            sample4 = (Uint8) ((((Sint16) src[4]) + ((Sint16) last_sample4)) >> 1);\n            sample3 = (Uint8) ((((Sint16) src[3]) + ((Sint16) last_sample3)) >> 1);\n            sample2 = (Uint8) ((((Sint16) src[2]) + ((Sint16) last_sample2)) >> 1);\n            sample1 = (Uint8) ((((Sint16) src[1]) + ((Sint16) last_sample1)) >> 1);\n            sample0 = (Uint8) ((((Sint16) src[0]) + ((Sint16) last_sample0)) >> 1);\n            last_sample7 = sample7;\n            last_sample6 = sample6;\n            last_sample5 = sample5;\n            last_sample4 = sample4;\n            last_sample3 = sample3;\n            last_sample2 = sample2;\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U8_8c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_U8, 8 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 128;\n    const int dstsize = (int) (((double)(cvt->len_cvt/8)) * cvt->rate_incr) * 8;\n    register int eps = 0;\n    Uint8 *dst = (Uint8 *) cvt->buf;\n    const Uint8 *src = (Uint8 *) cvt->buf;\n    const Uint8 *target = (const Uint8 *) (cvt->buf + dstsize);\n    Uint8 sample0 = src[0];\n    Uint8 sample1 = src[1];\n    Uint8 sample2 = src[2];\n    Uint8 sample3 = src[3];\n    Uint8 sample4 = src[4];\n    Uint8 sample5 = src[5];\n    Uint8 sample6 = src[6];\n    Uint8 sample7 = src[7];\n    Uint8 last_sample0 = sample0;\n    Uint8 last_sample1 = sample1;\n    Uint8 last_sample2 = sample2;\n    Uint8 last_sample3 = sample3;\n    Uint8 last_sample4 = sample4;\n    Uint8 last_sample5 = sample5;\n    Uint8 last_sample6 = sample6;\n    Uint8 last_sample7 = sample7;\n    while (dst < target) {\n        src += 8;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = sample0;\n            dst[1] = sample1;\n            dst[2] = sample2;\n            dst[3] = sample3;\n            dst[4] = sample4;\n            dst[5] = sample5;\n            dst[6] = sample6;\n            dst[7] = sample7;\n            dst += 8;\n            sample0 = (Uint8) ((((Sint16) src[0]) + ((Sint16) last_sample0)) >> 1);\n            sample1 = (Uint8) ((((Sint16) src[1]) + ((Sint16) last_sample1)) >> 1);\n            sample2 = (Uint8) ((((Sint16) src[2]) + ((Sint16) last_sample2)) >> 1);\n            sample3 = (Uint8) ((((Sint16) src[3]) + ((Sint16) last_sample3)) >> 1);\n            sample4 = (Uint8) ((((Sint16) src[4]) + ((Sint16) last_sample4)) >> 1);\n            sample5 = (Uint8) ((((Sint16) src[5]) + ((Sint16) last_sample5)) >> 1);\n            sample6 = (Uint8) ((((Sint16) src[6]) + ((Sint16) last_sample6)) >> 1);\n            sample7 = (Uint8) ((((Sint16) src[7]) + ((Sint16) last_sample7)) >> 1);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            last_sample2 = sample2;\n            last_sample3 = sample3;\n            last_sample4 = sample4;\n            last_sample5 = sample5;\n            last_sample6 = sample6;\n            last_sample7 = sample7;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S8_1c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_S8, 1 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 16;\n    const int dstsize = (int) (((double)(cvt->len_cvt/1)) * cvt->rate_incr) * 1;\n    register int eps = 0;\n    Sint8 *dst = ((Sint8 *) (cvt->buf + dstsize)) - 1;\n    const Sint8 *src = ((Sint8 *) (cvt->buf + cvt->len_cvt)) - 1;\n    const Sint8 *target = ((const Sint8 *) cvt->buf);\n    Sint8 sample0 = ((Sint8) src[0]);\n    Sint8 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[0] = ((Sint8) sample0);\n        dst--;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src--;\n            sample0 = (Sint8) ((((Sint16) ((Sint8) src[0])) + ((Sint16) last_sample0)) >> 1);\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S8_1c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_S8, 1 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 16;\n    const int dstsize = (int) (((double)(cvt->len_cvt/1)) * cvt->rate_incr) * 1;\n    register int eps = 0;\n    Sint8 *dst = (Sint8 *) cvt->buf;\n    const Sint8 *src = (Sint8 *) cvt->buf;\n    const Sint8 *target = (const Sint8 *) (cvt->buf + dstsize);\n    Sint8 sample0 = ((Sint8) src[0]);\n    Sint8 last_sample0 = sample0;\n    while (dst < target) {\n        src++;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = ((Sint8) sample0);\n            dst++;\n            sample0 = (Sint8) ((((Sint16) ((Sint8) src[0])) + ((Sint16) last_sample0)) >> 1);\n            last_sample0 = sample0;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S8_2c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_S8, 2 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 32;\n    const int dstsize = (int) (((double)(cvt->len_cvt/2)) * cvt->rate_incr) * 2;\n    register int eps = 0;\n    Sint8 *dst = ((Sint8 *) (cvt->buf + dstsize)) - 2;\n    const Sint8 *src = ((Sint8 *) (cvt->buf + cvt->len_cvt)) - 2;\n    const Sint8 *target = ((const Sint8 *) cvt->buf);\n    Sint8 sample1 = ((Sint8) src[1]);\n    Sint8 sample0 = ((Sint8) src[0]);\n    Sint8 last_sample1 = sample1;\n    Sint8 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[1] = ((Sint8) sample1);\n        dst[0] = ((Sint8) sample0);\n        dst -= 2;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 2;\n            sample1 = (Sint8) ((((Sint16) ((Sint8) src[1])) + ((Sint16) last_sample1)) >> 1);\n            sample0 = (Sint8) ((((Sint16) ((Sint8) src[0])) + ((Sint16) last_sample0)) >> 1);\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S8_2c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_S8, 2 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 32;\n    const int dstsize = (int) (((double)(cvt->len_cvt/2)) * cvt->rate_incr) * 2;\n    register int eps = 0;\n    Sint8 *dst = (Sint8 *) cvt->buf;\n    const Sint8 *src = (Sint8 *) cvt->buf;\n    const Sint8 *target = (const Sint8 *) (cvt->buf + dstsize);\n    Sint8 sample0 = ((Sint8) src[0]);\n    Sint8 sample1 = ((Sint8) src[1]);\n    Sint8 last_sample0 = sample0;\n    Sint8 last_sample1 = sample1;\n    while (dst < target) {\n        src += 2;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = ((Sint8) sample0);\n            dst[1] = ((Sint8) sample1);\n            dst += 2;\n            sample0 = (Sint8) ((((Sint16) ((Sint8) src[0])) + ((Sint16) last_sample0)) >> 1);\n            sample1 = (Sint8) ((((Sint16) ((Sint8) src[1])) + ((Sint16) last_sample1)) >> 1);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S8_4c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_S8, 4 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 64;\n    const int dstsize = (int) (((double)(cvt->len_cvt/4)) * cvt->rate_incr) * 4;\n    register int eps = 0;\n    Sint8 *dst = ((Sint8 *) (cvt->buf + dstsize)) - 4;\n    const Sint8 *src = ((Sint8 *) (cvt->buf + cvt->len_cvt)) - 4;\n    const Sint8 *target = ((const Sint8 *) cvt->buf);\n    Sint8 sample3 = ((Sint8) src[3]);\n    Sint8 sample2 = ((Sint8) src[2]);\n    Sint8 sample1 = ((Sint8) src[1]);\n    Sint8 sample0 = ((Sint8) src[0]);\n    Sint8 last_sample3 = sample3;\n    Sint8 last_sample2 = sample2;\n    Sint8 last_sample1 = sample1;\n    Sint8 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[3] = ((Sint8) sample3);\n        dst[2] = ((Sint8) sample2);\n        dst[1] = ((Sint8) sample1);\n        dst[0] = ((Sint8) sample0);\n        dst -= 4;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 4;\n            sample3 = (Sint8) ((((Sint16) ((Sint8) src[3])) + ((Sint16) last_sample3)) >> 1);\n            sample2 = (Sint8) ((((Sint16) ((Sint8) src[2])) + ((Sint16) last_sample2)) >> 1);\n            sample1 = (Sint8) ((((Sint16) ((Sint8) src[1])) + ((Sint16) last_sample1)) >> 1);\n            sample0 = (Sint8) ((((Sint16) ((Sint8) src[0])) + ((Sint16) last_sample0)) >> 1);\n            last_sample3 = sample3;\n            last_sample2 = sample2;\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S8_4c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_S8, 4 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 64;\n    const int dstsize = (int) (((double)(cvt->len_cvt/4)) * cvt->rate_incr) * 4;\n    register int eps = 0;\n    Sint8 *dst = (Sint8 *) cvt->buf;\n    const Sint8 *src = (Sint8 *) cvt->buf;\n    const Sint8 *target = (const Sint8 *) (cvt->buf + dstsize);\n    Sint8 sample0 = ((Sint8) src[0]);\n    Sint8 sample1 = ((Sint8) src[1]);\n    Sint8 sample2 = ((Sint8) src[2]);\n    Sint8 sample3 = ((Sint8) src[3]);\n    Sint8 last_sample0 = sample0;\n    Sint8 last_sample1 = sample1;\n    Sint8 last_sample2 = sample2;\n    Sint8 last_sample3 = sample3;\n    while (dst < target) {\n        src += 4;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = ((Sint8) sample0);\n            dst[1] = ((Sint8) sample1);\n            dst[2] = ((Sint8) sample2);\n            dst[3] = ((Sint8) sample3);\n            dst += 4;\n            sample0 = (Sint8) ((((Sint16) ((Sint8) src[0])) + ((Sint16) last_sample0)) >> 1);\n            sample1 = (Sint8) ((((Sint16) ((Sint8) src[1])) + ((Sint16) last_sample1)) >> 1);\n            sample2 = (Sint8) ((((Sint16) ((Sint8) src[2])) + ((Sint16) last_sample2)) >> 1);\n            sample3 = (Sint8) ((((Sint16) ((Sint8) src[3])) + ((Sint16) last_sample3)) >> 1);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            last_sample2 = sample2;\n            last_sample3 = sample3;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S8_6c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_S8, 6 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 96;\n    const int dstsize = (int) (((double)(cvt->len_cvt/6)) * cvt->rate_incr) * 6;\n    register int eps = 0;\n    Sint8 *dst = ((Sint8 *) (cvt->buf + dstsize)) - 6;\n    const Sint8 *src = ((Sint8 *) (cvt->buf + cvt->len_cvt)) - 6;\n    const Sint8 *target = ((const Sint8 *) cvt->buf);\n    Sint8 sample5 = ((Sint8) src[5]);\n    Sint8 sample4 = ((Sint8) src[4]);\n    Sint8 sample3 = ((Sint8) src[3]);\n    Sint8 sample2 = ((Sint8) src[2]);\n    Sint8 sample1 = ((Sint8) src[1]);\n    Sint8 sample0 = ((Sint8) src[0]);\n    Sint8 last_sample5 = sample5;\n    Sint8 last_sample4 = sample4;\n    Sint8 last_sample3 = sample3;\n    Sint8 last_sample2 = sample2;\n    Sint8 last_sample1 = sample1;\n    Sint8 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[5] = ((Sint8) sample5);\n        dst[4] = ((Sint8) sample4);\n        dst[3] = ((Sint8) sample3);\n        dst[2] = ((Sint8) sample2);\n        dst[1] = ((Sint8) sample1);\n        dst[0] = ((Sint8) sample0);\n        dst -= 6;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 6;\n            sample5 = (Sint8) ((((Sint16) ((Sint8) src[5])) + ((Sint16) last_sample5)) >> 1);\n            sample4 = (Sint8) ((((Sint16) ((Sint8) src[4])) + ((Sint16) last_sample4)) >> 1);\n            sample3 = (Sint8) ((((Sint16) ((Sint8) src[3])) + ((Sint16) last_sample3)) >> 1);\n            sample2 = (Sint8) ((((Sint16) ((Sint8) src[2])) + ((Sint16) last_sample2)) >> 1);\n            sample1 = (Sint8) ((((Sint16) ((Sint8) src[1])) + ((Sint16) last_sample1)) >> 1);\n            sample0 = (Sint8) ((((Sint16) ((Sint8) src[0])) + ((Sint16) last_sample0)) >> 1);\n            last_sample5 = sample5;\n            last_sample4 = sample4;\n            last_sample3 = sample3;\n            last_sample2 = sample2;\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S8_6c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_S8, 6 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 96;\n    const int dstsize = (int) (((double)(cvt->len_cvt/6)) * cvt->rate_incr) * 6;\n    register int eps = 0;\n    Sint8 *dst = (Sint8 *) cvt->buf;\n    const Sint8 *src = (Sint8 *) cvt->buf;\n    const Sint8 *target = (const Sint8 *) (cvt->buf + dstsize);\n    Sint8 sample0 = ((Sint8) src[0]);\n    Sint8 sample1 = ((Sint8) src[1]);\n    Sint8 sample2 = ((Sint8) src[2]);\n    Sint8 sample3 = ((Sint8) src[3]);\n    Sint8 sample4 = ((Sint8) src[4]);\n    Sint8 sample5 = ((Sint8) src[5]);\n    Sint8 last_sample0 = sample0;\n    Sint8 last_sample1 = sample1;\n    Sint8 last_sample2 = sample2;\n    Sint8 last_sample3 = sample3;\n    Sint8 last_sample4 = sample4;\n    Sint8 last_sample5 = sample5;\n    while (dst < target) {\n        src += 6;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = ((Sint8) sample0);\n            dst[1] = ((Sint8) sample1);\n            dst[2] = ((Sint8) sample2);\n            dst[3] = ((Sint8) sample3);\n            dst[4] = ((Sint8) sample4);\n            dst[5] = ((Sint8) sample5);\n            dst += 6;\n            sample0 = (Sint8) ((((Sint16) ((Sint8) src[0])) + ((Sint16) last_sample0)) >> 1);\n            sample1 = (Sint8) ((((Sint16) ((Sint8) src[1])) + ((Sint16) last_sample1)) >> 1);\n            sample2 = (Sint8) ((((Sint16) ((Sint8) src[2])) + ((Sint16) last_sample2)) >> 1);\n            sample3 = (Sint8) ((((Sint16) ((Sint8) src[3])) + ((Sint16) last_sample3)) >> 1);\n            sample4 = (Sint8) ((((Sint16) ((Sint8) src[4])) + ((Sint16) last_sample4)) >> 1);\n            sample5 = (Sint8) ((((Sint16) ((Sint8) src[5])) + ((Sint16) last_sample5)) >> 1);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            last_sample2 = sample2;\n            last_sample3 = sample3;\n            last_sample4 = sample4;\n            last_sample5 = sample5;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S8_8c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_S8, 8 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 128;\n    const int dstsize = (int) (((double)(cvt->len_cvt/8)) * cvt->rate_incr) * 8;\n    register int eps = 0;\n    Sint8 *dst = ((Sint8 *) (cvt->buf + dstsize)) - 8;\n    const Sint8 *src = ((Sint8 *) (cvt->buf + cvt->len_cvt)) - 8;\n    const Sint8 *target = ((const Sint8 *) cvt->buf);\n    Sint8 sample7 = ((Sint8) src[7]);\n    Sint8 sample6 = ((Sint8) src[6]);\n    Sint8 sample5 = ((Sint8) src[5]);\n    Sint8 sample4 = ((Sint8) src[4]);\n    Sint8 sample3 = ((Sint8) src[3]);\n    Sint8 sample2 = ((Sint8) src[2]);\n    Sint8 sample1 = ((Sint8) src[1]);\n    Sint8 sample0 = ((Sint8) src[0]);\n    Sint8 last_sample7 = sample7;\n    Sint8 last_sample6 = sample6;\n    Sint8 last_sample5 = sample5;\n    Sint8 last_sample4 = sample4;\n    Sint8 last_sample3 = sample3;\n    Sint8 last_sample2 = sample2;\n    Sint8 last_sample1 = sample1;\n    Sint8 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[7] = ((Sint8) sample7);\n        dst[6] = ((Sint8) sample6);\n        dst[5] = ((Sint8) sample5);\n        dst[4] = ((Sint8) sample4);\n        dst[3] = ((Sint8) sample3);\n        dst[2] = ((Sint8) sample2);\n        dst[1] = ((Sint8) sample1);\n        dst[0] = ((Sint8) sample0);\n        dst -= 8;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 8;\n            sample7 = (Sint8) ((((Sint16) ((Sint8) src[7])) + ((Sint16) last_sample7)) >> 1);\n            sample6 = (Sint8) ((((Sint16) ((Sint8) src[6])) + ((Sint16) last_sample6)) >> 1);\n            sample5 = (Sint8) ((((Sint16) ((Sint8) src[5])) + ((Sint16) last_sample5)) >> 1);\n            sample4 = (Sint8) ((((Sint16) ((Sint8) src[4])) + ((Sint16) last_sample4)) >> 1);\n            sample3 = (Sint8) ((((Sint16) ((Sint8) src[3])) + ((Sint16) last_sample3)) >> 1);\n            sample2 = (Sint8) ((((Sint16) ((Sint8) src[2])) + ((Sint16) last_sample2)) >> 1);\n            sample1 = (Sint8) ((((Sint16) ((Sint8) src[1])) + ((Sint16) last_sample1)) >> 1);\n            sample0 = (Sint8) ((((Sint16) ((Sint8) src[0])) + ((Sint16) last_sample0)) >> 1);\n            last_sample7 = sample7;\n            last_sample6 = sample6;\n            last_sample5 = sample5;\n            last_sample4 = sample4;\n            last_sample3 = sample3;\n            last_sample2 = sample2;\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S8_8c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_S8, 8 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 128;\n    const int dstsize = (int) (((double)(cvt->len_cvt/8)) * cvt->rate_incr) * 8;\n    register int eps = 0;\n    Sint8 *dst = (Sint8 *) cvt->buf;\n    const Sint8 *src = (Sint8 *) cvt->buf;\n    const Sint8 *target = (const Sint8 *) (cvt->buf + dstsize);\n    Sint8 sample0 = ((Sint8) src[0]);\n    Sint8 sample1 = ((Sint8) src[1]);\n    Sint8 sample2 = ((Sint8) src[2]);\n    Sint8 sample3 = ((Sint8) src[3]);\n    Sint8 sample4 = ((Sint8) src[4]);\n    Sint8 sample5 = ((Sint8) src[5]);\n    Sint8 sample6 = ((Sint8) src[6]);\n    Sint8 sample7 = ((Sint8) src[7]);\n    Sint8 last_sample0 = sample0;\n    Sint8 last_sample1 = sample1;\n    Sint8 last_sample2 = sample2;\n    Sint8 last_sample3 = sample3;\n    Sint8 last_sample4 = sample4;\n    Sint8 last_sample5 = sample5;\n    Sint8 last_sample6 = sample6;\n    Sint8 last_sample7 = sample7;\n    while (dst < target) {\n        src += 8;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = ((Sint8) sample0);\n            dst[1] = ((Sint8) sample1);\n            dst[2] = ((Sint8) sample2);\n            dst[3] = ((Sint8) sample3);\n            dst[4] = ((Sint8) sample4);\n            dst[5] = ((Sint8) sample5);\n            dst[6] = ((Sint8) sample6);\n            dst[7] = ((Sint8) sample7);\n            dst += 8;\n            sample0 = (Sint8) ((((Sint16) ((Sint8) src[0])) + ((Sint16) last_sample0)) >> 1);\n            sample1 = (Sint8) ((((Sint16) ((Sint8) src[1])) + ((Sint16) last_sample1)) >> 1);\n            sample2 = (Sint8) ((((Sint16) ((Sint8) src[2])) + ((Sint16) last_sample2)) >> 1);\n            sample3 = (Sint8) ((((Sint16) ((Sint8) src[3])) + ((Sint16) last_sample3)) >> 1);\n            sample4 = (Sint8) ((((Sint16) ((Sint8) src[4])) + ((Sint16) last_sample4)) >> 1);\n            sample5 = (Sint8) ((((Sint16) ((Sint8) src[5])) + ((Sint16) last_sample5)) >> 1);\n            sample6 = (Sint8) ((((Sint16) ((Sint8) src[6])) + ((Sint16) last_sample6)) >> 1);\n            sample7 = (Sint8) ((((Sint16) ((Sint8) src[7])) + ((Sint16) last_sample7)) >> 1);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            last_sample2 = sample2;\n            last_sample3 = sample3;\n            last_sample4 = sample4;\n            last_sample5 = sample5;\n            last_sample6 = sample6;\n            last_sample7 = sample7;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U16LSB_1c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_U16LSB, 1 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 32;\n    const int dstsize = (int) (((double)(cvt->len_cvt/2)) * cvt->rate_incr) * 2;\n    register int eps = 0;\n    Uint16 *dst = ((Uint16 *) (cvt->buf + dstsize)) - 1;\n    const Uint16 *src = ((Uint16 *) (cvt->buf + cvt->len_cvt)) - 1;\n    const Uint16 *target = ((const Uint16 *) cvt->buf);\n    Uint16 sample0 = SDL_SwapLE16(src[0]);\n    Uint16 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[0] = SDL_SwapLE16(sample0);\n        dst--;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src--;\n            sample0 = (Uint16) ((((Sint32) SDL_SwapLE16(src[0])) + ((Sint32) last_sample0)) >> 1);\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U16LSB_1c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_U16LSB, 1 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 32;\n    const int dstsize = (int) (((double)(cvt->len_cvt/2)) * cvt->rate_incr) * 2;\n    register int eps = 0;\n    Uint16 *dst = (Uint16 *) cvt->buf;\n    const Uint16 *src = (Uint16 *) cvt->buf;\n    const Uint16 *target = (const Uint16 *) (cvt->buf + dstsize);\n    Uint16 sample0 = SDL_SwapLE16(src[0]);\n    Uint16 last_sample0 = sample0;\n    while (dst < target) {\n        src++;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = SDL_SwapLE16(sample0);\n            dst++;\n            sample0 = (Uint16) ((((Sint32) SDL_SwapLE16(src[0])) + ((Sint32) last_sample0)) >> 1);\n            last_sample0 = sample0;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U16LSB_2c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_U16LSB, 2 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 64;\n    const int dstsize = (int) (((double)(cvt->len_cvt/4)) * cvt->rate_incr) * 4;\n    register int eps = 0;\n    Uint16 *dst = ((Uint16 *) (cvt->buf + dstsize)) - 2;\n    const Uint16 *src = ((Uint16 *) (cvt->buf + cvt->len_cvt)) - 2;\n    const Uint16 *target = ((const Uint16 *) cvt->buf);\n    Uint16 sample1 = SDL_SwapLE16(src[1]);\n    Uint16 sample0 = SDL_SwapLE16(src[0]);\n    Uint16 last_sample1 = sample1;\n    Uint16 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[1] = SDL_SwapLE16(sample1);\n        dst[0] = SDL_SwapLE16(sample0);\n        dst -= 2;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 2;\n            sample1 = (Uint16) ((((Sint32) SDL_SwapLE16(src[1])) + ((Sint32) last_sample1)) >> 1);\n            sample0 = (Uint16) ((((Sint32) SDL_SwapLE16(src[0])) + ((Sint32) last_sample0)) >> 1);\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U16LSB_2c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_U16LSB, 2 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 64;\n    const int dstsize = (int) (((double)(cvt->len_cvt/4)) * cvt->rate_incr) * 4;\n    register int eps = 0;\n    Uint16 *dst = (Uint16 *) cvt->buf;\n    const Uint16 *src = (Uint16 *) cvt->buf;\n    const Uint16 *target = (const Uint16 *) (cvt->buf + dstsize);\n    Uint16 sample0 = SDL_SwapLE16(src[0]);\n    Uint16 sample1 = SDL_SwapLE16(src[1]);\n    Uint16 last_sample0 = sample0;\n    Uint16 last_sample1 = sample1;\n    while (dst < target) {\n        src += 2;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = SDL_SwapLE16(sample0);\n            dst[1] = SDL_SwapLE16(sample1);\n            dst += 2;\n            sample0 = (Uint16) ((((Sint32) SDL_SwapLE16(src[0])) + ((Sint32) last_sample0)) >> 1);\n            sample1 = (Uint16) ((((Sint32) SDL_SwapLE16(src[1])) + ((Sint32) last_sample1)) >> 1);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U16LSB_4c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_U16LSB, 4 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 128;\n    const int dstsize = (int) (((double)(cvt->len_cvt/8)) * cvt->rate_incr) * 8;\n    register int eps = 0;\n    Uint16 *dst = ((Uint16 *) (cvt->buf + dstsize)) - 4;\n    const Uint16 *src = ((Uint16 *) (cvt->buf + cvt->len_cvt)) - 4;\n    const Uint16 *target = ((const Uint16 *) cvt->buf);\n    Uint16 sample3 = SDL_SwapLE16(src[3]);\n    Uint16 sample2 = SDL_SwapLE16(src[2]);\n    Uint16 sample1 = SDL_SwapLE16(src[1]);\n    Uint16 sample0 = SDL_SwapLE16(src[0]);\n    Uint16 last_sample3 = sample3;\n    Uint16 last_sample2 = sample2;\n    Uint16 last_sample1 = sample1;\n    Uint16 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[3] = SDL_SwapLE16(sample3);\n        dst[2] = SDL_SwapLE16(sample2);\n        dst[1] = SDL_SwapLE16(sample1);\n        dst[0] = SDL_SwapLE16(sample0);\n        dst -= 4;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 4;\n            sample3 = (Uint16) ((((Sint32) SDL_SwapLE16(src[3])) + ((Sint32) last_sample3)) >> 1);\n            sample2 = (Uint16) ((((Sint32) SDL_SwapLE16(src[2])) + ((Sint32) last_sample2)) >> 1);\n            sample1 = (Uint16) ((((Sint32) SDL_SwapLE16(src[1])) + ((Sint32) last_sample1)) >> 1);\n            sample0 = (Uint16) ((((Sint32) SDL_SwapLE16(src[0])) + ((Sint32) last_sample0)) >> 1);\n            last_sample3 = sample3;\n            last_sample2 = sample2;\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U16LSB_4c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_U16LSB, 4 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 128;\n    const int dstsize = (int) (((double)(cvt->len_cvt/8)) * cvt->rate_incr) * 8;\n    register int eps = 0;\n    Uint16 *dst = (Uint16 *) cvt->buf;\n    const Uint16 *src = (Uint16 *) cvt->buf;\n    const Uint16 *target = (const Uint16 *) (cvt->buf + dstsize);\n    Uint16 sample0 = SDL_SwapLE16(src[0]);\n    Uint16 sample1 = SDL_SwapLE16(src[1]);\n    Uint16 sample2 = SDL_SwapLE16(src[2]);\n    Uint16 sample3 = SDL_SwapLE16(src[3]);\n    Uint16 last_sample0 = sample0;\n    Uint16 last_sample1 = sample1;\n    Uint16 last_sample2 = sample2;\n    Uint16 last_sample3 = sample3;\n    while (dst < target) {\n        src += 4;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = SDL_SwapLE16(sample0);\n            dst[1] = SDL_SwapLE16(sample1);\n            dst[2] = SDL_SwapLE16(sample2);\n            dst[3] = SDL_SwapLE16(sample3);\n            dst += 4;\n            sample0 = (Uint16) ((((Sint32) SDL_SwapLE16(src[0])) + ((Sint32) last_sample0)) >> 1);\n            sample1 = (Uint16) ((((Sint32) SDL_SwapLE16(src[1])) + ((Sint32) last_sample1)) >> 1);\n            sample2 = (Uint16) ((((Sint32) SDL_SwapLE16(src[2])) + ((Sint32) last_sample2)) >> 1);\n            sample3 = (Uint16) ((((Sint32) SDL_SwapLE16(src[3])) + ((Sint32) last_sample3)) >> 1);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            last_sample2 = sample2;\n            last_sample3 = sample3;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U16LSB_6c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_U16LSB, 6 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 192;\n    const int dstsize = (int) (((double)(cvt->len_cvt/12)) * cvt->rate_incr) * 12;\n    register int eps = 0;\n    Uint16 *dst = ((Uint16 *) (cvt->buf + dstsize)) - 6;\n    const Uint16 *src = ((Uint16 *) (cvt->buf + cvt->len_cvt)) - 6;\n    const Uint16 *target = ((const Uint16 *) cvt->buf);\n    Uint16 sample5 = SDL_SwapLE16(src[5]);\n    Uint16 sample4 = SDL_SwapLE16(src[4]);\n    Uint16 sample3 = SDL_SwapLE16(src[3]);\n    Uint16 sample2 = SDL_SwapLE16(src[2]);\n    Uint16 sample1 = SDL_SwapLE16(src[1]);\n    Uint16 sample0 = SDL_SwapLE16(src[0]);\n    Uint16 last_sample5 = sample5;\n    Uint16 last_sample4 = sample4;\n    Uint16 last_sample3 = sample3;\n    Uint16 last_sample2 = sample2;\n    Uint16 last_sample1 = sample1;\n    Uint16 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[5] = SDL_SwapLE16(sample5);\n        dst[4] = SDL_SwapLE16(sample4);\n        dst[3] = SDL_SwapLE16(sample3);\n        dst[2] = SDL_SwapLE16(sample2);\n        dst[1] = SDL_SwapLE16(sample1);\n        dst[0] = SDL_SwapLE16(sample0);\n        dst -= 6;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 6;\n            sample5 = (Uint16) ((((Sint32) SDL_SwapLE16(src[5])) + ((Sint32) last_sample5)) >> 1);\n            sample4 = (Uint16) ((((Sint32) SDL_SwapLE16(src[4])) + ((Sint32) last_sample4)) >> 1);\n            sample3 = (Uint16) ((((Sint32) SDL_SwapLE16(src[3])) + ((Sint32) last_sample3)) >> 1);\n            sample2 = (Uint16) ((((Sint32) SDL_SwapLE16(src[2])) + ((Sint32) last_sample2)) >> 1);\n            sample1 = (Uint16) ((((Sint32) SDL_SwapLE16(src[1])) + ((Sint32) last_sample1)) >> 1);\n            sample0 = (Uint16) ((((Sint32) SDL_SwapLE16(src[0])) + ((Sint32) last_sample0)) >> 1);\n            last_sample5 = sample5;\n            last_sample4 = sample4;\n            last_sample3 = sample3;\n            last_sample2 = sample2;\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U16LSB_6c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_U16LSB, 6 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 192;\n    const int dstsize = (int) (((double)(cvt->len_cvt/12)) * cvt->rate_incr) * 12;\n    register int eps = 0;\n    Uint16 *dst = (Uint16 *) cvt->buf;\n    const Uint16 *src = (Uint16 *) cvt->buf;\n    const Uint16 *target = (const Uint16 *) (cvt->buf + dstsize);\n    Uint16 sample0 = SDL_SwapLE16(src[0]);\n    Uint16 sample1 = SDL_SwapLE16(src[1]);\n    Uint16 sample2 = SDL_SwapLE16(src[2]);\n    Uint16 sample3 = SDL_SwapLE16(src[3]);\n    Uint16 sample4 = SDL_SwapLE16(src[4]);\n    Uint16 sample5 = SDL_SwapLE16(src[5]);\n    Uint16 last_sample0 = sample0;\n    Uint16 last_sample1 = sample1;\n    Uint16 last_sample2 = sample2;\n    Uint16 last_sample3 = sample3;\n    Uint16 last_sample4 = sample4;\n    Uint16 last_sample5 = sample5;\n    while (dst < target) {\n        src += 6;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = SDL_SwapLE16(sample0);\n            dst[1] = SDL_SwapLE16(sample1);\n            dst[2] = SDL_SwapLE16(sample2);\n            dst[3] = SDL_SwapLE16(sample3);\n            dst[4] = SDL_SwapLE16(sample4);\n            dst[5] = SDL_SwapLE16(sample5);\n            dst += 6;\n            sample0 = (Uint16) ((((Sint32) SDL_SwapLE16(src[0])) + ((Sint32) last_sample0)) >> 1);\n            sample1 = (Uint16) ((((Sint32) SDL_SwapLE16(src[1])) + ((Sint32) last_sample1)) >> 1);\n            sample2 = (Uint16) ((((Sint32) SDL_SwapLE16(src[2])) + ((Sint32) last_sample2)) >> 1);\n            sample3 = (Uint16) ((((Sint32) SDL_SwapLE16(src[3])) + ((Sint32) last_sample3)) >> 1);\n            sample4 = (Uint16) ((((Sint32) SDL_SwapLE16(src[4])) + ((Sint32) last_sample4)) >> 1);\n            sample5 = (Uint16) ((((Sint32) SDL_SwapLE16(src[5])) + ((Sint32) last_sample5)) >> 1);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            last_sample2 = sample2;\n            last_sample3 = sample3;\n            last_sample4 = sample4;\n            last_sample5 = sample5;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U16LSB_8c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_U16LSB, 8 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 256;\n    const int dstsize = (int) (((double)(cvt->len_cvt/16)) * cvt->rate_incr) * 16;\n    register int eps = 0;\n    Uint16 *dst = ((Uint16 *) (cvt->buf + dstsize)) - 8;\n    const Uint16 *src = ((Uint16 *) (cvt->buf + cvt->len_cvt)) - 8;\n    const Uint16 *target = ((const Uint16 *) cvt->buf);\n    Uint16 sample7 = SDL_SwapLE16(src[7]);\n    Uint16 sample6 = SDL_SwapLE16(src[6]);\n    Uint16 sample5 = SDL_SwapLE16(src[5]);\n    Uint16 sample4 = SDL_SwapLE16(src[4]);\n    Uint16 sample3 = SDL_SwapLE16(src[3]);\n    Uint16 sample2 = SDL_SwapLE16(src[2]);\n    Uint16 sample1 = SDL_SwapLE16(src[1]);\n    Uint16 sample0 = SDL_SwapLE16(src[0]);\n    Uint16 last_sample7 = sample7;\n    Uint16 last_sample6 = sample6;\n    Uint16 last_sample5 = sample5;\n    Uint16 last_sample4 = sample4;\n    Uint16 last_sample3 = sample3;\n    Uint16 last_sample2 = sample2;\n    Uint16 last_sample1 = sample1;\n    Uint16 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[7] = SDL_SwapLE16(sample7);\n        dst[6] = SDL_SwapLE16(sample6);\n        dst[5] = SDL_SwapLE16(sample5);\n        dst[4] = SDL_SwapLE16(sample4);\n        dst[3] = SDL_SwapLE16(sample3);\n        dst[2] = SDL_SwapLE16(sample2);\n        dst[1] = SDL_SwapLE16(sample1);\n        dst[0] = SDL_SwapLE16(sample0);\n        dst -= 8;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 8;\n            sample7 = (Uint16) ((((Sint32) SDL_SwapLE16(src[7])) + ((Sint32) last_sample7)) >> 1);\n            sample6 = (Uint16) ((((Sint32) SDL_SwapLE16(src[6])) + ((Sint32) last_sample6)) >> 1);\n            sample5 = (Uint16) ((((Sint32) SDL_SwapLE16(src[5])) + ((Sint32) last_sample5)) >> 1);\n            sample4 = (Uint16) ((((Sint32) SDL_SwapLE16(src[4])) + ((Sint32) last_sample4)) >> 1);\n            sample3 = (Uint16) ((((Sint32) SDL_SwapLE16(src[3])) + ((Sint32) last_sample3)) >> 1);\n            sample2 = (Uint16) ((((Sint32) SDL_SwapLE16(src[2])) + ((Sint32) last_sample2)) >> 1);\n            sample1 = (Uint16) ((((Sint32) SDL_SwapLE16(src[1])) + ((Sint32) last_sample1)) >> 1);\n            sample0 = (Uint16) ((((Sint32) SDL_SwapLE16(src[0])) + ((Sint32) last_sample0)) >> 1);\n            last_sample7 = sample7;\n            last_sample6 = sample6;\n            last_sample5 = sample5;\n            last_sample4 = sample4;\n            last_sample3 = sample3;\n            last_sample2 = sample2;\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U16LSB_8c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_U16LSB, 8 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 256;\n    const int dstsize = (int) (((double)(cvt->len_cvt/16)) * cvt->rate_incr) * 16;\n    register int eps = 0;\n    Uint16 *dst = (Uint16 *) cvt->buf;\n    const Uint16 *src = (Uint16 *) cvt->buf;\n    const Uint16 *target = (const Uint16 *) (cvt->buf + dstsize);\n    Uint16 sample0 = SDL_SwapLE16(src[0]);\n    Uint16 sample1 = SDL_SwapLE16(src[1]);\n    Uint16 sample2 = SDL_SwapLE16(src[2]);\n    Uint16 sample3 = SDL_SwapLE16(src[3]);\n    Uint16 sample4 = SDL_SwapLE16(src[4]);\n    Uint16 sample5 = SDL_SwapLE16(src[5]);\n    Uint16 sample6 = SDL_SwapLE16(src[6]);\n    Uint16 sample7 = SDL_SwapLE16(src[7]);\n    Uint16 last_sample0 = sample0;\n    Uint16 last_sample1 = sample1;\n    Uint16 last_sample2 = sample2;\n    Uint16 last_sample3 = sample3;\n    Uint16 last_sample4 = sample4;\n    Uint16 last_sample5 = sample5;\n    Uint16 last_sample6 = sample6;\n    Uint16 last_sample7 = sample7;\n    while (dst < target) {\n        src += 8;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = SDL_SwapLE16(sample0);\n            dst[1] = SDL_SwapLE16(sample1);\n            dst[2] = SDL_SwapLE16(sample2);\n            dst[3] = SDL_SwapLE16(sample3);\n            dst[4] = SDL_SwapLE16(sample4);\n            dst[5] = SDL_SwapLE16(sample5);\n            dst[6] = SDL_SwapLE16(sample6);\n            dst[7] = SDL_SwapLE16(sample7);\n            dst += 8;\n            sample0 = (Uint16) ((((Sint32) SDL_SwapLE16(src[0])) + ((Sint32) last_sample0)) >> 1);\n            sample1 = (Uint16) ((((Sint32) SDL_SwapLE16(src[1])) + ((Sint32) last_sample1)) >> 1);\n            sample2 = (Uint16) ((((Sint32) SDL_SwapLE16(src[2])) + ((Sint32) last_sample2)) >> 1);\n            sample3 = (Uint16) ((((Sint32) SDL_SwapLE16(src[3])) + ((Sint32) last_sample3)) >> 1);\n            sample4 = (Uint16) ((((Sint32) SDL_SwapLE16(src[4])) + ((Sint32) last_sample4)) >> 1);\n            sample5 = (Uint16) ((((Sint32) SDL_SwapLE16(src[5])) + ((Sint32) last_sample5)) >> 1);\n            sample6 = (Uint16) ((((Sint32) SDL_SwapLE16(src[6])) + ((Sint32) last_sample6)) >> 1);\n            sample7 = (Uint16) ((((Sint32) SDL_SwapLE16(src[7])) + ((Sint32) last_sample7)) >> 1);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            last_sample2 = sample2;\n            last_sample3 = sample3;\n            last_sample4 = sample4;\n            last_sample5 = sample5;\n            last_sample6 = sample6;\n            last_sample7 = sample7;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S16LSB_1c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_S16LSB, 1 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 32;\n    const int dstsize = (int) (((double)(cvt->len_cvt/2)) * cvt->rate_incr) * 2;\n    register int eps = 0;\n    Sint16 *dst = ((Sint16 *) (cvt->buf + dstsize)) - 1;\n    const Sint16 *src = ((Sint16 *) (cvt->buf + cvt->len_cvt)) - 1;\n    const Sint16 *target = ((const Sint16 *) cvt->buf);\n    Sint16 sample0 = ((Sint16) SDL_SwapLE16(src[0]));\n    Sint16 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[0] = ((Sint16) SDL_SwapLE16(sample0));\n        dst--;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src--;\n            sample0 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[0]))) + ((Sint32) last_sample0)) >> 1);\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S16LSB_1c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_S16LSB, 1 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 32;\n    const int dstsize = (int) (((double)(cvt->len_cvt/2)) * cvt->rate_incr) * 2;\n    register int eps = 0;\n    Sint16 *dst = (Sint16 *) cvt->buf;\n    const Sint16 *src = (Sint16 *) cvt->buf;\n    const Sint16 *target = (const Sint16 *) (cvt->buf + dstsize);\n    Sint16 sample0 = ((Sint16) SDL_SwapLE16(src[0]));\n    Sint16 last_sample0 = sample0;\n    while (dst < target) {\n        src++;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = ((Sint16) SDL_SwapLE16(sample0));\n            dst++;\n            sample0 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[0]))) + ((Sint32) last_sample0)) >> 1);\n            last_sample0 = sample0;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S16LSB_2c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_S16LSB, 2 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 64;\n    const int dstsize = (int) (((double)(cvt->len_cvt/4)) * cvt->rate_incr) * 4;\n    register int eps = 0;\n    Sint16 *dst = ((Sint16 *) (cvt->buf + dstsize)) - 2;\n    const Sint16 *src = ((Sint16 *) (cvt->buf + cvt->len_cvt)) - 2;\n    const Sint16 *target = ((const Sint16 *) cvt->buf);\n    Sint16 sample1 = ((Sint16) SDL_SwapLE16(src[1]));\n    Sint16 sample0 = ((Sint16) SDL_SwapLE16(src[0]));\n    Sint16 last_sample1 = sample1;\n    Sint16 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[1] = ((Sint16) SDL_SwapLE16(sample1));\n        dst[0] = ((Sint16) SDL_SwapLE16(sample0));\n        dst -= 2;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 2;\n            sample1 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[1]))) + ((Sint32) last_sample1)) >> 1);\n            sample0 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[0]))) + ((Sint32) last_sample0)) >> 1);\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S16LSB_2c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_S16LSB, 2 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 64;\n    const int dstsize = (int) (((double)(cvt->len_cvt/4)) * cvt->rate_incr) * 4;\n    register int eps = 0;\n    Sint16 *dst = (Sint16 *) cvt->buf;\n    const Sint16 *src = (Sint16 *) cvt->buf;\n    const Sint16 *target = (const Sint16 *) (cvt->buf + dstsize);\n    Sint16 sample0 = ((Sint16) SDL_SwapLE16(src[0]));\n    Sint16 sample1 = ((Sint16) SDL_SwapLE16(src[1]));\n    Sint16 last_sample0 = sample0;\n    Sint16 last_sample1 = sample1;\n    while (dst < target) {\n        src += 2;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = ((Sint16) SDL_SwapLE16(sample0));\n            dst[1] = ((Sint16) SDL_SwapLE16(sample1));\n            dst += 2;\n            sample0 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[0]))) + ((Sint32) last_sample0)) >> 1);\n            sample1 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[1]))) + ((Sint32) last_sample1)) >> 1);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S16LSB_4c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_S16LSB, 4 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 128;\n    const int dstsize = (int) (((double)(cvt->len_cvt/8)) * cvt->rate_incr) * 8;\n    register int eps = 0;\n    Sint16 *dst = ((Sint16 *) (cvt->buf + dstsize)) - 4;\n    const Sint16 *src = ((Sint16 *) (cvt->buf + cvt->len_cvt)) - 4;\n    const Sint16 *target = ((const Sint16 *) cvt->buf);\n    Sint16 sample3 = ((Sint16) SDL_SwapLE16(src[3]));\n    Sint16 sample2 = ((Sint16) SDL_SwapLE16(src[2]));\n    Sint16 sample1 = ((Sint16) SDL_SwapLE16(src[1]));\n    Sint16 sample0 = ((Sint16) SDL_SwapLE16(src[0]));\n    Sint16 last_sample3 = sample3;\n    Sint16 last_sample2 = sample2;\n    Sint16 last_sample1 = sample1;\n    Sint16 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[3] = ((Sint16) SDL_SwapLE16(sample3));\n        dst[2] = ((Sint16) SDL_SwapLE16(sample2));\n        dst[1] = ((Sint16) SDL_SwapLE16(sample1));\n        dst[0] = ((Sint16) SDL_SwapLE16(sample0));\n        dst -= 4;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 4;\n            sample3 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[3]))) + ((Sint32) last_sample3)) >> 1);\n            sample2 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[2]))) + ((Sint32) last_sample2)) >> 1);\n            sample1 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[1]))) + ((Sint32) last_sample1)) >> 1);\n            sample0 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[0]))) + ((Sint32) last_sample0)) >> 1);\n            last_sample3 = sample3;\n            last_sample2 = sample2;\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S16LSB_4c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_S16LSB, 4 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 128;\n    const int dstsize = (int) (((double)(cvt->len_cvt/8)) * cvt->rate_incr) * 8;\n    register int eps = 0;\n    Sint16 *dst = (Sint16 *) cvt->buf;\n    const Sint16 *src = (Sint16 *) cvt->buf;\n    const Sint16 *target = (const Sint16 *) (cvt->buf + dstsize);\n    Sint16 sample0 = ((Sint16) SDL_SwapLE16(src[0]));\n    Sint16 sample1 = ((Sint16) SDL_SwapLE16(src[1]));\n    Sint16 sample2 = ((Sint16) SDL_SwapLE16(src[2]));\n    Sint16 sample3 = ((Sint16) SDL_SwapLE16(src[3]));\n    Sint16 last_sample0 = sample0;\n    Sint16 last_sample1 = sample1;\n    Sint16 last_sample2 = sample2;\n    Sint16 last_sample3 = sample3;\n    while (dst < target) {\n        src += 4;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = ((Sint16) SDL_SwapLE16(sample0));\n            dst[1] = ((Sint16) SDL_SwapLE16(sample1));\n            dst[2] = ((Sint16) SDL_SwapLE16(sample2));\n            dst[3] = ((Sint16) SDL_SwapLE16(sample3));\n            dst += 4;\n            sample0 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[0]))) + ((Sint32) last_sample0)) >> 1);\n            sample1 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[1]))) + ((Sint32) last_sample1)) >> 1);\n            sample2 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[2]))) + ((Sint32) last_sample2)) >> 1);\n            sample3 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[3]))) + ((Sint32) last_sample3)) >> 1);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            last_sample2 = sample2;\n            last_sample3 = sample3;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S16LSB_6c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_S16LSB, 6 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 192;\n    const int dstsize = (int) (((double)(cvt->len_cvt/12)) * cvt->rate_incr) * 12;\n    register int eps = 0;\n    Sint16 *dst = ((Sint16 *) (cvt->buf + dstsize)) - 6;\n    const Sint16 *src = ((Sint16 *) (cvt->buf + cvt->len_cvt)) - 6;\n    const Sint16 *target = ((const Sint16 *) cvt->buf);\n    Sint16 sample5 = ((Sint16) SDL_SwapLE16(src[5]));\n    Sint16 sample4 = ((Sint16) SDL_SwapLE16(src[4]));\n    Sint16 sample3 = ((Sint16) SDL_SwapLE16(src[3]));\n    Sint16 sample2 = ((Sint16) SDL_SwapLE16(src[2]));\n    Sint16 sample1 = ((Sint16) SDL_SwapLE16(src[1]));\n    Sint16 sample0 = ((Sint16) SDL_SwapLE16(src[0]));\n    Sint16 last_sample5 = sample5;\n    Sint16 last_sample4 = sample4;\n    Sint16 last_sample3 = sample3;\n    Sint16 last_sample2 = sample2;\n    Sint16 last_sample1 = sample1;\n    Sint16 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[5] = ((Sint16) SDL_SwapLE16(sample5));\n        dst[4] = ((Sint16) SDL_SwapLE16(sample4));\n        dst[3] = ((Sint16) SDL_SwapLE16(sample3));\n        dst[2] = ((Sint16) SDL_SwapLE16(sample2));\n        dst[1] = ((Sint16) SDL_SwapLE16(sample1));\n        dst[0] = ((Sint16) SDL_SwapLE16(sample0));\n        dst -= 6;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 6;\n            sample5 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[5]))) + ((Sint32) last_sample5)) >> 1);\n            sample4 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[4]))) + ((Sint32) last_sample4)) >> 1);\n            sample3 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[3]))) + ((Sint32) last_sample3)) >> 1);\n            sample2 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[2]))) + ((Sint32) last_sample2)) >> 1);\n            sample1 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[1]))) + ((Sint32) last_sample1)) >> 1);\n            sample0 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[0]))) + ((Sint32) last_sample0)) >> 1);\n            last_sample5 = sample5;\n            last_sample4 = sample4;\n            last_sample3 = sample3;\n            last_sample2 = sample2;\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S16LSB_6c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_S16LSB, 6 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 192;\n    const int dstsize = (int) (((double)(cvt->len_cvt/12)) * cvt->rate_incr) * 12;\n    register int eps = 0;\n    Sint16 *dst = (Sint16 *) cvt->buf;\n    const Sint16 *src = (Sint16 *) cvt->buf;\n    const Sint16 *target = (const Sint16 *) (cvt->buf + dstsize);\n    Sint16 sample0 = ((Sint16) SDL_SwapLE16(src[0]));\n    Sint16 sample1 = ((Sint16) SDL_SwapLE16(src[1]));\n    Sint16 sample2 = ((Sint16) SDL_SwapLE16(src[2]));\n    Sint16 sample3 = ((Sint16) SDL_SwapLE16(src[3]));\n    Sint16 sample4 = ((Sint16) SDL_SwapLE16(src[4]));\n    Sint16 sample5 = ((Sint16) SDL_SwapLE16(src[5]));\n    Sint16 last_sample0 = sample0;\n    Sint16 last_sample1 = sample1;\n    Sint16 last_sample2 = sample2;\n    Sint16 last_sample3 = sample3;\n    Sint16 last_sample4 = sample4;\n    Sint16 last_sample5 = sample5;\n    while (dst < target) {\n        src += 6;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = ((Sint16) SDL_SwapLE16(sample0));\n            dst[1] = ((Sint16) SDL_SwapLE16(sample1));\n            dst[2] = ((Sint16) SDL_SwapLE16(sample2));\n            dst[3] = ((Sint16) SDL_SwapLE16(sample3));\n            dst[4] = ((Sint16) SDL_SwapLE16(sample4));\n            dst[5] = ((Sint16) SDL_SwapLE16(sample5));\n            dst += 6;\n            sample0 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[0]))) + ((Sint32) last_sample0)) >> 1);\n            sample1 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[1]))) + ((Sint32) last_sample1)) >> 1);\n            sample2 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[2]))) + ((Sint32) last_sample2)) >> 1);\n            sample3 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[3]))) + ((Sint32) last_sample3)) >> 1);\n            sample4 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[4]))) + ((Sint32) last_sample4)) >> 1);\n            sample5 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[5]))) + ((Sint32) last_sample5)) >> 1);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            last_sample2 = sample2;\n            last_sample3 = sample3;\n            last_sample4 = sample4;\n            last_sample5 = sample5;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S16LSB_8c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_S16LSB, 8 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 256;\n    const int dstsize = (int) (((double)(cvt->len_cvt/16)) * cvt->rate_incr) * 16;\n    register int eps = 0;\n    Sint16 *dst = ((Sint16 *) (cvt->buf + dstsize)) - 8;\n    const Sint16 *src = ((Sint16 *) (cvt->buf + cvt->len_cvt)) - 8;\n    const Sint16 *target = ((const Sint16 *) cvt->buf);\n    Sint16 sample7 = ((Sint16) SDL_SwapLE16(src[7]));\n    Sint16 sample6 = ((Sint16) SDL_SwapLE16(src[6]));\n    Sint16 sample5 = ((Sint16) SDL_SwapLE16(src[5]));\n    Sint16 sample4 = ((Sint16) SDL_SwapLE16(src[4]));\n    Sint16 sample3 = ((Sint16) SDL_SwapLE16(src[3]));\n    Sint16 sample2 = ((Sint16) SDL_SwapLE16(src[2]));\n    Sint16 sample1 = ((Sint16) SDL_SwapLE16(src[1]));\n    Sint16 sample0 = ((Sint16) SDL_SwapLE16(src[0]));\n    Sint16 last_sample7 = sample7;\n    Sint16 last_sample6 = sample6;\n    Sint16 last_sample5 = sample5;\n    Sint16 last_sample4 = sample4;\n    Sint16 last_sample3 = sample3;\n    Sint16 last_sample2 = sample2;\n    Sint16 last_sample1 = sample1;\n    Sint16 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[7] = ((Sint16) SDL_SwapLE16(sample7));\n        dst[6] = ((Sint16) SDL_SwapLE16(sample6));\n        dst[5] = ((Sint16) SDL_SwapLE16(sample5));\n        dst[4] = ((Sint16) SDL_SwapLE16(sample4));\n        dst[3] = ((Sint16) SDL_SwapLE16(sample3));\n        dst[2] = ((Sint16) SDL_SwapLE16(sample2));\n        dst[1] = ((Sint16) SDL_SwapLE16(sample1));\n        dst[0] = ((Sint16) SDL_SwapLE16(sample0));\n        dst -= 8;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 8;\n            sample7 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[7]))) + ((Sint32) last_sample7)) >> 1);\n            sample6 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[6]))) + ((Sint32) last_sample6)) >> 1);\n            sample5 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[5]))) + ((Sint32) last_sample5)) >> 1);\n            sample4 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[4]))) + ((Sint32) last_sample4)) >> 1);\n            sample3 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[3]))) + ((Sint32) last_sample3)) >> 1);\n            sample2 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[2]))) + ((Sint32) last_sample2)) >> 1);\n            sample1 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[1]))) + ((Sint32) last_sample1)) >> 1);\n            sample0 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[0]))) + ((Sint32) last_sample0)) >> 1);\n            last_sample7 = sample7;\n            last_sample6 = sample6;\n            last_sample5 = sample5;\n            last_sample4 = sample4;\n            last_sample3 = sample3;\n            last_sample2 = sample2;\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S16LSB_8c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_S16LSB, 8 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 256;\n    const int dstsize = (int) (((double)(cvt->len_cvt/16)) * cvt->rate_incr) * 16;\n    register int eps = 0;\n    Sint16 *dst = (Sint16 *) cvt->buf;\n    const Sint16 *src = (Sint16 *) cvt->buf;\n    const Sint16 *target = (const Sint16 *) (cvt->buf + dstsize);\n    Sint16 sample0 = ((Sint16) SDL_SwapLE16(src[0]));\n    Sint16 sample1 = ((Sint16) SDL_SwapLE16(src[1]));\n    Sint16 sample2 = ((Sint16) SDL_SwapLE16(src[2]));\n    Sint16 sample3 = ((Sint16) SDL_SwapLE16(src[3]));\n    Sint16 sample4 = ((Sint16) SDL_SwapLE16(src[4]));\n    Sint16 sample5 = ((Sint16) SDL_SwapLE16(src[5]));\n    Sint16 sample6 = ((Sint16) SDL_SwapLE16(src[6]));\n    Sint16 sample7 = ((Sint16) SDL_SwapLE16(src[7]));\n    Sint16 last_sample0 = sample0;\n    Sint16 last_sample1 = sample1;\n    Sint16 last_sample2 = sample2;\n    Sint16 last_sample3 = sample3;\n    Sint16 last_sample4 = sample4;\n    Sint16 last_sample5 = sample5;\n    Sint16 last_sample6 = sample6;\n    Sint16 last_sample7 = sample7;\n    while (dst < target) {\n        src += 8;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = ((Sint16) SDL_SwapLE16(sample0));\n            dst[1] = ((Sint16) SDL_SwapLE16(sample1));\n            dst[2] = ((Sint16) SDL_SwapLE16(sample2));\n            dst[3] = ((Sint16) SDL_SwapLE16(sample3));\n            dst[4] = ((Sint16) SDL_SwapLE16(sample4));\n            dst[5] = ((Sint16) SDL_SwapLE16(sample5));\n            dst[6] = ((Sint16) SDL_SwapLE16(sample6));\n            dst[7] = ((Sint16) SDL_SwapLE16(sample7));\n            dst += 8;\n            sample0 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[0]))) + ((Sint32) last_sample0)) >> 1);\n            sample1 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[1]))) + ((Sint32) last_sample1)) >> 1);\n            sample2 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[2]))) + ((Sint32) last_sample2)) >> 1);\n            sample3 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[3]))) + ((Sint32) last_sample3)) >> 1);\n            sample4 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[4]))) + ((Sint32) last_sample4)) >> 1);\n            sample5 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[5]))) + ((Sint32) last_sample5)) >> 1);\n            sample6 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[6]))) + ((Sint32) last_sample6)) >> 1);\n            sample7 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapLE16(src[7]))) + ((Sint32) last_sample7)) >> 1);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            last_sample2 = sample2;\n            last_sample3 = sample3;\n            last_sample4 = sample4;\n            last_sample5 = sample5;\n            last_sample6 = sample6;\n            last_sample7 = sample7;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U16MSB_1c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_U16MSB, 1 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 32;\n    const int dstsize = (int) (((double)(cvt->len_cvt/2)) * cvt->rate_incr) * 2;\n    register int eps = 0;\n    Uint16 *dst = ((Uint16 *) (cvt->buf + dstsize)) - 1;\n    const Uint16 *src = ((Uint16 *) (cvt->buf + cvt->len_cvt)) - 1;\n    const Uint16 *target = ((const Uint16 *) cvt->buf);\n    Uint16 sample0 = SDL_SwapBE16(src[0]);\n    Uint16 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[0] = SDL_SwapBE16(sample0);\n        dst--;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src--;\n            sample0 = (Uint16) ((((Sint32) SDL_SwapBE16(src[0])) + ((Sint32) last_sample0)) >> 1);\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U16MSB_1c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_U16MSB, 1 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 32;\n    const int dstsize = (int) (((double)(cvt->len_cvt/2)) * cvt->rate_incr) * 2;\n    register int eps = 0;\n    Uint16 *dst = (Uint16 *) cvt->buf;\n    const Uint16 *src = (Uint16 *) cvt->buf;\n    const Uint16 *target = (const Uint16 *) (cvt->buf + dstsize);\n    Uint16 sample0 = SDL_SwapBE16(src[0]);\n    Uint16 last_sample0 = sample0;\n    while (dst < target) {\n        src++;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = SDL_SwapBE16(sample0);\n            dst++;\n            sample0 = (Uint16) ((((Sint32) SDL_SwapBE16(src[0])) + ((Sint32) last_sample0)) >> 1);\n            last_sample0 = sample0;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U16MSB_2c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_U16MSB, 2 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 64;\n    const int dstsize = (int) (((double)(cvt->len_cvt/4)) * cvt->rate_incr) * 4;\n    register int eps = 0;\n    Uint16 *dst = ((Uint16 *) (cvt->buf + dstsize)) - 2;\n    const Uint16 *src = ((Uint16 *) (cvt->buf + cvt->len_cvt)) - 2;\n    const Uint16 *target = ((const Uint16 *) cvt->buf);\n    Uint16 sample1 = SDL_SwapBE16(src[1]);\n    Uint16 sample0 = SDL_SwapBE16(src[0]);\n    Uint16 last_sample1 = sample1;\n    Uint16 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[1] = SDL_SwapBE16(sample1);\n        dst[0] = SDL_SwapBE16(sample0);\n        dst -= 2;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 2;\n            sample1 = (Uint16) ((((Sint32) SDL_SwapBE16(src[1])) + ((Sint32) last_sample1)) >> 1);\n            sample0 = (Uint16) ((((Sint32) SDL_SwapBE16(src[0])) + ((Sint32) last_sample0)) >> 1);\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U16MSB_2c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_U16MSB, 2 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 64;\n    const int dstsize = (int) (((double)(cvt->len_cvt/4)) * cvt->rate_incr) * 4;\n    register int eps = 0;\n    Uint16 *dst = (Uint16 *) cvt->buf;\n    const Uint16 *src = (Uint16 *) cvt->buf;\n    const Uint16 *target = (const Uint16 *) (cvt->buf + dstsize);\n    Uint16 sample0 = SDL_SwapBE16(src[0]);\n    Uint16 sample1 = SDL_SwapBE16(src[1]);\n    Uint16 last_sample0 = sample0;\n    Uint16 last_sample1 = sample1;\n    while (dst < target) {\n        src += 2;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = SDL_SwapBE16(sample0);\n            dst[1] = SDL_SwapBE16(sample1);\n            dst += 2;\n            sample0 = (Uint16) ((((Sint32) SDL_SwapBE16(src[0])) + ((Sint32) last_sample0)) >> 1);\n            sample1 = (Uint16) ((((Sint32) SDL_SwapBE16(src[1])) + ((Sint32) last_sample1)) >> 1);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U16MSB_4c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_U16MSB, 4 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 128;\n    const int dstsize = (int) (((double)(cvt->len_cvt/8)) * cvt->rate_incr) * 8;\n    register int eps = 0;\n    Uint16 *dst = ((Uint16 *) (cvt->buf + dstsize)) - 4;\n    const Uint16 *src = ((Uint16 *) (cvt->buf + cvt->len_cvt)) - 4;\n    const Uint16 *target = ((const Uint16 *) cvt->buf);\n    Uint16 sample3 = SDL_SwapBE16(src[3]);\n    Uint16 sample2 = SDL_SwapBE16(src[2]);\n    Uint16 sample1 = SDL_SwapBE16(src[1]);\n    Uint16 sample0 = SDL_SwapBE16(src[0]);\n    Uint16 last_sample3 = sample3;\n    Uint16 last_sample2 = sample2;\n    Uint16 last_sample1 = sample1;\n    Uint16 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[3] = SDL_SwapBE16(sample3);\n        dst[2] = SDL_SwapBE16(sample2);\n        dst[1] = SDL_SwapBE16(sample1);\n        dst[0] = SDL_SwapBE16(sample0);\n        dst -= 4;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 4;\n            sample3 = (Uint16) ((((Sint32) SDL_SwapBE16(src[3])) + ((Sint32) last_sample3)) >> 1);\n            sample2 = (Uint16) ((((Sint32) SDL_SwapBE16(src[2])) + ((Sint32) last_sample2)) >> 1);\n            sample1 = (Uint16) ((((Sint32) SDL_SwapBE16(src[1])) + ((Sint32) last_sample1)) >> 1);\n            sample0 = (Uint16) ((((Sint32) SDL_SwapBE16(src[0])) + ((Sint32) last_sample0)) >> 1);\n            last_sample3 = sample3;\n            last_sample2 = sample2;\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U16MSB_4c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_U16MSB, 4 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 128;\n    const int dstsize = (int) (((double)(cvt->len_cvt/8)) * cvt->rate_incr) * 8;\n    register int eps = 0;\n    Uint16 *dst = (Uint16 *) cvt->buf;\n    const Uint16 *src = (Uint16 *) cvt->buf;\n    const Uint16 *target = (const Uint16 *) (cvt->buf + dstsize);\n    Uint16 sample0 = SDL_SwapBE16(src[0]);\n    Uint16 sample1 = SDL_SwapBE16(src[1]);\n    Uint16 sample2 = SDL_SwapBE16(src[2]);\n    Uint16 sample3 = SDL_SwapBE16(src[3]);\n    Uint16 last_sample0 = sample0;\n    Uint16 last_sample1 = sample1;\n    Uint16 last_sample2 = sample2;\n    Uint16 last_sample3 = sample3;\n    while (dst < target) {\n        src += 4;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = SDL_SwapBE16(sample0);\n            dst[1] = SDL_SwapBE16(sample1);\n            dst[2] = SDL_SwapBE16(sample2);\n            dst[3] = SDL_SwapBE16(sample3);\n            dst += 4;\n            sample0 = (Uint16) ((((Sint32) SDL_SwapBE16(src[0])) + ((Sint32) last_sample0)) >> 1);\n            sample1 = (Uint16) ((((Sint32) SDL_SwapBE16(src[1])) + ((Sint32) last_sample1)) >> 1);\n            sample2 = (Uint16) ((((Sint32) SDL_SwapBE16(src[2])) + ((Sint32) last_sample2)) >> 1);\n            sample3 = (Uint16) ((((Sint32) SDL_SwapBE16(src[3])) + ((Sint32) last_sample3)) >> 1);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            last_sample2 = sample2;\n            last_sample3 = sample3;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U16MSB_6c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_U16MSB, 6 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 192;\n    const int dstsize = (int) (((double)(cvt->len_cvt/12)) * cvt->rate_incr) * 12;\n    register int eps = 0;\n    Uint16 *dst = ((Uint16 *) (cvt->buf + dstsize)) - 6;\n    const Uint16 *src = ((Uint16 *) (cvt->buf + cvt->len_cvt)) - 6;\n    const Uint16 *target = ((const Uint16 *) cvt->buf);\n    Uint16 sample5 = SDL_SwapBE16(src[5]);\n    Uint16 sample4 = SDL_SwapBE16(src[4]);\n    Uint16 sample3 = SDL_SwapBE16(src[3]);\n    Uint16 sample2 = SDL_SwapBE16(src[2]);\n    Uint16 sample1 = SDL_SwapBE16(src[1]);\n    Uint16 sample0 = SDL_SwapBE16(src[0]);\n    Uint16 last_sample5 = sample5;\n    Uint16 last_sample4 = sample4;\n    Uint16 last_sample3 = sample3;\n    Uint16 last_sample2 = sample2;\n    Uint16 last_sample1 = sample1;\n    Uint16 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[5] = SDL_SwapBE16(sample5);\n        dst[4] = SDL_SwapBE16(sample4);\n        dst[3] = SDL_SwapBE16(sample3);\n        dst[2] = SDL_SwapBE16(sample2);\n        dst[1] = SDL_SwapBE16(sample1);\n        dst[0] = SDL_SwapBE16(sample0);\n        dst -= 6;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 6;\n            sample5 = (Uint16) ((((Sint32) SDL_SwapBE16(src[5])) + ((Sint32) last_sample5)) >> 1);\n            sample4 = (Uint16) ((((Sint32) SDL_SwapBE16(src[4])) + ((Sint32) last_sample4)) >> 1);\n            sample3 = (Uint16) ((((Sint32) SDL_SwapBE16(src[3])) + ((Sint32) last_sample3)) >> 1);\n            sample2 = (Uint16) ((((Sint32) SDL_SwapBE16(src[2])) + ((Sint32) last_sample2)) >> 1);\n            sample1 = (Uint16) ((((Sint32) SDL_SwapBE16(src[1])) + ((Sint32) last_sample1)) >> 1);\n            sample0 = (Uint16) ((((Sint32) SDL_SwapBE16(src[0])) + ((Sint32) last_sample0)) >> 1);\n            last_sample5 = sample5;\n            last_sample4 = sample4;\n            last_sample3 = sample3;\n            last_sample2 = sample2;\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U16MSB_6c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_U16MSB, 6 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 192;\n    const int dstsize = (int) (((double)(cvt->len_cvt/12)) * cvt->rate_incr) * 12;\n    register int eps = 0;\n    Uint16 *dst = (Uint16 *) cvt->buf;\n    const Uint16 *src = (Uint16 *) cvt->buf;\n    const Uint16 *target = (const Uint16 *) (cvt->buf + dstsize);\n    Uint16 sample0 = SDL_SwapBE16(src[0]);\n    Uint16 sample1 = SDL_SwapBE16(src[1]);\n    Uint16 sample2 = SDL_SwapBE16(src[2]);\n    Uint16 sample3 = SDL_SwapBE16(src[3]);\n    Uint16 sample4 = SDL_SwapBE16(src[4]);\n    Uint16 sample5 = SDL_SwapBE16(src[5]);\n    Uint16 last_sample0 = sample0;\n    Uint16 last_sample1 = sample1;\n    Uint16 last_sample2 = sample2;\n    Uint16 last_sample3 = sample3;\n    Uint16 last_sample4 = sample4;\n    Uint16 last_sample5 = sample5;\n    while (dst < target) {\n        src += 6;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = SDL_SwapBE16(sample0);\n            dst[1] = SDL_SwapBE16(sample1);\n            dst[2] = SDL_SwapBE16(sample2);\n            dst[3] = SDL_SwapBE16(sample3);\n            dst[4] = SDL_SwapBE16(sample4);\n            dst[5] = SDL_SwapBE16(sample5);\n            dst += 6;\n            sample0 = (Uint16) ((((Sint32) SDL_SwapBE16(src[0])) + ((Sint32) last_sample0)) >> 1);\n            sample1 = (Uint16) ((((Sint32) SDL_SwapBE16(src[1])) + ((Sint32) last_sample1)) >> 1);\n            sample2 = (Uint16) ((((Sint32) SDL_SwapBE16(src[2])) + ((Sint32) last_sample2)) >> 1);\n            sample3 = (Uint16) ((((Sint32) SDL_SwapBE16(src[3])) + ((Sint32) last_sample3)) >> 1);\n            sample4 = (Uint16) ((((Sint32) SDL_SwapBE16(src[4])) + ((Sint32) last_sample4)) >> 1);\n            sample5 = (Uint16) ((((Sint32) SDL_SwapBE16(src[5])) + ((Sint32) last_sample5)) >> 1);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            last_sample2 = sample2;\n            last_sample3 = sample3;\n            last_sample4 = sample4;\n            last_sample5 = sample5;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U16MSB_8c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_U16MSB, 8 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 256;\n    const int dstsize = (int) (((double)(cvt->len_cvt/16)) * cvt->rate_incr) * 16;\n    register int eps = 0;\n    Uint16 *dst = ((Uint16 *) (cvt->buf + dstsize)) - 8;\n    const Uint16 *src = ((Uint16 *) (cvt->buf + cvt->len_cvt)) - 8;\n    const Uint16 *target = ((const Uint16 *) cvt->buf);\n    Uint16 sample7 = SDL_SwapBE16(src[7]);\n    Uint16 sample6 = SDL_SwapBE16(src[6]);\n    Uint16 sample5 = SDL_SwapBE16(src[5]);\n    Uint16 sample4 = SDL_SwapBE16(src[4]);\n    Uint16 sample3 = SDL_SwapBE16(src[3]);\n    Uint16 sample2 = SDL_SwapBE16(src[2]);\n    Uint16 sample1 = SDL_SwapBE16(src[1]);\n    Uint16 sample0 = SDL_SwapBE16(src[0]);\n    Uint16 last_sample7 = sample7;\n    Uint16 last_sample6 = sample6;\n    Uint16 last_sample5 = sample5;\n    Uint16 last_sample4 = sample4;\n    Uint16 last_sample3 = sample3;\n    Uint16 last_sample2 = sample2;\n    Uint16 last_sample1 = sample1;\n    Uint16 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[7] = SDL_SwapBE16(sample7);\n        dst[6] = SDL_SwapBE16(sample6);\n        dst[5] = SDL_SwapBE16(sample5);\n        dst[4] = SDL_SwapBE16(sample4);\n        dst[3] = SDL_SwapBE16(sample3);\n        dst[2] = SDL_SwapBE16(sample2);\n        dst[1] = SDL_SwapBE16(sample1);\n        dst[0] = SDL_SwapBE16(sample0);\n        dst -= 8;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 8;\n            sample7 = (Uint16) ((((Sint32) SDL_SwapBE16(src[7])) + ((Sint32) last_sample7)) >> 1);\n            sample6 = (Uint16) ((((Sint32) SDL_SwapBE16(src[6])) + ((Sint32) last_sample6)) >> 1);\n            sample5 = (Uint16) ((((Sint32) SDL_SwapBE16(src[5])) + ((Sint32) last_sample5)) >> 1);\n            sample4 = (Uint16) ((((Sint32) SDL_SwapBE16(src[4])) + ((Sint32) last_sample4)) >> 1);\n            sample3 = (Uint16) ((((Sint32) SDL_SwapBE16(src[3])) + ((Sint32) last_sample3)) >> 1);\n            sample2 = (Uint16) ((((Sint32) SDL_SwapBE16(src[2])) + ((Sint32) last_sample2)) >> 1);\n            sample1 = (Uint16) ((((Sint32) SDL_SwapBE16(src[1])) + ((Sint32) last_sample1)) >> 1);\n            sample0 = (Uint16) ((((Sint32) SDL_SwapBE16(src[0])) + ((Sint32) last_sample0)) >> 1);\n            last_sample7 = sample7;\n            last_sample6 = sample6;\n            last_sample5 = sample5;\n            last_sample4 = sample4;\n            last_sample3 = sample3;\n            last_sample2 = sample2;\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U16MSB_8c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_U16MSB, 8 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 256;\n    const int dstsize = (int) (((double)(cvt->len_cvt/16)) * cvt->rate_incr) * 16;\n    register int eps = 0;\n    Uint16 *dst = (Uint16 *) cvt->buf;\n    const Uint16 *src = (Uint16 *) cvt->buf;\n    const Uint16 *target = (const Uint16 *) (cvt->buf + dstsize);\n    Uint16 sample0 = SDL_SwapBE16(src[0]);\n    Uint16 sample1 = SDL_SwapBE16(src[1]);\n    Uint16 sample2 = SDL_SwapBE16(src[2]);\n    Uint16 sample3 = SDL_SwapBE16(src[3]);\n    Uint16 sample4 = SDL_SwapBE16(src[4]);\n    Uint16 sample5 = SDL_SwapBE16(src[5]);\n    Uint16 sample6 = SDL_SwapBE16(src[6]);\n    Uint16 sample7 = SDL_SwapBE16(src[7]);\n    Uint16 last_sample0 = sample0;\n    Uint16 last_sample1 = sample1;\n    Uint16 last_sample2 = sample2;\n    Uint16 last_sample3 = sample3;\n    Uint16 last_sample4 = sample4;\n    Uint16 last_sample5 = sample5;\n    Uint16 last_sample6 = sample6;\n    Uint16 last_sample7 = sample7;\n    while (dst < target) {\n        src += 8;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = SDL_SwapBE16(sample0);\n            dst[1] = SDL_SwapBE16(sample1);\n            dst[2] = SDL_SwapBE16(sample2);\n            dst[3] = SDL_SwapBE16(sample3);\n            dst[4] = SDL_SwapBE16(sample4);\n            dst[5] = SDL_SwapBE16(sample5);\n            dst[6] = SDL_SwapBE16(sample6);\n            dst[7] = SDL_SwapBE16(sample7);\n            dst += 8;\n            sample0 = (Uint16) ((((Sint32) SDL_SwapBE16(src[0])) + ((Sint32) last_sample0)) >> 1);\n            sample1 = (Uint16) ((((Sint32) SDL_SwapBE16(src[1])) + ((Sint32) last_sample1)) >> 1);\n            sample2 = (Uint16) ((((Sint32) SDL_SwapBE16(src[2])) + ((Sint32) last_sample2)) >> 1);\n            sample3 = (Uint16) ((((Sint32) SDL_SwapBE16(src[3])) + ((Sint32) last_sample3)) >> 1);\n            sample4 = (Uint16) ((((Sint32) SDL_SwapBE16(src[4])) + ((Sint32) last_sample4)) >> 1);\n            sample5 = (Uint16) ((((Sint32) SDL_SwapBE16(src[5])) + ((Sint32) last_sample5)) >> 1);\n            sample6 = (Uint16) ((((Sint32) SDL_SwapBE16(src[6])) + ((Sint32) last_sample6)) >> 1);\n            sample7 = (Uint16) ((((Sint32) SDL_SwapBE16(src[7])) + ((Sint32) last_sample7)) >> 1);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            last_sample2 = sample2;\n            last_sample3 = sample3;\n            last_sample4 = sample4;\n            last_sample5 = sample5;\n            last_sample6 = sample6;\n            last_sample7 = sample7;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S16MSB_1c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_S16MSB, 1 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 32;\n    const int dstsize = (int) (((double)(cvt->len_cvt/2)) * cvt->rate_incr) * 2;\n    register int eps = 0;\n    Sint16 *dst = ((Sint16 *) (cvt->buf + dstsize)) - 1;\n    const Sint16 *src = ((Sint16 *) (cvt->buf + cvt->len_cvt)) - 1;\n    const Sint16 *target = ((const Sint16 *) cvt->buf);\n    Sint16 sample0 = ((Sint16) SDL_SwapBE16(src[0]));\n    Sint16 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[0] = ((Sint16) SDL_SwapBE16(sample0));\n        dst--;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src--;\n            sample0 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[0]))) + ((Sint32) last_sample0)) >> 1);\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S16MSB_1c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_S16MSB, 1 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 32;\n    const int dstsize = (int) (((double)(cvt->len_cvt/2)) * cvt->rate_incr) * 2;\n    register int eps = 0;\n    Sint16 *dst = (Sint16 *) cvt->buf;\n    const Sint16 *src = (Sint16 *) cvt->buf;\n    const Sint16 *target = (const Sint16 *) (cvt->buf + dstsize);\n    Sint16 sample0 = ((Sint16) SDL_SwapBE16(src[0]));\n    Sint16 last_sample0 = sample0;\n    while (dst < target) {\n        src++;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = ((Sint16) SDL_SwapBE16(sample0));\n            dst++;\n            sample0 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[0]))) + ((Sint32) last_sample0)) >> 1);\n            last_sample0 = sample0;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S16MSB_2c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_S16MSB, 2 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 64;\n    const int dstsize = (int) (((double)(cvt->len_cvt/4)) * cvt->rate_incr) * 4;\n    register int eps = 0;\n    Sint16 *dst = ((Sint16 *) (cvt->buf + dstsize)) - 2;\n    const Sint16 *src = ((Sint16 *) (cvt->buf + cvt->len_cvt)) - 2;\n    const Sint16 *target = ((const Sint16 *) cvt->buf);\n    Sint16 sample1 = ((Sint16) SDL_SwapBE16(src[1]));\n    Sint16 sample0 = ((Sint16) SDL_SwapBE16(src[0]));\n    Sint16 last_sample1 = sample1;\n    Sint16 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[1] = ((Sint16) SDL_SwapBE16(sample1));\n        dst[0] = ((Sint16) SDL_SwapBE16(sample0));\n        dst -= 2;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 2;\n            sample1 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[1]))) + ((Sint32) last_sample1)) >> 1);\n            sample0 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[0]))) + ((Sint32) last_sample0)) >> 1);\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S16MSB_2c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_S16MSB, 2 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 64;\n    const int dstsize = (int) (((double)(cvt->len_cvt/4)) * cvt->rate_incr) * 4;\n    register int eps = 0;\n    Sint16 *dst = (Sint16 *) cvt->buf;\n    const Sint16 *src = (Sint16 *) cvt->buf;\n    const Sint16 *target = (const Sint16 *) (cvt->buf + dstsize);\n    Sint16 sample0 = ((Sint16) SDL_SwapBE16(src[0]));\n    Sint16 sample1 = ((Sint16) SDL_SwapBE16(src[1]));\n    Sint16 last_sample0 = sample0;\n    Sint16 last_sample1 = sample1;\n    while (dst < target) {\n        src += 2;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = ((Sint16) SDL_SwapBE16(sample0));\n            dst[1] = ((Sint16) SDL_SwapBE16(sample1));\n            dst += 2;\n            sample0 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[0]))) + ((Sint32) last_sample0)) >> 1);\n            sample1 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[1]))) + ((Sint32) last_sample1)) >> 1);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S16MSB_4c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_S16MSB, 4 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 128;\n    const int dstsize = (int) (((double)(cvt->len_cvt/8)) * cvt->rate_incr) * 8;\n    register int eps = 0;\n    Sint16 *dst = ((Sint16 *) (cvt->buf + dstsize)) - 4;\n    const Sint16 *src = ((Sint16 *) (cvt->buf + cvt->len_cvt)) - 4;\n    const Sint16 *target = ((const Sint16 *) cvt->buf);\n    Sint16 sample3 = ((Sint16) SDL_SwapBE16(src[3]));\n    Sint16 sample2 = ((Sint16) SDL_SwapBE16(src[2]));\n    Sint16 sample1 = ((Sint16) SDL_SwapBE16(src[1]));\n    Sint16 sample0 = ((Sint16) SDL_SwapBE16(src[0]));\n    Sint16 last_sample3 = sample3;\n    Sint16 last_sample2 = sample2;\n    Sint16 last_sample1 = sample1;\n    Sint16 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[3] = ((Sint16) SDL_SwapBE16(sample3));\n        dst[2] = ((Sint16) SDL_SwapBE16(sample2));\n        dst[1] = ((Sint16) SDL_SwapBE16(sample1));\n        dst[0] = ((Sint16) SDL_SwapBE16(sample0));\n        dst -= 4;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 4;\n            sample3 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[3]))) + ((Sint32) last_sample3)) >> 1);\n            sample2 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[2]))) + ((Sint32) last_sample2)) >> 1);\n            sample1 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[1]))) + ((Sint32) last_sample1)) >> 1);\n            sample0 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[0]))) + ((Sint32) last_sample0)) >> 1);\n            last_sample3 = sample3;\n            last_sample2 = sample2;\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S16MSB_4c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_S16MSB, 4 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 128;\n    const int dstsize = (int) (((double)(cvt->len_cvt/8)) * cvt->rate_incr) * 8;\n    register int eps = 0;\n    Sint16 *dst = (Sint16 *) cvt->buf;\n    const Sint16 *src = (Sint16 *) cvt->buf;\n    const Sint16 *target = (const Sint16 *) (cvt->buf + dstsize);\n    Sint16 sample0 = ((Sint16) SDL_SwapBE16(src[0]));\n    Sint16 sample1 = ((Sint16) SDL_SwapBE16(src[1]));\n    Sint16 sample2 = ((Sint16) SDL_SwapBE16(src[2]));\n    Sint16 sample3 = ((Sint16) SDL_SwapBE16(src[3]));\n    Sint16 last_sample0 = sample0;\n    Sint16 last_sample1 = sample1;\n    Sint16 last_sample2 = sample2;\n    Sint16 last_sample3 = sample3;\n    while (dst < target) {\n        src += 4;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = ((Sint16) SDL_SwapBE16(sample0));\n            dst[1] = ((Sint16) SDL_SwapBE16(sample1));\n            dst[2] = ((Sint16) SDL_SwapBE16(sample2));\n            dst[3] = ((Sint16) SDL_SwapBE16(sample3));\n            dst += 4;\n            sample0 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[0]))) + ((Sint32) last_sample0)) >> 1);\n            sample1 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[1]))) + ((Sint32) last_sample1)) >> 1);\n            sample2 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[2]))) + ((Sint32) last_sample2)) >> 1);\n            sample3 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[3]))) + ((Sint32) last_sample3)) >> 1);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            last_sample2 = sample2;\n            last_sample3 = sample3;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S16MSB_6c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_S16MSB, 6 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 192;\n    const int dstsize = (int) (((double)(cvt->len_cvt/12)) * cvt->rate_incr) * 12;\n    register int eps = 0;\n    Sint16 *dst = ((Sint16 *) (cvt->buf + dstsize)) - 6;\n    const Sint16 *src = ((Sint16 *) (cvt->buf + cvt->len_cvt)) - 6;\n    const Sint16 *target = ((const Sint16 *) cvt->buf);\n    Sint16 sample5 = ((Sint16) SDL_SwapBE16(src[5]));\n    Sint16 sample4 = ((Sint16) SDL_SwapBE16(src[4]));\n    Sint16 sample3 = ((Sint16) SDL_SwapBE16(src[3]));\n    Sint16 sample2 = ((Sint16) SDL_SwapBE16(src[2]));\n    Sint16 sample1 = ((Sint16) SDL_SwapBE16(src[1]));\n    Sint16 sample0 = ((Sint16) SDL_SwapBE16(src[0]));\n    Sint16 last_sample5 = sample5;\n    Sint16 last_sample4 = sample4;\n    Sint16 last_sample3 = sample3;\n    Sint16 last_sample2 = sample2;\n    Sint16 last_sample1 = sample1;\n    Sint16 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[5] = ((Sint16) SDL_SwapBE16(sample5));\n        dst[4] = ((Sint16) SDL_SwapBE16(sample4));\n        dst[3] = ((Sint16) SDL_SwapBE16(sample3));\n        dst[2] = ((Sint16) SDL_SwapBE16(sample2));\n        dst[1] = ((Sint16) SDL_SwapBE16(sample1));\n        dst[0] = ((Sint16) SDL_SwapBE16(sample0));\n        dst -= 6;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 6;\n            sample5 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[5]))) + ((Sint32) last_sample5)) >> 1);\n            sample4 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[4]))) + ((Sint32) last_sample4)) >> 1);\n            sample3 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[3]))) + ((Sint32) last_sample3)) >> 1);\n            sample2 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[2]))) + ((Sint32) last_sample2)) >> 1);\n            sample1 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[1]))) + ((Sint32) last_sample1)) >> 1);\n            sample0 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[0]))) + ((Sint32) last_sample0)) >> 1);\n            last_sample5 = sample5;\n            last_sample4 = sample4;\n            last_sample3 = sample3;\n            last_sample2 = sample2;\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S16MSB_6c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_S16MSB, 6 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 192;\n    const int dstsize = (int) (((double)(cvt->len_cvt/12)) * cvt->rate_incr) * 12;\n    register int eps = 0;\n    Sint16 *dst = (Sint16 *) cvt->buf;\n    const Sint16 *src = (Sint16 *) cvt->buf;\n    const Sint16 *target = (const Sint16 *) (cvt->buf + dstsize);\n    Sint16 sample0 = ((Sint16) SDL_SwapBE16(src[0]));\n    Sint16 sample1 = ((Sint16) SDL_SwapBE16(src[1]));\n    Sint16 sample2 = ((Sint16) SDL_SwapBE16(src[2]));\n    Sint16 sample3 = ((Sint16) SDL_SwapBE16(src[3]));\n    Sint16 sample4 = ((Sint16) SDL_SwapBE16(src[4]));\n    Sint16 sample5 = ((Sint16) SDL_SwapBE16(src[5]));\n    Sint16 last_sample0 = sample0;\n    Sint16 last_sample1 = sample1;\n    Sint16 last_sample2 = sample2;\n    Sint16 last_sample3 = sample3;\n    Sint16 last_sample4 = sample4;\n    Sint16 last_sample5 = sample5;\n    while (dst < target) {\n        src += 6;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = ((Sint16) SDL_SwapBE16(sample0));\n            dst[1] = ((Sint16) SDL_SwapBE16(sample1));\n            dst[2] = ((Sint16) SDL_SwapBE16(sample2));\n            dst[3] = ((Sint16) SDL_SwapBE16(sample3));\n            dst[4] = ((Sint16) SDL_SwapBE16(sample4));\n            dst[5] = ((Sint16) SDL_SwapBE16(sample5));\n            dst += 6;\n            sample0 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[0]))) + ((Sint32) last_sample0)) >> 1);\n            sample1 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[1]))) + ((Sint32) last_sample1)) >> 1);\n            sample2 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[2]))) + ((Sint32) last_sample2)) >> 1);\n            sample3 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[3]))) + ((Sint32) last_sample3)) >> 1);\n            sample4 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[4]))) + ((Sint32) last_sample4)) >> 1);\n            sample5 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[5]))) + ((Sint32) last_sample5)) >> 1);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            last_sample2 = sample2;\n            last_sample3 = sample3;\n            last_sample4 = sample4;\n            last_sample5 = sample5;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S16MSB_8c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_S16MSB, 8 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 256;\n    const int dstsize = (int) (((double)(cvt->len_cvt/16)) * cvt->rate_incr) * 16;\n    register int eps = 0;\n    Sint16 *dst = ((Sint16 *) (cvt->buf + dstsize)) - 8;\n    const Sint16 *src = ((Sint16 *) (cvt->buf + cvt->len_cvt)) - 8;\n    const Sint16 *target = ((const Sint16 *) cvt->buf);\n    Sint16 sample7 = ((Sint16) SDL_SwapBE16(src[7]));\n    Sint16 sample6 = ((Sint16) SDL_SwapBE16(src[6]));\n    Sint16 sample5 = ((Sint16) SDL_SwapBE16(src[5]));\n    Sint16 sample4 = ((Sint16) SDL_SwapBE16(src[4]));\n    Sint16 sample3 = ((Sint16) SDL_SwapBE16(src[3]));\n    Sint16 sample2 = ((Sint16) SDL_SwapBE16(src[2]));\n    Sint16 sample1 = ((Sint16) SDL_SwapBE16(src[1]));\n    Sint16 sample0 = ((Sint16) SDL_SwapBE16(src[0]));\n    Sint16 last_sample7 = sample7;\n    Sint16 last_sample6 = sample6;\n    Sint16 last_sample5 = sample5;\n    Sint16 last_sample4 = sample4;\n    Sint16 last_sample3 = sample3;\n    Sint16 last_sample2 = sample2;\n    Sint16 last_sample1 = sample1;\n    Sint16 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[7] = ((Sint16) SDL_SwapBE16(sample7));\n        dst[6] = ((Sint16) SDL_SwapBE16(sample6));\n        dst[5] = ((Sint16) SDL_SwapBE16(sample5));\n        dst[4] = ((Sint16) SDL_SwapBE16(sample4));\n        dst[3] = ((Sint16) SDL_SwapBE16(sample3));\n        dst[2] = ((Sint16) SDL_SwapBE16(sample2));\n        dst[1] = ((Sint16) SDL_SwapBE16(sample1));\n        dst[0] = ((Sint16) SDL_SwapBE16(sample0));\n        dst -= 8;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 8;\n            sample7 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[7]))) + ((Sint32) last_sample7)) >> 1);\n            sample6 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[6]))) + ((Sint32) last_sample6)) >> 1);\n            sample5 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[5]))) + ((Sint32) last_sample5)) >> 1);\n            sample4 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[4]))) + ((Sint32) last_sample4)) >> 1);\n            sample3 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[3]))) + ((Sint32) last_sample3)) >> 1);\n            sample2 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[2]))) + ((Sint32) last_sample2)) >> 1);\n            sample1 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[1]))) + ((Sint32) last_sample1)) >> 1);\n            sample0 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[0]))) + ((Sint32) last_sample0)) >> 1);\n            last_sample7 = sample7;\n            last_sample6 = sample6;\n            last_sample5 = sample5;\n            last_sample4 = sample4;\n            last_sample3 = sample3;\n            last_sample2 = sample2;\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S16MSB_8c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_S16MSB, 8 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 256;\n    const int dstsize = (int) (((double)(cvt->len_cvt/16)) * cvt->rate_incr) * 16;\n    register int eps = 0;\n    Sint16 *dst = (Sint16 *) cvt->buf;\n    const Sint16 *src = (Sint16 *) cvt->buf;\n    const Sint16 *target = (const Sint16 *) (cvt->buf + dstsize);\n    Sint16 sample0 = ((Sint16) SDL_SwapBE16(src[0]));\n    Sint16 sample1 = ((Sint16) SDL_SwapBE16(src[1]));\n    Sint16 sample2 = ((Sint16) SDL_SwapBE16(src[2]));\n    Sint16 sample3 = ((Sint16) SDL_SwapBE16(src[3]));\n    Sint16 sample4 = ((Sint16) SDL_SwapBE16(src[4]));\n    Sint16 sample5 = ((Sint16) SDL_SwapBE16(src[5]));\n    Sint16 sample6 = ((Sint16) SDL_SwapBE16(src[6]));\n    Sint16 sample7 = ((Sint16) SDL_SwapBE16(src[7]));\n    Sint16 last_sample0 = sample0;\n    Sint16 last_sample1 = sample1;\n    Sint16 last_sample2 = sample2;\n    Sint16 last_sample3 = sample3;\n    Sint16 last_sample4 = sample4;\n    Sint16 last_sample5 = sample5;\n    Sint16 last_sample6 = sample6;\n    Sint16 last_sample7 = sample7;\n    while (dst < target) {\n        src += 8;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = ((Sint16) SDL_SwapBE16(sample0));\n            dst[1] = ((Sint16) SDL_SwapBE16(sample1));\n            dst[2] = ((Sint16) SDL_SwapBE16(sample2));\n            dst[3] = ((Sint16) SDL_SwapBE16(sample3));\n            dst[4] = ((Sint16) SDL_SwapBE16(sample4));\n            dst[5] = ((Sint16) SDL_SwapBE16(sample5));\n            dst[6] = ((Sint16) SDL_SwapBE16(sample6));\n            dst[7] = ((Sint16) SDL_SwapBE16(sample7));\n            dst += 8;\n            sample0 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[0]))) + ((Sint32) last_sample0)) >> 1);\n            sample1 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[1]))) + ((Sint32) last_sample1)) >> 1);\n            sample2 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[2]))) + ((Sint32) last_sample2)) >> 1);\n            sample3 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[3]))) + ((Sint32) last_sample3)) >> 1);\n            sample4 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[4]))) + ((Sint32) last_sample4)) >> 1);\n            sample5 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[5]))) + ((Sint32) last_sample5)) >> 1);\n            sample6 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[6]))) + ((Sint32) last_sample6)) >> 1);\n            sample7 = (Sint16) ((((Sint32) ((Sint16) SDL_SwapBE16(src[7]))) + ((Sint32) last_sample7)) >> 1);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            last_sample2 = sample2;\n            last_sample3 = sample3;\n            last_sample4 = sample4;\n            last_sample5 = sample5;\n            last_sample6 = sample6;\n            last_sample7 = sample7;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S32LSB_1c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_S32LSB, 1 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 64;\n    const int dstsize = (int) (((double)(cvt->len_cvt/4)) * cvt->rate_incr) * 4;\n    register int eps = 0;\n    Sint32 *dst = ((Sint32 *) (cvt->buf + dstsize)) - 1;\n    const Sint32 *src = ((Sint32 *) (cvt->buf + cvt->len_cvt)) - 1;\n    const Sint32 *target = ((const Sint32 *) cvt->buf);\n    Sint32 sample0 = ((Sint32) SDL_SwapLE32(src[0]));\n    Sint32 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[0] = ((Sint32) SDL_SwapLE32(sample0));\n        dst--;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src--;\n            sample0 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[0]))) + ((Sint64) last_sample0)) >> 1);\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S32LSB_1c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_S32LSB, 1 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 64;\n    const int dstsize = (int) (((double)(cvt->len_cvt/4)) * cvt->rate_incr) * 4;\n    register int eps = 0;\n    Sint32 *dst = (Sint32 *) cvt->buf;\n    const Sint32 *src = (Sint32 *) cvt->buf;\n    const Sint32 *target = (const Sint32 *) (cvt->buf + dstsize);\n    Sint32 sample0 = ((Sint32) SDL_SwapLE32(src[0]));\n    Sint32 last_sample0 = sample0;\n    while (dst < target) {\n        src++;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = ((Sint32) SDL_SwapLE32(sample0));\n            dst++;\n            sample0 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[0]))) + ((Sint64) last_sample0)) >> 1);\n            last_sample0 = sample0;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S32LSB_2c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_S32LSB, 2 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 128;\n    const int dstsize = (int) (((double)(cvt->len_cvt/8)) * cvt->rate_incr) * 8;\n    register int eps = 0;\n    Sint32 *dst = ((Sint32 *) (cvt->buf + dstsize)) - 2;\n    const Sint32 *src = ((Sint32 *) (cvt->buf + cvt->len_cvt)) - 2;\n    const Sint32 *target = ((const Sint32 *) cvt->buf);\n    Sint32 sample1 = ((Sint32) SDL_SwapLE32(src[1]));\n    Sint32 sample0 = ((Sint32) SDL_SwapLE32(src[0]));\n    Sint32 last_sample1 = sample1;\n    Sint32 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[1] = ((Sint32) SDL_SwapLE32(sample1));\n        dst[0] = ((Sint32) SDL_SwapLE32(sample0));\n        dst -= 2;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 2;\n            sample1 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[1]))) + ((Sint64) last_sample1)) >> 1);\n            sample0 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[0]))) + ((Sint64) last_sample0)) >> 1);\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S32LSB_2c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_S32LSB, 2 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 128;\n    const int dstsize = (int) (((double)(cvt->len_cvt/8)) * cvt->rate_incr) * 8;\n    register int eps = 0;\n    Sint32 *dst = (Sint32 *) cvt->buf;\n    const Sint32 *src = (Sint32 *) cvt->buf;\n    const Sint32 *target = (const Sint32 *) (cvt->buf + dstsize);\n    Sint32 sample0 = ((Sint32) SDL_SwapLE32(src[0]));\n    Sint32 sample1 = ((Sint32) SDL_SwapLE32(src[1]));\n    Sint32 last_sample0 = sample0;\n    Sint32 last_sample1 = sample1;\n    while (dst < target) {\n        src += 2;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = ((Sint32) SDL_SwapLE32(sample0));\n            dst[1] = ((Sint32) SDL_SwapLE32(sample1));\n            dst += 2;\n            sample0 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[0]))) + ((Sint64) last_sample0)) >> 1);\n            sample1 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[1]))) + ((Sint64) last_sample1)) >> 1);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S32LSB_4c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_S32LSB, 4 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 256;\n    const int dstsize = (int) (((double)(cvt->len_cvt/16)) * cvt->rate_incr) * 16;\n    register int eps = 0;\n    Sint32 *dst = ((Sint32 *) (cvt->buf + dstsize)) - 4;\n    const Sint32 *src = ((Sint32 *) (cvt->buf + cvt->len_cvt)) - 4;\n    const Sint32 *target = ((const Sint32 *) cvt->buf);\n    Sint32 sample3 = ((Sint32) SDL_SwapLE32(src[3]));\n    Sint32 sample2 = ((Sint32) SDL_SwapLE32(src[2]));\n    Sint32 sample1 = ((Sint32) SDL_SwapLE32(src[1]));\n    Sint32 sample0 = ((Sint32) SDL_SwapLE32(src[0]));\n    Sint32 last_sample3 = sample3;\n    Sint32 last_sample2 = sample2;\n    Sint32 last_sample1 = sample1;\n    Sint32 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[3] = ((Sint32) SDL_SwapLE32(sample3));\n        dst[2] = ((Sint32) SDL_SwapLE32(sample2));\n        dst[1] = ((Sint32) SDL_SwapLE32(sample1));\n        dst[0] = ((Sint32) SDL_SwapLE32(sample0));\n        dst -= 4;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 4;\n            sample3 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[3]))) + ((Sint64) last_sample3)) >> 1);\n            sample2 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[2]))) + ((Sint64) last_sample2)) >> 1);\n            sample1 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[1]))) + ((Sint64) last_sample1)) >> 1);\n            sample0 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[0]))) + ((Sint64) last_sample0)) >> 1);\n            last_sample3 = sample3;\n            last_sample2 = sample2;\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S32LSB_4c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_S32LSB, 4 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 256;\n    const int dstsize = (int) (((double)(cvt->len_cvt/16)) * cvt->rate_incr) * 16;\n    register int eps = 0;\n    Sint32 *dst = (Sint32 *) cvt->buf;\n    const Sint32 *src = (Sint32 *) cvt->buf;\n    const Sint32 *target = (const Sint32 *) (cvt->buf + dstsize);\n    Sint32 sample0 = ((Sint32) SDL_SwapLE32(src[0]));\n    Sint32 sample1 = ((Sint32) SDL_SwapLE32(src[1]));\n    Sint32 sample2 = ((Sint32) SDL_SwapLE32(src[2]));\n    Sint32 sample3 = ((Sint32) SDL_SwapLE32(src[3]));\n    Sint32 last_sample0 = sample0;\n    Sint32 last_sample1 = sample1;\n    Sint32 last_sample2 = sample2;\n    Sint32 last_sample3 = sample3;\n    while (dst < target) {\n        src += 4;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = ((Sint32) SDL_SwapLE32(sample0));\n            dst[1] = ((Sint32) SDL_SwapLE32(sample1));\n            dst[2] = ((Sint32) SDL_SwapLE32(sample2));\n            dst[3] = ((Sint32) SDL_SwapLE32(sample3));\n            dst += 4;\n            sample0 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[0]))) + ((Sint64) last_sample0)) >> 1);\n            sample1 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[1]))) + ((Sint64) last_sample1)) >> 1);\n            sample2 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[2]))) + ((Sint64) last_sample2)) >> 1);\n            sample3 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[3]))) + ((Sint64) last_sample3)) >> 1);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            last_sample2 = sample2;\n            last_sample3 = sample3;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S32LSB_6c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_S32LSB, 6 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 384;\n    const int dstsize = (int) (((double)(cvt->len_cvt/24)) * cvt->rate_incr) * 24;\n    register int eps = 0;\n    Sint32 *dst = ((Sint32 *) (cvt->buf + dstsize)) - 6;\n    const Sint32 *src = ((Sint32 *) (cvt->buf + cvt->len_cvt)) - 6;\n    const Sint32 *target = ((const Sint32 *) cvt->buf);\n    Sint32 sample5 = ((Sint32) SDL_SwapLE32(src[5]));\n    Sint32 sample4 = ((Sint32) SDL_SwapLE32(src[4]));\n    Sint32 sample3 = ((Sint32) SDL_SwapLE32(src[3]));\n    Sint32 sample2 = ((Sint32) SDL_SwapLE32(src[2]));\n    Sint32 sample1 = ((Sint32) SDL_SwapLE32(src[1]));\n    Sint32 sample0 = ((Sint32) SDL_SwapLE32(src[0]));\n    Sint32 last_sample5 = sample5;\n    Sint32 last_sample4 = sample4;\n    Sint32 last_sample3 = sample3;\n    Sint32 last_sample2 = sample2;\n    Sint32 last_sample1 = sample1;\n    Sint32 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[5] = ((Sint32) SDL_SwapLE32(sample5));\n        dst[4] = ((Sint32) SDL_SwapLE32(sample4));\n        dst[3] = ((Sint32) SDL_SwapLE32(sample3));\n        dst[2] = ((Sint32) SDL_SwapLE32(sample2));\n        dst[1] = ((Sint32) SDL_SwapLE32(sample1));\n        dst[0] = ((Sint32) SDL_SwapLE32(sample0));\n        dst -= 6;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 6;\n            sample5 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[5]))) + ((Sint64) last_sample5)) >> 1);\n            sample4 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[4]))) + ((Sint64) last_sample4)) >> 1);\n            sample3 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[3]))) + ((Sint64) last_sample3)) >> 1);\n            sample2 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[2]))) + ((Sint64) last_sample2)) >> 1);\n            sample1 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[1]))) + ((Sint64) last_sample1)) >> 1);\n            sample0 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[0]))) + ((Sint64) last_sample0)) >> 1);\n            last_sample5 = sample5;\n            last_sample4 = sample4;\n            last_sample3 = sample3;\n            last_sample2 = sample2;\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S32LSB_6c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_S32LSB, 6 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 384;\n    const int dstsize = (int) (((double)(cvt->len_cvt/24)) * cvt->rate_incr) * 24;\n    register int eps = 0;\n    Sint32 *dst = (Sint32 *) cvt->buf;\n    const Sint32 *src = (Sint32 *) cvt->buf;\n    const Sint32 *target = (const Sint32 *) (cvt->buf + dstsize);\n    Sint32 sample0 = ((Sint32) SDL_SwapLE32(src[0]));\n    Sint32 sample1 = ((Sint32) SDL_SwapLE32(src[1]));\n    Sint32 sample2 = ((Sint32) SDL_SwapLE32(src[2]));\n    Sint32 sample3 = ((Sint32) SDL_SwapLE32(src[3]));\n    Sint32 sample4 = ((Sint32) SDL_SwapLE32(src[4]));\n    Sint32 sample5 = ((Sint32) SDL_SwapLE32(src[5]));\n    Sint32 last_sample0 = sample0;\n    Sint32 last_sample1 = sample1;\n    Sint32 last_sample2 = sample2;\n    Sint32 last_sample3 = sample3;\n    Sint32 last_sample4 = sample4;\n    Sint32 last_sample5 = sample5;\n    while (dst < target) {\n        src += 6;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = ((Sint32) SDL_SwapLE32(sample0));\n            dst[1] = ((Sint32) SDL_SwapLE32(sample1));\n            dst[2] = ((Sint32) SDL_SwapLE32(sample2));\n            dst[3] = ((Sint32) SDL_SwapLE32(sample3));\n            dst[4] = ((Sint32) SDL_SwapLE32(sample4));\n            dst[5] = ((Sint32) SDL_SwapLE32(sample5));\n            dst += 6;\n            sample0 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[0]))) + ((Sint64) last_sample0)) >> 1);\n            sample1 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[1]))) + ((Sint64) last_sample1)) >> 1);\n            sample2 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[2]))) + ((Sint64) last_sample2)) >> 1);\n            sample3 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[3]))) + ((Sint64) last_sample3)) >> 1);\n            sample4 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[4]))) + ((Sint64) last_sample4)) >> 1);\n            sample5 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[5]))) + ((Sint64) last_sample5)) >> 1);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            last_sample2 = sample2;\n            last_sample3 = sample3;\n            last_sample4 = sample4;\n            last_sample5 = sample5;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S32LSB_8c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_S32LSB, 8 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 512;\n    const int dstsize = (int) (((double)(cvt->len_cvt/32)) * cvt->rate_incr) * 32;\n    register int eps = 0;\n    Sint32 *dst = ((Sint32 *) (cvt->buf + dstsize)) - 8;\n    const Sint32 *src = ((Sint32 *) (cvt->buf + cvt->len_cvt)) - 8;\n    const Sint32 *target = ((const Sint32 *) cvt->buf);\n    Sint32 sample7 = ((Sint32) SDL_SwapLE32(src[7]));\n    Sint32 sample6 = ((Sint32) SDL_SwapLE32(src[6]));\n    Sint32 sample5 = ((Sint32) SDL_SwapLE32(src[5]));\n    Sint32 sample4 = ((Sint32) SDL_SwapLE32(src[4]));\n    Sint32 sample3 = ((Sint32) SDL_SwapLE32(src[3]));\n    Sint32 sample2 = ((Sint32) SDL_SwapLE32(src[2]));\n    Sint32 sample1 = ((Sint32) SDL_SwapLE32(src[1]));\n    Sint32 sample0 = ((Sint32) SDL_SwapLE32(src[0]));\n    Sint32 last_sample7 = sample7;\n    Sint32 last_sample6 = sample6;\n    Sint32 last_sample5 = sample5;\n    Sint32 last_sample4 = sample4;\n    Sint32 last_sample3 = sample3;\n    Sint32 last_sample2 = sample2;\n    Sint32 last_sample1 = sample1;\n    Sint32 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[7] = ((Sint32) SDL_SwapLE32(sample7));\n        dst[6] = ((Sint32) SDL_SwapLE32(sample6));\n        dst[5] = ((Sint32) SDL_SwapLE32(sample5));\n        dst[4] = ((Sint32) SDL_SwapLE32(sample4));\n        dst[3] = ((Sint32) SDL_SwapLE32(sample3));\n        dst[2] = ((Sint32) SDL_SwapLE32(sample2));\n        dst[1] = ((Sint32) SDL_SwapLE32(sample1));\n        dst[0] = ((Sint32) SDL_SwapLE32(sample0));\n        dst -= 8;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 8;\n            sample7 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[7]))) + ((Sint64) last_sample7)) >> 1);\n            sample6 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[6]))) + ((Sint64) last_sample6)) >> 1);\n            sample5 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[5]))) + ((Sint64) last_sample5)) >> 1);\n            sample4 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[4]))) + ((Sint64) last_sample4)) >> 1);\n            sample3 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[3]))) + ((Sint64) last_sample3)) >> 1);\n            sample2 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[2]))) + ((Sint64) last_sample2)) >> 1);\n            sample1 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[1]))) + ((Sint64) last_sample1)) >> 1);\n            sample0 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[0]))) + ((Sint64) last_sample0)) >> 1);\n            last_sample7 = sample7;\n            last_sample6 = sample6;\n            last_sample5 = sample5;\n            last_sample4 = sample4;\n            last_sample3 = sample3;\n            last_sample2 = sample2;\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S32LSB_8c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_S32LSB, 8 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 512;\n    const int dstsize = (int) (((double)(cvt->len_cvt/32)) * cvt->rate_incr) * 32;\n    register int eps = 0;\n    Sint32 *dst = (Sint32 *) cvt->buf;\n    const Sint32 *src = (Sint32 *) cvt->buf;\n    const Sint32 *target = (const Sint32 *) (cvt->buf + dstsize);\n    Sint32 sample0 = ((Sint32) SDL_SwapLE32(src[0]));\n    Sint32 sample1 = ((Sint32) SDL_SwapLE32(src[1]));\n    Sint32 sample2 = ((Sint32) SDL_SwapLE32(src[2]));\n    Sint32 sample3 = ((Sint32) SDL_SwapLE32(src[3]));\n    Sint32 sample4 = ((Sint32) SDL_SwapLE32(src[4]));\n    Sint32 sample5 = ((Sint32) SDL_SwapLE32(src[5]));\n    Sint32 sample6 = ((Sint32) SDL_SwapLE32(src[6]));\n    Sint32 sample7 = ((Sint32) SDL_SwapLE32(src[7]));\n    Sint32 last_sample0 = sample0;\n    Sint32 last_sample1 = sample1;\n    Sint32 last_sample2 = sample2;\n    Sint32 last_sample3 = sample3;\n    Sint32 last_sample4 = sample4;\n    Sint32 last_sample5 = sample5;\n    Sint32 last_sample6 = sample6;\n    Sint32 last_sample7 = sample7;\n    while (dst < target) {\n        src += 8;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = ((Sint32) SDL_SwapLE32(sample0));\n            dst[1] = ((Sint32) SDL_SwapLE32(sample1));\n            dst[2] = ((Sint32) SDL_SwapLE32(sample2));\n            dst[3] = ((Sint32) SDL_SwapLE32(sample3));\n            dst[4] = ((Sint32) SDL_SwapLE32(sample4));\n            dst[5] = ((Sint32) SDL_SwapLE32(sample5));\n            dst[6] = ((Sint32) SDL_SwapLE32(sample6));\n            dst[7] = ((Sint32) SDL_SwapLE32(sample7));\n            dst += 8;\n            sample0 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[0]))) + ((Sint64) last_sample0)) >> 1);\n            sample1 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[1]))) + ((Sint64) last_sample1)) >> 1);\n            sample2 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[2]))) + ((Sint64) last_sample2)) >> 1);\n            sample3 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[3]))) + ((Sint64) last_sample3)) >> 1);\n            sample4 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[4]))) + ((Sint64) last_sample4)) >> 1);\n            sample5 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[5]))) + ((Sint64) last_sample5)) >> 1);\n            sample6 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[6]))) + ((Sint64) last_sample6)) >> 1);\n            sample7 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapLE32(src[7]))) + ((Sint64) last_sample7)) >> 1);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            last_sample2 = sample2;\n            last_sample3 = sample3;\n            last_sample4 = sample4;\n            last_sample5 = sample5;\n            last_sample6 = sample6;\n            last_sample7 = sample7;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S32MSB_1c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_S32MSB, 1 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 64;\n    const int dstsize = (int) (((double)(cvt->len_cvt/4)) * cvt->rate_incr) * 4;\n    register int eps = 0;\n    Sint32 *dst = ((Sint32 *) (cvt->buf + dstsize)) - 1;\n    const Sint32 *src = ((Sint32 *) (cvt->buf + cvt->len_cvt)) - 1;\n    const Sint32 *target = ((const Sint32 *) cvt->buf);\n    Sint32 sample0 = ((Sint32) SDL_SwapBE32(src[0]));\n    Sint32 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[0] = ((Sint32) SDL_SwapBE32(sample0));\n        dst--;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src--;\n            sample0 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[0]))) + ((Sint64) last_sample0)) >> 1);\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S32MSB_1c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_S32MSB, 1 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 64;\n    const int dstsize = (int) (((double)(cvt->len_cvt/4)) * cvt->rate_incr) * 4;\n    register int eps = 0;\n    Sint32 *dst = (Sint32 *) cvt->buf;\n    const Sint32 *src = (Sint32 *) cvt->buf;\n    const Sint32 *target = (const Sint32 *) (cvt->buf + dstsize);\n    Sint32 sample0 = ((Sint32) SDL_SwapBE32(src[0]));\n    Sint32 last_sample0 = sample0;\n    while (dst < target) {\n        src++;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = ((Sint32) SDL_SwapBE32(sample0));\n            dst++;\n            sample0 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[0]))) + ((Sint64) last_sample0)) >> 1);\n            last_sample0 = sample0;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S32MSB_2c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_S32MSB, 2 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 128;\n    const int dstsize = (int) (((double)(cvt->len_cvt/8)) * cvt->rate_incr) * 8;\n    register int eps = 0;\n    Sint32 *dst = ((Sint32 *) (cvt->buf + dstsize)) - 2;\n    const Sint32 *src = ((Sint32 *) (cvt->buf + cvt->len_cvt)) - 2;\n    const Sint32 *target = ((const Sint32 *) cvt->buf);\n    Sint32 sample1 = ((Sint32) SDL_SwapBE32(src[1]));\n    Sint32 sample0 = ((Sint32) SDL_SwapBE32(src[0]));\n    Sint32 last_sample1 = sample1;\n    Sint32 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[1] = ((Sint32) SDL_SwapBE32(sample1));\n        dst[0] = ((Sint32) SDL_SwapBE32(sample0));\n        dst -= 2;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 2;\n            sample1 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[1]))) + ((Sint64) last_sample1)) >> 1);\n            sample0 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[0]))) + ((Sint64) last_sample0)) >> 1);\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S32MSB_2c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_S32MSB, 2 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 128;\n    const int dstsize = (int) (((double)(cvt->len_cvt/8)) * cvt->rate_incr) * 8;\n    register int eps = 0;\n    Sint32 *dst = (Sint32 *) cvt->buf;\n    const Sint32 *src = (Sint32 *) cvt->buf;\n    const Sint32 *target = (const Sint32 *) (cvt->buf + dstsize);\n    Sint32 sample0 = ((Sint32) SDL_SwapBE32(src[0]));\n    Sint32 sample1 = ((Sint32) SDL_SwapBE32(src[1]));\n    Sint32 last_sample0 = sample0;\n    Sint32 last_sample1 = sample1;\n    while (dst < target) {\n        src += 2;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = ((Sint32) SDL_SwapBE32(sample0));\n            dst[1] = ((Sint32) SDL_SwapBE32(sample1));\n            dst += 2;\n            sample0 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[0]))) + ((Sint64) last_sample0)) >> 1);\n            sample1 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[1]))) + ((Sint64) last_sample1)) >> 1);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S32MSB_4c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_S32MSB, 4 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 256;\n    const int dstsize = (int) (((double)(cvt->len_cvt/16)) * cvt->rate_incr) * 16;\n    register int eps = 0;\n    Sint32 *dst = ((Sint32 *) (cvt->buf + dstsize)) - 4;\n    const Sint32 *src = ((Sint32 *) (cvt->buf + cvt->len_cvt)) - 4;\n    const Sint32 *target = ((const Sint32 *) cvt->buf);\n    Sint32 sample3 = ((Sint32) SDL_SwapBE32(src[3]));\n    Sint32 sample2 = ((Sint32) SDL_SwapBE32(src[2]));\n    Sint32 sample1 = ((Sint32) SDL_SwapBE32(src[1]));\n    Sint32 sample0 = ((Sint32) SDL_SwapBE32(src[0]));\n    Sint32 last_sample3 = sample3;\n    Sint32 last_sample2 = sample2;\n    Sint32 last_sample1 = sample1;\n    Sint32 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[3] = ((Sint32) SDL_SwapBE32(sample3));\n        dst[2] = ((Sint32) SDL_SwapBE32(sample2));\n        dst[1] = ((Sint32) SDL_SwapBE32(sample1));\n        dst[0] = ((Sint32) SDL_SwapBE32(sample0));\n        dst -= 4;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 4;\n            sample3 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[3]))) + ((Sint64) last_sample3)) >> 1);\n            sample2 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[2]))) + ((Sint64) last_sample2)) >> 1);\n            sample1 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[1]))) + ((Sint64) last_sample1)) >> 1);\n            sample0 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[0]))) + ((Sint64) last_sample0)) >> 1);\n            last_sample3 = sample3;\n            last_sample2 = sample2;\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S32MSB_4c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_S32MSB, 4 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 256;\n    const int dstsize = (int) (((double)(cvt->len_cvt/16)) * cvt->rate_incr) * 16;\n    register int eps = 0;\n    Sint32 *dst = (Sint32 *) cvt->buf;\n    const Sint32 *src = (Sint32 *) cvt->buf;\n    const Sint32 *target = (const Sint32 *) (cvt->buf + dstsize);\n    Sint32 sample0 = ((Sint32) SDL_SwapBE32(src[0]));\n    Sint32 sample1 = ((Sint32) SDL_SwapBE32(src[1]));\n    Sint32 sample2 = ((Sint32) SDL_SwapBE32(src[2]));\n    Sint32 sample3 = ((Sint32) SDL_SwapBE32(src[3]));\n    Sint32 last_sample0 = sample0;\n    Sint32 last_sample1 = sample1;\n    Sint32 last_sample2 = sample2;\n    Sint32 last_sample3 = sample3;\n    while (dst < target) {\n        src += 4;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = ((Sint32) SDL_SwapBE32(sample0));\n            dst[1] = ((Sint32) SDL_SwapBE32(sample1));\n            dst[2] = ((Sint32) SDL_SwapBE32(sample2));\n            dst[3] = ((Sint32) SDL_SwapBE32(sample3));\n            dst += 4;\n            sample0 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[0]))) + ((Sint64) last_sample0)) >> 1);\n            sample1 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[1]))) + ((Sint64) last_sample1)) >> 1);\n            sample2 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[2]))) + ((Sint64) last_sample2)) >> 1);\n            sample3 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[3]))) + ((Sint64) last_sample3)) >> 1);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            last_sample2 = sample2;\n            last_sample3 = sample3;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S32MSB_6c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_S32MSB, 6 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 384;\n    const int dstsize = (int) (((double)(cvt->len_cvt/24)) * cvt->rate_incr) * 24;\n    register int eps = 0;\n    Sint32 *dst = ((Sint32 *) (cvt->buf + dstsize)) - 6;\n    const Sint32 *src = ((Sint32 *) (cvt->buf + cvt->len_cvt)) - 6;\n    const Sint32 *target = ((const Sint32 *) cvt->buf);\n    Sint32 sample5 = ((Sint32) SDL_SwapBE32(src[5]));\n    Sint32 sample4 = ((Sint32) SDL_SwapBE32(src[4]));\n    Sint32 sample3 = ((Sint32) SDL_SwapBE32(src[3]));\n    Sint32 sample2 = ((Sint32) SDL_SwapBE32(src[2]));\n    Sint32 sample1 = ((Sint32) SDL_SwapBE32(src[1]));\n    Sint32 sample0 = ((Sint32) SDL_SwapBE32(src[0]));\n    Sint32 last_sample5 = sample5;\n    Sint32 last_sample4 = sample4;\n    Sint32 last_sample3 = sample3;\n    Sint32 last_sample2 = sample2;\n    Sint32 last_sample1 = sample1;\n    Sint32 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[5] = ((Sint32) SDL_SwapBE32(sample5));\n        dst[4] = ((Sint32) SDL_SwapBE32(sample4));\n        dst[3] = ((Sint32) SDL_SwapBE32(sample3));\n        dst[2] = ((Sint32) SDL_SwapBE32(sample2));\n        dst[1] = ((Sint32) SDL_SwapBE32(sample1));\n        dst[0] = ((Sint32) SDL_SwapBE32(sample0));\n        dst -= 6;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 6;\n            sample5 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[5]))) + ((Sint64) last_sample5)) >> 1);\n            sample4 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[4]))) + ((Sint64) last_sample4)) >> 1);\n            sample3 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[3]))) + ((Sint64) last_sample3)) >> 1);\n            sample2 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[2]))) + ((Sint64) last_sample2)) >> 1);\n            sample1 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[1]))) + ((Sint64) last_sample1)) >> 1);\n            sample0 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[0]))) + ((Sint64) last_sample0)) >> 1);\n            last_sample5 = sample5;\n            last_sample4 = sample4;\n            last_sample3 = sample3;\n            last_sample2 = sample2;\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S32MSB_6c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_S32MSB, 6 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 384;\n    const int dstsize = (int) (((double)(cvt->len_cvt/24)) * cvt->rate_incr) * 24;\n    register int eps = 0;\n    Sint32 *dst = (Sint32 *) cvt->buf;\n    const Sint32 *src = (Sint32 *) cvt->buf;\n    const Sint32 *target = (const Sint32 *) (cvt->buf + dstsize);\n    Sint32 sample0 = ((Sint32) SDL_SwapBE32(src[0]));\n    Sint32 sample1 = ((Sint32) SDL_SwapBE32(src[1]));\n    Sint32 sample2 = ((Sint32) SDL_SwapBE32(src[2]));\n    Sint32 sample3 = ((Sint32) SDL_SwapBE32(src[3]));\n    Sint32 sample4 = ((Sint32) SDL_SwapBE32(src[4]));\n    Sint32 sample5 = ((Sint32) SDL_SwapBE32(src[5]));\n    Sint32 last_sample0 = sample0;\n    Sint32 last_sample1 = sample1;\n    Sint32 last_sample2 = sample2;\n    Sint32 last_sample3 = sample3;\n    Sint32 last_sample4 = sample4;\n    Sint32 last_sample5 = sample5;\n    while (dst < target) {\n        src += 6;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = ((Sint32) SDL_SwapBE32(sample0));\n            dst[1] = ((Sint32) SDL_SwapBE32(sample1));\n            dst[2] = ((Sint32) SDL_SwapBE32(sample2));\n            dst[3] = ((Sint32) SDL_SwapBE32(sample3));\n            dst[4] = ((Sint32) SDL_SwapBE32(sample4));\n            dst[5] = ((Sint32) SDL_SwapBE32(sample5));\n            dst += 6;\n            sample0 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[0]))) + ((Sint64) last_sample0)) >> 1);\n            sample1 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[1]))) + ((Sint64) last_sample1)) >> 1);\n            sample2 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[2]))) + ((Sint64) last_sample2)) >> 1);\n            sample3 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[3]))) + ((Sint64) last_sample3)) >> 1);\n            sample4 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[4]))) + ((Sint64) last_sample4)) >> 1);\n            sample5 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[5]))) + ((Sint64) last_sample5)) >> 1);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            last_sample2 = sample2;\n            last_sample3 = sample3;\n            last_sample4 = sample4;\n            last_sample5 = sample5;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S32MSB_8c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_S32MSB, 8 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 512;\n    const int dstsize = (int) (((double)(cvt->len_cvt/32)) * cvt->rate_incr) * 32;\n    register int eps = 0;\n    Sint32 *dst = ((Sint32 *) (cvt->buf + dstsize)) - 8;\n    const Sint32 *src = ((Sint32 *) (cvt->buf + cvt->len_cvt)) - 8;\n    const Sint32 *target = ((const Sint32 *) cvt->buf);\n    Sint32 sample7 = ((Sint32) SDL_SwapBE32(src[7]));\n    Sint32 sample6 = ((Sint32) SDL_SwapBE32(src[6]));\n    Sint32 sample5 = ((Sint32) SDL_SwapBE32(src[5]));\n    Sint32 sample4 = ((Sint32) SDL_SwapBE32(src[4]));\n    Sint32 sample3 = ((Sint32) SDL_SwapBE32(src[3]));\n    Sint32 sample2 = ((Sint32) SDL_SwapBE32(src[2]));\n    Sint32 sample1 = ((Sint32) SDL_SwapBE32(src[1]));\n    Sint32 sample0 = ((Sint32) SDL_SwapBE32(src[0]));\n    Sint32 last_sample7 = sample7;\n    Sint32 last_sample6 = sample6;\n    Sint32 last_sample5 = sample5;\n    Sint32 last_sample4 = sample4;\n    Sint32 last_sample3 = sample3;\n    Sint32 last_sample2 = sample2;\n    Sint32 last_sample1 = sample1;\n    Sint32 last_sample0 = sample0;\n    while (dst >= target) {\n        dst[7] = ((Sint32) SDL_SwapBE32(sample7));\n        dst[6] = ((Sint32) SDL_SwapBE32(sample6));\n        dst[5] = ((Sint32) SDL_SwapBE32(sample5));\n        dst[4] = ((Sint32) SDL_SwapBE32(sample4));\n        dst[3] = ((Sint32) SDL_SwapBE32(sample3));\n        dst[2] = ((Sint32) SDL_SwapBE32(sample2));\n        dst[1] = ((Sint32) SDL_SwapBE32(sample1));\n        dst[0] = ((Sint32) SDL_SwapBE32(sample0));\n        dst -= 8;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 8;\n            sample7 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[7]))) + ((Sint64) last_sample7)) >> 1);\n            sample6 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[6]))) + ((Sint64) last_sample6)) >> 1);\n            sample5 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[5]))) + ((Sint64) last_sample5)) >> 1);\n            sample4 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[4]))) + ((Sint64) last_sample4)) >> 1);\n            sample3 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[3]))) + ((Sint64) last_sample3)) >> 1);\n            sample2 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[2]))) + ((Sint64) last_sample2)) >> 1);\n            sample1 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[1]))) + ((Sint64) last_sample1)) >> 1);\n            sample0 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[0]))) + ((Sint64) last_sample0)) >> 1);\n            last_sample7 = sample7;\n            last_sample6 = sample6;\n            last_sample5 = sample5;\n            last_sample4 = sample4;\n            last_sample3 = sample3;\n            last_sample2 = sample2;\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S32MSB_8c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_S32MSB, 8 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 512;\n    const int dstsize = (int) (((double)(cvt->len_cvt/32)) * cvt->rate_incr) * 32;\n    register int eps = 0;\n    Sint32 *dst = (Sint32 *) cvt->buf;\n    const Sint32 *src = (Sint32 *) cvt->buf;\n    const Sint32 *target = (const Sint32 *) (cvt->buf + dstsize);\n    Sint32 sample0 = ((Sint32) SDL_SwapBE32(src[0]));\n    Sint32 sample1 = ((Sint32) SDL_SwapBE32(src[1]));\n    Sint32 sample2 = ((Sint32) SDL_SwapBE32(src[2]));\n    Sint32 sample3 = ((Sint32) SDL_SwapBE32(src[3]));\n    Sint32 sample4 = ((Sint32) SDL_SwapBE32(src[4]));\n    Sint32 sample5 = ((Sint32) SDL_SwapBE32(src[5]));\n    Sint32 sample6 = ((Sint32) SDL_SwapBE32(src[6]));\n    Sint32 sample7 = ((Sint32) SDL_SwapBE32(src[7]));\n    Sint32 last_sample0 = sample0;\n    Sint32 last_sample1 = sample1;\n    Sint32 last_sample2 = sample2;\n    Sint32 last_sample3 = sample3;\n    Sint32 last_sample4 = sample4;\n    Sint32 last_sample5 = sample5;\n    Sint32 last_sample6 = sample6;\n    Sint32 last_sample7 = sample7;\n    while (dst < target) {\n        src += 8;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = ((Sint32) SDL_SwapBE32(sample0));\n            dst[1] = ((Sint32) SDL_SwapBE32(sample1));\n            dst[2] = ((Sint32) SDL_SwapBE32(sample2));\n            dst[3] = ((Sint32) SDL_SwapBE32(sample3));\n            dst[4] = ((Sint32) SDL_SwapBE32(sample4));\n            dst[5] = ((Sint32) SDL_SwapBE32(sample5));\n            dst[6] = ((Sint32) SDL_SwapBE32(sample6));\n            dst[7] = ((Sint32) SDL_SwapBE32(sample7));\n            dst += 8;\n            sample0 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[0]))) + ((Sint64) last_sample0)) >> 1);\n            sample1 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[1]))) + ((Sint64) last_sample1)) >> 1);\n            sample2 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[2]))) + ((Sint64) last_sample2)) >> 1);\n            sample3 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[3]))) + ((Sint64) last_sample3)) >> 1);\n            sample4 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[4]))) + ((Sint64) last_sample4)) >> 1);\n            sample5 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[5]))) + ((Sint64) last_sample5)) >> 1);\n            sample6 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[6]))) + ((Sint64) last_sample6)) >> 1);\n            sample7 = (Sint32) ((((Sint64) ((Sint32) SDL_SwapBE32(src[7]))) + ((Sint64) last_sample7)) >> 1);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            last_sample2 = sample2;\n            last_sample3 = sample3;\n            last_sample4 = sample4;\n            last_sample5 = sample5;\n            last_sample6 = sample6;\n            last_sample7 = sample7;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_F32LSB_1c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_F32LSB, 1 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 64;\n    const int dstsize = (int) (((double)(cvt->len_cvt/4)) * cvt->rate_incr) * 4;\n    register int eps = 0;\n    float *dst = ((float *) (cvt->buf + dstsize)) - 1;\n    const float *src = ((float *) (cvt->buf + cvt->len_cvt)) - 1;\n    const float *target = ((const float *) cvt->buf);\n    float sample0 = SDL_SwapFloatLE(src[0]);\n    float last_sample0 = sample0;\n    while (dst >= target) {\n        dst[0] = SDL_SwapFloatLE(sample0);\n        dst--;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src--;\n            sample0 = (float) ((((double) SDL_SwapFloatLE(src[0])) + ((double) last_sample0)) * 0.5);\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_F32LSB_1c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_F32LSB, 1 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 64;\n    const int dstsize = (int) (((double)(cvt->len_cvt/4)) * cvt->rate_incr) * 4;\n    register int eps = 0;\n    float *dst = (float *) cvt->buf;\n    const float *src = (float *) cvt->buf;\n    const float *target = (const float *) (cvt->buf + dstsize);\n    float sample0 = SDL_SwapFloatLE(src[0]);\n    float last_sample0 = sample0;\n    while (dst < target) {\n        src++;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = SDL_SwapFloatLE(sample0);\n            dst++;\n            sample0 = (float) ((((double) SDL_SwapFloatLE(src[0])) + ((double) last_sample0)) * 0.5);\n            last_sample0 = sample0;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_F32LSB_2c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_F32LSB, 2 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 128;\n    const int dstsize = (int) (((double)(cvt->len_cvt/8)) * cvt->rate_incr) * 8;\n    register int eps = 0;\n    float *dst = ((float *) (cvt->buf + dstsize)) - 2;\n    const float *src = ((float *) (cvt->buf + cvt->len_cvt)) - 2;\n    const float *target = ((const float *) cvt->buf);\n    float sample1 = SDL_SwapFloatLE(src[1]);\n    float sample0 = SDL_SwapFloatLE(src[0]);\n    float last_sample1 = sample1;\n    float last_sample0 = sample0;\n    while (dst >= target) {\n        dst[1] = SDL_SwapFloatLE(sample1);\n        dst[0] = SDL_SwapFloatLE(sample0);\n        dst -= 2;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 2;\n            sample1 = (float) ((((double) SDL_SwapFloatLE(src[1])) + ((double) last_sample1)) * 0.5);\n            sample0 = (float) ((((double) SDL_SwapFloatLE(src[0])) + ((double) last_sample0)) * 0.5);\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_F32LSB_2c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_F32LSB, 2 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 128;\n    const int dstsize = (int) (((double)(cvt->len_cvt/8)) * cvt->rate_incr) * 8;\n    register int eps = 0;\n    float *dst = (float *) cvt->buf;\n    const float *src = (float *) cvt->buf;\n    const float *target = (const float *) (cvt->buf + dstsize);\n    float sample0 = SDL_SwapFloatLE(src[0]);\n    float sample1 = SDL_SwapFloatLE(src[1]);\n    float last_sample0 = sample0;\n    float last_sample1 = sample1;\n    while (dst < target) {\n        src += 2;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = SDL_SwapFloatLE(sample0);\n            dst[1] = SDL_SwapFloatLE(sample1);\n            dst += 2;\n            sample0 = (float) ((((double) SDL_SwapFloatLE(src[0])) + ((double) last_sample0)) * 0.5);\n            sample1 = (float) ((((double) SDL_SwapFloatLE(src[1])) + ((double) last_sample1)) * 0.5);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_F32LSB_4c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_F32LSB, 4 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 256;\n    const int dstsize = (int) (((double)(cvt->len_cvt/16)) * cvt->rate_incr) * 16;\n    register int eps = 0;\n    float *dst = ((float *) (cvt->buf + dstsize)) - 4;\n    const float *src = ((float *) (cvt->buf + cvt->len_cvt)) - 4;\n    const float *target = ((const float *) cvt->buf);\n    float sample3 = SDL_SwapFloatLE(src[3]);\n    float sample2 = SDL_SwapFloatLE(src[2]);\n    float sample1 = SDL_SwapFloatLE(src[1]);\n    float sample0 = SDL_SwapFloatLE(src[0]);\n    float last_sample3 = sample3;\n    float last_sample2 = sample2;\n    float last_sample1 = sample1;\n    float last_sample0 = sample0;\n    while (dst >= target) {\n        dst[3] = SDL_SwapFloatLE(sample3);\n        dst[2] = SDL_SwapFloatLE(sample2);\n        dst[1] = SDL_SwapFloatLE(sample1);\n        dst[0] = SDL_SwapFloatLE(sample0);\n        dst -= 4;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 4;\n            sample3 = (float) ((((double) SDL_SwapFloatLE(src[3])) + ((double) last_sample3)) * 0.5);\n            sample2 = (float) ((((double) SDL_SwapFloatLE(src[2])) + ((double) last_sample2)) * 0.5);\n            sample1 = (float) ((((double) SDL_SwapFloatLE(src[1])) + ((double) last_sample1)) * 0.5);\n            sample0 = (float) ((((double) SDL_SwapFloatLE(src[0])) + ((double) last_sample0)) * 0.5);\n            last_sample3 = sample3;\n            last_sample2 = sample2;\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_F32LSB_4c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_F32LSB, 4 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 256;\n    const int dstsize = (int) (((double)(cvt->len_cvt/16)) * cvt->rate_incr) * 16;\n    register int eps = 0;\n    float *dst = (float *) cvt->buf;\n    const float *src = (float *) cvt->buf;\n    const float *target = (const float *) (cvt->buf + dstsize);\n    float sample0 = SDL_SwapFloatLE(src[0]);\n    float sample1 = SDL_SwapFloatLE(src[1]);\n    float sample2 = SDL_SwapFloatLE(src[2]);\n    float sample3 = SDL_SwapFloatLE(src[3]);\n    float last_sample0 = sample0;\n    float last_sample1 = sample1;\n    float last_sample2 = sample2;\n    float last_sample3 = sample3;\n    while (dst < target) {\n        src += 4;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = SDL_SwapFloatLE(sample0);\n            dst[1] = SDL_SwapFloatLE(sample1);\n            dst[2] = SDL_SwapFloatLE(sample2);\n            dst[3] = SDL_SwapFloatLE(sample3);\n            dst += 4;\n            sample0 = (float) ((((double) SDL_SwapFloatLE(src[0])) + ((double) last_sample0)) * 0.5);\n            sample1 = (float) ((((double) SDL_SwapFloatLE(src[1])) + ((double) last_sample1)) * 0.5);\n            sample2 = (float) ((((double) SDL_SwapFloatLE(src[2])) + ((double) last_sample2)) * 0.5);\n            sample3 = (float) ((((double) SDL_SwapFloatLE(src[3])) + ((double) last_sample3)) * 0.5);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            last_sample2 = sample2;\n            last_sample3 = sample3;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_F32LSB_6c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_F32LSB, 6 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 384;\n    const int dstsize = (int) (((double)(cvt->len_cvt/24)) * cvt->rate_incr) * 24;\n    register int eps = 0;\n    float *dst = ((float *) (cvt->buf + dstsize)) - 6;\n    const float *src = ((float *) (cvt->buf + cvt->len_cvt)) - 6;\n    const float *target = ((const float *) cvt->buf);\n    float sample5 = SDL_SwapFloatLE(src[5]);\n    float sample4 = SDL_SwapFloatLE(src[4]);\n    float sample3 = SDL_SwapFloatLE(src[3]);\n    float sample2 = SDL_SwapFloatLE(src[2]);\n    float sample1 = SDL_SwapFloatLE(src[1]);\n    float sample0 = SDL_SwapFloatLE(src[0]);\n    float last_sample5 = sample5;\n    float last_sample4 = sample4;\n    float last_sample3 = sample3;\n    float last_sample2 = sample2;\n    float last_sample1 = sample1;\n    float last_sample0 = sample0;\n    while (dst >= target) {\n        dst[5] = SDL_SwapFloatLE(sample5);\n        dst[4] = SDL_SwapFloatLE(sample4);\n        dst[3] = SDL_SwapFloatLE(sample3);\n        dst[2] = SDL_SwapFloatLE(sample2);\n        dst[1] = SDL_SwapFloatLE(sample1);\n        dst[0] = SDL_SwapFloatLE(sample0);\n        dst -= 6;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 6;\n            sample5 = (float) ((((double) SDL_SwapFloatLE(src[5])) + ((double) last_sample5)) * 0.5);\n            sample4 = (float) ((((double) SDL_SwapFloatLE(src[4])) + ((double) last_sample4)) * 0.5);\n            sample3 = (float) ((((double) SDL_SwapFloatLE(src[3])) + ((double) last_sample3)) * 0.5);\n            sample2 = (float) ((((double) SDL_SwapFloatLE(src[2])) + ((double) last_sample2)) * 0.5);\n            sample1 = (float) ((((double) SDL_SwapFloatLE(src[1])) + ((double) last_sample1)) * 0.5);\n            sample0 = (float) ((((double) SDL_SwapFloatLE(src[0])) + ((double) last_sample0)) * 0.5);\n            last_sample5 = sample5;\n            last_sample4 = sample4;\n            last_sample3 = sample3;\n            last_sample2 = sample2;\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_F32LSB_6c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_F32LSB, 6 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 384;\n    const int dstsize = (int) (((double)(cvt->len_cvt/24)) * cvt->rate_incr) * 24;\n    register int eps = 0;\n    float *dst = (float *) cvt->buf;\n    const float *src = (float *) cvt->buf;\n    const float *target = (const float *) (cvt->buf + dstsize);\n    float sample0 = SDL_SwapFloatLE(src[0]);\n    float sample1 = SDL_SwapFloatLE(src[1]);\n    float sample2 = SDL_SwapFloatLE(src[2]);\n    float sample3 = SDL_SwapFloatLE(src[3]);\n    float sample4 = SDL_SwapFloatLE(src[4]);\n    float sample5 = SDL_SwapFloatLE(src[5]);\n    float last_sample0 = sample0;\n    float last_sample1 = sample1;\n    float last_sample2 = sample2;\n    float last_sample3 = sample3;\n    float last_sample4 = sample4;\n    float last_sample5 = sample5;\n    while (dst < target) {\n        src += 6;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = SDL_SwapFloatLE(sample0);\n            dst[1] = SDL_SwapFloatLE(sample1);\n            dst[2] = SDL_SwapFloatLE(sample2);\n            dst[3] = SDL_SwapFloatLE(sample3);\n            dst[4] = SDL_SwapFloatLE(sample4);\n            dst[5] = SDL_SwapFloatLE(sample5);\n            dst += 6;\n            sample0 = (float) ((((double) SDL_SwapFloatLE(src[0])) + ((double) last_sample0)) * 0.5);\n            sample1 = (float) ((((double) SDL_SwapFloatLE(src[1])) + ((double) last_sample1)) * 0.5);\n            sample2 = (float) ((((double) SDL_SwapFloatLE(src[2])) + ((double) last_sample2)) * 0.5);\n            sample3 = (float) ((((double) SDL_SwapFloatLE(src[3])) + ((double) last_sample3)) * 0.5);\n            sample4 = (float) ((((double) SDL_SwapFloatLE(src[4])) + ((double) last_sample4)) * 0.5);\n            sample5 = (float) ((((double) SDL_SwapFloatLE(src[5])) + ((double) last_sample5)) * 0.5);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            last_sample2 = sample2;\n            last_sample3 = sample3;\n            last_sample4 = sample4;\n            last_sample5 = sample5;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_F32LSB_8c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_F32LSB, 8 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 512;\n    const int dstsize = (int) (((double)(cvt->len_cvt/32)) * cvt->rate_incr) * 32;\n    register int eps = 0;\n    float *dst = ((float *) (cvt->buf + dstsize)) - 8;\n    const float *src = ((float *) (cvt->buf + cvt->len_cvt)) - 8;\n    const float *target = ((const float *) cvt->buf);\n    float sample7 = SDL_SwapFloatLE(src[7]);\n    float sample6 = SDL_SwapFloatLE(src[6]);\n    float sample5 = SDL_SwapFloatLE(src[5]);\n    float sample4 = SDL_SwapFloatLE(src[4]);\n    float sample3 = SDL_SwapFloatLE(src[3]);\n    float sample2 = SDL_SwapFloatLE(src[2]);\n    float sample1 = SDL_SwapFloatLE(src[1]);\n    float sample0 = SDL_SwapFloatLE(src[0]);\n    float last_sample7 = sample7;\n    float last_sample6 = sample6;\n    float last_sample5 = sample5;\n    float last_sample4 = sample4;\n    float last_sample3 = sample3;\n    float last_sample2 = sample2;\n    float last_sample1 = sample1;\n    float last_sample0 = sample0;\n    while (dst >= target) {\n        dst[7] = SDL_SwapFloatLE(sample7);\n        dst[6] = SDL_SwapFloatLE(sample6);\n        dst[5] = SDL_SwapFloatLE(sample5);\n        dst[4] = SDL_SwapFloatLE(sample4);\n        dst[3] = SDL_SwapFloatLE(sample3);\n        dst[2] = SDL_SwapFloatLE(sample2);\n        dst[1] = SDL_SwapFloatLE(sample1);\n        dst[0] = SDL_SwapFloatLE(sample0);\n        dst -= 8;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 8;\n            sample7 = (float) ((((double) SDL_SwapFloatLE(src[7])) + ((double) last_sample7)) * 0.5);\n            sample6 = (float) ((((double) SDL_SwapFloatLE(src[6])) + ((double) last_sample6)) * 0.5);\n            sample5 = (float) ((((double) SDL_SwapFloatLE(src[5])) + ((double) last_sample5)) * 0.5);\n            sample4 = (float) ((((double) SDL_SwapFloatLE(src[4])) + ((double) last_sample4)) * 0.5);\n            sample3 = (float) ((((double) SDL_SwapFloatLE(src[3])) + ((double) last_sample3)) * 0.5);\n            sample2 = (float) ((((double) SDL_SwapFloatLE(src[2])) + ((double) last_sample2)) * 0.5);\n            sample1 = (float) ((((double) SDL_SwapFloatLE(src[1])) + ((double) last_sample1)) * 0.5);\n            sample0 = (float) ((((double) SDL_SwapFloatLE(src[0])) + ((double) last_sample0)) * 0.5);\n            last_sample7 = sample7;\n            last_sample6 = sample6;\n            last_sample5 = sample5;\n            last_sample4 = sample4;\n            last_sample3 = sample3;\n            last_sample2 = sample2;\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_F32LSB_8c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_F32LSB, 8 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 512;\n    const int dstsize = (int) (((double)(cvt->len_cvt/32)) * cvt->rate_incr) * 32;\n    register int eps = 0;\n    float *dst = (float *) cvt->buf;\n    const float *src = (float *) cvt->buf;\n    const float *target = (const float *) (cvt->buf + dstsize);\n    float sample0 = SDL_SwapFloatLE(src[0]);\n    float sample1 = SDL_SwapFloatLE(src[1]);\n    float sample2 = SDL_SwapFloatLE(src[2]);\n    float sample3 = SDL_SwapFloatLE(src[3]);\n    float sample4 = SDL_SwapFloatLE(src[4]);\n    float sample5 = SDL_SwapFloatLE(src[5]);\n    float sample6 = SDL_SwapFloatLE(src[6]);\n    float sample7 = SDL_SwapFloatLE(src[7]);\n    float last_sample0 = sample0;\n    float last_sample1 = sample1;\n    float last_sample2 = sample2;\n    float last_sample3 = sample3;\n    float last_sample4 = sample4;\n    float last_sample5 = sample5;\n    float last_sample6 = sample6;\n    float last_sample7 = sample7;\n    while (dst < target) {\n        src += 8;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = SDL_SwapFloatLE(sample0);\n            dst[1] = SDL_SwapFloatLE(sample1);\n            dst[2] = SDL_SwapFloatLE(sample2);\n            dst[3] = SDL_SwapFloatLE(sample3);\n            dst[4] = SDL_SwapFloatLE(sample4);\n            dst[5] = SDL_SwapFloatLE(sample5);\n            dst[6] = SDL_SwapFloatLE(sample6);\n            dst[7] = SDL_SwapFloatLE(sample7);\n            dst += 8;\n            sample0 = (float) ((((double) SDL_SwapFloatLE(src[0])) + ((double) last_sample0)) * 0.5);\n            sample1 = (float) ((((double) SDL_SwapFloatLE(src[1])) + ((double) last_sample1)) * 0.5);\n            sample2 = (float) ((((double) SDL_SwapFloatLE(src[2])) + ((double) last_sample2)) * 0.5);\n            sample3 = (float) ((((double) SDL_SwapFloatLE(src[3])) + ((double) last_sample3)) * 0.5);\n            sample4 = (float) ((((double) SDL_SwapFloatLE(src[4])) + ((double) last_sample4)) * 0.5);\n            sample5 = (float) ((((double) SDL_SwapFloatLE(src[5])) + ((double) last_sample5)) * 0.5);\n            sample6 = (float) ((((double) SDL_SwapFloatLE(src[6])) + ((double) last_sample6)) * 0.5);\n            sample7 = (float) ((((double) SDL_SwapFloatLE(src[7])) + ((double) last_sample7)) * 0.5);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            last_sample2 = sample2;\n            last_sample3 = sample3;\n            last_sample4 = sample4;\n            last_sample5 = sample5;\n            last_sample6 = sample6;\n            last_sample7 = sample7;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_F32MSB_1c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_F32MSB, 1 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 64;\n    const int dstsize = (int) (((double)(cvt->len_cvt/4)) * cvt->rate_incr) * 4;\n    register int eps = 0;\n    float *dst = ((float *) (cvt->buf + dstsize)) - 1;\n    const float *src = ((float *) (cvt->buf + cvt->len_cvt)) - 1;\n    const float *target = ((const float *) cvt->buf);\n    float sample0 = SDL_SwapFloatBE(src[0]);\n    float last_sample0 = sample0;\n    while (dst >= target) {\n        dst[0] = SDL_SwapFloatBE(sample0);\n        dst--;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src--;\n            sample0 = (float) ((((double) SDL_SwapFloatBE(src[0])) + ((double) last_sample0)) * 0.5);\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_F32MSB_1c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_F32MSB, 1 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 64;\n    const int dstsize = (int) (((double)(cvt->len_cvt/4)) * cvt->rate_incr) * 4;\n    register int eps = 0;\n    float *dst = (float *) cvt->buf;\n    const float *src = (float *) cvt->buf;\n    const float *target = (const float *) (cvt->buf + dstsize);\n    float sample0 = SDL_SwapFloatBE(src[0]);\n    float last_sample0 = sample0;\n    while (dst < target) {\n        src++;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = SDL_SwapFloatBE(sample0);\n            dst++;\n            sample0 = (float) ((((double) SDL_SwapFloatBE(src[0])) + ((double) last_sample0)) * 0.5);\n            last_sample0 = sample0;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_F32MSB_2c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_F32MSB, 2 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 128;\n    const int dstsize = (int) (((double)(cvt->len_cvt/8)) * cvt->rate_incr) * 8;\n    register int eps = 0;\n    float *dst = ((float *) (cvt->buf + dstsize)) - 2;\n    const float *src = ((float *) (cvt->buf + cvt->len_cvt)) - 2;\n    const float *target = ((const float *) cvt->buf);\n    float sample1 = SDL_SwapFloatBE(src[1]);\n    float sample0 = SDL_SwapFloatBE(src[0]);\n    float last_sample1 = sample1;\n    float last_sample0 = sample0;\n    while (dst >= target) {\n        dst[1] = SDL_SwapFloatBE(sample1);\n        dst[0] = SDL_SwapFloatBE(sample0);\n        dst -= 2;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 2;\n            sample1 = (float) ((((double) SDL_SwapFloatBE(src[1])) + ((double) last_sample1)) * 0.5);\n            sample0 = (float) ((((double) SDL_SwapFloatBE(src[0])) + ((double) last_sample0)) * 0.5);\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_F32MSB_2c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_F32MSB, 2 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 128;\n    const int dstsize = (int) (((double)(cvt->len_cvt/8)) * cvt->rate_incr) * 8;\n    register int eps = 0;\n    float *dst = (float *) cvt->buf;\n    const float *src = (float *) cvt->buf;\n    const float *target = (const float *) (cvt->buf + dstsize);\n    float sample0 = SDL_SwapFloatBE(src[0]);\n    float sample1 = SDL_SwapFloatBE(src[1]);\n    float last_sample0 = sample0;\n    float last_sample1 = sample1;\n    while (dst < target) {\n        src += 2;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = SDL_SwapFloatBE(sample0);\n            dst[1] = SDL_SwapFloatBE(sample1);\n            dst += 2;\n            sample0 = (float) ((((double) SDL_SwapFloatBE(src[0])) + ((double) last_sample0)) * 0.5);\n            sample1 = (float) ((((double) SDL_SwapFloatBE(src[1])) + ((double) last_sample1)) * 0.5);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_F32MSB_4c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_F32MSB, 4 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 256;\n    const int dstsize = (int) (((double)(cvt->len_cvt/16)) * cvt->rate_incr) * 16;\n    register int eps = 0;\n    float *dst = ((float *) (cvt->buf + dstsize)) - 4;\n    const float *src = ((float *) (cvt->buf + cvt->len_cvt)) - 4;\n    const float *target = ((const float *) cvt->buf);\n    float sample3 = SDL_SwapFloatBE(src[3]);\n    float sample2 = SDL_SwapFloatBE(src[2]);\n    float sample1 = SDL_SwapFloatBE(src[1]);\n    float sample0 = SDL_SwapFloatBE(src[0]);\n    float last_sample3 = sample3;\n    float last_sample2 = sample2;\n    float last_sample1 = sample1;\n    float last_sample0 = sample0;\n    while (dst >= target) {\n        dst[3] = SDL_SwapFloatBE(sample3);\n        dst[2] = SDL_SwapFloatBE(sample2);\n        dst[1] = SDL_SwapFloatBE(sample1);\n        dst[0] = SDL_SwapFloatBE(sample0);\n        dst -= 4;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 4;\n            sample3 = (float) ((((double) SDL_SwapFloatBE(src[3])) + ((double) last_sample3)) * 0.5);\n            sample2 = (float) ((((double) SDL_SwapFloatBE(src[2])) + ((double) last_sample2)) * 0.5);\n            sample1 = (float) ((((double) SDL_SwapFloatBE(src[1])) + ((double) last_sample1)) * 0.5);\n            sample0 = (float) ((((double) SDL_SwapFloatBE(src[0])) + ((double) last_sample0)) * 0.5);\n            last_sample3 = sample3;\n            last_sample2 = sample2;\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_F32MSB_4c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_F32MSB, 4 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 256;\n    const int dstsize = (int) (((double)(cvt->len_cvt/16)) * cvt->rate_incr) * 16;\n    register int eps = 0;\n    float *dst = (float *) cvt->buf;\n    const float *src = (float *) cvt->buf;\n    const float *target = (const float *) (cvt->buf + dstsize);\n    float sample0 = SDL_SwapFloatBE(src[0]);\n    float sample1 = SDL_SwapFloatBE(src[1]);\n    float sample2 = SDL_SwapFloatBE(src[2]);\n    float sample3 = SDL_SwapFloatBE(src[3]);\n    float last_sample0 = sample0;\n    float last_sample1 = sample1;\n    float last_sample2 = sample2;\n    float last_sample3 = sample3;\n    while (dst < target) {\n        src += 4;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = SDL_SwapFloatBE(sample0);\n            dst[1] = SDL_SwapFloatBE(sample1);\n            dst[2] = SDL_SwapFloatBE(sample2);\n            dst[3] = SDL_SwapFloatBE(sample3);\n            dst += 4;\n            sample0 = (float) ((((double) SDL_SwapFloatBE(src[0])) + ((double) last_sample0)) * 0.5);\n            sample1 = (float) ((((double) SDL_SwapFloatBE(src[1])) + ((double) last_sample1)) * 0.5);\n            sample2 = (float) ((((double) SDL_SwapFloatBE(src[2])) + ((double) last_sample2)) * 0.5);\n            sample3 = (float) ((((double) SDL_SwapFloatBE(src[3])) + ((double) last_sample3)) * 0.5);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            last_sample2 = sample2;\n            last_sample3 = sample3;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_F32MSB_6c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_F32MSB, 6 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 384;\n    const int dstsize = (int) (((double)(cvt->len_cvt/24)) * cvt->rate_incr) * 24;\n    register int eps = 0;\n    float *dst = ((float *) (cvt->buf + dstsize)) - 6;\n    const float *src = ((float *) (cvt->buf + cvt->len_cvt)) - 6;\n    const float *target = ((const float *) cvt->buf);\n    float sample5 = SDL_SwapFloatBE(src[5]);\n    float sample4 = SDL_SwapFloatBE(src[4]);\n    float sample3 = SDL_SwapFloatBE(src[3]);\n    float sample2 = SDL_SwapFloatBE(src[2]);\n    float sample1 = SDL_SwapFloatBE(src[1]);\n    float sample0 = SDL_SwapFloatBE(src[0]);\n    float last_sample5 = sample5;\n    float last_sample4 = sample4;\n    float last_sample3 = sample3;\n    float last_sample2 = sample2;\n    float last_sample1 = sample1;\n    float last_sample0 = sample0;\n    while (dst >= target) {\n        dst[5] = SDL_SwapFloatBE(sample5);\n        dst[4] = SDL_SwapFloatBE(sample4);\n        dst[3] = SDL_SwapFloatBE(sample3);\n        dst[2] = SDL_SwapFloatBE(sample2);\n        dst[1] = SDL_SwapFloatBE(sample1);\n        dst[0] = SDL_SwapFloatBE(sample0);\n        dst -= 6;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 6;\n            sample5 = (float) ((((double) SDL_SwapFloatBE(src[5])) + ((double) last_sample5)) * 0.5);\n            sample4 = (float) ((((double) SDL_SwapFloatBE(src[4])) + ((double) last_sample4)) * 0.5);\n            sample3 = (float) ((((double) SDL_SwapFloatBE(src[3])) + ((double) last_sample3)) * 0.5);\n            sample2 = (float) ((((double) SDL_SwapFloatBE(src[2])) + ((double) last_sample2)) * 0.5);\n            sample1 = (float) ((((double) SDL_SwapFloatBE(src[1])) + ((double) last_sample1)) * 0.5);\n            sample0 = (float) ((((double) SDL_SwapFloatBE(src[0])) + ((double) last_sample0)) * 0.5);\n            last_sample5 = sample5;\n            last_sample4 = sample4;\n            last_sample3 = sample3;\n            last_sample2 = sample2;\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_F32MSB_6c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_F32MSB, 6 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 384;\n    const int dstsize = (int) (((double)(cvt->len_cvt/24)) * cvt->rate_incr) * 24;\n    register int eps = 0;\n    float *dst = (float *) cvt->buf;\n    const float *src = (float *) cvt->buf;\n    const float *target = (const float *) (cvt->buf + dstsize);\n    float sample0 = SDL_SwapFloatBE(src[0]);\n    float sample1 = SDL_SwapFloatBE(src[1]);\n    float sample2 = SDL_SwapFloatBE(src[2]);\n    float sample3 = SDL_SwapFloatBE(src[3]);\n    float sample4 = SDL_SwapFloatBE(src[4]);\n    float sample5 = SDL_SwapFloatBE(src[5]);\n    float last_sample0 = sample0;\n    float last_sample1 = sample1;\n    float last_sample2 = sample2;\n    float last_sample3 = sample3;\n    float last_sample4 = sample4;\n    float last_sample5 = sample5;\n    while (dst < target) {\n        src += 6;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = SDL_SwapFloatBE(sample0);\n            dst[1] = SDL_SwapFloatBE(sample1);\n            dst[2] = SDL_SwapFloatBE(sample2);\n            dst[3] = SDL_SwapFloatBE(sample3);\n            dst[4] = SDL_SwapFloatBE(sample4);\n            dst[5] = SDL_SwapFloatBE(sample5);\n            dst += 6;\n            sample0 = (float) ((((double) SDL_SwapFloatBE(src[0])) + ((double) last_sample0)) * 0.5);\n            sample1 = (float) ((((double) SDL_SwapFloatBE(src[1])) + ((double) last_sample1)) * 0.5);\n            sample2 = (float) ((((double) SDL_SwapFloatBE(src[2])) + ((double) last_sample2)) * 0.5);\n            sample3 = (float) ((((double) SDL_SwapFloatBE(src[3])) + ((double) last_sample3)) * 0.5);\n            sample4 = (float) ((((double) SDL_SwapFloatBE(src[4])) + ((double) last_sample4)) * 0.5);\n            sample5 = (float) ((((double) SDL_SwapFloatBE(src[5])) + ((double) last_sample5)) * 0.5);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            last_sample2 = sample2;\n            last_sample3 = sample3;\n            last_sample4 = sample4;\n            last_sample5 = sample5;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_F32MSB_8c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample arbitrary (x%f) AUDIO_F32MSB, 8 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 512;\n    const int dstsize = (int) (((double)(cvt->len_cvt/32)) * cvt->rate_incr) * 32;\n    register int eps = 0;\n    float *dst = ((float *) (cvt->buf + dstsize)) - 8;\n    const float *src = ((float *) (cvt->buf + cvt->len_cvt)) - 8;\n    const float *target = ((const float *) cvt->buf);\n    float sample7 = SDL_SwapFloatBE(src[7]);\n    float sample6 = SDL_SwapFloatBE(src[6]);\n    float sample5 = SDL_SwapFloatBE(src[5]);\n    float sample4 = SDL_SwapFloatBE(src[4]);\n    float sample3 = SDL_SwapFloatBE(src[3]);\n    float sample2 = SDL_SwapFloatBE(src[2]);\n    float sample1 = SDL_SwapFloatBE(src[1]);\n    float sample0 = SDL_SwapFloatBE(src[0]);\n    float last_sample7 = sample7;\n    float last_sample6 = sample6;\n    float last_sample5 = sample5;\n    float last_sample4 = sample4;\n    float last_sample3 = sample3;\n    float last_sample2 = sample2;\n    float last_sample1 = sample1;\n    float last_sample0 = sample0;\n    while (dst >= target) {\n        dst[7] = SDL_SwapFloatBE(sample7);\n        dst[6] = SDL_SwapFloatBE(sample6);\n        dst[5] = SDL_SwapFloatBE(sample5);\n        dst[4] = SDL_SwapFloatBE(sample4);\n        dst[3] = SDL_SwapFloatBE(sample3);\n        dst[2] = SDL_SwapFloatBE(sample2);\n        dst[1] = SDL_SwapFloatBE(sample1);\n        dst[0] = SDL_SwapFloatBE(sample0);\n        dst -= 8;\n        eps += srcsize;\n        if ((eps << 1) >= dstsize) {\n            src -= 8;\n            sample7 = (float) ((((double) SDL_SwapFloatBE(src[7])) + ((double) last_sample7)) * 0.5);\n            sample6 = (float) ((((double) SDL_SwapFloatBE(src[6])) + ((double) last_sample6)) * 0.5);\n            sample5 = (float) ((((double) SDL_SwapFloatBE(src[5])) + ((double) last_sample5)) * 0.5);\n            sample4 = (float) ((((double) SDL_SwapFloatBE(src[4])) + ((double) last_sample4)) * 0.5);\n            sample3 = (float) ((((double) SDL_SwapFloatBE(src[3])) + ((double) last_sample3)) * 0.5);\n            sample2 = (float) ((((double) SDL_SwapFloatBE(src[2])) + ((double) last_sample2)) * 0.5);\n            sample1 = (float) ((((double) SDL_SwapFloatBE(src[1])) + ((double) last_sample1)) * 0.5);\n            sample0 = (float) ((((double) SDL_SwapFloatBE(src[0])) + ((double) last_sample0)) * 0.5);\n            last_sample7 = sample7;\n            last_sample6 = sample6;\n            last_sample5 = sample5;\n            last_sample4 = sample4;\n            last_sample3 = sample3;\n            last_sample2 = sample2;\n            last_sample1 = sample1;\n            last_sample0 = sample0;\n            eps -= dstsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_F32MSB_8c(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample arbitrary (x%f) AUDIO_F32MSB, 8 channels.\\n\", cvt->rate_incr);\n#endif\n\n    const int srcsize = cvt->len_cvt - 512;\n    const int dstsize = (int) (((double)(cvt->len_cvt/32)) * cvt->rate_incr) * 32;\n    register int eps = 0;\n    float *dst = (float *) cvt->buf;\n    const float *src = (float *) cvt->buf;\n    const float *target = (const float *) (cvt->buf + dstsize);\n    float sample0 = SDL_SwapFloatBE(src[0]);\n    float sample1 = SDL_SwapFloatBE(src[1]);\n    float sample2 = SDL_SwapFloatBE(src[2]);\n    float sample3 = SDL_SwapFloatBE(src[3]);\n    float sample4 = SDL_SwapFloatBE(src[4]);\n    float sample5 = SDL_SwapFloatBE(src[5]);\n    float sample6 = SDL_SwapFloatBE(src[6]);\n    float sample7 = SDL_SwapFloatBE(src[7]);\n    float last_sample0 = sample0;\n    float last_sample1 = sample1;\n    float last_sample2 = sample2;\n    float last_sample3 = sample3;\n    float last_sample4 = sample4;\n    float last_sample5 = sample5;\n    float last_sample6 = sample6;\n    float last_sample7 = sample7;\n    while (dst < target) {\n        src += 8;\n        eps += dstsize;\n        if ((eps << 1) >= srcsize) {\n            dst[0] = SDL_SwapFloatBE(sample0);\n            dst[1] = SDL_SwapFloatBE(sample1);\n            dst[2] = SDL_SwapFloatBE(sample2);\n            dst[3] = SDL_SwapFloatBE(sample3);\n            dst[4] = SDL_SwapFloatBE(sample4);\n            dst[5] = SDL_SwapFloatBE(sample5);\n            dst[6] = SDL_SwapFloatBE(sample6);\n            dst[7] = SDL_SwapFloatBE(sample7);\n            dst += 8;\n            sample0 = (float) ((((double) SDL_SwapFloatBE(src[0])) + ((double) last_sample0)) * 0.5);\n            sample1 = (float) ((((double) SDL_SwapFloatBE(src[1])) + ((double) last_sample1)) * 0.5);\n            sample2 = (float) ((((double) SDL_SwapFloatBE(src[2])) + ((double) last_sample2)) * 0.5);\n            sample3 = (float) ((((double) SDL_SwapFloatBE(src[3])) + ((double) last_sample3)) * 0.5);\n            sample4 = (float) ((((double) SDL_SwapFloatBE(src[4])) + ((double) last_sample4)) * 0.5);\n            sample5 = (float) ((((double) SDL_SwapFloatBE(src[5])) + ((double) last_sample5)) * 0.5);\n            sample6 = (float) ((((double) SDL_SwapFloatBE(src[6])) + ((double) last_sample6)) * 0.5);\n            sample7 = (float) ((((double) SDL_SwapFloatBE(src[7])) + ((double) last_sample7)) * 0.5);\n            last_sample0 = sample0;\n            last_sample1 = sample1;\n            last_sample2 = sample2;\n            last_sample3 = sample3;\n            last_sample4 = sample4;\n            last_sample5 = sample5;\n            last_sample6 = sample6;\n            last_sample7 = sample7;\n            eps -= srcsize;\n        }\n    }\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\n\n#if !LESS_RESAMPLERS\n\nstatic void SDLCALL\nSDL_Upsample_U8_1c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_U8, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Uint8 *dst = ((Uint8 *) (cvt->buf + dstsize)) - 1 * 2;\n    const Uint8 *src = ((Uint8 *) (cvt->buf + cvt->len_cvt)) - 1;\n    const Uint8 *target = ((const Uint8 *) cvt->buf);\n    Sint16 last_sample0 = (Sint16) src[0];\n    while (dst >= target) {\n        const Sint16 sample0 = (Sint16) src[0];\n        src--;\n        dst[1] = (Uint8) ((sample0 + last_sample0) >> 1);\n        dst[0] = (Uint8) sample0;\n        last_sample0 = sample0;\n        dst -= 2;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U8_1c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_U8, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Uint8 *dst = (Uint8 *) cvt->buf;\n    const Uint8 *src = (Uint8 *) cvt->buf;\n    const Uint8 *target = (const Uint8 *) (cvt->buf + dstsize);\n    Sint16 last_sample0 = (Sint16) src[0];\n    while (dst < target) {\n        const Sint16 sample0 = (Sint16) src[0];\n        src += 2;\n        dst[0] = (Uint8) ((sample0 + last_sample0) >> 1);\n        last_sample0 = sample0;\n        dst++;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U8_1c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_U8, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Uint8 *dst = ((Uint8 *) (cvt->buf + dstsize)) - 1 * 4;\n    const Uint8 *src = ((Uint8 *) (cvt->buf + cvt->len_cvt)) - 1;\n    const Uint8 *target = ((const Uint8 *) cvt->buf);\n    Sint16 last_sample0 = (Sint16) src[0];\n    while (dst >= target) {\n        const Sint16 sample0 = (Sint16) src[0];\n        src--;\n        dst[3] = (Uint8) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[2] = (Uint8) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Uint8) (((3 * sample0) + last_sample0) >> 2);\n        dst[0] = (Uint8) sample0;\n        last_sample0 = sample0;\n        dst -= 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U8_1c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_U8, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Uint8 *dst = (Uint8 *) cvt->buf;\n    const Uint8 *src = (Uint8 *) cvt->buf;\n    const Uint8 *target = (const Uint8 *) (cvt->buf + dstsize);\n    Sint16 last_sample0 = (Sint16) src[0];\n    while (dst < target) {\n        const Sint16 sample0 = (Sint16) src[0];\n        src += 4;\n        dst[0] = (Uint8) ((sample0 + last_sample0) >> 1);\n        last_sample0 = sample0;\n        dst++;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U8_2c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_U8, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Uint8 *dst = ((Uint8 *) (cvt->buf + dstsize)) - 2 * 2;\n    const Uint8 *src = ((Uint8 *) (cvt->buf + cvt->len_cvt)) - 2;\n    const Uint8 *target = ((const Uint8 *) cvt->buf);\n    Sint16 last_sample1 = (Sint16) src[1];\n    Sint16 last_sample0 = (Sint16) src[0];\n    while (dst >= target) {\n        const Sint16 sample1 = (Sint16) src[1];\n        const Sint16 sample0 = (Sint16) src[0];\n        src -= 2;\n        dst[3] = (Uint8) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Uint8) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Uint8) sample1;\n        dst[0] = (Uint8) sample0;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U8_2c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_U8, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Uint8 *dst = (Uint8 *) cvt->buf;\n    const Uint8 *src = (Uint8 *) cvt->buf;\n    const Uint8 *target = (const Uint8 *) (cvt->buf + dstsize);\n    Sint16 last_sample0 = (Sint16) src[0];\n    Sint16 last_sample1 = (Sint16) src[1];\n    while (dst < target) {\n        const Sint16 sample0 = (Sint16) src[0];\n        const Sint16 sample1 = (Sint16) src[1];\n        src += 4;\n        dst[0] = (Uint8) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Uint8) ((sample1 + last_sample1) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        dst += 2;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U8_2c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_U8, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Uint8 *dst = ((Uint8 *) (cvt->buf + dstsize)) - 2 * 4;\n    const Uint8 *src = ((Uint8 *) (cvt->buf + cvt->len_cvt)) - 2;\n    const Uint8 *target = ((const Uint8 *) cvt->buf);\n    Sint16 last_sample1 = (Sint16) src[1];\n    Sint16 last_sample0 = (Sint16) src[0];\n    while (dst >= target) {\n        const Sint16 sample1 = (Sint16) src[1];\n        const Sint16 sample0 = (Sint16) src[0];\n        src -= 2;\n        dst[7] = (Uint8) ((sample1 + (3 * last_sample1)) >> 2);\n        dst[6] = (Uint8) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[5] = (Uint8) ((sample1 + last_sample1) >> 1);\n        dst[4] = (Uint8) ((sample0 + last_sample0) >> 1);\n        dst[3] = (Uint8) (((3 * sample1) + last_sample1) >> 2);\n        dst[2] = (Uint8) (((3 * sample0) + last_sample0) >> 2);\n        dst[1] = (Uint8) sample1;\n        dst[0] = (Uint8) sample0;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U8_2c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_U8, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Uint8 *dst = (Uint8 *) cvt->buf;\n    const Uint8 *src = (Uint8 *) cvt->buf;\n    const Uint8 *target = (const Uint8 *) (cvt->buf + dstsize);\n    Sint16 last_sample0 = (Sint16) src[0];\n    Sint16 last_sample1 = (Sint16) src[1];\n    while (dst < target) {\n        const Sint16 sample0 = (Sint16) src[0];\n        const Sint16 sample1 = (Sint16) src[1];\n        src += 8;\n        dst[0] = (Uint8) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Uint8) ((sample1 + last_sample1) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        dst += 2;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U8_4c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_U8, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Uint8 *dst = ((Uint8 *) (cvt->buf + dstsize)) - 4 * 2;\n    const Uint8 *src = ((Uint8 *) (cvt->buf + cvt->len_cvt)) - 4;\n    const Uint8 *target = ((const Uint8 *) cvt->buf);\n    Sint16 last_sample3 = (Sint16) src[3];\n    Sint16 last_sample2 = (Sint16) src[2];\n    Sint16 last_sample1 = (Sint16) src[1];\n    Sint16 last_sample0 = (Sint16) src[0];\n    while (dst >= target) {\n        const Sint16 sample3 = (Sint16) src[3];\n        const Sint16 sample2 = (Sint16) src[2];\n        const Sint16 sample1 = (Sint16) src[1];\n        const Sint16 sample0 = (Sint16) src[0];\n        src -= 4;\n        dst[7] = (Uint8) ((sample3 + last_sample3) >> 1);\n        dst[6] = (Uint8) ((sample2 + last_sample2) >> 1);\n        dst[5] = (Uint8) ((sample1 + last_sample1) >> 1);\n        dst[4] = (Uint8) ((sample0 + last_sample0) >> 1);\n        dst[3] = (Uint8) sample3;\n        dst[2] = (Uint8) sample2;\n        dst[1] = (Uint8) sample1;\n        dst[0] = (Uint8) sample0;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U8_4c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_U8, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Uint8 *dst = (Uint8 *) cvt->buf;\n    const Uint8 *src = (Uint8 *) cvt->buf;\n    const Uint8 *target = (const Uint8 *) (cvt->buf + dstsize);\n    Sint16 last_sample0 = (Sint16) src[0];\n    Sint16 last_sample1 = (Sint16) src[1];\n    Sint16 last_sample2 = (Sint16) src[2];\n    Sint16 last_sample3 = (Sint16) src[3];\n    while (dst < target) {\n        const Sint16 sample0 = (Sint16) src[0];\n        const Sint16 sample1 = (Sint16) src[1];\n        const Sint16 sample2 = (Sint16) src[2];\n        const Sint16 sample3 = (Sint16) src[3];\n        src += 8;\n        dst[0] = (Uint8) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Uint8) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Uint8) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Uint8) ((sample3 + last_sample3) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        dst += 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U8_4c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_U8, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Uint8 *dst = ((Uint8 *) (cvt->buf + dstsize)) - 4 * 4;\n    const Uint8 *src = ((Uint8 *) (cvt->buf + cvt->len_cvt)) - 4;\n    const Uint8 *target = ((const Uint8 *) cvt->buf);\n    Sint16 last_sample3 = (Sint16) src[3];\n    Sint16 last_sample2 = (Sint16) src[2];\n    Sint16 last_sample1 = (Sint16) src[1];\n    Sint16 last_sample0 = (Sint16) src[0];\n    while (dst >= target) {\n        const Sint16 sample3 = (Sint16) src[3];\n        const Sint16 sample2 = (Sint16) src[2];\n        const Sint16 sample1 = (Sint16) src[1];\n        const Sint16 sample0 = (Sint16) src[0];\n        src -= 4;\n        dst[15] = (Uint8) ((sample3 + (3 * last_sample3)) >> 2);\n        dst[14] = (Uint8) ((sample2 + (3 * last_sample2)) >> 2);\n        dst[13] = (Uint8) ((sample1 + (3 * last_sample1)) >> 2);\n        dst[12] = (Uint8) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[11] = (Uint8) ((sample3 + last_sample3) >> 1);\n        dst[10] = (Uint8) ((sample2 + last_sample2) >> 1);\n        dst[9] = (Uint8) ((sample1 + last_sample1) >> 1);\n        dst[8] = (Uint8) ((sample0 + last_sample0) >> 1);\n        dst[7] = (Uint8) (((3 * sample3) + last_sample3) >> 2);\n        dst[6] = (Uint8) (((3 * sample2) + last_sample2) >> 2);\n        dst[5] = (Uint8) (((3 * sample1) + last_sample1) >> 2);\n        dst[4] = (Uint8) (((3 * sample0) + last_sample0) >> 2);\n        dst[3] = (Uint8) sample3;\n        dst[2] = (Uint8) sample2;\n        dst[1] = (Uint8) sample1;\n        dst[0] = (Uint8) sample0;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 16;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U8_4c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_U8, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Uint8 *dst = (Uint8 *) cvt->buf;\n    const Uint8 *src = (Uint8 *) cvt->buf;\n    const Uint8 *target = (const Uint8 *) (cvt->buf + dstsize);\n    Sint16 last_sample0 = (Sint16) src[0];\n    Sint16 last_sample1 = (Sint16) src[1];\n    Sint16 last_sample2 = (Sint16) src[2];\n    Sint16 last_sample3 = (Sint16) src[3];\n    while (dst < target) {\n        const Sint16 sample0 = (Sint16) src[0];\n        const Sint16 sample1 = (Sint16) src[1];\n        const Sint16 sample2 = (Sint16) src[2];\n        const Sint16 sample3 = (Sint16) src[3];\n        src += 16;\n        dst[0] = (Uint8) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Uint8) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Uint8) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Uint8) ((sample3 + last_sample3) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        dst += 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U8_6c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_U8, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Uint8 *dst = ((Uint8 *) (cvt->buf + dstsize)) - 6 * 2;\n    const Uint8 *src = ((Uint8 *) (cvt->buf + cvt->len_cvt)) - 6;\n    const Uint8 *target = ((const Uint8 *) cvt->buf);\n    Sint16 last_sample5 = (Sint16) src[5];\n    Sint16 last_sample4 = (Sint16) src[4];\n    Sint16 last_sample3 = (Sint16) src[3];\n    Sint16 last_sample2 = (Sint16) src[2];\n    Sint16 last_sample1 = (Sint16) src[1];\n    Sint16 last_sample0 = (Sint16) src[0];\n    while (dst >= target) {\n        const Sint16 sample5 = (Sint16) src[5];\n        const Sint16 sample4 = (Sint16) src[4];\n        const Sint16 sample3 = (Sint16) src[3];\n        const Sint16 sample2 = (Sint16) src[2];\n        const Sint16 sample1 = (Sint16) src[1];\n        const Sint16 sample0 = (Sint16) src[0];\n        src -= 6;\n        dst[11] = (Uint8) ((sample5 + last_sample5) >> 1);\n        dst[10] = (Uint8) ((sample4 + last_sample4) >> 1);\n        dst[9] = (Uint8) ((sample3 + last_sample3) >> 1);\n        dst[8] = (Uint8) ((sample2 + last_sample2) >> 1);\n        dst[7] = (Uint8) ((sample1 + last_sample1) >> 1);\n        dst[6] = (Uint8) ((sample0 + last_sample0) >> 1);\n        dst[5] = (Uint8) sample5;\n        dst[4] = (Uint8) sample4;\n        dst[3] = (Uint8) sample3;\n        dst[2] = (Uint8) sample2;\n        dst[1] = (Uint8) sample1;\n        dst[0] = (Uint8) sample0;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 12;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U8_6c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_U8, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Uint8 *dst = (Uint8 *) cvt->buf;\n    const Uint8 *src = (Uint8 *) cvt->buf;\n    const Uint8 *target = (const Uint8 *) (cvt->buf + dstsize);\n    Sint16 last_sample0 = (Sint16) src[0];\n    Sint16 last_sample1 = (Sint16) src[1];\n    Sint16 last_sample2 = (Sint16) src[2];\n    Sint16 last_sample3 = (Sint16) src[3];\n    Sint16 last_sample4 = (Sint16) src[4];\n    Sint16 last_sample5 = (Sint16) src[5];\n    while (dst < target) {\n        const Sint16 sample0 = (Sint16) src[0];\n        const Sint16 sample1 = (Sint16) src[1];\n        const Sint16 sample2 = (Sint16) src[2];\n        const Sint16 sample3 = (Sint16) src[3];\n        const Sint16 sample4 = (Sint16) src[4];\n        const Sint16 sample5 = (Sint16) src[5];\n        src += 12;\n        dst[0] = (Uint8) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Uint8) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Uint8) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Uint8) ((sample3 + last_sample3) >> 1);\n        dst[4] = (Uint8) ((sample4 + last_sample4) >> 1);\n        dst[5] = (Uint8) ((sample5 + last_sample5) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        dst += 6;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U8_6c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_U8, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Uint8 *dst = ((Uint8 *) (cvt->buf + dstsize)) - 6 * 4;\n    const Uint8 *src = ((Uint8 *) (cvt->buf + cvt->len_cvt)) - 6;\n    const Uint8 *target = ((const Uint8 *) cvt->buf);\n    Sint16 last_sample5 = (Sint16) src[5];\n    Sint16 last_sample4 = (Sint16) src[4];\n    Sint16 last_sample3 = (Sint16) src[3];\n    Sint16 last_sample2 = (Sint16) src[2];\n    Sint16 last_sample1 = (Sint16) src[1];\n    Sint16 last_sample0 = (Sint16) src[0];\n    while (dst >= target) {\n        const Sint16 sample5 = (Sint16) src[5];\n        const Sint16 sample4 = (Sint16) src[4];\n        const Sint16 sample3 = (Sint16) src[3];\n        const Sint16 sample2 = (Sint16) src[2];\n        const Sint16 sample1 = (Sint16) src[1];\n        const Sint16 sample0 = (Sint16) src[0];\n        src -= 6;\n        dst[23] = (Uint8) ((sample5 + (3 * last_sample5)) >> 2);\n        dst[22] = (Uint8) ((sample4 + (3 * last_sample4)) >> 2);\n        dst[21] = (Uint8) ((sample3 + (3 * last_sample3)) >> 2);\n        dst[20] = (Uint8) ((sample2 + (3 * last_sample2)) >> 2);\n        dst[19] = (Uint8) ((sample1 + (3 * last_sample1)) >> 2);\n        dst[18] = (Uint8) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[17] = (Uint8) ((sample5 + last_sample5) >> 1);\n        dst[16] = (Uint8) ((sample4 + last_sample4) >> 1);\n        dst[15] = (Uint8) ((sample3 + last_sample3) >> 1);\n        dst[14] = (Uint8) ((sample2 + last_sample2) >> 1);\n        dst[13] = (Uint8) ((sample1 + last_sample1) >> 1);\n        dst[12] = (Uint8) ((sample0 + last_sample0) >> 1);\n        dst[11] = (Uint8) (((3 * sample5) + last_sample5) >> 2);\n        dst[10] = (Uint8) (((3 * sample4) + last_sample4) >> 2);\n        dst[9] = (Uint8) (((3 * sample3) + last_sample3) >> 2);\n        dst[8] = (Uint8) (((3 * sample2) + last_sample2) >> 2);\n        dst[7] = (Uint8) (((3 * sample1) + last_sample1) >> 2);\n        dst[6] = (Uint8) (((3 * sample0) + last_sample0) >> 2);\n        dst[5] = (Uint8) sample5;\n        dst[4] = (Uint8) sample4;\n        dst[3] = (Uint8) sample3;\n        dst[2] = (Uint8) sample2;\n        dst[1] = (Uint8) sample1;\n        dst[0] = (Uint8) sample0;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 24;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U8_6c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_U8, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Uint8 *dst = (Uint8 *) cvt->buf;\n    const Uint8 *src = (Uint8 *) cvt->buf;\n    const Uint8 *target = (const Uint8 *) (cvt->buf + dstsize);\n    Sint16 last_sample0 = (Sint16) src[0];\n    Sint16 last_sample1 = (Sint16) src[1];\n    Sint16 last_sample2 = (Sint16) src[2];\n    Sint16 last_sample3 = (Sint16) src[3];\n    Sint16 last_sample4 = (Sint16) src[4];\n    Sint16 last_sample5 = (Sint16) src[5];\n    while (dst < target) {\n        const Sint16 sample0 = (Sint16) src[0];\n        const Sint16 sample1 = (Sint16) src[1];\n        const Sint16 sample2 = (Sint16) src[2];\n        const Sint16 sample3 = (Sint16) src[3];\n        const Sint16 sample4 = (Sint16) src[4];\n        const Sint16 sample5 = (Sint16) src[5];\n        src += 24;\n        dst[0] = (Uint8) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Uint8) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Uint8) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Uint8) ((sample3 + last_sample3) >> 1);\n        dst[4] = (Uint8) ((sample4 + last_sample4) >> 1);\n        dst[5] = (Uint8) ((sample5 + last_sample5) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        dst += 6;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U8_8c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_U8, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Uint8 *dst = ((Uint8 *) (cvt->buf + dstsize)) - 8 * 2;\n    const Uint8 *src = ((Uint8 *) (cvt->buf + cvt->len_cvt)) - 8;\n    const Uint8 *target = ((const Uint8 *) cvt->buf);\n    Sint16 last_sample7 = (Sint16) src[7];\n    Sint16 last_sample6 = (Sint16) src[6];\n    Sint16 last_sample5 = (Sint16) src[5];\n    Sint16 last_sample4 = (Sint16) src[4];\n    Sint16 last_sample3 = (Sint16) src[3];\n    Sint16 last_sample2 = (Sint16) src[2];\n    Sint16 last_sample1 = (Sint16) src[1];\n    Sint16 last_sample0 = (Sint16) src[0];\n    while (dst >= target) {\n        const Sint16 sample7 = (Sint16) src[7];\n        const Sint16 sample6 = (Sint16) src[6];\n        const Sint16 sample5 = (Sint16) src[5];\n        const Sint16 sample4 = (Sint16) src[4];\n        const Sint16 sample3 = (Sint16) src[3];\n        const Sint16 sample2 = (Sint16) src[2];\n        const Sint16 sample1 = (Sint16) src[1];\n        const Sint16 sample0 = (Sint16) src[0];\n        src -= 8;\n        dst[15] = (Uint8) ((sample7 + last_sample7) >> 1);\n        dst[14] = (Uint8) ((sample6 + last_sample6) >> 1);\n        dst[13] = (Uint8) ((sample5 + last_sample5) >> 1);\n        dst[12] = (Uint8) ((sample4 + last_sample4) >> 1);\n        dst[11] = (Uint8) ((sample3 + last_sample3) >> 1);\n        dst[10] = (Uint8) ((sample2 + last_sample2) >> 1);\n        dst[9] = (Uint8) ((sample1 + last_sample1) >> 1);\n        dst[8] = (Uint8) ((sample0 + last_sample0) >> 1);\n        dst[7] = (Uint8) sample7;\n        dst[6] = (Uint8) sample6;\n        dst[5] = (Uint8) sample5;\n        dst[4] = (Uint8) sample4;\n        dst[3] = (Uint8) sample3;\n        dst[2] = (Uint8) sample2;\n        dst[1] = (Uint8) sample1;\n        dst[0] = (Uint8) sample0;\n        last_sample7 = sample7;\n        last_sample6 = sample6;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 16;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U8_8c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_U8, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Uint8 *dst = (Uint8 *) cvt->buf;\n    const Uint8 *src = (Uint8 *) cvt->buf;\n    const Uint8 *target = (const Uint8 *) (cvt->buf + dstsize);\n    Sint16 last_sample0 = (Sint16) src[0];\n    Sint16 last_sample1 = (Sint16) src[1];\n    Sint16 last_sample2 = (Sint16) src[2];\n    Sint16 last_sample3 = (Sint16) src[3];\n    Sint16 last_sample4 = (Sint16) src[4];\n    Sint16 last_sample5 = (Sint16) src[5];\n    Sint16 last_sample6 = (Sint16) src[6];\n    Sint16 last_sample7 = (Sint16) src[7];\n    while (dst < target) {\n        const Sint16 sample0 = (Sint16) src[0];\n        const Sint16 sample1 = (Sint16) src[1];\n        const Sint16 sample2 = (Sint16) src[2];\n        const Sint16 sample3 = (Sint16) src[3];\n        const Sint16 sample4 = (Sint16) src[4];\n        const Sint16 sample5 = (Sint16) src[5];\n        const Sint16 sample6 = (Sint16) src[6];\n        const Sint16 sample7 = (Sint16) src[7];\n        src += 16;\n        dst[0] = (Uint8) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Uint8) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Uint8) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Uint8) ((sample3 + last_sample3) >> 1);\n        dst[4] = (Uint8) ((sample4 + last_sample4) >> 1);\n        dst[5] = (Uint8) ((sample5 + last_sample5) >> 1);\n        dst[6] = (Uint8) ((sample6 + last_sample6) >> 1);\n        dst[7] = (Uint8) ((sample7 + last_sample7) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        last_sample6 = sample6;\n        last_sample7 = sample7;\n        dst += 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U8_8c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_U8, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Uint8 *dst = ((Uint8 *) (cvt->buf + dstsize)) - 8 * 4;\n    const Uint8 *src = ((Uint8 *) (cvt->buf + cvt->len_cvt)) - 8;\n    const Uint8 *target = ((const Uint8 *) cvt->buf);\n    Sint16 last_sample7 = (Sint16) src[7];\n    Sint16 last_sample6 = (Sint16) src[6];\n    Sint16 last_sample5 = (Sint16) src[5];\n    Sint16 last_sample4 = (Sint16) src[4];\n    Sint16 last_sample3 = (Sint16) src[3];\n    Sint16 last_sample2 = (Sint16) src[2];\n    Sint16 last_sample1 = (Sint16) src[1];\n    Sint16 last_sample0 = (Sint16) src[0];\n    while (dst >= target) {\n        const Sint16 sample7 = (Sint16) src[7];\n        const Sint16 sample6 = (Sint16) src[6];\n        const Sint16 sample5 = (Sint16) src[5];\n        const Sint16 sample4 = (Sint16) src[4];\n        const Sint16 sample3 = (Sint16) src[3];\n        const Sint16 sample2 = (Sint16) src[2];\n        const Sint16 sample1 = (Sint16) src[1];\n        const Sint16 sample0 = (Sint16) src[0];\n        src -= 8;\n        dst[31] = (Uint8) ((sample7 + (3 * last_sample7)) >> 2);\n        dst[30] = (Uint8) ((sample6 + (3 * last_sample6)) >> 2);\n        dst[29] = (Uint8) ((sample5 + (3 * last_sample5)) >> 2);\n        dst[28] = (Uint8) ((sample4 + (3 * last_sample4)) >> 2);\n        dst[27] = (Uint8) ((sample3 + (3 * last_sample3)) >> 2);\n        dst[26] = (Uint8) ((sample2 + (3 * last_sample2)) >> 2);\n        dst[25] = (Uint8) ((sample1 + (3 * last_sample1)) >> 2);\n        dst[24] = (Uint8) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[23] = (Uint8) ((sample7 + last_sample7) >> 1);\n        dst[22] = (Uint8) ((sample6 + last_sample6) >> 1);\n        dst[21] = (Uint8) ((sample5 + last_sample5) >> 1);\n        dst[20] = (Uint8) ((sample4 + last_sample4) >> 1);\n        dst[19] = (Uint8) ((sample3 + last_sample3) >> 1);\n        dst[18] = (Uint8) ((sample2 + last_sample2) >> 1);\n        dst[17] = (Uint8) ((sample1 + last_sample1) >> 1);\n        dst[16] = (Uint8) ((sample0 + last_sample0) >> 1);\n        dst[15] = (Uint8) (((3 * sample7) + last_sample7) >> 2);\n        dst[14] = (Uint8) (((3 * sample6) + last_sample6) >> 2);\n        dst[13] = (Uint8) (((3 * sample5) + last_sample5) >> 2);\n        dst[12] = (Uint8) (((3 * sample4) + last_sample4) >> 2);\n        dst[11] = (Uint8) (((3 * sample3) + last_sample3) >> 2);\n        dst[10] = (Uint8) (((3 * sample2) + last_sample2) >> 2);\n        dst[9] = (Uint8) (((3 * sample1) + last_sample1) >> 2);\n        dst[8] = (Uint8) (((3 * sample0) + last_sample0) >> 2);\n        dst[7] = (Uint8) sample7;\n        dst[6] = (Uint8) sample6;\n        dst[5] = (Uint8) sample5;\n        dst[4] = (Uint8) sample4;\n        dst[3] = (Uint8) sample3;\n        dst[2] = (Uint8) sample2;\n        dst[1] = (Uint8) sample1;\n        dst[0] = (Uint8) sample0;\n        last_sample7 = sample7;\n        last_sample6 = sample6;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 32;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U8_8c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_U8, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Uint8 *dst = (Uint8 *) cvt->buf;\n    const Uint8 *src = (Uint8 *) cvt->buf;\n    const Uint8 *target = (const Uint8 *) (cvt->buf + dstsize);\n    Sint16 last_sample0 = (Sint16) src[0];\n    Sint16 last_sample1 = (Sint16) src[1];\n    Sint16 last_sample2 = (Sint16) src[2];\n    Sint16 last_sample3 = (Sint16) src[3];\n    Sint16 last_sample4 = (Sint16) src[4];\n    Sint16 last_sample5 = (Sint16) src[5];\n    Sint16 last_sample6 = (Sint16) src[6];\n    Sint16 last_sample7 = (Sint16) src[7];\n    while (dst < target) {\n        const Sint16 sample0 = (Sint16) src[0];\n        const Sint16 sample1 = (Sint16) src[1];\n        const Sint16 sample2 = (Sint16) src[2];\n        const Sint16 sample3 = (Sint16) src[3];\n        const Sint16 sample4 = (Sint16) src[4];\n        const Sint16 sample5 = (Sint16) src[5];\n        const Sint16 sample6 = (Sint16) src[6];\n        const Sint16 sample7 = (Sint16) src[7];\n        src += 32;\n        dst[0] = (Uint8) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Uint8) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Uint8) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Uint8) ((sample3 + last_sample3) >> 1);\n        dst[4] = (Uint8) ((sample4 + last_sample4) >> 1);\n        dst[5] = (Uint8) ((sample5 + last_sample5) >> 1);\n        dst[6] = (Uint8) ((sample6 + last_sample6) >> 1);\n        dst[7] = (Uint8) ((sample7 + last_sample7) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        last_sample6 = sample6;\n        last_sample7 = sample7;\n        dst += 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S8_1c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_S8, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Sint8 *dst = ((Sint8 *) (cvt->buf + dstsize)) - 1 * 2;\n    const Sint8 *src = ((Sint8 *) (cvt->buf + cvt->len_cvt)) - 1;\n    const Sint8 *target = ((const Sint8 *) cvt->buf);\n    Sint16 last_sample0 = (Sint16) ((Sint8) src[0]);\n    while (dst >= target) {\n        const Sint16 sample0 = (Sint16) ((Sint8) src[0]);\n        src--;\n        dst[1] = (Sint8) ((sample0 + last_sample0) >> 1);\n        dst[0] = (Sint8) sample0;\n        last_sample0 = sample0;\n        dst -= 2;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S8_1c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_S8, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Sint8 *dst = (Sint8 *) cvt->buf;\n    const Sint8 *src = (Sint8 *) cvt->buf;\n    const Sint8 *target = (const Sint8 *) (cvt->buf + dstsize);\n    Sint16 last_sample0 = (Sint16) ((Sint8) src[0]);\n    while (dst < target) {\n        const Sint16 sample0 = (Sint16) ((Sint8) src[0]);\n        src += 2;\n        dst[0] = (Sint8) ((sample0 + last_sample0) >> 1);\n        last_sample0 = sample0;\n        dst++;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S8_1c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_S8, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Sint8 *dst = ((Sint8 *) (cvt->buf + dstsize)) - 1 * 4;\n    const Sint8 *src = ((Sint8 *) (cvt->buf + cvt->len_cvt)) - 1;\n    const Sint8 *target = ((const Sint8 *) cvt->buf);\n    Sint16 last_sample0 = (Sint16) ((Sint8) src[0]);\n    while (dst >= target) {\n        const Sint16 sample0 = (Sint16) ((Sint8) src[0]);\n        src--;\n        dst[3] = (Sint8) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[2] = (Sint8) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint8) (((3 * sample0) + last_sample0) >> 2);\n        dst[0] = (Sint8) sample0;\n        last_sample0 = sample0;\n        dst -= 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S8_1c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_S8, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Sint8 *dst = (Sint8 *) cvt->buf;\n    const Sint8 *src = (Sint8 *) cvt->buf;\n    const Sint8 *target = (const Sint8 *) (cvt->buf + dstsize);\n    Sint16 last_sample0 = (Sint16) ((Sint8) src[0]);\n    while (dst < target) {\n        const Sint16 sample0 = (Sint16) ((Sint8) src[0]);\n        src += 4;\n        dst[0] = (Sint8) ((sample0 + last_sample0) >> 1);\n        last_sample0 = sample0;\n        dst++;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S8_2c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_S8, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Sint8 *dst = ((Sint8 *) (cvt->buf + dstsize)) - 2 * 2;\n    const Sint8 *src = ((Sint8 *) (cvt->buf + cvt->len_cvt)) - 2;\n    const Sint8 *target = ((const Sint8 *) cvt->buf);\n    Sint16 last_sample1 = (Sint16) ((Sint8) src[1]);\n    Sint16 last_sample0 = (Sint16) ((Sint8) src[0]);\n    while (dst >= target) {\n        const Sint16 sample1 = (Sint16) ((Sint8) src[1]);\n        const Sint16 sample0 = (Sint16) ((Sint8) src[0]);\n        src -= 2;\n        dst[3] = (Sint8) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Sint8) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint8) sample1;\n        dst[0] = (Sint8) sample0;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S8_2c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_S8, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Sint8 *dst = (Sint8 *) cvt->buf;\n    const Sint8 *src = (Sint8 *) cvt->buf;\n    const Sint8 *target = (const Sint8 *) (cvt->buf + dstsize);\n    Sint16 last_sample0 = (Sint16) ((Sint8) src[0]);\n    Sint16 last_sample1 = (Sint16) ((Sint8) src[1]);\n    while (dst < target) {\n        const Sint16 sample0 = (Sint16) ((Sint8) src[0]);\n        const Sint16 sample1 = (Sint16) ((Sint8) src[1]);\n        src += 4;\n        dst[0] = (Sint8) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint8) ((sample1 + last_sample1) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        dst += 2;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S8_2c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_S8, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Sint8 *dst = ((Sint8 *) (cvt->buf + dstsize)) - 2 * 4;\n    const Sint8 *src = ((Sint8 *) (cvt->buf + cvt->len_cvt)) - 2;\n    const Sint8 *target = ((const Sint8 *) cvt->buf);\n    Sint16 last_sample1 = (Sint16) ((Sint8) src[1]);\n    Sint16 last_sample0 = (Sint16) ((Sint8) src[0]);\n    while (dst >= target) {\n        const Sint16 sample1 = (Sint16) ((Sint8) src[1]);\n        const Sint16 sample0 = (Sint16) ((Sint8) src[0]);\n        src -= 2;\n        dst[7] = (Sint8) ((sample1 + (3 * last_sample1)) >> 2);\n        dst[6] = (Sint8) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[5] = (Sint8) ((sample1 + last_sample1) >> 1);\n        dst[4] = (Sint8) ((sample0 + last_sample0) >> 1);\n        dst[3] = (Sint8) (((3 * sample1) + last_sample1) >> 2);\n        dst[2] = (Sint8) (((3 * sample0) + last_sample0) >> 2);\n        dst[1] = (Sint8) sample1;\n        dst[0] = (Sint8) sample0;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S8_2c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_S8, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Sint8 *dst = (Sint8 *) cvt->buf;\n    const Sint8 *src = (Sint8 *) cvt->buf;\n    const Sint8 *target = (const Sint8 *) (cvt->buf + dstsize);\n    Sint16 last_sample0 = (Sint16) ((Sint8) src[0]);\n    Sint16 last_sample1 = (Sint16) ((Sint8) src[1]);\n    while (dst < target) {\n        const Sint16 sample0 = (Sint16) ((Sint8) src[0]);\n        const Sint16 sample1 = (Sint16) ((Sint8) src[1]);\n        src += 8;\n        dst[0] = (Sint8) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint8) ((sample1 + last_sample1) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        dst += 2;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S8_4c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_S8, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Sint8 *dst = ((Sint8 *) (cvt->buf + dstsize)) - 4 * 2;\n    const Sint8 *src = ((Sint8 *) (cvt->buf + cvt->len_cvt)) - 4;\n    const Sint8 *target = ((const Sint8 *) cvt->buf);\n    Sint16 last_sample3 = (Sint16) ((Sint8) src[3]);\n    Sint16 last_sample2 = (Sint16) ((Sint8) src[2]);\n    Sint16 last_sample1 = (Sint16) ((Sint8) src[1]);\n    Sint16 last_sample0 = (Sint16) ((Sint8) src[0]);\n    while (dst >= target) {\n        const Sint16 sample3 = (Sint16) ((Sint8) src[3]);\n        const Sint16 sample2 = (Sint16) ((Sint8) src[2]);\n        const Sint16 sample1 = (Sint16) ((Sint8) src[1]);\n        const Sint16 sample0 = (Sint16) ((Sint8) src[0]);\n        src -= 4;\n        dst[7] = (Sint8) ((sample3 + last_sample3) >> 1);\n        dst[6] = (Sint8) ((sample2 + last_sample2) >> 1);\n        dst[5] = (Sint8) ((sample1 + last_sample1) >> 1);\n        dst[4] = (Sint8) ((sample0 + last_sample0) >> 1);\n        dst[3] = (Sint8) sample3;\n        dst[2] = (Sint8) sample2;\n        dst[1] = (Sint8) sample1;\n        dst[0] = (Sint8) sample0;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S8_4c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_S8, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Sint8 *dst = (Sint8 *) cvt->buf;\n    const Sint8 *src = (Sint8 *) cvt->buf;\n    const Sint8 *target = (const Sint8 *) (cvt->buf + dstsize);\n    Sint16 last_sample0 = (Sint16) ((Sint8) src[0]);\n    Sint16 last_sample1 = (Sint16) ((Sint8) src[1]);\n    Sint16 last_sample2 = (Sint16) ((Sint8) src[2]);\n    Sint16 last_sample3 = (Sint16) ((Sint8) src[3]);\n    while (dst < target) {\n        const Sint16 sample0 = (Sint16) ((Sint8) src[0]);\n        const Sint16 sample1 = (Sint16) ((Sint8) src[1]);\n        const Sint16 sample2 = (Sint16) ((Sint8) src[2]);\n        const Sint16 sample3 = (Sint16) ((Sint8) src[3]);\n        src += 8;\n        dst[0] = (Sint8) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint8) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Sint8) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Sint8) ((sample3 + last_sample3) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        dst += 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S8_4c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_S8, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Sint8 *dst = ((Sint8 *) (cvt->buf + dstsize)) - 4 * 4;\n    const Sint8 *src = ((Sint8 *) (cvt->buf + cvt->len_cvt)) - 4;\n    const Sint8 *target = ((const Sint8 *) cvt->buf);\n    Sint16 last_sample3 = (Sint16) ((Sint8) src[3]);\n    Sint16 last_sample2 = (Sint16) ((Sint8) src[2]);\n    Sint16 last_sample1 = (Sint16) ((Sint8) src[1]);\n    Sint16 last_sample0 = (Sint16) ((Sint8) src[0]);\n    while (dst >= target) {\n        const Sint16 sample3 = (Sint16) ((Sint8) src[3]);\n        const Sint16 sample2 = (Sint16) ((Sint8) src[2]);\n        const Sint16 sample1 = (Sint16) ((Sint8) src[1]);\n        const Sint16 sample0 = (Sint16) ((Sint8) src[0]);\n        src -= 4;\n        dst[15] = (Sint8) ((sample3 + (3 * last_sample3)) >> 2);\n        dst[14] = (Sint8) ((sample2 + (3 * last_sample2)) >> 2);\n        dst[13] = (Sint8) ((sample1 + (3 * last_sample1)) >> 2);\n        dst[12] = (Sint8) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[11] = (Sint8) ((sample3 + last_sample3) >> 1);\n        dst[10] = (Sint8) ((sample2 + last_sample2) >> 1);\n        dst[9] = (Sint8) ((sample1 + last_sample1) >> 1);\n        dst[8] = (Sint8) ((sample0 + last_sample0) >> 1);\n        dst[7] = (Sint8) (((3 * sample3) + last_sample3) >> 2);\n        dst[6] = (Sint8) (((3 * sample2) + last_sample2) >> 2);\n        dst[5] = (Sint8) (((3 * sample1) + last_sample1) >> 2);\n        dst[4] = (Sint8) (((3 * sample0) + last_sample0) >> 2);\n        dst[3] = (Sint8) sample3;\n        dst[2] = (Sint8) sample2;\n        dst[1] = (Sint8) sample1;\n        dst[0] = (Sint8) sample0;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 16;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S8_4c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_S8, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Sint8 *dst = (Sint8 *) cvt->buf;\n    const Sint8 *src = (Sint8 *) cvt->buf;\n    const Sint8 *target = (const Sint8 *) (cvt->buf + dstsize);\n    Sint16 last_sample0 = (Sint16) ((Sint8) src[0]);\n    Sint16 last_sample1 = (Sint16) ((Sint8) src[1]);\n    Sint16 last_sample2 = (Sint16) ((Sint8) src[2]);\n    Sint16 last_sample3 = (Sint16) ((Sint8) src[3]);\n    while (dst < target) {\n        const Sint16 sample0 = (Sint16) ((Sint8) src[0]);\n        const Sint16 sample1 = (Sint16) ((Sint8) src[1]);\n        const Sint16 sample2 = (Sint16) ((Sint8) src[2]);\n        const Sint16 sample3 = (Sint16) ((Sint8) src[3]);\n        src += 16;\n        dst[0] = (Sint8) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint8) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Sint8) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Sint8) ((sample3 + last_sample3) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        dst += 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S8_6c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_S8, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Sint8 *dst = ((Sint8 *) (cvt->buf + dstsize)) - 6 * 2;\n    const Sint8 *src = ((Sint8 *) (cvt->buf + cvt->len_cvt)) - 6;\n    const Sint8 *target = ((const Sint8 *) cvt->buf);\n    Sint16 last_sample5 = (Sint16) ((Sint8) src[5]);\n    Sint16 last_sample4 = (Sint16) ((Sint8) src[4]);\n    Sint16 last_sample3 = (Sint16) ((Sint8) src[3]);\n    Sint16 last_sample2 = (Sint16) ((Sint8) src[2]);\n    Sint16 last_sample1 = (Sint16) ((Sint8) src[1]);\n    Sint16 last_sample0 = (Sint16) ((Sint8) src[0]);\n    while (dst >= target) {\n        const Sint16 sample5 = (Sint16) ((Sint8) src[5]);\n        const Sint16 sample4 = (Sint16) ((Sint8) src[4]);\n        const Sint16 sample3 = (Sint16) ((Sint8) src[3]);\n        const Sint16 sample2 = (Sint16) ((Sint8) src[2]);\n        const Sint16 sample1 = (Sint16) ((Sint8) src[1]);\n        const Sint16 sample0 = (Sint16) ((Sint8) src[0]);\n        src -= 6;\n        dst[11] = (Sint8) ((sample5 + last_sample5) >> 1);\n        dst[10] = (Sint8) ((sample4 + last_sample4) >> 1);\n        dst[9] = (Sint8) ((sample3 + last_sample3) >> 1);\n        dst[8] = (Sint8) ((sample2 + last_sample2) >> 1);\n        dst[7] = (Sint8) ((sample1 + last_sample1) >> 1);\n        dst[6] = (Sint8) ((sample0 + last_sample0) >> 1);\n        dst[5] = (Sint8) sample5;\n        dst[4] = (Sint8) sample4;\n        dst[3] = (Sint8) sample3;\n        dst[2] = (Sint8) sample2;\n        dst[1] = (Sint8) sample1;\n        dst[0] = (Sint8) sample0;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 12;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S8_6c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_S8, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Sint8 *dst = (Sint8 *) cvt->buf;\n    const Sint8 *src = (Sint8 *) cvt->buf;\n    const Sint8 *target = (const Sint8 *) (cvt->buf + dstsize);\n    Sint16 last_sample0 = (Sint16) ((Sint8) src[0]);\n    Sint16 last_sample1 = (Sint16) ((Sint8) src[1]);\n    Sint16 last_sample2 = (Sint16) ((Sint8) src[2]);\n    Sint16 last_sample3 = (Sint16) ((Sint8) src[3]);\n    Sint16 last_sample4 = (Sint16) ((Sint8) src[4]);\n    Sint16 last_sample5 = (Sint16) ((Sint8) src[5]);\n    while (dst < target) {\n        const Sint16 sample0 = (Sint16) ((Sint8) src[0]);\n        const Sint16 sample1 = (Sint16) ((Sint8) src[1]);\n        const Sint16 sample2 = (Sint16) ((Sint8) src[2]);\n        const Sint16 sample3 = (Sint16) ((Sint8) src[3]);\n        const Sint16 sample4 = (Sint16) ((Sint8) src[4]);\n        const Sint16 sample5 = (Sint16) ((Sint8) src[5]);\n        src += 12;\n        dst[0] = (Sint8) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint8) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Sint8) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Sint8) ((sample3 + last_sample3) >> 1);\n        dst[4] = (Sint8) ((sample4 + last_sample4) >> 1);\n        dst[5] = (Sint8) ((sample5 + last_sample5) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        dst += 6;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S8_6c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_S8, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Sint8 *dst = ((Sint8 *) (cvt->buf + dstsize)) - 6 * 4;\n    const Sint8 *src = ((Sint8 *) (cvt->buf + cvt->len_cvt)) - 6;\n    const Sint8 *target = ((const Sint8 *) cvt->buf);\n    Sint16 last_sample5 = (Sint16) ((Sint8) src[5]);\n    Sint16 last_sample4 = (Sint16) ((Sint8) src[4]);\n    Sint16 last_sample3 = (Sint16) ((Sint8) src[3]);\n    Sint16 last_sample2 = (Sint16) ((Sint8) src[2]);\n    Sint16 last_sample1 = (Sint16) ((Sint8) src[1]);\n    Sint16 last_sample0 = (Sint16) ((Sint8) src[0]);\n    while (dst >= target) {\n        const Sint16 sample5 = (Sint16) ((Sint8) src[5]);\n        const Sint16 sample4 = (Sint16) ((Sint8) src[4]);\n        const Sint16 sample3 = (Sint16) ((Sint8) src[3]);\n        const Sint16 sample2 = (Sint16) ((Sint8) src[2]);\n        const Sint16 sample1 = (Sint16) ((Sint8) src[1]);\n        const Sint16 sample0 = (Sint16) ((Sint8) src[0]);\n        src -= 6;\n        dst[23] = (Sint8) ((sample5 + (3 * last_sample5)) >> 2);\n        dst[22] = (Sint8) ((sample4 + (3 * last_sample4)) >> 2);\n        dst[21] = (Sint8) ((sample3 + (3 * last_sample3)) >> 2);\n        dst[20] = (Sint8) ((sample2 + (3 * last_sample2)) >> 2);\n        dst[19] = (Sint8) ((sample1 + (3 * last_sample1)) >> 2);\n        dst[18] = (Sint8) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[17] = (Sint8) ((sample5 + last_sample5) >> 1);\n        dst[16] = (Sint8) ((sample4 + last_sample4) >> 1);\n        dst[15] = (Sint8) ((sample3 + last_sample3) >> 1);\n        dst[14] = (Sint8) ((sample2 + last_sample2) >> 1);\n        dst[13] = (Sint8) ((sample1 + last_sample1) >> 1);\n        dst[12] = (Sint8) ((sample0 + last_sample0) >> 1);\n        dst[11] = (Sint8) (((3 * sample5) + last_sample5) >> 2);\n        dst[10] = (Sint8) (((3 * sample4) + last_sample4) >> 2);\n        dst[9] = (Sint8) (((3 * sample3) + last_sample3) >> 2);\n        dst[8] = (Sint8) (((3 * sample2) + last_sample2) >> 2);\n        dst[7] = (Sint8) (((3 * sample1) + last_sample1) >> 2);\n        dst[6] = (Sint8) (((3 * sample0) + last_sample0) >> 2);\n        dst[5] = (Sint8) sample5;\n        dst[4] = (Sint8) sample4;\n        dst[3] = (Sint8) sample3;\n        dst[2] = (Sint8) sample2;\n        dst[1] = (Sint8) sample1;\n        dst[0] = (Sint8) sample0;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 24;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S8_6c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_S8, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Sint8 *dst = (Sint8 *) cvt->buf;\n    const Sint8 *src = (Sint8 *) cvt->buf;\n    const Sint8 *target = (const Sint8 *) (cvt->buf + dstsize);\n    Sint16 last_sample0 = (Sint16) ((Sint8) src[0]);\n    Sint16 last_sample1 = (Sint16) ((Sint8) src[1]);\n    Sint16 last_sample2 = (Sint16) ((Sint8) src[2]);\n    Sint16 last_sample3 = (Sint16) ((Sint8) src[3]);\n    Sint16 last_sample4 = (Sint16) ((Sint8) src[4]);\n    Sint16 last_sample5 = (Sint16) ((Sint8) src[5]);\n    while (dst < target) {\n        const Sint16 sample0 = (Sint16) ((Sint8) src[0]);\n        const Sint16 sample1 = (Sint16) ((Sint8) src[1]);\n        const Sint16 sample2 = (Sint16) ((Sint8) src[2]);\n        const Sint16 sample3 = (Sint16) ((Sint8) src[3]);\n        const Sint16 sample4 = (Sint16) ((Sint8) src[4]);\n        const Sint16 sample5 = (Sint16) ((Sint8) src[5]);\n        src += 24;\n        dst[0] = (Sint8) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint8) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Sint8) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Sint8) ((sample3 + last_sample3) >> 1);\n        dst[4] = (Sint8) ((sample4 + last_sample4) >> 1);\n        dst[5] = (Sint8) ((sample5 + last_sample5) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        dst += 6;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S8_8c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_S8, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Sint8 *dst = ((Sint8 *) (cvt->buf + dstsize)) - 8 * 2;\n    const Sint8 *src = ((Sint8 *) (cvt->buf + cvt->len_cvt)) - 8;\n    const Sint8 *target = ((const Sint8 *) cvt->buf);\n    Sint16 last_sample7 = (Sint16) ((Sint8) src[7]);\n    Sint16 last_sample6 = (Sint16) ((Sint8) src[6]);\n    Sint16 last_sample5 = (Sint16) ((Sint8) src[5]);\n    Sint16 last_sample4 = (Sint16) ((Sint8) src[4]);\n    Sint16 last_sample3 = (Sint16) ((Sint8) src[3]);\n    Sint16 last_sample2 = (Sint16) ((Sint8) src[2]);\n    Sint16 last_sample1 = (Sint16) ((Sint8) src[1]);\n    Sint16 last_sample0 = (Sint16) ((Sint8) src[0]);\n    while (dst >= target) {\n        const Sint16 sample7 = (Sint16) ((Sint8) src[7]);\n        const Sint16 sample6 = (Sint16) ((Sint8) src[6]);\n        const Sint16 sample5 = (Sint16) ((Sint8) src[5]);\n        const Sint16 sample4 = (Sint16) ((Sint8) src[4]);\n        const Sint16 sample3 = (Sint16) ((Sint8) src[3]);\n        const Sint16 sample2 = (Sint16) ((Sint8) src[2]);\n        const Sint16 sample1 = (Sint16) ((Sint8) src[1]);\n        const Sint16 sample0 = (Sint16) ((Sint8) src[0]);\n        src -= 8;\n        dst[15] = (Sint8) ((sample7 + last_sample7) >> 1);\n        dst[14] = (Sint8) ((sample6 + last_sample6) >> 1);\n        dst[13] = (Sint8) ((sample5 + last_sample5) >> 1);\n        dst[12] = (Sint8) ((sample4 + last_sample4) >> 1);\n        dst[11] = (Sint8) ((sample3 + last_sample3) >> 1);\n        dst[10] = (Sint8) ((sample2 + last_sample2) >> 1);\n        dst[9] = (Sint8) ((sample1 + last_sample1) >> 1);\n        dst[8] = (Sint8) ((sample0 + last_sample0) >> 1);\n        dst[7] = (Sint8) sample7;\n        dst[6] = (Sint8) sample6;\n        dst[5] = (Sint8) sample5;\n        dst[4] = (Sint8) sample4;\n        dst[3] = (Sint8) sample3;\n        dst[2] = (Sint8) sample2;\n        dst[1] = (Sint8) sample1;\n        dst[0] = (Sint8) sample0;\n        last_sample7 = sample7;\n        last_sample6 = sample6;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 16;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S8_8c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_S8, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Sint8 *dst = (Sint8 *) cvt->buf;\n    const Sint8 *src = (Sint8 *) cvt->buf;\n    const Sint8 *target = (const Sint8 *) (cvt->buf + dstsize);\n    Sint16 last_sample0 = (Sint16) ((Sint8) src[0]);\n    Sint16 last_sample1 = (Sint16) ((Sint8) src[1]);\n    Sint16 last_sample2 = (Sint16) ((Sint8) src[2]);\n    Sint16 last_sample3 = (Sint16) ((Sint8) src[3]);\n    Sint16 last_sample4 = (Sint16) ((Sint8) src[4]);\n    Sint16 last_sample5 = (Sint16) ((Sint8) src[5]);\n    Sint16 last_sample6 = (Sint16) ((Sint8) src[6]);\n    Sint16 last_sample7 = (Sint16) ((Sint8) src[7]);\n    while (dst < target) {\n        const Sint16 sample0 = (Sint16) ((Sint8) src[0]);\n        const Sint16 sample1 = (Sint16) ((Sint8) src[1]);\n        const Sint16 sample2 = (Sint16) ((Sint8) src[2]);\n        const Sint16 sample3 = (Sint16) ((Sint8) src[3]);\n        const Sint16 sample4 = (Sint16) ((Sint8) src[4]);\n        const Sint16 sample5 = (Sint16) ((Sint8) src[5]);\n        const Sint16 sample6 = (Sint16) ((Sint8) src[6]);\n        const Sint16 sample7 = (Sint16) ((Sint8) src[7]);\n        src += 16;\n        dst[0] = (Sint8) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint8) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Sint8) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Sint8) ((sample3 + last_sample3) >> 1);\n        dst[4] = (Sint8) ((sample4 + last_sample4) >> 1);\n        dst[5] = (Sint8) ((sample5 + last_sample5) >> 1);\n        dst[6] = (Sint8) ((sample6 + last_sample6) >> 1);\n        dst[7] = (Sint8) ((sample7 + last_sample7) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        last_sample6 = sample6;\n        last_sample7 = sample7;\n        dst += 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S8_8c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_S8, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Sint8 *dst = ((Sint8 *) (cvt->buf + dstsize)) - 8 * 4;\n    const Sint8 *src = ((Sint8 *) (cvt->buf + cvt->len_cvt)) - 8;\n    const Sint8 *target = ((const Sint8 *) cvt->buf);\n    Sint16 last_sample7 = (Sint16) ((Sint8) src[7]);\n    Sint16 last_sample6 = (Sint16) ((Sint8) src[6]);\n    Sint16 last_sample5 = (Sint16) ((Sint8) src[5]);\n    Sint16 last_sample4 = (Sint16) ((Sint8) src[4]);\n    Sint16 last_sample3 = (Sint16) ((Sint8) src[3]);\n    Sint16 last_sample2 = (Sint16) ((Sint8) src[2]);\n    Sint16 last_sample1 = (Sint16) ((Sint8) src[1]);\n    Sint16 last_sample0 = (Sint16) ((Sint8) src[0]);\n    while (dst >= target) {\n        const Sint16 sample7 = (Sint16) ((Sint8) src[7]);\n        const Sint16 sample6 = (Sint16) ((Sint8) src[6]);\n        const Sint16 sample5 = (Sint16) ((Sint8) src[5]);\n        const Sint16 sample4 = (Sint16) ((Sint8) src[4]);\n        const Sint16 sample3 = (Sint16) ((Sint8) src[3]);\n        const Sint16 sample2 = (Sint16) ((Sint8) src[2]);\n        const Sint16 sample1 = (Sint16) ((Sint8) src[1]);\n        const Sint16 sample0 = (Sint16) ((Sint8) src[0]);\n        src -= 8;\n        dst[31] = (Sint8) ((sample7 + (3 * last_sample7)) >> 2);\n        dst[30] = (Sint8) ((sample6 + (3 * last_sample6)) >> 2);\n        dst[29] = (Sint8) ((sample5 + (3 * last_sample5)) >> 2);\n        dst[28] = (Sint8) ((sample4 + (3 * last_sample4)) >> 2);\n        dst[27] = (Sint8) ((sample3 + (3 * last_sample3)) >> 2);\n        dst[26] = (Sint8) ((sample2 + (3 * last_sample2)) >> 2);\n        dst[25] = (Sint8) ((sample1 + (3 * last_sample1)) >> 2);\n        dst[24] = (Sint8) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[23] = (Sint8) ((sample7 + last_sample7) >> 1);\n        dst[22] = (Sint8) ((sample6 + last_sample6) >> 1);\n        dst[21] = (Sint8) ((sample5 + last_sample5) >> 1);\n        dst[20] = (Sint8) ((sample4 + last_sample4) >> 1);\n        dst[19] = (Sint8) ((sample3 + last_sample3) >> 1);\n        dst[18] = (Sint8) ((sample2 + last_sample2) >> 1);\n        dst[17] = (Sint8) ((sample1 + last_sample1) >> 1);\n        dst[16] = (Sint8) ((sample0 + last_sample0) >> 1);\n        dst[15] = (Sint8) (((3 * sample7) + last_sample7) >> 2);\n        dst[14] = (Sint8) (((3 * sample6) + last_sample6) >> 2);\n        dst[13] = (Sint8) (((3 * sample5) + last_sample5) >> 2);\n        dst[12] = (Sint8) (((3 * sample4) + last_sample4) >> 2);\n        dst[11] = (Sint8) (((3 * sample3) + last_sample3) >> 2);\n        dst[10] = (Sint8) (((3 * sample2) + last_sample2) >> 2);\n        dst[9] = (Sint8) (((3 * sample1) + last_sample1) >> 2);\n        dst[8] = (Sint8) (((3 * sample0) + last_sample0) >> 2);\n        dst[7] = (Sint8) sample7;\n        dst[6] = (Sint8) sample6;\n        dst[5] = (Sint8) sample5;\n        dst[4] = (Sint8) sample4;\n        dst[3] = (Sint8) sample3;\n        dst[2] = (Sint8) sample2;\n        dst[1] = (Sint8) sample1;\n        dst[0] = (Sint8) sample0;\n        last_sample7 = sample7;\n        last_sample6 = sample6;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 32;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S8_8c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_S8, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Sint8 *dst = (Sint8 *) cvt->buf;\n    const Sint8 *src = (Sint8 *) cvt->buf;\n    const Sint8 *target = (const Sint8 *) (cvt->buf + dstsize);\n    Sint16 last_sample0 = (Sint16) ((Sint8) src[0]);\n    Sint16 last_sample1 = (Sint16) ((Sint8) src[1]);\n    Sint16 last_sample2 = (Sint16) ((Sint8) src[2]);\n    Sint16 last_sample3 = (Sint16) ((Sint8) src[3]);\n    Sint16 last_sample4 = (Sint16) ((Sint8) src[4]);\n    Sint16 last_sample5 = (Sint16) ((Sint8) src[5]);\n    Sint16 last_sample6 = (Sint16) ((Sint8) src[6]);\n    Sint16 last_sample7 = (Sint16) ((Sint8) src[7]);\n    while (dst < target) {\n        const Sint16 sample0 = (Sint16) ((Sint8) src[0]);\n        const Sint16 sample1 = (Sint16) ((Sint8) src[1]);\n        const Sint16 sample2 = (Sint16) ((Sint8) src[2]);\n        const Sint16 sample3 = (Sint16) ((Sint8) src[3]);\n        const Sint16 sample4 = (Sint16) ((Sint8) src[4]);\n        const Sint16 sample5 = (Sint16) ((Sint8) src[5]);\n        const Sint16 sample6 = (Sint16) ((Sint8) src[6]);\n        const Sint16 sample7 = (Sint16) ((Sint8) src[7]);\n        src += 32;\n        dst[0] = (Sint8) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint8) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Sint8) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Sint8) ((sample3 + last_sample3) >> 1);\n        dst[4] = (Sint8) ((sample4 + last_sample4) >> 1);\n        dst[5] = (Sint8) ((sample5 + last_sample5) >> 1);\n        dst[6] = (Sint8) ((sample6 + last_sample6) >> 1);\n        dst[7] = (Sint8) ((sample7 + last_sample7) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        last_sample6 = sample6;\n        last_sample7 = sample7;\n        dst += 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U16LSB_1c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_U16LSB, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Uint16 *dst = ((Uint16 *) (cvt->buf + dstsize)) - 1 * 2;\n    const Uint16 *src = ((Uint16 *) (cvt->buf + cvt->len_cvt)) - 1;\n    const Uint16 *target = ((const Uint16 *) cvt->buf);\n    Sint32 last_sample0 = (Sint32) SDL_SwapLE16(src[0]);\n    while (dst >= target) {\n        const Sint32 sample0 = (Sint32) SDL_SwapLE16(src[0]);\n        src--;\n        dst[1] = (Uint16) ((sample0 + last_sample0) >> 1);\n        dst[0] = (Uint16) sample0;\n        last_sample0 = sample0;\n        dst -= 2;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U16LSB_1c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_U16LSB, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Uint16 *dst = (Uint16 *) cvt->buf;\n    const Uint16 *src = (Uint16 *) cvt->buf;\n    const Uint16 *target = (const Uint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) SDL_SwapLE16(src[0]);\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) SDL_SwapLE16(src[0]);\n        src += 2;\n        dst[0] = (Uint16) ((sample0 + last_sample0) >> 1);\n        last_sample0 = sample0;\n        dst++;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U16LSB_1c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_U16LSB, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Uint16 *dst = ((Uint16 *) (cvt->buf + dstsize)) - 1 * 4;\n    const Uint16 *src = ((Uint16 *) (cvt->buf + cvt->len_cvt)) - 1;\n    const Uint16 *target = ((const Uint16 *) cvt->buf);\n    Sint32 last_sample0 = (Sint32) SDL_SwapLE16(src[0]);\n    while (dst >= target) {\n        const Sint32 sample0 = (Sint32) SDL_SwapLE16(src[0]);\n        src--;\n        dst[3] = (Uint16) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[2] = (Uint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Uint16) (((3 * sample0) + last_sample0) >> 2);\n        dst[0] = (Uint16) sample0;\n        last_sample0 = sample0;\n        dst -= 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U16LSB_1c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_U16LSB, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Uint16 *dst = (Uint16 *) cvt->buf;\n    const Uint16 *src = (Uint16 *) cvt->buf;\n    const Uint16 *target = (const Uint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) SDL_SwapLE16(src[0]);\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) SDL_SwapLE16(src[0]);\n        src += 4;\n        dst[0] = (Uint16) ((sample0 + last_sample0) >> 1);\n        last_sample0 = sample0;\n        dst++;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U16LSB_2c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_U16LSB, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Uint16 *dst = ((Uint16 *) (cvt->buf + dstsize)) - 2 * 2;\n    const Uint16 *src = ((Uint16 *) (cvt->buf + cvt->len_cvt)) - 2;\n    const Uint16 *target = ((const Uint16 *) cvt->buf);\n    Sint32 last_sample1 = (Sint32) SDL_SwapLE16(src[1]);\n    Sint32 last_sample0 = (Sint32) SDL_SwapLE16(src[0]);\n    while (dst >= target) {\n        const Sint32 sample1 = (Sint32) SDL_SwapLE16(src[1]);\n        const Sint32 sample0 = (Sint32) SDL_SwapLE16(src[0]);\n        src -= 2;\n        dst[3] = (Uint16) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Uint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Uint16) sample1;\n        dst[0] = (Uint16) sample0;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U16LSB_2c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_U16LSB, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Uint16 *dst = (Uint16 *) cvt->buf;\n    const Uint16 *src = (Uint16 *) cvt->buf;\n    const Uint16 *target = (const Uint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) SDL_SwapLE16(src[0]);\n    Sint32 last_sample1 = (Sint32) SDL_SwapLE16(src[1]);\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) SDL_SwapLE16(src[0]);\n        const Sint32 sample1 = (Sint32) SDL_SwapLE16(src[1]);\n        src += 4;\n        dst[0] = (Uint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Uint16) ((sample1 + last_sample1) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        dst += 2;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U16LSB_2c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_U16LSB, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Uint16 *dst = ((Uint16 *) (cvt->buf + dstsize)) - 2 * 4;\n    const Uint16 *src = ((Uint16 *) (cvt->buf + cvt->len_cvt)) - 2;\n    const Uint16 *target = ((const Uint16 *) cvt->buf);\n    Sint32 last_sample1 = (Sint32) SDL_SwapLE16(src[1]);\n    Sint32 last_sample0 = (Sint32) SDL_SwapLE16(src[0]);\n    while (dst >= target) {\n        const Sint32 sample1 = (Sint32) SDL_SwapLE16(src[1]);\n        const Sint32 sample0 = (Sint32) SDL_SwapLE16(src[0]);\n        src -= 2;\n        dst[7] = (Uint16) ((sample1 + (3 * last_sample1)) >> 2);\n        dst[6] = (Uint16) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[5] = (Uint16) ((sample1 + last_sample1) >> 1);\n        dst[4] = (Uint16) ((sample0 + last_sample0) >> 1);\n        dst[3] = (Uint16) (((3 * sample1) + last_sample1) >> 2);\n        dst[2] = (Uint16) (((3 * sample0) + last_sample0) >> 2);\n        dst[1] = (Uint16) sample1;\n        dst[0] = (Uint16) sample0;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U16LSB_2c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_U16LSB, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Uint16 *dst = (Uint16 *) cvt->buf;\n    const Uint16 *src = (Uint16 *) cvt->buf;\n    const Uint16 *target = (const Uint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) SDL_SwapLE16(src[0]);\n    Sint32 last_sample1 = (Sint32) SDL_SwapLE16(src[1]);\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) SDL_SwapLE16(src[0]);\n        const Sint32 sample1 = (Sint32) SDL_SwapLE16(src[1]);\n        src += 8;\n        dst[0] = (Uint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Uint16) ((sample1 + last_sample1) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        dst += 2;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U16LSB_4c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_U16LSB, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Uint16 *dst = ((Uint16 *) (cvt->buf + dstsize)) - 4 * 2;\n    const Uint16 *src = ((Uint16 *) (cvt->buf + cvt->len_cvt)) - 4;\n    const Uint16 *target = ((const Uint16 *) cvt->buf);\n    Sint32 last_sample3 = (Sint32) SDL_SwapLE16(src[3]);\n    Sint32 last_sample2 = (Sint32) SDL_SwapLE16(src[2]);\n    Sint32 last_sample1 = (Sint32) SDL_SwapLE16(src[1]);\n    Sint32 last_sample0 = (Sint32) SDL_SwapLE16(src[0]);\n    while (dst >= target) {\n        const Sint32 sample3 = (Sint32) SDL_SwapLE16(src[3]);\n        const Sint32 sample2 = (Sint32) SDL_SwapLE16(src[2]);\n        const Sint32 sample1 = (Sint32) SDL_SwapLE16(src[1]);\n        const Sint32 sample0 = (Sint32) SDL_SwapLE16(src[0]);\n        src -= 4;\n        dst[7] = (Uint16) ((sample3 + last_sample3) >> 1);\n        dst[6] = (Uint16) ((sample2 + last_sample2) >> 1);\n        dst[5] = (Uint16) ((sample1 + last_sample1) >> 1);\n        dst[4] = (Uint16) ((sample0 + last_sample0) >> 1);\n        dst[3] = (Uint16) sample3;\n        dst[2] = (Uint16) sample2;\n        dst[1] = (Uint16) sample1;\n        dst[0] = (Uint16) sample0;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U16LSB_4c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_U16LSB, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Uint16 *dst = (Uint16 *) cvt->buf;\n    const Uint16 *src = (Uint16 *) cvt->buf;\n    const Uint16 *target = (const Uint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) SDL_SwapLE16(src[0]);\n    Sint32 last_sample1 = (Sint32) SDL_SwapLE16(src[1]);\n    Sint32 last_sample2 = (Sint32) SDL_SwapLE16(src[2]);\n    Sint32 last_sample3 = (Sint32) SDL_SwapLE16(src[3]);\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) SDL_SwapLE16(src[0]);\n        const Sint32 sample1 = (Sint32) SDL_SwapLE16(src[1]);\n        const Sint32 sample2 = (Sint32) SDL_SwapLE16(src[2]);\n        const Sint32 sample3 = (Sint32) SDL_SwapLE16(src[3]);\n        src += 8;\n        dst[0] = (Uint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Uint16) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Uint16) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Uint16) ((sample3 + last_sample3) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        dst += 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U16LSB_4c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_U16LSB, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Uint16 *dst = ((Uint16 *) (cvt->buf + dstsize)) - 4 * 4;\n    const Uint16 *src = ((Uint16 *) (cvt->buf + cvt->len_cvt)) - 4;\n    const Uint16 *target = ((const Uint16 *) cvt->buf);\n    Sint32 last_sample3 = (Sint32) SDL_SwapLE16(src[3]);\n    Sint32 last_sample2 = (Sint32) SDL_SwapLE16(src[2]);\n    Sint32 last_sample1 = (Sint32) SDL_SwapLE16(src[1]);\n    Sint32 last_sample0 = (Sint32) SDL_SwapLE16(src[0]);\n    while (dst >= target) {\n        const Sint32 sample3 = (Sint32) SDL_SwapLE16(src[3]);\n        const Sint32 sample2 = (Sint32) SDL_SwapLE16(src[2]);\n        const Sint32 sample1 = (Sint32) SDL_SwapLE16(src[1]);\n        const Sint32 sample0 = (Sint32) SDL_SwapLE16(src[0]);\n        src -= 4;\n        dst[15] = (Uint16) ((sample3 + (3 * last_sample3)) >> 2);\n        dst[14] = (Uint16) ((sample2 + (3 * last_sample2)) >> 2);\n        dst[13] = (Uint16) ((sample1 + (3 * last_sample1)) >> 2);\n        dst[12] = (Uint16) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[11] = (Uint16) ((sample3 + last_sample3) >> 1);\n        dst[10] = (Uint16) ((sample2 + last_sample2) >> 1);\n        dst[9] = (Uint16) ((sample1 + last_sample1) >> 1);\n        dst[8] = (Uint16) ((sample0 + last_sample0) >> 1);\n        dst[7] = (Uint16) (((3 * sample3) + last_sample3) >> 2);\n        dst[6] = (Uint16) (((3 * sample2) + last_sample2) >> 2);\n        dst[5] = (Uint16) (((3 * sample1) + last_sample1) >> 2);\n        dst[4] = (Uint16) (((3 * sample0) + last_sample0) >> 2);\n        dst[3] = (Uint16) sample3;\n        dst[2] = (Uint16) sample2;\n        dst[1] = (Uint16) sample1;\n        dst[0] = (Uint16) sample0;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 16;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U16LSB_4c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_U16LSB, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Uint16 *dst = (Uint16 *) cvt->buf;\n    const Uint16 *src = (Uint16 *) cvt->buf;\n    const Uint16 *target = (const Uint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) SDL_SwapLE16(src[0]);\n    Sint32 last_sample1 = (Sint32) SDL_SwapLE16(src[1]);\n    Sint32 last_sample2 = (Sint32) SDL_SwapLE16(src[2]);\n    Sint32 last_sample3 = (Sint32) SDL_SwapLE16(src[3]);\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) SDL_SwapLE16(src[0]);\n        const Sint32 sample1 = (Sint32) SDL_SwapLE16(src[1]);\n        const Sint32 sample2 = (Sint32) SDL_SwapLE16(src[2]);\n        const Sint32 sample3 = (Sint32) SDL_SwapLE16(src[3]);\n        src += 16;\n        dst[0] = (Uint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Uint16) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Uint16) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Uint16) ((sample3 + last_sample3) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        dst += 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U16LSB_6c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_U16LSB, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Uint16 *dst = ((Uint16 *) (cvt->buf + dstsize)) - 6 * 2;\n    const Uint16 *src = ((Uint16 *) (cvt->buf + cvt->len_cvt)) - 6;\n    const Uint16 *target = ((const Uint16 *) cvt->buf);\n    Sint32 last_sample5 = (Sint32) SDL_SwapLE16(src[5]);\n    Sint32 last_sample4 = (Sint32) SDL_SwapLE16(src[4]);\n    Sint32 last_sample3 = (Sint32) SDL_SwapLE16(src[3]);\n    Sint32 last_sample2 = (Sint32) SDL_SwapLE16(src[2]);\n    Sint32 last_sample1 = (Sint32) SDL_SwapLE16(src[1]);\n    Sint32 last_sample0 = (Sint32) SDL_SwapLE16(src[0]);\n    while (dst >= target) {\n        const Sint32 sample5 = (Sint32) SDL_SwapLE16(src[5]);\n        const Sint32 sample4 = (Sint32) SDL_SwapLE16(src[4]);\n        const Sint32 sample3 = (Sint32) SDL_SwapLE16(src[3]);\n        const Sint32 sample2 = (Sint32) SDL_SwapLE16(src[2]);\n        const Sint32 sample1 = (Sint32) SDL_SwapLE16(src[1]);\n        const Sint32 sample0 = (Sint32) SDL_SwapLE16(src[0]);\n        src -= 6;\n        dst[11] = (Uint16) ((sample5 + last_sample5) >> 1);\n        dst[10] = (Uint16) ((sample4 + last_sample4) >> 1);\n        dst[9] = (Uint16) ((sample3 + last_sample3) >> 1);\n        dst[8] = (Uint16) ((sample2 + last_sample2) >> 1);\n        dst[7] = (Uint16) ((sample1 + last_sample1) >> 1);\n        dst[6] = (Uint16) ((sample0 + last_sample0) >> 1);\n        dst[5] = (Uint16) sample5;\n        dst[4] = (Uint16) sample4;\n        dst[3] = (Uint16) sample3;\n        dst[2] = (Uint16) sample2;\n        dst[1] = (Uint16) sample1;\n        dst[0] = (Uint16) sample0;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 12;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U16LSB_6c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_U16LSB, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Uint16 *dst = (Uint16 *) cvt->buf;\n    const Uint16 *src = (Uint16 *) cvt->buf;\n    const Uint16 *target = (const Uint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) SDL_SwapLE16(src[0]);\n    Sint32 last_sample1 = (Sint32) SDL_SwapLE16(src[1]);\n    Sint32 last_sample2 = (Sint32) SDL_SwapLE16(src[2]);\n    Sint32 last_sample3 = (Sint32) SDL_SwapLE16(src[3]);\n    Sint32 last_sample4 = (Sint32) SDL_SwapLE16(src[4]);\n    Sint32 last_sample5 = (Sint32) SDL_SwapLE16(src[5]);\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) SDL_SwapLE16(src[0]);\n        const Sint32 sample1 = (Sint32) SDL_SwapLE16(src[1]);\n        const Sint32 sample2 = (Sint32) SDL_SwapLE16(src[2]);\n        const Sint32 sample3 = (Sint32) SDL_SwapLE16(src[3]);\n        const Sint32 sample4 = (Sint32) SDL_SwapLE16(src[4]);\n        const Sint32 sample5 = (Sint32) SDL_SwapLE16(src[5]);\n        src += 12;\n        dst[0] = (Uint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Uint16) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Uint16) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Uint16) ((sample3 + last_sample3) >> 1);\n        dst[4] = (Uint16) ((sample4 + last_sample4) >> 1);\n        dst[5] = (Uint16) ((sample5 + last_sample5) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        dst += 6;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U16LSB_6c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_U16LSB, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Uint16 *dst = ((Uint16 *) (cvt->buf + dstsize)) - 6 * 4;\n    const Uint16 *src = ((Uint16 *) (cvt->buf + cvt->len_cvt)) - 6;\n    const Uint16 *target = ((const Uint16 *) cvt->buf);\n    Sint32 last_sample5 = (Sint32) SDL_SwapLE16(src[5]);\n    Sint32 last_sample4 = (Sint32) SDL_SwapLE16(src[4]);\n    Sint32 last_sample3 = (Sint32) SDL_SwapLE16(src[3]);\n    Sint32 last_sample2 = (Sint32) SDL_SwapLE16(src[2]);\n    Sint32 last_sample1 = (Sint32) SDL_SwapLE16(src[1]);\n    Sint32 last_sample0 = (Sint32) SDL_SwapLE16(src[0]);\n    while (dst >= target) {\n        const Sint32 sample5 = (Sint32) SDL_SwapLE16(src[5]);\n        const Sint32 sample4 = (Sint32) SDL_SwapLE16(src[4]);\n        const Sint32 sample3 = (Sint32) SDL_SwapLE16(src[3]);\n        const Sint32 sample2 = (Sint32) SDL_SwapLE16(src[2]);\n        const Sint32 sample1 = (Sint32) SDL_SwapLE16(src[1]);\n        const Sint32 sample0 = (Sint32) SDL_SwapLE16(src[0]);\n        src -= 6;\n        dst[23] = (Uint16) ((sample5 + (3 * last_sample5)) >> 2);\n        dst[22] = (Uint16) ((sample4 + (3 * last_sample4)) >> 2);\n        dst[21] = (Uint16) ((sample3 + (3 * last_sample3)) >> 2);\n        dst[20] = (Uint16) ((sample2 + (3 * last_sample2)) >> 2);\n        dst[19] = (Uint16) ((sample1 + (3 * last_sample1)) >> 2);\n        dst[18] = (Uint16) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[17] = (Uint16) ((sample5 + last_sample5) >> 1);\n        dst[16] = (Uint16) ((sample4 + last_sample4) >> 1);\n        dst[15] = (Uint16) ((sample3 + last_sample3) >> 1);\n        dst[14] = (Uint16) ((sample2 + last_sample2) >> 1);\n        dst[13] = (Uint16) ((sample1 + last_sample1) >> 1);\n        dst[12] = (Uint16) ((sample0 + last_sample0) >> 1);\n        dst[11] = (Uint16) (((3 * sample5) + last_sample5) >> 2);\n        dst[10] = (Uint16) (((3 * sample4) + last_sample4) >> 2);\n        dst[9] = (Uint16) (((3 * sample3) + last_sample3) >> 2);\n        dst[8] = (Uint16) (((3 * sample2) + last_sample2) >> 2);\n        dst[7] = (Uint16) (((3 * sample1) + last_sample1) >> 2);\n        dst[6] = (Uint16) (((3 * sample0) + last_sample0) >> 2);\n        dst[5] = (Uint16) sample5;\n        dst[4] = (Uint16) sample4;\n        dst[3] = (Uint16) sample3;\n        dst[2] = (Uint16) sample2;\n        dst[1] = (Uint16) sample1;\n        dst[0] = (Uint16) sample0;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 24;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U16LSB_6c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_U16LSB, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Uint16 *dst = (Uint16 *) cvt->buf;\n    const Uint16 *src = (Uint16 *) cvt->buf;\n    const Uint16 *target = (const Uint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) SDL_SwapLE16(src[0]);\n    Sint32 last_sample1 = (Sint32) SDL_SwapLE16(src[1]);\n    Sint32 last_sample2 = (Sint32) SDL_SwapLE16(src[2]);\n    Sint32 last_sample3 = (Sint32) SDL_SwapLE16(src[3]);\n    Sint32 last_sample4 = (Sint32) SDL_SwapLE16(src[4]);\n    Sint32 last_sample5 = (Sint32) SDL_SwapLE16(src[5]);\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) SDL_SwapLE16(src[0]);\n        const Sint32 sample1 = (Sint32) SDL_SwapLE16(src[1]);\n        const Sint32 sample2 = (Sint32) SDL_SwapLE16(src[2]);\n        const Sint32 sample3 = (Sint32) SDL_SwapLE16(src[3]);\n        const Sint32 sample4 = (Sint32) SDL_SwapLE16(src[4]);\n        const Sint32 sample5 = (Sint32) SDL_SwapLE16(src[5]);\n        src += 24;\n        dst[0] = (Uint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Uint16) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Uint16) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Uint16) ((sample3 + last_sample3) >> 1);\n        dst[4] = (Uint16) ((sample4 + last_sample4) >> 1);\n        dst[5] = (Uint16) ((sample5 + last_sample5) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        dst += 6;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U16LSB_8c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_U16LSB, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Uint16 *dst = ((Uint16 *) (cvt->buf + dstsize)) - 8 * 2;\n    const Uint16 *src = ((Uint16 *) (cvt->buf + cvt->len_cvt)) - 8;\n    const Uint16 *target = ((const Uint16 *) cvt->buf);\n    Sint32 last_sample7 = (Sint32) SDL_SwapLE16(src[7]);\n    Sint32 last_sample6 = (Sint32) SDL_SwapLE16(src[6]);\n    Sint32 last_sample5 = (Sint32) SDL_SwapLE16(src[5]);\n    Sint32 last_sample4 = (Sint32) SDL_SwapLE16(src[4]);\n    Sint32 last_sample3 = (Sint32) SDL_SwapLE16(src[3]);\n    Sint32 last_sample2 = (Sint32) SDL_SwapLE16(src[2]);\n    Sint32 last_sample1 = (Sint32) SDL_SwapLE16(src[1]);\n    Sint32 last_sample0 = (Sint32) SDL_SwapLE16(src[0]);\n    while (dst >= target) {\n        const Sint32 sample7 = (Sint32) SDL_SwapLE16(src[7]);\n        const Sint32 sample6 = (Sint32) SDL_SwapLE16(src[6]);\n        const Sint32 sample5 = (Sint32) SDL_SwapLE16(src[5]);\n        const Sint32 sample4 = (Sint32) SDL_SwapLE16(src[4]);\n        const Sint32 sample3 = (Sint32) SDL_SwapLE16(src[3]);\n        const Sint32 sample2 = (Sint32) SDL_SwapLE16(src[2]);\n        const Sint32 sample1 = (Sint32) SDL_SwapLE16(src[1]);\n        const Sint32 sample0 = (Sint32) SDL_SwapLE16(src[0]);\n        src -= 8;\n        dst[15] = (Uint16) ((sample7 + last_sample7) >> 1);\n        dst[14] = (Uint16) ((sample6 + last_sample6) >> 1);\n        dst[13] = (Uint16) ((sample5 + last_sample5) >> 1);\n        dst[12] = (Uint16) ((sample4 + last_sample4) >> 1);\n        dst[11] = (Uint16) ((sample3 + last_sample3) >> 1);\n        dst[10] = (Uint16) ((sample2 + last_sample2) >> 1);\n        dst[9] = (Uint16) ((sample1 + last_sample1) >> 1);\n        dst[8] = (Uint16) ((sample0 + last_sample0) >> 1);\n        dst[7] = (Uint16) sample7;\n        dst[6] = (Uint16) sample6;\n        dst[5] = (Uint16) sample5;\n        dst[4] = (Uint16) sample4;\n        dst[3] = (Uint16) sample3;\n        dst[2] = (Uint16) sample2;\n        dst[1] = (Uint16) sample1;\n        dst[0] = (Uint16) sample0;\n        last_sample7 = sample7;\n        last_sample6 = sample6;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 16;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U16LSB_8c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_U16LSB, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Uint16 *dst = (Uint16 *) cvt->buf;\n    const Uint16 *src = (Uint16 *) cvt->buf;\n    const Uint16 *target = (const Uint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) SDL_SwapLE16(src[0]);\n    Sint32 last_sample1 = (Sint32) SDL_SwapLE16(src[1]);\n    Sint32 last_sample2 = (Sint32) SDL_SwapLE16(src[2]);\n    Sint32 last_sample3 = (Sint32) SDL_SwapLE16(src[3]);\n    Sint32 last_sample4 = (Sint32) SDL_SwapLE16(src[4]);\n    Sint32 last_sample5 = (Sint32) SDL_SwapLE16(src[5]);\n    Sint32 last_sample6 = (Sint32) SDL_SwapLE16(src[6]);\n    Sint32 last_sample7 = (Sint32) SDL_SwapLE16(src[7]);\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) SDL_SwapLE16(src[0]);\n        const Sint32 sample1 = (Sint32) SDL_SwapLE16(src[1]);\n        const Sint32 sample2 = (Sint32) SDL_SwapLE16(src[2]);\n        const Sint32 sample3 = (Sint32) SDL_SwapLE16(src[3]);\n        const Sint32 sample4 = (Sint32) SDL_SwapLE16(src[4]);\n        const Sint32 sample5 = (Sint32) SDL_SwapLE16(src[5]);\n        const Sint32 sample6 = (Sint32) SDL_SwapLE16(src[6]);\n        const Sint32 sample7 = (Sint32) SDL_SwapLE16(src[7]);\n        src += 16;\n        dst[0] = (Uint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Uint16) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Uint16) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Uint16) ((sample3 + last_sample3) >> 1);\n        dst[4] = (Uint16) ((sample4 + last_sample4) >> 1);\n        dst[5] = (Uint16) ((sample5 + last_sample5) >> 1);\n        dst[6] = (Uint16) ((sample6 + last_sample6) >> 1);\n        dst[7] = (Uint16) ((sample7 + last_sample7) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        last_sample6 = sample6;\n        last_sample7 = sample7;\n        dst += 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U16LSB_8c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_U16LSB, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Uint16 *dst = ((Uint16 *) (cvt->buf + dstsize)) - 8 * 4;\n    const Uint16 *src = ((Uint16 *) (cvt->buf + cvt->len_cvt)) - 8;\n    const Uint16 *target = ((const Uint16 *) cvt->buf);\n    Sint32 last_sample7 = (Sint32) SDL_SwapLE16(src[7]);\n    Sint32 last_sample6 = (Sint32) SDL_SwapLE16(src[6]);\n    Sint32 last_sample5 = (Sint32) SDL_SwapLE16(src[5]);\n    Sint32 last_sample4 = (Sint32) SDL_SwapLE16(src[4]);\n    Sint32 last_sample3 = (Sint32) SDL_SwapLE16(src[3]);\n    Sint32 last_sample2 = (Sint32) SDL_SwapLE16(src[2]);\n    Sint32 last_sample1 = (Sint32) SDL_SwapLE16(src[1]);\n    Sint32 last_sample0 = (Sint32) SDL_SwapLE16(src[0]);\n    while (dst >= target) {\n        const Sint32 sample7 = (Sint32) SDL_SwapLE16(src[7]);\n        const Sint32 sample6 = (Sint32) SDL_SwapLE16(src[6]);\n        const Sint32 sample5 = (Sint32) SDL_SwapLE16(src[5]);\n        const Sint32 sample4 = (Sint32) SDL_SwapLE16(src[4]);\n        const Sint32 sample3 = (Sint32) SDL_SwapLE16(src[3]);\n        const Sint32 sample2 = (Sint32) SDL_SwapLE16(src[2]);\n        const Sint32 sample1 = (Sint32) SDL_SwapLE16(src[1]);\n        const Sint32 sample0 = (Sint32) SDL_SwapLE16(src[0]);\n        src -= 8;\n        dst[31] = (Uint16) ((sample7 + (3 * last_sample7)) >> 2);\n        dst[30] = (Uint16) ((sample6 + (3 * last_sample6)) >> 2);\n        dst[29] = (Uint16) ((sample5 + (3 * last_sample5)) >> 2);\n        dst[28] = (Uint16) ((sample4 + (3 * last_sample4)) >> 2);\n        dst[27] = (Uint16) ((sample3 + (3 * last_sample3)) >> 2);\n        dst[26] = (Uint16) ((sample2 + (3 * last_sample2)) >> 2);\n        dst[25] = (Uint16) ((sample1 + (3 * last_sample1)) >> 2);\n        dst[24] = (Uint16) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[23] = (Uint16) ((sample7 + last_sample7) >> 1);\n        dst[22] = (Uint16) ((sample6 + last_sample6) >> 1);\n        dst[21] = (Uint16) ((sample5 + last_sample5) >> 1);\n        dst[20] = (Uint16) ((sample4 + last_sample4) >> 1);\n        dst[19] = (Uint16) ((sample3 + last_sample3) >> 1);\n        dst[18] = (Uint16) ((sample2 + last_sample2) >> 1);\n        dst[17] = (Uint16) ((sample1 + last_sample1) >> 1);\n        dst[16] = (Uint16) ((sample0 + last_sample0) >> 1);\n        dst[15] = (Uint16) (((3 * sample7) + last_sample7) >> 2);\n        dst[14] = (Uint16) (((3 * sample6) + last_sample6) >> 2);\n        dst[13] = (Uint16) (((3 * sample5) + last_sample5) >> 2);\n        dst[12] = (Uint16) (((3 * sample4) + last_sample4) >> 2);\n        dst[11] = (Uint16) (((3 * sample3) + last_sample3) >> 2);\n        dst[10] = (Uint16) (((3 * sample2) + last_sample2) >> 2);\n        dst[9] = (Uint16) (((3 * sample1) + last_sample1) >> 2);\n        dst[8] = (Uint16) (((3 * sample0) + last_sample0) >> 2);\n        dst[7] = (Uint16) sample7;\n        dst[6] = (Uint16) sample6;\n        dst[5] = (Uint16) sample5;\n        dst[4] = (Uint16) sample4;\n        dst[3] = (Uint16) sample3;\n        dst[2] = (Uint16) sample2;\n        dst[1] = (Uint16) sample1;\n        dst[0] = (Uint16) sample0;\n        last_sample7 = sample7;\n        last_sample6 = sample6;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 32;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U16LSB_8c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_U16LSB, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Uint16 *dst = (Uint16 *) cvt->buf;\n    const Uint16 *src = (Uint16 *) cvt->buf;\n    const Uint16 *target = (const Uint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) SDL_SwapLE16(src[0]);\n    Sint32 last_sample1 = (Sint32) SDL_SwapLE16(src[1]);\n    Sint32 last_sample2 = (Sint32) SDL_SwapLE16(src[2]);\n    Sint32 last_sample3 = (Sint32) SDL_SwapLE16(src[3]);\n    Sint32 last_sample4 = (Sint32) SDL_SwapLE16(src[4]);\n    Sint32 last_sample5 = (Sint32) SDL_SwapLE16(src[5]);\n    Sint32 last_sample6 = (Sint32) SDL_SwapLE16(src[6]);\n    Sint32 last_sample7 = (Sint32) SDL_SwapLE16(src[7]);\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) SDL_SwapLE16(src[0]);\n        const Sint32 sample1 = (Sint32) SDL_SwapLE16(src[1]);\n        const Sint32 sample2 = (Sint32) SDL_SwapLE16(src[2]);\n        const Sint32 sample3 = (Sint32) SDL_SwapLE16(src[3]);\n        const Sint32 sample4 = (Sint32) SDL_SwapLE16(src[4]);\n        const Sint32 sample5 = (Sint32) SDL_SwapLE16(src[5]);\n        const Sint32 sample6 = (Sint32) SDL_SwapLE16(src[6]);\n        const Sint32 sample7 = (Sint32) SDL_SwapLE16(src[7]);\n        src += 32;\n        dst[0] = (Uint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Uint16) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Uint16) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Uint16) ((sample3 + last_sample3) >> 1);\n        dst[4] = (Uint16) ((sample4 + last_sample4) >> 1);\n        dst[5] = (Uint16) ((sample5 + last_sample5) >> 1);\n        dst[6] = (Uint16) ((sample6 + last_sample6) >> 1);\n        dst[7] = (Uint16) ((sample7 + last_sample7) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        last_sample6 = sample6;\n        last_sample7 = sample7;\n        dst += 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S16LSB_1c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_S16LSB, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Sint16 *dst = ((Sint16 *) (cvt->buf + dstsize)) - 1 * 2;\n    const Sint16 *src = ((Sint16 *) (cvt->buf + cvt->len_cvt)) - 1;\n    const Sint16 *target = ((const Sint16 *) cvt->buf);\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n    while (dst >= target) {\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n        src--;\n        dst[1] = (Sint16) ((sample0 + last_sample0) >> 1);\n        dst[0] = (Sint16) sample0;\n        last_sample0 = sample0;\n        dst -= 2;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S16LSB_1c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_S16LSB, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Sint16 *dst = (Sint16 *) cvt->buf;\n    const Sint16 *src = (Sint16 *) cvt->buf;\n    const Sint16 *target = (const Sint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n        src += 2;\n        dst[0] = (Sint16) ((sample0 + last_sample0) >> 1);\n        last_sample0 = sample0;\n        dst++;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S16LSB_1c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_S16LSB, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Sint16 *dst = ((Sint16 *) (cvt->buf + dstsize)) - 1 * 4;\n    const Sint16 *src = ((Sint16 *) (cvt->buf + cvt->len_cvt)) - 1;\n    const Sint16 *target = ((const Sint16 *) cvt->buf);\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n    while (dst >= target) {\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n        src--;\n        dst[3] = (Sint16) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[2] = (Sint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint16) (((3 * sample0) + last_sample0) >> 2);\n        dst[0] = (Sint16) sample0;\n        last_sample0 = sample0;\n        dst -= 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S16LSB_1c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_S16LSB, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Sint16 *dst = (Sint16 *) cvt->buf;\n    const Sint16 *src = (Sint16 *) cvt->buf;\n    const Sint16 *target = (const Sint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n        src += 4;\n        dst[0] = (Sint16) ((sample0 + last_sample0) >> 1);\n        last_sample0 = sample0;\n        dst++;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S16LSB_2c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_S16LSB, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Sint16 *dst = ((Sint16 *) (cvt->buf + dstsize)) - 2 * 2;\n    const Sint16 *src = ((Sint16 *) (cvt->buf + cvt->len_cvt)) - 2;\n    const Sint16 *target = ((const Sint16 *) cvt->buf);\n    Sint32 last_sample1 = (Sint32) ((Sint16) SDL_SwapLE16(src[1]));\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n    while (dst >= target) {\n        const Sint32 sample1 = (Sint32) ((Sint16) SDL_SwapLE16(src[1]));\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n        src -= 2;\n        dst[3] = (Sint16) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Sint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint16) sample1;\n        dst[0] = (Sint16) sample0;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S16LSB_2c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_S16LSB, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Sint16 *dst = (Sint16 *) cvt->buf;\n    const Sint16 *src = (Sint16 *) cvt->buf;\n    const Sint16 *target = (const Sint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n    Sint32 last_sample1 = (Sint32) ((Sint16) SDL_SwapLE16(src[1]));\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n        const Sint32 sample1 = (Sint32) ((Sint16) SDL_SwapLE16(src[1]));\n        src += 4;\n        dst[0] = (Sint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint16) ((sample1 + last_sample1) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        dst += 2;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S16LSB_2c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_S16LSB, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Sint16 *dst = ((Sint16 *) (cvt->buf + dstsize)) - 2 * 4;\n    const Sint16 *src = ((Sint16 *) (cvt->buf + cvt->len_cvt)) - 2;\n    const Sint16 *target = ((const Sint16 *) cvt->buf);\n    Sint32 last_sample1 = (Sint32) ((Sint16) SDL_SwapLE16(src[1]));\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n    while (dst >= target) {\n        const Sint32 sample1 = (Sint32) ((Sint16) SDL_SwapLE16(src[1]));\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n        src -= 2;\n        dst[7] = (Sint16) ((sample1 + (3 * last_sample1)) >> 2);\n        dst[6] = (Sint16) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[5] = (Sint16) ((sample1 + last_sample1) >> 1);\n        dst[4] = (Sint16) ((sample0 + last_sample0) >> 1);\n        dst[3] = (Sint16) (((3 * sample1) + last_sample1) >> 2);\n        dst[2] = (Sint16) (((3 * sample0) + last_sample0) >> 2);\n        dst[1] = (Sint16) sample1;\n        dst[0] = (Sint16) sample0;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S16LSB_2c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_S16LSB, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Sint16 *dst = (Sint16 *) cvt->buf;\n    const Sint16 *src = (Sint16 *) cvt->buf;\n    const Sint16 *target = (const Sint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n    Sint32 last_sample1 = (Sint32) ((Sint16) SDL_SwapLE16(src[1]));\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n        const Sint32 sample1 = (Sint32) ((Sint16) SDL_SwapLE16(src[1]));\n        src += 8;\n        dst[0] = (Sint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint16) ((sample1 + last_sample1) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        dst += 2;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S16LSB_4c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_S16LSB, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Sint16 *dst = ((Sint16 *) (cvt->buf + dstsize)) - 4 * 2;\n    const Sint16 *src = ((Sint16 *) (cvt->buf + cvt->len_cvt)) - 4;\n    const Sint16 *target = ((const Sint16 *) cvt->buf);\n    Sint32 last_sample3 = (Sint32) ((Sint16) SDL_SwapLE16(src[3]));\n    Sint32 last_sample2 = (Sint32) ((Sint16) SDL_SwapLE16(src[2]));\n    Sint32 last_sample1 = (Sint32) ((Sint16) SDL_SwapLE16(src[1]));\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n    while (dst >= target) {\n        const Sint32 sample3 = (Sint32) ((Sint16) SDL_SwapLE16(src[3]));\n        const Sint32 sample2 = (Sint32) ((Sint16) SDL_SwapLE16(src[2]));\n        const Sint32 sample1 = (Sint32) ((Sint16) SDL_SwapLE16(src[1]));\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n        src -= 4;\n        dst[7] = (Sint16) ((sample3 + last_sample3) >> 1);\n        dst[6] = (Sint16) ((sample2 + last_sample2) >> 1);\n        dst[5] = (Sint16) ((sample1 + last_sample1) >> 1);\n        dst[4] = (Sint16) ((sample0 + last_sample0) >> 1);\n        dst[3] = (Sint16) sample3;\n        dst[2] = (Sint16) sample2;\n        dst[1] = (Sint16) sample1;\n        dst[0] = (Sint16) sample0;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S16LSB_4c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_S16LSB, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Sint16 *dst = (Sint16 *) cvt->buf;\n    const Sint16 *src = (Sint16 *) cvt->buf;\n    const Sint16 *target = (const Sint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n    Sint32 last_sample1 = (Sint32) ((Sint16) SDL_SwapLE16(src[1]));\n    Sint32 last_sample2 = (Sint32) ((Sint16) SDL_SwapLE16(src[2]));\n    Sint32 last_sample3 = (Sint32) ((Sint16) SDL_SwapLE16(src[3]));\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n        const Sint32 sample1 = (Sint32) ((Sint16) SDL_SwapLE16(src[1]));\n        const Sint32 sample2 = (Sint32) ((Sint16) SDL_SwapLE16(src[2]));\n        const Sint32 sample3 = (Sint32) ((Sint16) SDL_SwapLE16(src[3]));\n        src += 8;\n        dst[0] = (Sint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint16) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Sint16) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Sint16) ((sample3 + last_sample3) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        dst += 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S16LSB_4c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_S16LSB, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Sint16 *dst = ((Sint16 *) (cvt->buf + dstsize)) - 4 * 4;\n    const Sint16 *src = ((Sint16 *) (cvt->buf + cvt->len_cvt)) - 4;\n    const Sint16 *target = ((const Sint16 *) cvt->buf);\n    Sint32 last_sample3 = (Sint32) ((Sint16) SDL_SwapLE16(src[3]));\n    Sint32 last_sample2 = (Sint32) ((Sint16) SDL_SwapLE16(src[2]));\n    Sint32 last_sample1 = (Sint32) ((Sint16) SDL_SwapLE16(src[1]));\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n    while (dst >= target) {\n        const Sint32 sample3 = (Sint32) ((Sint16) SDL_SwapLE16(src[3]));\n        const Sint32 sample2 = (Sint32) ((Sint16) SDL_SwapLE16(src[2]));\n        const Sint32 sample1 = (Sint32) ((Sint16) SDL_SwapLE16(src[1]));\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n        src -= 4;\n        dst[15] = (Sint16) ((sample3 + (3 * last_sample3)) >> 2);\n        dst[14] = (Sint16) ((sample2 + (3 * last_sample2)) >> 2);\n        dst[13] = (Sint16) ((sample1 + (3 * last_sample1)) >> 2);\n        dst[12] = (Sint16) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[11] = (Sint16) ((sample3 + last_sample3) >> 1);\n        dst[10] = (Sint16) ((sample2 + last_sample2) >> 1);\n        dst[9] = (Sint16) ((sample1 + last_sample1) >> 1);\n        dst[8] = (Sint16) ((sample0 + last_sample0) >> 1);\n        dst[7] = (Sint16) (((3 * sample3) + last_sample3) >> 2);\n        dst[6] = (Sint16) (((3 * sample2) + last_sample2) >> 2);\n        dst[5] = (Sint16) (((3 * sample1) + last_sample1) >> 2);\n        dst[4] = (Sint16) (((3 * sample0) + last_sample0) >> 2);\n        dst[3] = (Sint16) sample3;\n        dst[2] = (Sint16) sample2;\n        dst[1] = (Sint16) sample1;\n        dst[0] = (Sint16) sample0;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 16;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S16LSB_4c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_S16LSB, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Sint16 *dst = (Sint16 *) cvt->buf;\n    const Sint16 *src = (Sint16 *) cvt->buf;\n    const Sint16 *target = (const Sint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n    Sint32 last_sample1 = (Sint32) ((Sint16) SDL_SwapLE16(src[1]));\n    Sint32 last_sample2 = (Sint32) ((Sint16) SDL_SwapLE16(src[2]));\n    Sint32 last_sample3 = (Sint32) ((Sint16) SDL_SwapLE16(src[3]));\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n        const Sint32 sample1 = (Sint32) ((Sint16) SDL_SwapLE16(src[1]));\n        const Sint32 sample2 = (Sint32) ((Sint16) SDL_SwapLE16(src[2]));\n        const Sint32 sample3 = (Sint32) ((Sint16) SDL_SwapLE16(src[3]));\n        src += 16;\n        dst[0] = (Sint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint16) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Sint16) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Sint16) ((sample3 + last_sample3) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        dst += 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S16LSB_6c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_S16LSB, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Sint16 *dst = ((Sint16 *) (cvt->buf + dstsize)) - 6 * 2;\n    const Sint16 *src = ((Sint16 *) (cvt->buf + cvt->len_cvt)) - 6;\n    const Sint16 *target = ((const Sint16 *) cvt->buf);\n    Sint32 last_sample5 = (Sint32) ((Sint16) SDL_SwapLE16(src[5]));\n    Sint32 last_sample4 = (Sint32) ((Sint16) SDL_SwapLE16(src[4]));\n    Sint32 last_sample3 = (Sint32) ((Sint16) SDL_SwapLE16(src[3]));\n    Sint32 last_sample2 = (Sint32) ((Sint16) SDL_SwapLE16(src[2]));\n    Sint32 last_sample1 = (Sint32) ((Sint16) SDL_SwapLE16(src[1]));\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n    while (dst >= target) {\n        const Sint32 sample5 = (Sint32) ((Sint16) SDL_SwapLE16(src[5]));\n        const Sint32 sample4 = (Sint32) ((Sint16) SDL_SwapLE16(src[4]));\n        const Sint32 sample3 = (Sint32) ((Sint16) SDL_SwapLE16(src[3]));\n        const Sint32 sample2 = (Sint32) ((Sint16) SDL_SwapLE16(src[2]));\n        const Sint32 sample1 = (Sint32) ((Sint16) SDL_SwapLE16(src[1]));\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n        src -= 6;\n        dst[11] = (Sint16) ((sample5 + last_sample5) >> 1);\n        dst[10] = (Sint16) ((sample4 + last_sample4) >> 1);\n        dst[9] = (Sint16) ((sample3 + last_sample3) >> 1);\n        dst[8] = (Sint16) ((sample2 + last_sample2) >> 1);\n        dst[7] = (Sint16) ((sample1 + last_sample1) >> 1);\n        dst[6] = (Sint16) ((sample0 + last_sample0) >> 1);\n        dst[5] = (Sint16) sample5;\n        dst[4] = (Sint16) sample4;\n        dst[3] = (Sint16) sample3;\n        dst[2] = (Sint16) sample2;\n        dst[1] = (Sint16) sample1;\n        dst[0] = (Sint16) sample0;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 12;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S16LSB_6c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_S16LSB, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Sint16 *dst = (Sint16 *) cvt->buf;\n    const Sint16 *src = (Sint16 *) cvt->buf;\n    const Sint16 *target = (const Sint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n    Sint32 last_sample1 = (Sint32) ((Sint16) SDL_SwapLE16(src[1]));\n    Sint32 last_sample2 = (Sint32) ((Sint16) SDL_SwapLE16(src[2]));\n    Sint32 last_sample3 = (Sint32) ((Sint16) SDL_SwapLE16(src[3]));\n    Sint32 last_sample4 = (Sint32) ((Sint16) SDL_SwapLE16(src[4]));\n    Sint32 last_sample5 = (Sint32) ((Sint16) SDL_SwapLE16(src[5]));\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n        const Sint32 sample1 = (Sint32) ((Sint16) SDL_SwapLE16(src[1]));\n        const Sint32 sample2 = (Sint32) ((Sint16) SDL_SwapLE16(src[2]));\n        const Sint32 sample3 = (Sint32) ((Sint16) SDL_SwapLE16(src[3]));\n        const Sint32 sample4 = (Sint32) ((Sint16) SDL_SwapLE16(src[4]));\n        const Sint32 sample5 = (Sint32) ((Sint16) SDL_SwapLE16(src[5]));\n        src += 12;\n        dst[0] = (Sint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint16) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Sint16) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Sint16) ((sample3 + last_sample3) >> 1);\n        dst[4] = (Sint16) ((sample4 + last_sample4) >> 1);\n        dst[5] = (Sint16) ((sample5 + last_sample5) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        dst += 6;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S16LSB_6c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_S16LSB, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Sint16 *dst = ((Sint16 *) (cvt->buf + dstsize)) - 6 * 4;\n    const Sint16 *src = ((Sint16 *) (cvt->buf + cvt->len_cvt)) - 6;\n    const Sint16 *target = ((const Sint16 *) cvt->buf);\n    Sint32 last_sample5 = (Sint32) ((Sint16) SDL_SwapLE16(src[5]));\n    Sint32 last_sample4 = (Sint32) ((Sint16) SDL_SwapLE16(src[4]));\n    Sint32 last_sample3 = (Sint32) ((Sint16) SDL_SwapLE16(src[3]));\n    Sint32 last_sample2 = (Sint32) ((Sint16) SDL_SwapLE16(src[2]));\n    Sint32 last_sample1 = (Sint32) ((Sint16) SDL_SwapLE16(src[1]));\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n    while (dst >= target) {\n        const Sint32 sample5 = (Sint32) ((Sint16) SDL_SwapLE16(src[5]));\n        const Sint32 sample4 = (Sint32) ((Sint16) SDL_SwapLE16(src[4]));\n        const Sint32 sample3 = (Sint32) ((Sint16) SDL_SwapLE16(src[3]));\n        const Sint32 sample2 = (Sint32) ((Sint16) SDL_SwapLE16(src[2]));\n        const Sint32 sample1 = (Sint32) ((Sint16) SDL_SwapLE16(src[1]));\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n        src -= 6;\n        dst[23] = (Sint16) ((sample5 + (3 * last_sample5)) >> 2);\n        dst[22] = (Sint16) ((sample4 + (3 * last_sample4)) >> 2);\n        dst[21] = (Sint16) ((sample3 + (3 * last_sample3)) >> 2);\n        dst[20] = (Sint16) ((sample2 + (3 * last_sample2)) >> 2);\n        dst[19] = (Sint16) ((sample1 + (3 * last_sample1)) >> 2);\n        dst[18] = (Sint16) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[17] = (Sint16) ((sample5 + last_sample5) >> 1);\n        dst[16] = (Sint16) ((sample4 + last_sample4) >> 1);\n        dst[15] = (Sint16) ((sample3 + last_sample3) >> 1);\n        dst[14] = (Sint16) ((sample2 + last_sample2) >> 1);\n        dst[13] = (Sint16) ((sample1 + last_sample1) >> 1);\n        dst[12] = (Sint16) ((sample0 + last_sample0) >> 1);\n        dst[11] = (Sint16) (((3 * sample5) + last_sample5) >> 2);\n        dst[10] = (Sint16) (((3 * sample4) + last_sample4) >> 2);\n        dst[9] = (Sint16) (((3 * sample3) + last_sample3) >> 2);\n        dst[8] = (Sint16) (((3 * sample2) + last_sample2) >> 2);\n        dst[7] = (Sint16) (((3 * sample1) + last_sample1) >> 2);\n        dst[6] = (Sint16) (((3 * sample0) + last_sample0) >> 2);\n        dst[5] = (Sint16) sample5;\n        dst[4] = (Sint16) sample4;\n        dst[3] = (Sint16) sample3;\n        dst[2] = (Sint16) sample2;\n        dst[1] = (Sint16) sample1;\n        dst[0] = (Sint16) sample0;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 24;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S16LSB_6c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_S16LSB, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Sint16 *dst = (Sint16 *) cvt->buf;\n    const Sint16 *src = (Sint16 *) cvt->buf;\n    const Sint16 *target = (const Sint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n    Sint32 last_sample1 = (Sint32) ((Sint16) SDL_SwapLE16(src[1]));\n    Sint32 last_sample2 = (Sint32) ((Sint16) SDL_SwapLE16(src[2]));\n    Sint32 last_sample3 = (Sint32) ((Sint16) SDL_SwapLE16(src[3]));\n    Sint32 last_sample4 = (Sint32) ((Sint16) SDL_SwapLE16(src[4]));\n    Sint32 last_sample5 = (Sint32) ((Sint16) SDL_SwapLE16(src[5]));\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n        const Sint32 sample1 = (Sint32) ((Sint16) SDL_SwapLE16(src[1]));\n        const Sint32 sample2 = (Sint32) ((Sint16) SDL_SwapLE16(src[2]));\n        const Sint32 sample3 = (Sint32) ((Sint16) SDL_SwapLE16(src[3]));\n        const Sint32 sample4 = (Sint32) ((Sint16) SDL_SwapLE16(src[4]));\n        const Sint32 sample5 = (Sint32) ((Sint16) SDL_SwapLE16(src[5]));\n        src += 24;\n        dst[0] = (Sint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint16) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Sint16) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Sint16) ((sample3 + last_sample3) >> 1);\n        dst[4] = (Sint16) ((sample4 + last_sample4) >> 1);\n        dst[5] = (Sint16) ((sample5 + last_sample5) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        dst += 6;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S16LSB_8c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_S16LSB, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Sint16 *dst = ((Sint16 *) (cvt->buf + dstsize)) - 8 * 2;\n    const Sint16 *src = ((Sint16 *) (cvt->buf + cvt->len_cvt)) - 8;\n    const Sint16 *target = ((const Sint16 *) cvt->buf);\n    Sint32 last_sample7 = (Sint32) ((Sint16) SDL_SwapLE16(src[7]));\n    Sint32 last_sample6 = (Sint32) ((Sint16) SDL_SwapLE16(src[6]));\n    Sint32 last_sample5 = (Sint32) ((Sint16) SDL_SwapLE16(src[5]));\n    Sint32 last_sample4 = (Sint32) ((Sint16) SDL_SwapLE16(src[4]));\n    Sint32 last_sample3 = (Sint32) ((Sint16) SDL_SwapLE16(src[3]));\n    Sint32 last_sample2 = (Sint32) ((Sint16) SDL_SwapLE16(src[2]));\n    Sint32 last_sample1 = (Sint32) ((Sint16) SDL_SwapLE16(src[1]));\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n    while (dst >= target) {\n        const Sint32 sample7 = (Sint32) ((Sint16) SDL_SwapLE16(src[7]));\n        const Sint32 sample6 = (Sint32) ((Sint16) SDL_SwapLE16(src[6]));\n        const Sint32 sample5 = (Sint32) ((Sint16) SDL_SwapLE16(src[5]));\n        const Sint32 sample4 = (Sint32) ((Sint16) SDL_SwapLE16(src[4]));\n        const Sint32 sample3 = (Sint32) ((Sint16) SDL_SwapLE16(src[3]));\n        const Sint32 sample2 = (Sint32) ((Sint16) SDL_SwapLE16(src[2]));\n        const Sint32 sample1 = (Sint32) ((Sint16) SDL_SwapLE16(src[1]));\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n        src -= 8;\n        dst[15] = (Sint16) ((sample7 + last_sample7) >> 1);\n        dst[14] = (Sint16) ((sample6 + last_sample6) >> 1);\n        dst[13] = (Sint16) ((sample5 + last_sample5) >> 1);\n        dst[12] = (Sint16) ((sample4 + last_sample4) >> 1);\n        dst[11] = (Sint16) ((sample3 + last_sample3) >> 1);\n        dst[10] = (Sint16) ((sample2 + last_sample2) >> 1);\n        dst[9] = (Sint16) ((sample1 + last_sample1) >> 1);\n        dst[8] = (Sint16) ((sample0 + last_sample0) >> 1);\n        dst[7] = (Sint16) sample7;\n        dst[6] = (Sint16) sample6;\n        dst[5] = (Sint16) sample5;\n        dst[4] = (Sint16) sample4;\n        dst[3] = (Sint16) sample3;\n        dst[2] = (Sint16) sample2;\n        dst[1] = (Sint16) sample1;\n        dst[0] = (Sint16) sample0;\n        last_sample7 = sample7;\n        last_sample6 = sample6;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 16;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S16LSB_8c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_S16LSB, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Sint16 *dst = (Sint16 *) cvt->buf;\n    const Sint16 *src = (Sint16 *) cvt->buf;\n    const Sint16 *target = (const Sint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n    Sint32 last_sample1 = (Sint32) ((Sint16) SDL_SwapLE16(src[1]));\n    Sint32 last_sample2 = (Sint32) ((Sint16) SDL_SwapLE16(src[2]));\n    Sint32 last_sample3 = (Sint32) ((Sint16) SDL_SwapLE16(src[3]));\n    Sint32 last_sample4 = (Sint32) ((Sint16) SDL_SwapLE16(src[4]));\n    Sint32 last_sample5 = (Sint32) ((Sint16) SDL_SwapLE16(src[5]));\n    Sint32 last_sample6 = (Sint32) ((Sint16) SDL_SwapLE16(src[6]));\n    Sint32 last_sample7 = (Sint32) ((Sint16) SDL_SwapLE16(src[7]));\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n        const Sint32 sample1 = (Sint32) ((Sint16) SDL_SwapLE16(src[1]));\n        const Sint32 sample2 = (Sint32) ((Sint16) SDL_SwapLE16(src[2]));\n        const Sint32 sample3 = (Sint32) ((Sint16) SDL_SwapLE16(src[3]));\n        const Sint32 sample4 = (Sint32) ((Sint16) SDL_SwapLE16(src[4]));\n        const Sint32 sample5 = (Sint32) ((Sint16) SDL_SwapLE16(src[5]));\n        const Sint32 sample6 = (Sint32) ((Sint16) SDL_SwapLE16(src[6]));\n        const Sint32 sample7 = (Sint32) ((Sint16) SDL_SwapLE16(src[7]));\n        src += 16;\n        dst[0] = (Sint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint16) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Sint16) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Sint16) ((sample3 + last_sample3) >> 1);\n        dst[4] = (Sint16) ((sample4 + last_sample4) >> 1);\n        dst[5] = (Sint16) ((sample5 + last_sample5) >> 1);\n        dst[6] = (Sint16) ((sample6 + last_sample6) >> 1);\n        dst[7] = (Sint16) ((sample7 + last_sample7) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        last_sample6 = sample6;\n        last_sample7 = sample7;\n        dst += 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S16LSB_8c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_S16LSB, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Sint16 *dst = ((Sint16 *) (cvt->buf + dstsize)) - 8 * 4;\n    const Sint16 *src = ((Sint16 *) (cvt->buf + cvt->len_cvt)) - 8;\n    const Sint16 *target = ((const Sint16 *) cvt->buf);\n    Sint32 last_sample7 = (Sint32) ((Sint16) SDL_SwapLE16(src[7]));\n    Sint32 last_sample6 = (Sint32) ((Sint16) SDL_SwapLE16(src[6]));\n    Sint32 last_sample5 = (Sint32) ((Sint16) SDL_SwapLE16(src[5]));\n    Sint32 last_sample4 = (Sint32) ((Sint16) SDL_SwapLE16(src[4]));\n    Sint32 last_sample3 = (Sint32) ((Sint16) SDL_SwapLE16(src[3]));\n    Sint32 last_sample2 = (Sint32) ((Sint16) SDL_SwapLE16(src[2]));\n    Sint32 last_sample1 = (Sint32) ((Sint16) SDL_SwapLE16(src[1]));\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n    while (dst >= target) {\n        const Sint32 sample7 = (Sint32) ((Sint16) SDL_SwapLE16(src[7]));\n        const Sint32 sample6 = (Sint32) ((Sint16) SDL_SwapLE16(src[6]));\n        const Sint32 sample5 = (Sint32) ((Sint16) SDL_SwapLE16(src[5]));\n        const Sint32 sample4 = (Sint32) ((Sint16) SDL_SwapLE16(src[4]));\n        const Sint32 sample3 = (Sint32) ((Sint16) SDL_SwapLE16(src[3]));\n        const Sint32 sample2 = (Sint32) ((Sint16) SDL_SwapLE16(src[2]));\n        const Sint32 sample1 = (Sint32) ((Sint16) SDL_SwapLE16(src[1]));\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n        src -= 8;\n        dst[31] = (Sint16) ((sample7 + (3 * last_sample7)) >> 2);\n        dst[30] = (Sint16) ((sample6 + (3 * last_sample6)) >> 2);\n        dst[29] = (Sint16) ((sample5 + (3 * last_sample5)) >> 2);\n        dst[28] = (Sint16) ((sample4 + (3 * last_sample4)) >> 2);\n        dst[27] = (Sint16) ((sample3 + (3 * last_sample3)) >> 2);\n        dst[26] = (Sint16) ((sample2 + (3 * last_sample2)) >> 2);\n        dst[25] = (Sint16) ((sample1 + (3 * last_sample1)) >> 2);\n        dst[24] = (Sint16) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[23] = (Sint16) ((sample7 + last_sample7) >> 1);\n        dst[22] = (Sint16) ((sample6 + last_sample6) >> 1);\n        dst[21] = (Sint16) ((sample5 + last_sample5) >> 1);\n        dst[20] = (Sint16) ((sample4 + last_sample4) >> 1);\n        dst[19] = (Sint16) ((sample3 + last_sample3) >> 1);\n        dst[18] = (Sint16) ((sample2 + last_sample2) >> 1);\n        dst[17] = (Sint16) ((sample1 + last_sample1) >> 1);\n        dst[16] = (Sint16) ((sample0 + last_sample0) >> 1);\n        dst[15] = (Sint16) (((3 * sample7) + last_sample7) >> 2);\n        dst[14] = (Sint16) (((3 * sample6) + last_sample6) >> 2);\n        dst[13] = (Sint16) (((3 * sample5) + last_sample5) >> 2);\n        dst[12] = (Sint16) (((3 * sample4) + last_sample4) >> 2);\n        dst[11] = (Sint16) (((3 * sample3) + last_sample3) >> 2);\n        dst[10] = (Sint16) (((3 * sample2) + last_sample2) >> 2);\n        dst[9] = (Sint16) (((3 * sample1) + last_sample1) >> 2);\n        dst[8] = (Sint16) (((3 * sample0) + last_sample0) >> 2);\n        dst[7] = (Sint16) sample7;\n        dst[6] = (Sint16) sample6;\n        dst[5] = (Sint16) sample5;\n        dst[4] = (Sint16) sample4;\n        dst[3] = (Sint16) sample3;\n        dst[2] = (Sint16) sample2;\n        dst[1] = (Sint16) sample1;\n        dst[0] = (Sint16) sample0;\n        last_sample7 = sample7;\n        last_sample6 = sample6;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 32;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S16LSB_8c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_S16LSB, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Sint16 *dst = (Sint16 *) cvt->buf;\n    const Sint16 *src = (Sint16 *) cvt->buf;\n    const Sint16 *target = (const Sint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n    Sint32 last_sample1 = (Sint32) ((Sint16) SDL_SwapLE16(src[1]));\n    Sint32 last_sample2 = (Sint32) ((Sint16) SDL_SwapLE16(src[2]));\n    Sint32 last_sample3 = (Sint32) ((Sint16) SDL_SwapLE16(src[3]));\n    Sint32 last_sample4 = (Sint32) ((Sint16) SDL_SwapLE16(src[4]));\n    Sint32 last_sample5 = (Sint32) ((Sint16) SDL_SwapLE16(src[5]));\n    Sint32 last_sample6 = (Sint32) ((Sint16) SDL_SwapLE16(src[6]));\n    Sint32 last_sample7 = (Sint32) ((Sint16) SDL_SwapLE16(src[7]));\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapLE16(src[0]));\n        const Sint32 sample1 = (Sint32) ((Sint16) SDL_SwapLE16(src[1]));\n        const Sint32 sample2 = (Sint32) ((Sint16) SDL_SwapLE16(src[2]));\n        const Sint32 sample3 = (Sint32) ((Sint16) SDL_SwapLE16(src[3]));\n        const Sint32 sample4 = (Sint32) ((Sint16) SDL_SwapLE16(src[4]));\n        const Sint32 sample5 = (Sint32) ((Sint16) SDL_SwapLE16(src[5]));\n        const Sint32 sample6 = (Sint32) ((Sint16) SDL_SwapLE16(src[6]));\n        const Sint32 sample7 = (Sint32) ((Sint16) SDL_SwapLE16(src[7]));\n        src += 32;\n        dst[0] = (Sint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint16) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Sint16) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Sint16) ((sample3 + last_sample3) >> 1);\n        dst[4] = (Sint16) ((sample4 + last_sample4) >> 1);\n        dst[5] = (Sint16) ((sample5 + last_sample5) >> 1);\n        dst[6] = (Sint16) ((sample6 + last_sample6) >> 1);\n        dst[7] = (Sint16) ((sample7 + last_sample7) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        last_sample6 = sample6;\n        last_sample7 = sample7;\n        dst += 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U16MSB_1c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_U16MSB, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Uint16 *dst = ((Uint16 *) (cvt->buf + dstsize)) - 1 * 2;\n    const Uint16 *src = ((Uint16 *) (cvt->buf + cvt->len_cvt)) - 1;\n    const Uint16 *target = ((const Uint16 *) cvt->buf);\n    Sint32 last_sample0 = (Sint32) SDL_SwapBE16(src[0]);\n    while (dst >= target) {\n        const Sint32 sample0 = (Sint32) SDL_SwapBE16(src[0]);\n        src--;\n        dst[1] = (Uint16) ((sample0 + last_sample0) >> 1);\n        dst[0] = (Uint16) sample0;\n        last_sample0 = sample0;\n        dst -= 2;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U16MSB_1c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_U16MSB, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Uint16 *dst = (Uint16 *) cvt->buf;\n    const Uint16 *src = (Uint16 *) cvt->buf;\n    const Uint16 *target = (const Uint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) SDL_SwapBE16(src[0]);\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) SDL_SwapBE16(src[0]);\n        src += 2;\n        dst[0] = (Uint16) ((sample0 + last_sample0) >> 1);\n        last_sample0 = sample0;\n        dst++;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U16MSB_1c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_U16MSB, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Uint16 *dst = ((Uint16 *) (cvt->buf + dstsize)) - 1 * 4;\n    const Uint16 *src = ((Uint16 *) (cvt->buf + cvt->len_cvt)) - 1;\n    const Uint16 *target = ((const Uint16 *) cvt->buf);\n    Sint32 last_sample0 = (Sint32) SDL_SwapBE16(src[0]);\n    while (dst >= target) {\n        const Sint32 sample0 = (Sint32) SDL_SwapBE16(src[0]);\n        src--;\n        dst[3] = (Uint16) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[2] = (Uint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Uint16) (((3 * sample0) + last_sample0) >> 2);\n        dst[0] = (Uint16) sample0;\n        last_sample0 = sample0;\n        dst -= 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U16MSB_1c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_U16MSB, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Uint16 *dst = (Uint16 *) cvt->buf;\n    const Uint16 *src = (Uint16 *) cvt->buf;\n    const Uint16 *target = (const Uint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) SDL_SwapBE16(src[0]);\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) SDL_SwapBE16(src[0]);\n        src += 4;\n        dst[0] = (Uint16) ((sample0 + last_sample0) >> 1);\n        last_sample0 = sample0;\n        dst++;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U16MSB_2c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_U16MSB, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Uint16 *dst = ((Uint16 *) (cvt->buf + dstsize)) - 2 * 2;\n    const Uint16 *src = ((Uint16 *) (cvt->buf + cvt->len_cvt)) - 2;\n    const Uint16 *target = ((const Uint16 *) cvt->buf);\n    Sint32 last_sample1 = (Sint32) SDL_SwapBE16(src[1]);\n    Sint32 last_sample0 = (Sint32) SDL_SwapBE16(src[0]);\n    while (dst >= target) {\n        const Sint32 sample1 = (Sint32) SDL_SwapBE16(src[1]);\n        const Sint32 sample0 = (Sint32) SDL_SwapBE16(src[0]);\n        src -= 2;\n        dst[3] = (Uint16) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Uint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Uint16) sample1;\n        dst[0] = (Uint16) sample0;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U16MSB_2c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_U16MSB, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Uint16 *dst = (Uint16 *) cvt->buf;\n    const Uint16 *src = (Uint16 *) cvt->buf;\n    const Uint16 *target = (const Uint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) SDL_SwapBE16(src[0]);\n    Sint32 last_sample1 = (Sint32) SDL_SwapBE16(src[1]);\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) SDL_SwapBE16(src[0]);\n        const Sint32 sample1 = (Sint32) SDL_SwapBE16(src[1]);\n        src += 4;\n        dst[0] = (Uint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Uint16) ((sample1 + last_sample1) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        dst += 2;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U16MSB_2c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_U16MSB, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Uint16 *dst = ((Uint16 *) (cvt->buf + dstsize)) - 2 * 4;\n    const Uint16 *src = ((Uint16 *) (cvt->buf + cvt->len_cvt)) - 2;\n    const Uint16 *target = ((const Uint16 *) cvt->buf);\n    Sint32 last_sample1 = (Sint32) SDL_SwapBE16(src[1]);\n    Sint32 last_sample0 = (Sint32) SDL_SwapBE16(src[0]);\n    while (dst >= target) {\n        const Sint32 sample1 = (Sint32) SDL_SwapBE16(src[1]);\n        const Sint32 sample0 = (Sint32) SDL_SwapBE16(src[0]);\n        src -= 2;\n        dst[7] = (Uint16) ((sample1 + (3 * last_sample1)) >> 2);\n        dst[6] = (Uint16) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[5] = (Uint16) ((sample1 + last_sample1) >> 1);\n        dst[4] = (Uint16) ((sample0 + last_sample0) >> 1);\n        dst[3] = (Uint16) (((3 * sample1) + last_sample1) >> 2);\n        dst[2] = (Uint16) (((3 * sample0) + last_sample0) >> 2);\n        dst[1] = (Uint16) sample1;\n        dst[0] = (Uint16) sample0;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U16MSB_2c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_U16MSB, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Uint16 *dst = (Uint16 *) cvt->buf;\n    const Uint16 *src = (Uint16 *) cvt->buf;\n    const Uint16 *target = (const Uint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) SDL_SwapBE16(src[0]);\n    Sint32 last_sample1 = (Sint32) SDL_SwapBE16(src[1]);\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) SDL_SwapBE16(src[0]);\n        const Sint32 sample1 = (Sint32) SDL_SwapBE16(src[1]);\n        src += 8;\n        dst[0] = (Uint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Uint16) ((sample1 + last_sample1) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        dst += 2;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U16MSB_4c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_U16MSB, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Uint16 *dst = ((Uint16 *) (cvt->buf + dstsize)) - 4 * 2;\n    const Uint16 *src = ((Uint16 *) (cvt->buf + cvt->len_cvt)) - 4;\n    const Uint16 *target = ((const Uint16 *) cvt->buf);\n    Sint32 last_sample3 = (Sint32) SDL_SwapBE16(src[3]);\n    Sint32 last_sample2 = (Sint32) SDL_SwapBE16(src[2]);\n    Sint32 last_sample1 = (Sint32) SDL_SwapBE16(src[1]);\n    Sint32 last_sample0 = (Sint32) SDL_SwapBE16(src[0]);\n    while (dst >= target) {\n        const Sint32 sample3 = (Sint32) SDL_SwapBE16(src[3]);\n        const Sint32 sample2 = (Sint32) SDL_SwapBE16(src[2]);\n        const Sint32 sample1 = (Sint32) SDL_SwapBE16(src[1]);\n        const Sint32 sample0 = (Sint32) SDL_SwapBE16(src[0]);\n        src -= 4;\n        dst[7] = (Uint16) ((sample3 + last_sample3) >> 1);\n        dst[6] = (Uint16) ((sample2 + last_sample2) >> 1);\n        dst[5] = (Uint16) ((sample1 + last_sample1) >> 1);\n        dst[4] = (Uint16) ((sample0 + last_sample0) >> 1);\n        dst[3] = (Uint16) sample3;\n        dst[2] = (Uint16) sample2;\n        dst[1] = (Uint16) sample1;\n        dst[0] = (Uint16) sample0;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U16MSB_4c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_U16MSB, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Uint16 *dst = (Uint16 *) cvt->buf;\n    const Uint16 *src = (Uint16 *) cvt->buf;\n    const Uint16 *target = (const Uint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) SDL_SwapBE16(src[0]);\n    Sint32 last_sample1 = (Sint32) SDL_SwapBE16(src[1]);\n    Sint32 last_sample2 = (Sint32) SDL_SwapBE16(src[2]);\n    Sint32 last_sample3 = (Sint32) SDL_SwapBE16(src[3]);\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) SDL_SwapBE16(src[0]);\n        const Sint32 sample1 = (Sint32) SDL_SwapBE16(src[1]);\n        const Sint32 sample2 = (Sint32) SDL_SwapBE16(src[2]);\n        const Sint32 sample3 = (Sint32) SDL_SwapBE16(src[3]);\n        src += 8;\n        dst[0] = (Uint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Uint16) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Uint16) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Uint16) ((sample3 + last_sample3) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        dst += 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U16MSB_4c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_U16MSB, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Uint16 *dst = ((Uint16 *) (cvt->buf + dstsize)) - 4 * 4;\n    const Uint16 *src = ((Uint16 *) (cvt->buf + cvt->len_cvt)) - 4;\n    const Uint16 *target = ((const Uint16 *) cvt->buf);\n    Sint32 last_sample3 = (Sint32) SDL_SwapBE16(src[3]);\n    Sint32 last_sample2 = (Sint32) SDL_SwapBE16(src[2]);\n    Sint32 last_sample1 = (Sint32) SDL_SwapBE16(src[1]);\n    Sint32 last_sample0 = (Sint32) SDL_SwapBE16(src[0]);\n    while (dst >= target) {\n        const Sint32 sample3 = (Sint32) SDL_SwapBE16(src[3]);\n        const Sint32 sample2 = (Sint32) SDL_SwapBE16(src[2]);\n        const Sint32 sample1 = (Sint32) SDL_SwapBE16(src[1]);\n        const Sint32 sample0 = (Sint32) SDL_SwapBE16(src[0]);\n        src -= 4;\n        dst[15] = (Uint16) ((sample3 + (3 * last_sample3)) >> 2);\n        dst[14] = (Uint16) ((sample2 + (3 * last_sample2)) >> 2);\n        dst[13] = (Uint16) ((sample1 + (3 * last_sample1)) >> 2);\n        dst[12] = (Uint16) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[11] = (Uint16) ((sample3 + last_sample3) >> 1);\n        dst[10] = (Uint16) ((sample2 + last_sample2) >> 1);\n        dst[9] = (Uint16) ((sample1 + last_sample1) >> 1);\n        dst[8] = (Uint16) ((sample0 + last_sample0) >> 1);\n        dst[7] = (Uint16) (((3 * sample3) + last_sample3) >> 2);\n        dst[6] = (Uint16) (((3 * sample2) + last_sample2) >> 2);\n        dst[5] = (Uint16) (((3 * sample1) + last_sample1) >> 2);\n        dst[4] = (Uint16) (((3 * sample0) + last_sample0) >> 2);\n        dst[3] = (Uint16) sample3;\n        dst[2] = (Uint16) sample2;\n        dst[1] = (Uint16) sample1;\n        dst[0] = (Uint16) sample0;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 16;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U16MSB_4c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_U16MSB, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Uint16 *dst = (Uint16 *) cvt->buf;\n    const Uint16 *src = (Uint16 *) cvt->buf;\n    const Uint16 *target = (const Uint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) SDL_SwapBE16(src[0]);\n    Sint32 last_sample1 = (Sint32) SDL_SwapBE16(src[1]);\n    Sint32 last_sample2 = (Sint32) SDL_SwapBE16(src[2]);\n    Sint32 last_sample3 = (Sint32) SDL_SwapBE16(src[3]);\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) SDL_SwapBE16(src[0]);\n        const Sint32 sample1 = (Sint32) SDL_SwapBE16(src[1]);\n        const Sint32 sample2 = (Sint32) SDL_SwapBE16(src[2]);\n        const Sint32 sample3 = (Sint32) SDL_SwapBE16(src[3]);\n        src += 16;\n        dst[0] = (Uint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Uint16) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Uint16) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Uint16) ((sample3 + last_sample3) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        dst += 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U16MSB_6c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_U16MSB, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Uint16 *dst = ((Uint16 *) (cvt->buf + dstsize)) - 6 * 2;\n    const Uint16 *src = ((Uint16 *) (cvt->buf + cvt->len_cvt)) - 6;\n    const Uint16 *target = ((const Uint16 *) cvt->buf);\n    Sint32 last_sample5 = (Sint32) SDL_SwapBE16(src[5]);\n    Sint32 last_sample4 = (Sint32) SDL_SwapBE16(src[4]);\n    Sint32 last_sample3 = (Sint32) SDL_SwapBE16(src[3]);\n    Sint32 last_sample2 = (Sint32) SDL_SwapBE16(src[2]);\n    Sint32 last_sample1 = (Sint32) SDL_SwapBE16(src[1]);\n    Sint32 last_sample0 = (Sint32) SDL_SwapBE16(src[0]);\n    while (dst >= target) {\n        const Sint32 sample5 = (Sint32) SDL_SwapBE16(src[5]);\n        const Sint32 sample4 = (Sint32) SDL_SwapBE16(src[4]);\n        const Sint32 sample3 = (Sint32) SDL_SwapBE16(src[3]);\n        const Sint32 sample2 = (Sint32) SDL_SwapBE16(src[2]);\n        const Sint32 sample1 = (Sint32) SDL_SwapBE16(src[1]);\n        const Sint32 sample0 = (Sint32) SDL_SwapBE16(src[0]);\n        src -= 6;\n        dst[11] = (Uint16) ((sample5 + last_sample5) >> 1);\n        dst[10] = (Uint16) ((sample4 + last_sample4) >> 1);\n        dst[9] = (Uint16) ((sample3 + last_sample3) >> 1);\n        dst[8] = (Uint16) ((sample2 + last_sample2) >> 1);\n        dst[7] = (Uint16) ((sample1 + last_sample1) >> 1);\n        dst[6] = (Uint16) ((sample0 + last_sample0) >> 1);\n        dst[5] = (Uint16) sample5;\n        dst[4] = (Uint16) sample4;\n        dst[3] = (Uint16) sample3;\n        dst[2] = (Uint16) sample2;\n        dst[1] = (Uint16) sample1;\n        dst[0] = (Uint16) sample0;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 12;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U16MSB_6c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_U16MSB, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Uint16 *dst = (Uint16 *) cvt->buf;\n    const Uint16 *src = (Uint16 *) cvt->buf;\n    const Uint16 *target = (const Uint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) SDL_SwapBE16(src[0]);\n    Sint32 last_sample1 = (Sint32) SDL_SwapBE16(src[1]);\n    Sint32 last_sample2 = (Sint32) SDL_SwapBE16(src[2]);\n    Sint32 last_sample3 = (Sint32) SDL_SwapBE16(src[3]);\n    Sint32 last_sample4 = (Sint32) SDL_SwapBE16(src[4]);\n    Sint32 last_sample5 = (Sint32) SDL_SwapBE16(src[5]);\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) SDL_SwapBE16(src[0]);\n        const Sint32 sample1 = (Sint32) SDL_SwapBE16(src[1]);\n        const Sint32 sample2 = (Sint32) SDL_SwapBE16(src[2]);\n        const Sint32 sample3 = (Sint32) SDL_SwapBE16(src[3]);\n        const Sint32 sample4 = (Sint32) SDL_SwapBE16(src[4]);\n        const Sint32 sample5 = (Sint32) SDL_SwapBE16(src[5]);\n        src += 12;\n        dst[0] = (Uint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Uint16) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Uint16) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Uint16) ((sample3 + last_sample3) >> 1);\n        dst[4] = (Uint16) ((sample4 + last_sample4) >> 1);\n        dst[5] = (Uint16) ((sample5 + last_sample5) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        dst += 6;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U16MSB_6c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_U16MSB, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Uint16 *dst = ((Uint16 *) (cvt->buf + dstsize)) - 6 * 4;\n    const Uint16 *src = ((Uint16 *) (cvt->buf + cvt->len_cvt)) - 6;\n    const Uint16 *target = ((const Uint16 *) cvt->buf);\n    Sint32 last_sample5 = (Sint32) SDL_SwapBE16(src[5]);\n    Sint32 last_sample4 = (Sint32) SDL_SwapBE16(src[4]);\n    Sint32 last_sample3 = (Sint32) SDL_SwapBE16(src[3]);\n    Sint32 last_sample2 = (Sint32) SDL_SwapBE16(src[2]);\n    Sint32 last_sample1 = (Sint32) SDL_SwapBE16(src[1]);\n    Sint32 last_sample0 = (Sint32) SDL_SwapBE16(src[0]);\n    while (dst >= target) {\n        const Sint32 sample5 = (Sint32) SDL_SwapBE16(src[5]);\n        const Sint32 sample4 = (Sint32) SDL_SwapBE16(src[4]);\n        const Sint32 sample3 = (Sint32) SDL_SwapBE16(src[3]);\n        const Sint32 sample2 = (Sint32) SDL_SwapBE16(src[2]);\n        const Sint32 sample1 = (Sint32) SDL_SwapBE16(src[1]);\n        const Sint32 sample0 = (Sint32) SDL_SwapBE16(src[0]);\n        src -= 6;\n        dst[23] = (Uint16) ((sample5 + (3 * last_sample5)) >> 2);\n        dst[22] = (Uint16) ((sample4 + (3 * last_sample4)) >> 2);\n        dst[21] = (Uint16) ((sample3 + (3 * last_sample3)) >> 2);\n        dst[20] = (Uint16) ((sample2 + (3 * last_sample2)) >> 2);\n        dst[19] = (Uint16) ((sample1 + (3 * last_sample1)) >> 2);\n        dst[18] = (Uint16) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[17] = (Uint16) ((sample5 + last_sample5) >> 1);\n        dst[16] = (Uint16) ((sample4 + last_sample4) >> 1);\n        dst[15] = (Uint16) ((sample3 + last_sample3) >> 1);\n        dst[14] = (Uint16) ((sample2 + last_sample2) >> 1);\n        dst[13] = (Uint16) ((sample1 + last_sample1) >> 1);\n        dst[12] = (Uint16) ((sample0 + last_sample0) >> 1);\n        dst[11] = (Uint16) (((3 * sample5) + last_sample5) >> 2);\n        dst[10] = (Uint16) (((3 * sample4) + last_sample4) >> 2);\n        dst[9] = (Uint16) (((3 * sample3) + last_sample3) >> 2);\n        dst[8] = (Uint16) (((3 * sample2) + last_sample2) >> 2);\n        dst[7] = (Uint16) (((3 * sample1) + last_sample1) >> 2);\n        dst[6] = (Uint16) (((3 * sample0) + last_sample0) >> 2);\n        dst[5] = (Uint16) sample5;\n        dst[4] = (Uint16) sample4;\n        dst[3] = (Uint16) sample3;\n        dst[2] = (Uint16) sample2;\n        dst[1] = (Uint16) sample1;\n        dst[0] = (Uint16) sample0;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 24;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U16MSB_6c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_U16MSB, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Uint16 *dst = (Uint16 *) cvt->buf;\n    const Uint16 *src = (Uint16 *) cvt->buf;\n    const Uint16 *target = (const Uint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) SDL_SwapBE16(src[0]);\n    Sint32 last_sample1 = (Sint32) SDL_SwapBE16(src[1]);\n    Sint32 last_sample2 = (Sint32) SDL_SwapBE16(src[2]);\n    Sint32 last_sample3 = (Sint32) SDL_SwapBE16(src[3]);\n    Sint32 last_sample4 = (Sint32) SDL_SwapBE16(src[4]);\n    Sint32 last_sample5 = (Sint32) SDL_SwapBE16(src[5]);\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) SDL_SwapBE16(src[0]);\n        const Sint32 sample1 = (Sint32) SDL_SwapBE16(src[1]);\n        const Sint32 sample2 = (Sint32) SDL_SwapBE16(src[2]);\n        const Sint32 sample3 = (Sint32) SDL_SwapBE16(src[3]);\n        const Sint32 sample4 = (Sint32) SDL_SwapBE16(src[4]);\n        const Sint32 sample5 = (Sint32) SDL_SwapBE16(src[5]);\n        src += 24;\n        dst[0] = (Uint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Uint16) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Uint16) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Uint16) ((sample3 + last_sample3) >> 1);\n        dst[4] = (Uint16) ((sample4 + last_sample4) >> 1);\n        dst[5] = (Uint16) ((sample5 + last_sample5) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        dst += 6;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U16MSB_8c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_U16MSB, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Uint16 *dst = ((Uint16 *) (cvt->buf + dstsize)) - 8 * 2;\n    const Uint16 *src = ((Uint16 *) (cvt->buf + cvt->len_cvt)) - 8;\n    const Uint16 *target = ((const Uint16 *) cvt->buf);\n    Sint32 last_sample7 = (Sint32) SDL_SwapBE16(src[7]);\n    Sint32 last_sample6 = (Sint32) SDL_SwapBE16(src[6]);\n    Sint32 last_sample5 = (Sint32) SDL_SwapBE16(src[5]);\n    Sint32 last_sample4 = (Sint32) SDL_SwapBE16(src[4]);\n    Sint32 last_sample3 = (Sint32) SDL_SwapBE16(src[3]);\n    Sint32 last_sample2 = (Sint32) SDL_SwapBE16(src[2]);\n    Sint32 last_sample1 = (Sint32) SDL_SwapBE16(src[1]);\n    Sint32 last_sample0 = (Sint32) SDL_SwapBE16(src[0]);\n    while (dst >= target) {\n        const Sint32 sample7 = (Sint32) SDL_SwapBE16(src[7]);\n        const Sint32 sample6 = (Sint32) SDL_SwapBE16(src[6]);\n        const Sint32 sample5 = (Sint32) SDL_SwapBE16(src[5]);\n        const Sint32 sample4 = (Sint32) SDL_SwapBE16(src[4]);\n        const Sint32 sample3 = (Sint32) SDL_SwapBE16(src[3]);\n        const Sint32 sample2 = (Sint32) SDL_SwapBE16(src[2]);\n        const Sint32 sample1 = (Sint32) SDL_SwapBE16(src[1]);\n        const Sint32 sample0 = (Sint32) SDL_SwapBE16(src[0]);\n        src -= 8;\n        dst[15] = (Uint16) ((sample7 + last_sample7) >> 1);\n        dst[14] = (Uint16) ((sample6 + last_sample6) >> 1);\n        dst[13] = (Uint16) ((sample5 + last_sample5) >> 1);\n        dst[12] = (Uint16) ((sample4 + last_sample4) >> 1);\n        dst[11] = (Uint16) ((sample3 + last_sample3) >> 1);\n        dst[10] = (Uint16) ((sample2 + last_sample2) >> 1);\n        dst[9] = (Uint16) ((sample1 + last_sample1) >> 1);\n        dst[8] = (Uint16) ((sample0 + last_sample0) >> 1);\n        dst[7] = (Uint16) sample7;\n        dst[6] = (Uint16) sample6;\n        dst[5] = (Uint16) sample5;\n        dst[4] = (Uint16) sample4;\n        dst[3] = (Uint16) sample3;\n        dst[2] = (Uint16) sample2;\n        dst[1] = (Uint16) sample1;\n        dst[0] = (Uint16) sample0;\n        last_sample7 = sample7;\n        last_sample6 = sample6;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 16;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U16MSB_8c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_U16MSB, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Uint16 *dst = (Uint16 *) cvt->buf;\n    const Uint16 *src = (Uint16 *) cvt->buf;\n    const Uint16 *target = (const Uint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) SDL_SwapBE16(src[0]);\n    Sint32 last_sample1 = (Sint32) SDL_SwapBE16(src[1]);\n    Sint32 last_sample2 = (Sint32) SDL_SwapBE16(src[2]);\n    Sint32 last_sample3 = (Sint32) SDL_SwapBE16(src[3]);\n    Sint32 last_sample4 = (Sint32) SDL_SwapBE16(src[4]);\n    Sint32 last_sample5 = (Sint32) SDL_SwapBE16(src[5]);\n    Sint32 last_sample6 = (Sint32) SDL_SwapBE16(src[6]);\n    Sint32 last_sample7 = (Sint32) SDL_SwapBE16(src[7]);\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) SDL_SwapBE16(src[0]);\n        const Sint32 sample1 = (Sint32) SDL_SwapBE16(src[1]);\n        const Sint32 sample2 = (Sint32) SDL_SwapBE16(src[2]);\n        const Sint32 sample3 = (Sint32) SDL_SwapBE16(src[3]);\n        const Sint32 sample4 = (Sint32) SDL_SwapBE16(src[4]);\n        const Sint32 sample5 = (Sint32) SDL_SwapBE16(src[5]);\n        const Sint32 sample6 = (Sint32) SDL_SwapBE16(src[6]);\n        const Sint32 sample7 = (Sint32) SDL_SwapBE16(src[7]);\n        src += 16;\n        dst[0] = (Uint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Uint16) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Uint16) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Uint16) ((sample3 + last_sample3) >> 1);\n        dst[4] = (Uint16) ((sample4 + last_sample4) >> 1);\n        dst[5] = (Uint16) ((sample5 + last_sample5) >> 1);\n        dst[6] = (Uint16) ((sample6 + last_sample6) >> 1);\n        dst[7] = (Uint16) ((sample7 + last_sample7) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        last_sample6 = sample6;\n        last_sample7 = sample7;\n        dst += 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_U16MSB_8c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_U16MSB, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Uint16 *dst = ((Uint16 *) (cvt->buf + dstsize)) - 8 * 4;\n    const Uint16 *src = ((Uint16 *) (cvt->buf + cvt->len_cvt)) - 8;\n    const Uint16 *target = ((const Uint16 *) cvt->buf);\n    Sint32 last_sample7 = (Sint32) SDL_SwapBE16(src[7]);\n    Sint32 last_sample6 = (Sint32) SDL_SwapBE16(src[6]);\n    Sint32 last_sample5 = (Sint32) SDL_SwapBE16(src[5]);\n    Sint32 last_sample4 = (Sint32) SDL_SwapBE16(src[4]);\n    Sint32 last_sample3 = (Sint32) SDL_SwapBE16(src[3]);\n    Sint32 last_sample2 = (Sint32) SDL_SwapBE16(src[2]);\n    Sint32 last_sample1 = (Sint32) SDL_SwapBE16(src[1]);\n    Sint32 last_sample0 = (Sint32) SDL_SwapBE16(src[0]);\n    while (dst >= target) {\n        const Sint32 sample7 = (Sint32) SDL_SwapBE16(src[7]);\n        const Sint32 sample6 = (Sint32) SDL_SwapBE16(src[6]);\n        const Sint32 sample5 = (Sint32) SDL_SwapBE16(src[5]);\n        const Sint32 sample4 = (Sint32) SDL_SwapBE16(src[4]);\n        const Sint32 sample3 = (Sint32) SDL_SwapBE16(src[3]);\n        const Sint32 sample2 = (Sint32) SDL_SwapBE16(src[2]);\n        const Sint32 sample1 = (Sint32) SDL_SwapBE16(src[1]);\n        const Sint32 sample0 = (Sint32) SDL_SwapBE16(src[0]);\n        src -= 8;\n        dst[31] = (Uint16) ((sample7 + (3 * last_sample7)) >> 2);\n        dst[30] = (Uint16) ((sample6 + (3 * last_sample6)) >> 2);\n        dst[29] = (Uint16) ((sample5 + (3 * last_sample5)) >> 2);\n        dst[28] = (Uint16) ((sample4 + (3 * last_sample4)) >> 2);\n        dst[27] = (Uint16) ((sample3 + (3 * last_sample3)) >> 2);\n        dst[26] = (Uint16) ((sample2 + (3 * last_sample2)) >> 2);\n        dst[25] = (Uint16) ((sample1 + (3 * last_sample1)) >> 2);\n        dst[24] = (Uint16) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[23] = (Uint16) ((sample7 + last_sample7) >> 1);\n        dst[22] = (Uint16) ((sample6 + last_sample6) >> 1);\n        dst[21] = (Uint16) ((sample5 + last_sample5) >> 1);\n        dst[20] = (Uint16) ((sample4 + last_sample4) >> 1);\n        dst[19] = (Uint16) ((sample3 + last_sample3) >> 1);\n        dst[18] = (Uint16) ((sample2 + last_sample2) >> 1);\n        dst[17] = (Uint16) ((sample1 + last_sample1) >> 1);\n        dst[16] = (Uint16) ((sample0 + last_sample0) >> 1);\n        dst[15] = (Uint16) (((3 * sample7) + last_sample7) >> 2);\n        dst[14] = (Uint16) (((3 * sample6) + last_sample6) >> 2);\n        dst[13] = (Uint16) (((3 * sample5) + last_sample5) >> 2);\n        dst[12] = (Uint16) (((3 * sample4) + last_sample4) >> 2);\n        dst[11] = (Uint16) (((3 * sample3) + last_sample3) >> 2);\n        dst[10] = (Uint16) (((3 * sample2) + last_sample2) >> 2);\n        dst[9] = (Uint16) (((3 * sample1) + last_sample1) >> 2);\n        dst[8] = (Uint16) (((3 * sample0) + last_sample0) >> 2);\n        dst[7] = (Uint16) sample7;\n        dst[6] = (Uint16) sample6;\n        dst[5] = (Uint16) sample5;\n        dst[4] = (Uint16) sample4;\n        dst[3] = (Uint16) sample3;\n        dst[2] = (Uint16) sample2;\n        dst[1] = (Uint16) sample1;\n        dst[0] = (Uint16) sample0;\n        last_sample7 = sample7;\n        last_sample6 = sample6;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 32;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_U16MSB_8c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_U16MSB, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Uint16 *dst = (Uint16 *) cvt->buf;\n    const Uint16 *src = (Uint16 *) cvt->buf;\n    const Uint16 *target = (const Uint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) SDL_SwapBE16(src[0]);\n    Sint32 last_sample1 = (Sint32) SDL_SwapBE16(src[1]);\n    Sint32 last_sample2 = (Sint32) SDL_SwapBE16(src[2]);\n    Sint32 last_sample3 = (Sint32) SDL_SwapBE16(src[3]);\n    Sint32 last_sample4 = (Sint32) SDL_SwapBE16(src[4]);\n    Sint32 last_sample5 = (Sint32) SDL_SwapBE16(src[5]);\n    Sint32 last_sample6 = (Sint32) SDL_SwapBE16(src[6]);\n    Sint32 last_sample7 = (Sint32) SDL_SwapBE16(src[7]);\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) SDL_SwapBE16(src[0]);\n        const Sint32 sample1 = (Sint32) SDL_SwapBE16(src[1]);\n        const Sint32 sample2 = (Sint32) SDL_SwapBE16(src[2]);\n        const Sint32 sample3 = (Sint32) SDL_SwapBE16(src[3]);\n        const Sint32 sample4 = (Sint32) SDL_SwapBE16(src[4]);\n        const Sint32 sample5 = (Sint32) SDL_SwapBE16(src[5]);\n        const Sint32 sample6 = (Sint32) SDL_SwapBE16(src[6]);\n        const Sint32 sample7 = (Sint32) SDL_SwapBE16(src[7]);\n        src += 32;\n        dst[0] = (Uint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Uint16) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Uint16) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Uint16) ((sample3 + last_sample3) >> 1);\n        dst[4] = (Uint16) ((sample4 + last_sample4) >> 1);\n        dst[5] = (Uint16) ((sample5 + last_sample5) >> 1);\n        dst[6] = (Uint16) ((sample6 + last_sample6) >> 1);\n        dst[7] = (Uint16) ((sample7 + last_sample7) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        last_sample6 = sample6;\n        last_sample7 = sample7;\n        dst += 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S16MSB_1c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_S16MSB, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Sint16 *dst = ((Sint16 *) (cvt->buf + dstsize)) - 1 * 2;\n    const Sint16 *src = ((Sint16 *) (cvt->buf + cvt->len_cvt)) - 1;\n    const Sint16 *target = ((const Sint16 *) cvt->buf);\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n    while (dst >= target) {\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n        src--;\n        dst[1] = (Sint16) ((sample0 + last_sample0) >> 1);\n        dst[0] = (Sint16) sample0;\n        last_sample0 = sample0;\n        dst -= 2;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S16MSB_1c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_S16MSB, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Sint16 *dst = (Sint16 *) cvt->buf;\n    const Sint16 *src = (Sint16 *) cvt->buf;\n    const Sint16 *target = (const Sint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n        src += 2;\n        dst[0] = (Sint16) ((sample0 + last_sample0) >> 1);\n        last_sample0 = sample0;\n        dst++;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S16MSB_1c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_S16MSB, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Sint16 *dst = ((Sint16 *) (cvt->buf + dstsize)) - 1 * 4;\n    const Sint16 *src = ((Sint16 *) (cvt->buf + cvt->len_cvt)) - 1;\n    const Sint16 *target = ((const Sint16 *) cvt->buf);\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n    while (dst >= target) {\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n        src--;\n        dst[3] = (Sint16) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[2] = (Sint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint16) (((3 * sample0) + last_sample0) >> 2);\n        dst[0] = (Sint16) sample0;\n        last_sample0 = sample0;\n        dst -= 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S16MSB_1c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_S16MSB, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Sint16 *dst = (Sint16 *) cvt->buf;\n    const Sint16 *src = (Sint16 *) cvt->buf;\n    const Sint16 *target = (const Sint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n        src += 4;\n        dst[0] = (Sint16) ((sample0 + last_sample0) >> 1);\n        last_sample0 = sample0;\n        dst++;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S16MSB_2c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_S16MSB, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Sint16 *dst = ((Sint16 *) (cvt->buf + dstsize)) - 2 * 2;\n    const Sint16 *src = ((Sint16 *) (cvt->buf + cvt->len_cvt)) - 2;\n    const Sint16 *target = ((const Sint16 *) cvt->buf);\n    Sint32 last_sample1 = (Sint32) ((Sint16) SDL_SwapBE16(src[1]));\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n    while (dst >= target) {\n        const Sint32 sample1 = (Sint32) ((Sint16) SDL_SwapBE16(src[1]));\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n        src -= 2;\n        dst[3] = (Sint16) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Sint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint16) sample1;\n        dst[0] = (Sint16) sample0;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S16MSB_2c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_S16MSB, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Sint16 *dst = (Sint16 *) cvt->buf;\n    const Sint16 *src = (Sint16 *) cvt->buf;\n    const Sint16 *target = (const Sint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n    Sint32 last_sample1 = (Sint32) ((Sint16) SDL_SwapBE16(src[1]));\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n        const Sint32 sample1 = (Sint32) ((Sint16) SDL_SwapBE16(src[1]));\n        src += 4;\n        dst[0] = (Sint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint16) ((sample1 + last_sample1) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        dst += 2;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S16MSB_2c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_S16MSB, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Sint16 *dst = ((Sint16 *) (cvt->buf + dstsize)) - 2 * 4;\n    const Sint16 *src = ((Sint16 *) (cvt->buf + cvt->len_cvt)) - 2;\n    const Sint16 *target = ((const Sint16 *) cvt->buf);\n    Sint32 last_sample1 = (Sint32) ((Sint16) SDL_SwapBE16(src[1]));\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n    while (dst >= target) {\n        const Sint32 sample1 = (Sint32) ((Sint16) SDL_SwapBE16(src[1]));\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n        src -= 2;\n        dst[7] = (Sint16) ((sample1 + (3 * last_sample1)) >> 2);\n        dst[6] = (Sint16) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[5] = (Sint16) ((sample1 + last_sample1) >> 1);\n        dst[4] = (Sint16) ((sample0 + last_sample0) >> 1);\n        dst[3] = (Sint16) (((3 * sample1) + last_sample1) >> 2);\n        dst[2] = (Sint16) (((3 * sample0) + last_sample0) >> 2);\n        dst[1] = (Sint16) sample1;\n        dst[0] = (Sint16) sample0;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S16MSB_2c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_S16MSB, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Sint16 *dst = (Sint16 *) cvt->buf;\n    const Sint16 *src = (Sint16 *) cvt->buf;\n    const Sint16 *target = (const Sint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n    Sint32 last_sample1 = (Sint32) ((Sint16) SDL_SwapBE16(src[1]));\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n        const Sint32 sample1 = (Sint32) ((Sint16) SDL_SwapBE16(src[1]));\n        src += 8;\n        dst[0] = (Sint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint16) ((sample1 + last_sample1) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        dst += 2;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S16MSB_4c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_S16MSB, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Sint16 *dst = ((Sint16 *) (cvt->buf + dstsize)) - 4 * 2;\n    const Sint16 *src = ((Sint16 *) (cvt->buf + cvt->len_cvt)) - 4;\n    const Sint16 *target = ((const Sint16 *) cvt->buf);\n    Sint32 last_sample3 = (Sint32) ((Sint16) SDL_SwapBE16(src[3]));\n    Sint32 last_sample2 = (Sint32) ((Sint16) SDL_SwapBE16(src[2]));\n    Sint32 last_sample1 = (Sint32) ((Sint16) SDL_SwapBE16(src[1]));\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n    while (dst >= target) {\n        const Sint32 sample3 = (Sint32) ((Sint16) SDL_SwapBE16(src[3]));\n        const Sint32 sample2 = (Sint32) ((Sint16) SDL_SwapBE16(src[2]));\n        const Sint32 sample1 = (Sint32) ((Sint16) SDL_SwapBE16(src[1]));\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n        src -= 4;\n        dst[7] = (Sint16) ((sample3 + last_sample3) >> 1);\n        dst[6] = (Sint16) ((sample2 + last_sample2) >> 1);\n        dst[5] = (Sint16) ((sample1 + last_sample1) >> 1);\n        dst[4] = (Sint16) ((sample0 + last_sample0) >> 1);\n        dst[3] = (Sint16) sample3;\n        dst[2] = (Sint16) sample2;\n        dst[1] = (Sint16) sample1;\n        dst[0] = (Sint16) sample0;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S16MSB_4c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_S16MSB, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Sint16 *dst = (Sint16 *) cvt->buf;\n    const Sint16 *src = (Sint16 *) cvt->buf;\n    const Sint16 *target = (const Sint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n    Sint32 last_sample1 = (Sint32) ((Sint16) SDL_SwapBE16(src[1]));\n    Sint32 last_sample2 = (Sint32) ((Sint16) SDL_SwapBE16(src[2]));\n    Sint32 last_sample3 = (Sint32) ((Sint16) SDL_SwapBE16(src[3]));\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n        const Sint32 sample1 = (Sint32) ((Sint16) SDL_SwapBE16(src[1]));\n        const Sint32 sample2 = (Sint32) ((Sint16) SDL_SwapBE16(src[2]));\n        const Sint32 sample3 = (Sint32) ((Sint16) SDL_SwapBE16(src[3]));\n        src += 8;\n        dst[0] = (Sint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint16) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Sint16) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Sint16) ((sample3 + last_sample3) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        dst += 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S16MSB_4c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_S16MSB, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Sint16 *dst = ((Sint16 *) (cvt->buf + dstsize)) - 4 * 4;\n    const Sint16 *src = ((Sint16 *) (cvt->buf + cvt->len_cvt)) - 4;\n    const Sint16 *target = ((const Sint16 *) cvt->buf);\n    Sint32 last_sample3 = (Sint32) ((Sint16) SDL_SwapBE16(src[3]));\n    Sint32 last_sample2 = (Sint32) ((Sint16) SDL_SwapBE16(src[2]));\n    Sint32 last_sample1 = (Sint32) ((Sint16) SDL_SwapBE16(src[1]));\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n    while (dst >= target) {\n        const Sint32 sample3 = (Sint32) ((Sint16) SDL_SwapBE16(src[3]));\n        const Sint32 sample2 = (Sint32) ((Sint16) SDL_SwapBE16(src[2]));\n        const Sint32 sample1 = (Sint32) ((Sint16) SDL_SwapBE16(src[1]));\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n        src -= 4;\n        dst[15] = (Sint16) ((sample3 + (3 * last_sample3)) >> 2);\n        dst[14] = (Sint16) ((sample2 + (3 * last_sample2)) >> 2);\n        dst[13] = (Sint16) ((sample1 + (3 * last_sample1)) >> 2);\n        dst[12] = (Sint16) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[11] = (Sint16) ((sample3 + last_sample3) >> 1);\n        dst[10] = (Sint16) ((sample2 + last_sample2) >> 1);\n        dst[9] = (Sint16) ((sample1 + last_sample1) >> 1);\n        dst[8] = (Sint16) ((sample0 + last_sample0) >> 1);\n        dst[7] = (Sint16) (((3 * sample3) + last_sample3) >> 2);\n        dst[6] = (Sint16) (((3 * sample2) + last_sample2) >> 2);\n        dst[5] = (Sint16) (((3 * sample1) + last_sample1) >> 2);\n        dst[4] = (Sint16) (((3 * sample0) + last_sample0) >> 2);\n        dst[3] = (Sint16) sample3;\n        dst[2] = (Sint16) sample2;\n        dst[1] = (Sint16) sample1;\n        dst[0] = (Sint16) sample0;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 16;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S16MSB_4c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_S16MSB, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Sint16 *dst = (Sint16 *) cvt->buf;\n    const Sint16 *src = (Sint16 *) cvt->buf;\n    const Sint16 *target = (const Sint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n    Sint32 last_sample1 = (Sint32) ((Sint16) SDL_SwapBE16(src[1]));\n    Sint32 last_sample2 = (Sint32) ((Sint16) SDL_SwapBE16(src[2]));\n    Sint32 last_sample3 = (Sint32) ((Sint16) SDL_SwapBE16(src[3]));\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n        const Sint32 sample1 = (Sint32) ((Sint16) SDL_SwapBE16(src[1]));\n        const Sint32 sample2 = (Sint32) ((Sint16) SDL_SwapBE16(src[2]));\n        const Sint32 sample3 = (Sint32) ((Sint16) SDL_SwapBE16(src[3]));\n        src += 16;\n        dst[0] = (Sint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint16) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Sint16) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Sint16) ((sample3 + last_sample3) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        dst += 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S16MSB_6c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_S16MSB, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Sint16 *dst = ((Sint16 *) (cvt->buf + dstsize)) - 6 * 2;\n    const Sint16 *src = ((Sint16 *) (cvt->buf + cvt->len_cvt)) - 6;\n    const Sint16 *target = ((const Sint16 *) cvt->buf);\n    Sint32 last_sample5 = (Sint32) ((Sint16) SDL_SwapBE16(src[5]));\n    Sint32 last_sample4 = (Sint32) ((Sint16) SDL_SwapBE16(src[4]));\n    Sint32 last_sample3 = (Sint32) ((Sint16) SDL_SwapBE16(src[3]));\n    Sint32 last_sample2 = (Sint32) ((Sint16) SDL_SwapBE16(src[2]));\n    Sint32 last_sample1 = (Sint32) ((Sint16) SDL_SwapBE16(src[1]));\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n    while (dst >= target) {\n        const Sint32 sample5 = (Sint32) ((Sint16) SDL_SwapBE16(src[5]));\n        const Sint32 sample4 = (Sint32) ((Sint16) SDL_SwapBE16(src[4]));\n        const Sint32 sample3 = (Sint32) ((Sint16) SDL_SwapBE16(src[3]));\n        const Sint32 sample2 = (Sint32) ((Sint16) SDL_SwapBE16(src[2]));\n        const Sint32 sample1 = (Sint32) ((Sint16) SDL_SwapBE16(src[1]));\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n        src -= 6;\n        dst[11] = (Sint16) ((sample5 + last_sample5) >> 1);\n        dst[10] = (Sint16) ((sample4 + last_sample4) >> 1);\n        dst[9] = (Sint16) ((sample3 + last_sample3) >> 1);\n        dst[8] = (Sint16) ((sample2 + last_sample2) >> 1);\n        dst[7] = (Sint16) ((sample1 + last_sample1) >> 1);\n        dst[6] = (Sint16) ((sample0 + last_sample0) >> 1);\n        dst[5] = (Sint16) sample5;\n        dst[4] = (Sint16) sample4;\n        dst[3] = (Sint16) sample3;\n        dst[2] = (Sint16) sample2;\n        dst[1] = (Sint16) sample1;\n        dst[0] = (Sint16) sample0;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 12;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S16MSB_6c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_S16MSB, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Sint16 *dst = (Sint16 *) cvt->buf;\n    const Sint16 *src = (Sint16 *) cvt->buf;\n    const Sint16 *target = (const Sint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n    Sint32 last_sample1 = (Sint32) ((Sint16) SDL_SwapBE16(src[1]));\n    Sint32 last_sample2 = (Sint32) ((Sint16) SDL_SwapBE16(src[2]));\n    Sint32 last_sample3 = (Sint32) ((Sint16) SDL_SwapBE16(src[3]));\n    Sint32 last_sample4 = (Sint32) ((Sint16) SDL_SwapBE16(src[4]));\n    Sint32 last_sample5 = (Sint32) ((Sint16) SDL_SwapBE16(src[5]));\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n        const Sint32 sample1 = (Sint32) ((Sint16) SDL_SwapBE16(src[1]));\n        const Sint32 sample2 = (Sint32) ((Sint16) SDL_SwapBE16(src[2]));\n        const Sint32 sample3 = (Sint32) ((Sint16) SDL_SwapBE16(src[3]));\n        const Sint32 sample4 = (Sint32) ((Sint16) SDL_SwapBE16(src[4]));\n        const Sint32 sample5 = (Sint32) ((Sint16) SDL_SwapBE16(src[5]));\n        src += 12;\n        dst[0] = (Sint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint16) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Sint16) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Sint16) ((sample3 + last_sample3) >> 1);\n        dst[4] = (Sint16) ((sample4 + last_sample4) >> 1);\n        dst[5] = (Sint16) ((sample5 + last_sample5) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        dst += 6;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S16MSB_6c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_S16MSB, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Sint16 *dst = ((Sint16 *) (cvt->buf + dstsize)) - 6 * 4;\n    const Sint16 *src = ((Sint16 *) (cvt->buf + cvt->len_cvt)) - 6;\n    const Sint16 *target = ((const Sint16 *) cvt->buf);\n    Sint32 last_sample5 = (Sint32) ((Sint16) SDL_SwapBE16(src[5]));\n    Sint32 last_sample4 = (Sint32) ((Sint16) SDL_SwapBE16(src[4]));\n    Sint32 last_sample3 = (Sint32) ((Sint16) SDL_SwapBE16(src[3]));\n    Sint32 last_sample2 = (Sint32) ((Sint16) SDL_SwapBE16(src[2]));\n    Sint32 last_sample1 = (Sint32) ((Sint16) SDL_SwapBE16(src[1]));\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n    while (dst >= target) {\n        const Sint32 sample5 = (Sint32) ((Sint16) SDL_SwapBE16(src[5]));\n        const Sint32 sample4 = (Sint32) ((Sint16) SDL_SwapBE16(src[4]));\n        const Sint32 sample3 = (Sint32) ((Sint16) SDL_SwapBE16(src[3]));\n        const Sint32 sample2 = (Sint32) ((Sint16) SDL_SwapBE16(src[2]));\n        const Sint32 sample1 = (Sint32) ((Sint16) SDL_SwapBE16(src[1]));\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n        src -= 6;\n        dst[23] = (Sint16) ((sample5 + (3 * last_sample5)) >> 2);\n        dst[22] = (Sint16) ((sample4 + (3 * last_sample4)) >> 2);\n        dst[21] = (Sint16) ((sample3 + (3 * last_sample3)) >> 2);\n        dst[20] = (Sint16) ((sample2 + (3 * last_sample2)) >> 2);\n        dst[19] = (Sint16) ((sample1 + (3 * last_sample1)) >> 2);\n        dst[18] = (Sint16) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[17] = (Sint16) ((sample5 + last_sample5) >> 1);\n        dst[16] = (Sint16) ((sample4 + last_sample4) >> 1);\n        dst[15] = (Sint16) ((sample3 + last_sample3) >> 1);\n        dst[14] = (Sint16) ((sample2 + last_sample2) >> 1);\n        dst[13] = (Sint16) ((sample1 + last_sample1) >> 1);\n        dst[12] = (Sint16) ((sample0 + last_sample0) >> 1);\n        dst[11] = (Sint16) (((3 * sample5) + last_sample5) >> 2);\n        dst[10] = (Sint16) (((3 * sample4) + last_sample4) >> 2);\n        dst[9] = (Sint16) (((3 * sample3) + last_sample3) >> 2);\n        dst[8] = (Sint16) (((3 * sample2) + last_sample2) >> 2);\n        dst[7] = (Sint16) (((3 * sample1) + last_sample1) >> 2);\n        dst[6] = (Sint16) (((3 * sample0) + last_sample0) >> 2);\n        dst[5] = (Sint16) sample5;\n        dst[4] = (Sint16) sample4;\n        dst[3] = (Sint16) sample3;\n        dst[2] = (Sint16) sample2;\n        dst[1] = (Sint16) sample1;\n        dst[0] = (Sint16) sample0;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 24;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S16MSB_6c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_S16MSB, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Sint16 *dst = (Sint16 *) cvt->buf;\n    const Sint16 *src = (Sint16 *) cvt->buf;\n    const Sint16 *target = (const Sint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n    Sint32 last_sample1 = (Sint32) ((Sint16) SDL_SwapBE16(src[1]));\n    Sint32 last_sample2 = (Sint32) ((Sint16) SDL_SwapBE16(src[2]));\n    Sint32 last_sample3 = (Sint32) ((Sint16) SDL_SwapBE16(src[3]));\n    Sint32 last_sample4 = (Sint32) ((Sint16) SDL_SwapBE16(src[4]));\n    Sint32 last_sample5 = (Sint32) ((Sint16) SDL_SwapBE16(src[5]));\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n        const Sint32 sample1 = (Sint32) ((Sint16) SDL_SwapBE16(src[1]));\n        const Sint32 sample2 = (Sint32) ((Sint16) SDL_SwapBE16(src[2]));\n        const Sint32 sample3 = (Sint32) ((Sint16) SDL_SwapBE16(src[3]));\n        const Sint32 sample4 = (Sint32) ((Sint16) SDL_SwapBE16(src[4]));\n        const Sint32 sample5 = (Sint32) ((Sint16) SDL_SwapBE16(src[5]));\n        src += 24;\n        dst[0] = (Sint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint16) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Sint16) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Sint16) ((sample3 + last_sample3) >> 1);\n        dst[4] = (Sint16) ((sample4 + last_sample4) >> 1);\n        dst[5] = (Sint16) ((sample5 + last_sample5) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        dst += 6;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S16MSB_8c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_S16MSB, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Sint16 *dst = ((Sint16 *) (cvt->buf + dstsize)) - 8 * 2;\n    const Sint16 *src = ((Sint16 *) (cvt->buf + cvt->len_cvt)) - 8;\n    const Sint16 *target = ((const Sint16 *) cvt->buf);\n    Sint32 last_sample7 = (Sint32) ((Sint16) SDL_SwapBE16(src[7]));\n    Sint32 last_sample6 = (Sint32) ((Sint16) SDL_SwapBE16(src[6]));\n    Sint32 last_sample5 = (Sint32) ((Sint16) SDL_SwapBE16(src[5]));\n    Sint32 last_sample4 = (Sint32) ((Sint16) SDL_SwapBE16(src[4]));\n    Sint32 last_sample3 = (Sint32) ((Sint16) SDL_SwapBE16(src[3]));\n    Sint32 last_sample2 = (Sint32) ((Sint16) SDL_SwapBE16(src[2]));\n    Sint32 last_sample1 = (Sint32) ((Sint16) SDL_SwapBE16(src[1]));\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n    while (dst >= target) {\n        const Sint32 sample7 = (Sint32) ((Sint16) SDL_SwapBE16(src[7]));\n        const Sint32 sample6 = (Sint32) ((Sint16) SDL_SwapBE16(src[6]));\n        const Sint32 sample5 = (Sint32) ((Sint16) SDL_SwapBE16(src[5]));\n        const Sint32 sample4 = (Sint32) ((Sint16) SDL_SwapBE16(src[4]));\n        const Sint32 sample3 = (Sint32) ((Sint16) SDL_SwapBE16(src[3]));\n        const Sint32 sample2 = (Sint32) ((Sint16) SDL_SwapBE16(src[2]));\n        const Sint32 sample1 = (Sint32) ((Sint16) SDL_SwapBE16(src[1]));\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n        src -= 8;\n        dst[15] = (Sint16) ((sample7 + last_sample7) >> 1);\n        dst[14] = (Sint16) ((sample6 + last_sample6) >> 1);\n        dst[13] = (Sint16) ((sample5 + last_sample5) >> 1);\n        dst[12] = (Sint16) ((sample4 + last_sample4) >> 1);\n        dst[11] = (Sint16) ((sample3 + last_sample3) >> 1);\n        dst[10] = (Sint16) ((sample2 + last_sample2) >> 1);\n        dst[9] = (Sint16) ((sample1 + last_sample1) >> 1);\n        dst[8] = (Sint16) ((sample0 + last_sample0) >> 1);\n        dst[7] = (Sint16) sample7;\n        dst[6] = (Sint16) sample6;\n        dst[5] = (Sint16) sample5;\n        dst[4] = (Sint16) sample4;\n        dst[3] = (Sint16) sample3;\n        dst[2] = (Sint16) sample2;\n        dst[1] = (Sint16) sample1;\n        dst[0] = (Sint16) sample0;\n        last_sample7 = sample7;\n        last_sample6 = sample6;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 16;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S16MSB_8c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_S16MSB, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Sint16 *dst = (Sint16 *) cvt->buf;\n    const Sint16 *src = (Sint16 *) cvt->buf;\n    const Sint16 *target = (const Sint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n    Sint32 last_sample1 = (Sint32) ((Sint16) SDL_SwapBE16(src[1]));\n    Sint32 last_sample2 = (Sint32) ((Sint16) SDL_SwapBE16(src[2]));\n    Sint32 last_sample3 = (Sint32) ((Sint16) SDL_SwapBE16(src[3]));\n    Sint32 last_sample4 = (Sint32) ((Sint16) SDL_SwapBE16(src[4]));\n    Sint32 last_sample5 = (Sint32) ((Sint16) SDL_SwapBE16(src[5]));\n    Sint32 last_sample6 = (Sint32) ((Sint16) SDL_SwapBE16(src[6]));\n    Sint32 last_sample7 = (Sint32) ((Sint16) SDL_SwapBE16(src[7]));\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n        const Sint32 sample1 = (Sint32) ((Sint16) SDL_SwapBE16(src[1]));\n        const Sint32 sample2 = (Sint32) ((Sint16) SDL_SwapBE16(src[2]));\n        const Sint32 sample3 = (Sint32) ((Sint16) SDL_SwapBE16(src[3]));\n        const Sint32 sample4 = (Sint32) ((Sint16) SDL_SwapBE16(src[4]));\n        const Sint32 sample5 = (Sint32) ((Sint16) SDL_SwapBE16(src[5]));\n        const Sint32 sample6 = (Sint32) ((Sint16) SDL_SwapBE16(src[6]));\n        const Sint32 sample7 = (Sint32) ((Sint16) SDL_SwapBE16(src[7]));\n        src += 16;\n        dst[0] = (Sint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint16) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Sint16) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Sint16) ((sample3 + last_sample3) >> 1);\n        dst[4] = (Sint16) ((sample4 + last_sample4) >> 1);\n        dst[5] = (Sint16) ((sample5 + last_sample5) >> 1);\n        dst[6] = (Sint16) ((sample6 + last_sample6) >> 1);\n        dst[7] = (Sint16) ((sample7 + last_sample7) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        last_sample6 = sample6;\n        last_sample7 = sample7;\n        dst += 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S16MSB_8c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_S16MSB, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Sint16 *dst = ((Sint16 *) (cvt->buf + dstsize)) - 8 * 4;\n    const Sint16 *src = ((Sint16 *) (cvt->buf + cvt->len_cvt)) - 8;\n    const Sint16 *target = ((const Sint16 *) cvt->buf);\n    Sint32 last_sample7 = (Sint32) ((Sint16) SDL_SwapBE16(src[7]));\n    Sint32 last_sample6 = (Sint32) ((Sint16) SDL_SwapBE16(src[6]));\n    Sint32 last_sample5 = (Sint32) ((Sint16) SDL_SwapBE16(src[5]));\n    Sint32 last_sample4 = (Sint32) ((Sint16) SDL_SwapBE16(src[4]));\n    Sint32 last_sample3 = (Sint32) ((Sint16) SDL_SwapBE16(src[3]));\n    Sint32 last_sample2 = (Sint32) ((Sint16) SDL_SwapBE16(src[2]));\n    Sint32 last_sample1 = (Sint32) ((Sint16) SDL_SwapBE16(src[1]));\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n    while (dst >= target) {\n        const Sint32 sample7 = (Sint32) ((Sint16) SDL_SwapBE16(src[7]));\n        const Sint32 sample6 = (Sint32) ((Sint16) SDL_SwapBE16(src[6]));\n        const Sint32 sample5 = (Sint32) ((Sint16) SDL_SwapBE16(src[5]));\n        const Sint32 sample4 = (Sint32) ((Sint16) SDL_SwapBE16(src[4]));\n        const Sint32 sample3 = (Sint32) ((Sint16) SDL_SwapBE16(src[3]));\n        const Sint32 sample2 = (Sint32) ((Sint16) SDL_SwapBE16(src[2]));\n        const Sint32 sample1 = (Sint32) ((Sint16) SDL_SwapBE16(src[1]));\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n        src -= 8;\n        dst[31] = (Sint16) ((sample7 + (3 * last_sample7)) >> 2);\n        dst[30] = (Sint16) ((sample6 + (3 * last_sample6)) >> 2);\n        dst[29] = (Sint16) ((sample5 + (3 * last_sample5)) >> 2);\n        dst[28] = (Sint16) ((sample4 + (3 * last_sample4)) >> 2);\n        dst[27] = (Sint16) ((sample3 + (3 * last_sample3)) >> 2);\n        dst[26] = (Sint16) ((sample2 + (3 * last_sample2)) >> 2);\n        dst[25] = (Sint16) ((sample1 + (3 * last_sample1)) >> 2);\n        dst[24] = (Sint16) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[23] = (Sint16) ((sample7 + last_sample7) >> 1);\n        dst[22] = (Sint16) ((sample6 + last_sample6) >> 1);\n        dst[21] = (Sint16) ((sample5 + last_sample5) >> 1);\n        dst[20] = (Sint16) ((sample4 + last_sample4) >> 1);\n        dst[19] = (Sint16) ((sample3 + last_sample3) >> 1);\n        dst[18] = (Sint16) ((sample2 + last_sample2) >> 1);\n        dst[17] = (Sint16) ((sample1 + last_sample1) >> 1);\n        dst[16] = (Sint16) ((sample0 + last_sample0) >> 1);\n        dst[15] = (Sint16) (((3 * sample7) + last_sample7) >> 2);\n        dst[14] = (Sint16) (((3 * sample6) + last_sample6) >> 2);\n        dst[13] = (Sint16) (((3 * sample5) + last_sample5) >> 2);\n        dst[12] = (Sint16) (((3 * sample4) + last_sample4) >> 2);\n        dst[11] = (Sint16) (((3 * sample3) + last_sample3) >> 2);\n        dst[10] = (Sint16) (((3 * sample2) + last_sample2) >> 2);\n        dst[9] = (Sint16) (((3 * sample1) + last_sample1) >> 2);\n        dst[8] = (Sint16) (((3 * sample0) + last_sample0) >> 2);\n        dst[7] = (Sint16) sample7;\n        dst[6] = (Sint16) sample6;\n        dst[5] = (Sint16) sample5;\n        dst[4] = (Sint16) sample4;\n        dst[3] = (Sint16) sample3;\n        dst[2] = (Sint16) sample2;\n        dst[1] = (Sint16) sample1;\n        dst[0] = (Sint16) sample0;\n        last_sample7 = sample7;\n        last_sample6 = sample6;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 32;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S16MSB_8c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_S16MSB, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Sint16 *dst = (Sint16 *) cvt->buf;\n    const Sint16 *src = (Sint16 *) cvt->buf;\n    const Sint16 *target = (const Sint16 *) (cvt->buf + dstsize);\n    Sint32 last_sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n    Sint32 last_sample1 = (Sint32) ((Sint16) SDL_SwapBE16(src[1]));\n    Sint32 last_sample2 = (Sint32) ((Sint16) SDL_SwapBE16(src[2]));\n    Sint32 last_sample3 = (Sint32) ((Sint16) SDL_SwapBE16(src[3]));\n    Sint32 last_sample4 = (Sint32) ((Sint16) SDL_SwapBE16(src[4]));\n    Sint32 last_sample5 = (Sint32) ((Sint16) SDL_SwapBE16(src[5]));\n    Sint32 last_sample6 = (Sint32) ((Sint16) SDL_SwapBE16(src[6]));\n    Sint32 last_sample7 = (Sint32) ((Sint16) SDL_SwapBE16(src[7]));\n    while (dst < target) {\n        const Sint32 sample0 = (Sint32) ((Sint16) SDL_SwapBE16(src[0]));\n        const Sint32 sample1 = (Sint32) ((Sint16) SDL_SwapBE16(src[1]));\n        const Sint32 sample2 = (Sint32) ((Sint16) SDL_SwapBE16(src[2]));\n        const Sint32 sample3 = (Sint32) ((Sint16) SDL_SwapBE16(src[3]));\n        const Sint32 sample4 = (Sint32) ((Sint16) SDL_SwapBE16(src[4]));\n        const Sint32 sample5 = (Sint32) ((Sint16) SDL_SwapBE16(src[5]));\n        const Sint32 sample6 = (Sint32) ((Sint16) SDL_SwapBE16(src[6]));\n        const Sint32 sample7 = (Sint32) ((Sint16) SDL_SwapBE16(src[7]));\n        src += 32;\n        dst[0] = (Sint16) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint16) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Sint16) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Sint16) ((sample3 + last_sample3) >> 1);\n        dst[4] = (Sint16) ((sample4 + last_sample4) >> 1);\n        dst[5] = (Sint16) ((sample5 + last_sample5) >> 1);\n        dst[6] = (Sint16) ((sample6 + last_sample6) >> 1);\n        dst[7] = (Sint16) ((sample7 + last_sample7) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        last_sample6 = sample6;\n        last_sample7 = sample7;\n        dst += 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S32LSB_1c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_S32LSB, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Sint32 *dst = ((Sint32 *) (cvt->buf + dstsize)) - 1 * 2;\n    const Sint32 *src = ((Sint32 *) (cvt->buf + cvt->len_cvt)) - 1;\n    const Sint32 *target = ((const Sint32 *) cvt->buf);\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n    while (dst >= target) {\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n        src--;\n        dst[1] = (Sint32) ((sample0 + last_sample0) >> 1);\n        dst[0] = (Sint32) sample0;\n        last_sample0 = sample0;\n        dst -= 2;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S32LSB_1c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_S32LSB, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Sint32 *dst = (Sint32 *) cvt->buf;\n    const Sint32 *src = (Sint32 *) cvt->buf;\n    const Sint32 *target = (const Sint32 *) (cvt->buf + dstsize);\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n    while (dst < target) {\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n        src += 2;\n        dst[0] = (Sint32) ((sample0 + last_sample0) >> 1);\n        last_sample0 = sample0;\n        dst++;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S32LSB_1c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_S32LSB, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Sint32 *dst = ((Sint32 *) (cvt->buf + dstsize)) - 1 * 4;\n    const Sint32 *src = ((Sint32 *) (cvt->buf + cvt->len_cvt)) - 1;\n    const Sint32 *target = ((const Sint32 *) cvt->buf);\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n    while (dst >= target) {\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n        src--;\n        dst[3] = (Sint32) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[2] = (Sint32) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint32) (((3 * sample0) + last_sample0) >> 2);\n        dst[0] = (Sint32) sample0;\n        last_sample0 = sample0;\n        dst -= 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S32LSB_1c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_S32LSB, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Sint32 *dst = (Sint32 *) cvt->buf;\n    const Sint32 *src = (Sint32 *) cvt->buf;\n    const Sint32 *target = (const Sint32 *) (cvt->buf + dstsize);\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n    while (dst < target) {\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n        src += 4;\n        dst[0] = (Sint32) ((sample0 + last_sample0) >> 1);\n        last_sample0 = sample0;\n        dst++;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S32LSB_2c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_S32LSB, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Sint32 *dst = ((Sint32 *) (cvt->buf + dstsize)) - 2 * 2;\n    const Sint32 *src = ((Sint32 *) (cvt->buf + cvt->len_cvt)) - 2;\n    const Sint32 *target = ((const Sint32 *) cvt->buf);\n    Sint64 last_sample1 = (Sint64) ((Sint32) SDL_SwapLE32(src[1]));\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n    while (dst >= target) {\n        const Sint64 sample1 = (Sint64) ((Sint32) SDL_SwapLE32(src[1]));\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n        src -= 2;\n        dst[3] = (Sint32) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Sint32) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint32) sample1;\n        dst[0] = (Sint32) sample0;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S32LSB_2c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_S32LSB, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Sint32 *dst = (Sint32 *) cvt->buf;\n    const Sint32 *src = (Sint32 *) cvt->buf;\n    const Sint32 *target = (const Sint32 *) (cvt->buf + dstsize);\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n    Sint64 last_sample1 = (Sint64) ((Sint32) SDL_SwapLE32(src[1]));\n    while (dst < target) {\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n        const Sint64 sample1 = (Sint64) ((Sint32) SDL_SwapLE32(src[1]));\n        src += 4;\n        dst[0] = (Sint32) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint32) ((sample1 + last_sample1) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        dst += 2;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S32LSB_2c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_S32LSB, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Sint32 *dst = ((Sint32 *) (cvt->buf + dstsize)) - 2 * 4;\n    const Sint32 *src = ((Sint32 *) (cvt->buf + cvt->len_cvt)) - 2;\n    const Sint32 *target = ((const Sint32 *) cvt->buf);\n    Sint64 last_sample1 = (Sint64) ((Sint32) SDL_SwapLE32(src[1]));\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n    while (dst >= target) {\n        const Sint64 sample1 = (Sint64) ((Sint32) SDL_SwapLE32(src[1]));\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n        src -= 2;\n        dst[7] = (Sint32) ((sample1 + (3 * last_sample1)) >> 2);\n        dst[6] = (Sint32) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[5] = (Sint32) ((sample1 + last_sample1) >> 1);\n        dst[4] = (Sint32) ((sample0 + last_sample0) >> 1);\n        dst[3] = (Sint32) (((3 * sample1) + last_sample1) >> 2);\n        dst[2] = (Sint32) (((3 * sample0) + last_sample0) >> 2);\n        dst[1] = (Sint32) sample1;\n        dst[0] = (Sint32) sample0;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S32LSB_2c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_S32LSB, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Sint32 *dst = (Sint32 *) cvt->buf;\n    const Sint32 *src = (Sint32 *) cvt->buf;\n    const Sint32 *target = (const Sint32 *) (cvt->buf + dstsize);\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n    Sint64 last_sample1 = (Sint64) ((Sint32) SDL_SwapLE32(src[1]));\n    while (dst < target) {\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n        const Sint64 sample1 = (Sint64) ((Sint32) SDL_SwapLE32(src[1]));\n        src += 8;\n        dst[0] = (Sint32) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint32) ((sample1 + last_sample1) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        dst += 2;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S32LSB_4c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_S32LSB, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Sint32 *dst = ((Sint32 *) (cvt->buf + dstsize)) - 4 * 2;\n    const Sint32 *src = ((Sint32 *) (cvt->buf + cvt->len_cvt)) - 4;\n    const Sint32 *target = ((const Sint32 *) cvt->buf);\n    Sint64 last_sample3 = (Sint64) ((Sint32) SDL_SwapLE32(src[3]));\n    Sint64 last_sample2 = (Sint64) ((Sint32) SDL_SwapLE32(src[2]));\n    Sint64 last_sample1 = (Sint64) ((Sint32) SDL_SwapLE32(src[1]));\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n    while (dst >= target) {\n        const Sint64 sample3 = (Sint64) ((Sint32) SDL_SwapLE32(src[3]));\n        const Sint64 sample2 = (Sint64) ((Sint32) SDL_SwapLE32(src[2]));\n        const Sint64 sample1 = (Sint64) ((Sint32) SDL_SwapLE32(src[1]));\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n        src -= 4;\n        dst[7] = (Sint32) ((sample3 + last_sample3) >> 1);\n        dst[6] = (Sint32) ((sample2 + last_sample2) >> 1);\n        dst[5] = (Sint32) ((sample1 + last_sample1) >> 1);\n        dst[4] = (Sint32) ((sample0 + last_sample0) >> 1);\n        dst[3] = (Sint32) sample3;\n        dst[2] = (Sint32) sample2;\n        dst[1] = (Sint32) sample1;\n        dst[0] = (Sint32) sample0;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S32LSB_4c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_S32LSB, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Sint32 *dst = (Sint32 *) cvt->buf;\n    const Sint32 *src = (Sint32 *) cvt->buf;\n    const Sint32 *target = (const Sint32 *) (cvt->buf + dstsize);\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n    Sint64 last_sample1 = (Sint64) ((Sint32) SDL_SwapLE32(src[1]));\n    Sint64 last_sample2 = (Sint64) ((Sint32) SDL_SwapLE32(src[2]));\n    Sint64 last_sample3 = (Sint64) ((Sint32) SDL_SwapLE32(src[3]));\n    while (dst < target) {\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n        const Sint64 sample1 = (Sint64) ((Sint32) SDL_SwapLE32(src[1]));\n        const Sint64 sample2 = (Sint64) ((Sint32) SDL_SwapLE32(src[2]));\n        const Sint64 sample3 = (Sint64) ((Sint32) SDL_SwapLE32(src[3]));\n        src += 8;\n        dst[0] = (Sint32) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint32) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Sint32) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Sint32) ((sample3 + last_sample3) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        dst += 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S32LSB_4c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_S32LSB, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Sint32 *dst = ((Sint32 *) (cvt->buf + dstsize)) - 4 * 4;\n    const Sint32 *src = ((Sint32 *) (cvt->buf + cvt->len_cvt)) - 4;\n    const Sint32 *target = ((const Sint32 *) cvt->buf);\n    Sint64 last_sample3 = (Sint64) ((Sint32) SDL_SwapLE32(src[3]));\n    Sint64 last_sample2 = (Sint64) ((Sint32) SDL_SwapLE32(src[2]));\n    Sint64 last_sample1 = (Sint64) ((Sint32) SDL_SwapLE32(src[1]));\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n    while (dst >= target) {\n        const Sint64 sample3 = (Sint64) ((Sint32) SDL_SwapLE32(src[3]));\n        const Sint64 sample2 = (Sint64) ((Sint32) SDL_SwapLE32(src[2]));\n        const Sint64 sample1 = (Sint64) ((Sint32) SDL_SwapLE32(src[1]));\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n        src -= 4;\n        dst[15] = (Sint32) ((sample3 + (3 * last_sample3)) >> 2);\n        dst[14] = (Sint32) ((sample2 + (3 * last_sample2)) >> 2);\n        dst[13] = (Sint32) ((sample1 + (3 * last_sample1)) >> 2);\n        dst[12] = (Sint32) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[11] = (Sint32) ((sample3 + last_sample3) >> 1);\n        dst[10] = (Sint32) ((sample2 + last_sample2) >> 1);\n        dst[9] = (Sint32) ((sample1 + last_sample1) >> 1);\n        dst[8] = (Sint32) ((sample0 + last_sample0) >> 1);\n        dst[7] = (Sint32) (((3 * sample3) + last_sample3) >> 2);\n        dst[6] = (Sint32) (((3 * sample2) + last_sample2) >> 2);\n        dst[5] = (Sint32) (((3 * sample1) + last_sample1) >> 2);\n        dst[4] = (Sint32) (((3 * sample0) + last_sample0) >> 2);\n        dst[3] = (Sint32) sample3;\n        dst[2] = (Sint32) sample2;\n        dst[1] = (Sint32) sample1;\n        dst[0] = (Sint32) sample0;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 16;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S32LSB_4c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_S32LSB, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Sint32 *dst = (Sint32 *) cvt->buf;\n    const Sint32 *src = (Sint32 *) cvt->buf;\n    const Sint32 *target = (const Sint32 *) (cvt->buf + dstsize);\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n    Sint64 last_sample1 = (Sint64) ((Sint32) SDL_SwapLE32(src[1]));\n    Sint64 last_sample2 = (Sint64) ((Sint32) SDL_SwapLE32(src[2]));\n    Sint64 last_sample3 = (Sint64) ((Sint32) SDL_SwapLE32(src[3]));\n    while (dst < target) {\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n        const Sint64 sample1 = (Sint64) ((Sint32) SDL_SwapLE32(src[1]));\n        const Sint64 sample2 = (Sint64) ((Sint32) SDL_SwapLE32(src[2]));\n        const Sint64 sample3 = (Sint64) ((Sint32) SDL_SwapLE32(src[3]));\n        src += 16;\n        dst[0] = (Sint32) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint32) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Sint32) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Sint32) ((sample3 + last_sample3) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        dst += 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S32LSB_6c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_S32LSB, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Sint32 *dst = ((Sint32 *) (cvt->buf + dstsize)) - 6 * 2;\n    const Sint32 *src = ((Sint32 *) (cvt->buf + cvt->len_cvt)) - 6;\n    const Sint32 *target = ((const Sint32 *) cvt->buf);\n    Sint64 last_sample5 = (Sint64) ((Sint32) SDL_SwapLE32(src[5]));\n    Sint64 last_sample4 = (Sint64) ((Sint32) SDL_SwapLE32(src[4]));\n    Sint64 last_sample3 = (Sint64) ((Sint32) SDL_SwapLE32(src[3]));\n    Sint64 last_sample2 = (Sint64) ((Sint32) SDL_SwapLE32(src[2]));\n    Sint64 last_sample1 = (Sint64) ((Sint32) SDL_SwapLE32(src[1]));\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n    while (dst >= target) {\n        const Sint64 sample5 = (Sint64) ((Sint32) SDL_SwapLE32(src[5]));\n        const Sint64 sample4 = (Sint64) ((Sint32) SDL_SwapLE32(src[4]));\n        const Sint64 sample3 = (Sint64) ((Sint32) SDL_SwapLE32(src[3]));\n        const Sint64 sample2 = (Sint64) ((Sint32) SDL_SwapLE32(src[2]));\n        const Sint64 sample1 = (Sint64) ((Sint32) SDL_SwapLE32(src[1]));\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n        src -= 6;\n        dst[11] = (Sint32) ((sample5 + last_sample5) >> 1);\n        dst[10] = (Sint32) ((sample4 + last_sample4) >> 1);\n        dst[9] = (Sint32) ((sample3 + last_sample3) >> 1);\n        dst[8] = (Sint32) ((sample2 + last_sample2) >> 1);\n        dst[7] = (Sint32) ((sample1 + last_sample1) >> 1);\n        dst[6] = (Sint32) ((sample0 + last_sample0) >> 1);\n        dst[5] = (Sint32) sample5;\n        dst[4] = (Sint32) sample4;\n        dst[3] = (Sint32) sample3;\n        dst[2] = (Sint32) sample2;\n        dst[1] = (Sint32) sample1;\n        dst[0] = (Sint32) sample0;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 12;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S32LSB_6c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_S32LSB, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Sint32 *dst = (Sint32 *) cvt->buf;\n    const Sint32 *src = (Sint32 *) cvt->buf;\n    const Sint32 *target = (const Sint32 *) (cvt->buf + dstsize);\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n    Sint64 last_sample1 = (Sint64) ((Sint32) SDL_SwapLE32(src[1]));\n    Sint64 last_sample2 = (Sint64) ((Sint32) SDL_SwapLE32(src[2]));\n    Sint64 last_sample3 = (Sint64) ((Sint32) SDL_SwapLE32(src[3]));\n    Sint64 last_sample4 = (Sint64) ((Sint32) SDL_SwapLE32(src[4]));\n    Sint64 last_sample5 = (Sint64) ((Sint32) SDL_SwapLE32(src[5]));\n    while (dst < target) {\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n        const Sint64 sample1 = (Sint64) ((Sint32) SDL_SwapLE32(src[1]));\n        const Sint64 sample2 = (Sint64) ((Sint32) SDL_SwapLE32(src[2]));\n        const Sint64 sample3 = (Sint64) ((Sint32) SDL_SwapLE32(src[3]));\n        const Sint64 sample4 = (Sint64) ((Sint32) SDL_SwapLE32(src[4]));\n        const Sint64 sample5 = (Sint64) ((Sint32) SDL_SwapLE32(src[5]));\n        src += 12;\n        dst[0] = (Sint32) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint32) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Sint32) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Sint32) ((sample3 + last_sample3) >> 1);\n        dst[4] = (Sint32) ((sample4 + last_sample4) >> 1);\n        dst[5] = (Sint32) ((sample5 + last_sample5) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        dst += 6;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S32LSB_6c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_S32LSB, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Sint32 *dst = ((Sint32 *) (cvt->buf + dstsize)) - 6 * 4;\n    const Sint32 *src = ((Sint32 *) (cvt->buf + cvt->len_cvt)) - 6;\n    const Sint32 *target = ((const Sint32 *) cvt->buf);\n    Sint64 last_sample5 = (Sint64) ((Sint32) SDL_SwapLE32(src[5]));\n    Sint64 last_sample4 = (Sint64) ((Sint32) SDL_SwapLE32(src[4]));\n    Sint64 last_sample3 = (Sint64) ((Sint32) SDL_SwapLE32(src[3]));\n    Sint64 last_sample2 = (Sint64) ((Sint32) SDL_SwapLE32(src[2]));\n    Sint64 last_sample1 = (Sint64) ((Sint32) SDL_SwapLE32(src[1]));\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n    while (dst >= target) {\n        const Sint64 sample5 = (Sint64) ((Sint32) SDL_SwapLE32(src[5]));\n        const Sint64 sample4 = (Sint64) ((Sint32) SDL_SwapLE32(src[4]));\n        const Sint64 sample3 = (Sint64) ((Sint32) SDL_SwapLE32(src[3]));\n        const Sint64 sample2 = (Sint64) ((Sint32) SDL_SwapLE32(src[2]));\n        const Sint64 sample1 = (Sint64) ((Sint32) SDL_SwapLE32(src[1]));\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n        src -= 6;\n        dst[23] = (Sint32) ((sample5 + (3 * last_sample5)) >> 2);\n        dst[22] = (Sint32) ((sample4 + (3 * last_sample4)) >> 2);\n        dst[21] = (Sint32) ((sample3 + (3 * last_sample3)) >> 2);\n        dst[20] = (Sint32) ((sample2 + (3 * last_sample2)) >> 2);\n        dst[19] = (Sint32) ((sample1 + (3 * last_sample1)) >> 2);\n        dst[18] = (Sint32) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[17] = (Sint32) ((sample5 + last_sample5) >> 1);\n        dst[16] = (Sint32) ((sample4 + last_sample4) >> 1);\n        dst[15] = (Sint32) ((sample3 + last_sample3) >> 1);\n        dst[14] = (Sint32) ((sample2 + last_sample2) >> 1);\n        dst[13] = (Sint32) ((sample1 + last_sample1) >> 1);\n        dst[12] = (Sint32) ((sample0 + last_sample0) >> 1);\n        dst[11] = (Sint32) (((3 * sample5) + last_sample5) >> 2);\n        dst[10] = (Sint32) (((3 * sample4) + last_sample4) >> 2);\n        dst[9] = (Sint32) (((3 * sample3) + last_sample3) >> 2);\n        dst[8] = (Sint32) (((3 * sample2) + last_sample2) >> 2);\n        dst[7] = (Sint32) (((3 * sample1) + last_sample1) >> 2);\n        dst[6] = (Sint32) (((3 * sample0) + last_sample0) >> 2);\n        dst[5] = (Sint32) sample5;\n        dst[4] = (Sint32) sample4;\n        dst[3] = (Sint32) sample3;\n        dst[2] = (Sint32) sample2;\n        dst[1] = (Sint32) sample1;\n        dst[0] = (Sint32) sample0;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 24;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S32LSB_6c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_S32LSB, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Sint32 *dst = (Sint32 *) cvt->buf;\n    const Sint32 *src = (Sint32 *) cvt->buf;\n    const Sint32 *target = (const Sint32 *) (cvt->buf + dstsize);\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n    Sint64 last_sample1 = (Sint64) ((Sint32) SDL_SwapLE32(src[1]));\n    Sint64 last_sample2 = (Sint64) ((Sint32) SDL_SwapLE32(src[2]));\n    Sint64 last_sample3 = (Sint64) ((Sint32) SDL_SwapLE32(src[3]));\n    Sint64 last_sample4 = (Sint64) ((Sint32) SDL_SwapLE32(src[4]));\n    Sint64 last_sample5 = (Sint64) ((Sint32) SDL_SwapLE32(src[5]));\n    while (dst < target) {\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n        const Sint64 sample1 = (Sint64) ((Sint32) SDL_SwapLE32(src[1]));\n        const Sint64 sample2 = (Sint64) ((Sint32) SDL_SwapLE32(src[2]));\n        const Sint64 sample3 = (Sint64) ((Sint32) SDL_SwapLE32(src[3]));\n        const Sint64 sample4 = (Sint64) ((Sint32) SDL_SwapLE32(src[4]));\n        const Sint64 sample5 = (Sint64) ((Sint32) SDL_SwapLE32(src[5]));\n        src += 24;\n        dst[0] = (Sint32) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint32) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Sint32) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Sint32) ((sample3 + last_sample3) >> 1);\n        dst[4] = (Sint32) ((sample4 + last_sample4) >> 1);\n        dst[5] = (Sint32) ((sample5 + last_sample5) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        dst += 6;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S32LSB_8c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_S32LSB, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Sint32 *dst = ((Sint32 *) (cvt->buf + dstsize)) - 8 * 2;\n    const Sint32 *src = ((Sint32 *) (cvt->buf + cvt->len_cvt)) - 8;\n    const Sint32 *target = ((const Sint32 *) cvt->buf);\n    Sint64 last_sample7 = (Sint64) ((Sint32) SDL_SwapLE32(src[7]));\n    Sint64 last_sample6 = (Sint64) ((Sint32) SDL_SwapLE32(src[6]));\n    Sint64 last_sample5 = (Sint64) ((Sint32) SDL_SwapLE32(src[5]));\n    Sint64 last_sample4 = (Sint64) ((Sint32) SDL_SwapLE32(src[4]));\n    Sint64 last_sample3 = (Sint64) ((Sint32) SDL_SwapLE32(src[3]));\n    Sint64 last_sample2 = (Sint64) ((Sint32) SDL_SwapLE32(src[2]));\n    Sint64 last_sample1 = (Sint64) ((Sint32) SDL_SwapLE32(src[1]));\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n    while (dst >= target) {\n        const Sint64 sample7 = (Sint64) ((Sint32) SDL_SwapLE32(src[7]));\n        const Sint64 sample6 = (Sint64) ((Sint32) SDL_SwapLE32(src[6]));\n        const Sint64 sample5 = (Sint64) ((Sint32) SDL_SwapLE32(src[5]));\n        const Sint64 sample4 = (Sint64) ((Sint32) SDL_SwapLE32(src[4]));\n        const Sint64 sample3 = (Sint64) ((Sint32) SDL_SwapLE32(src[3]));\n        const Sint64 sample2 = (Sint64) ((Sint32) SDL_SwapLE32(src[2]));\n        const Sint64 sample1 = (Sint64) ((Sint32) SDL_SwapLE32(src[1]));\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n        src -= 8;\n        dst[15] = (Sint32) ((sample7 + last_sample7) >> 1);\n        dst[14] = (Sint32) ((sample6 + last_sample6) >> 1);\n        dst[13] = (Sint32) ((sample5 + last_sample5) >> 1);\n        dst[12] = (Sint32) ((sample4 + last_sample4) >> 1);\n        dst[11] = (Sint32) ((sample3 + last_sample3) >> 1);\n        dst[10] = (Sint32) ((sample2 + last_sample2) >> 1);\n        dst[9] = (Sint32) ((sample1 + last_sample1) >> 1);\n        dst[8] = (Sint32) ((sample0 + last_sample0) >> 1);\n        dst[7] = (Sint32) sample7;\n        dst[6] = (Sint32) sample6;\n        dst[5] = (Sint32) sample5;\n        dst[4] = (Sint32) sample4;\n        dst[3] = (Sint32) sample3;\n        dst[2] = (Sint32) sample2;\n        dst[1] = (Sint32) sample1;\n        dst[0] = (Sint32) sample0;\n        last_sample7 = sample7;\n        last_sample6 = sample6;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 16;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S32LSB_8c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_S32LSB, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Sint32 *dst = (Sint32 *) cvt->buf;\n    const Sint32 *src = (Sint32 *) cvt->buf;\n    const Sint32 *target = (const Sint32 *) (cvt->buf + dstsize);\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n    Sint64 last_sample1 = (Sint64) ((Sint32) SDL_SwapLE32(src[1]));\n    Sint64 last_sample2 = (Sint64) ((Sint32) SDL_SwapLE32(src[2]));\n    Sint64 last_sample3 = (Sint64) ((Sint32) SDL_SwapLE32(src[3]));\n    Sint64 last_sample4 = (Sint64) ((Sint32) SDL_SwapLE32(src[4]));\n    Sint64 last_sample5 = (Sint64) ((Sint32) SDL_SwapLE32(src[5]));\n    Sint64 last_sample6 = (Sint64) ((Sint32) SDL_SwapLE32(src[6]));\n    Sint64 last_sample7 = (Sint64) ((Sint32) SDL_SwapLE32(src[7]));\n    while (dst < target) {\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n        const Sint64 sample1 = (Sint64) ((Sint32) SDL_SwapLE32(src[1]));\n        const Sint64 sample2 = (Sint64) ((Sint32) SDL_SwapLE32(src[2]));\n        const Sint64 sample3 = (Sint64) ((Sint32) SDL_SwapLE32(src[3]));\n        const Sint64 sample4 = (Sint64) ((Sint32) SDL_SwapLE32(src[4]));\n        const Sint64 sample5 = (Sint64) ((Sint32) SDL_SwapLE32(src[5]));\n        const Sint64 sample6 = (Sint64) ((Sint32) SDL_SwapLE32(src[6]));\n        const Sint64 sample7 = (Sint64) ((Sint32) SDL_SwapLE32(src[7]));\n        src += 16;\n        dst[0] = (Sint32) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint32) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Sint32) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Sint32) ((sample3 + last_sample3) >> 1);\n        dst[4] = (Sint32) ((sample4 + last_sample4) >> 1);\n        dst[5] = (Sint32) ((sample5 + last_sample5) >> 1);\n        dst[6] = (Sint32) ((sample6 + last_sample6) >> 1);\n        dst[7] = (Sint32) ((sample7 + last_sample7) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        last_sample6 = sample6;\n        last_sample7 = sample7;\n        dst += 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S32LSB_8c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_S32LSB, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Sint32 *dst = ((Sint32 *) (cvt->buf + dstsize)) - 8 * 4;\n    const Sint32 *src = ((Sint32 *) (cvt->buf + cvt->len_cvt)) - 8;\n    const Sint32 *target = ((const Sint32 *) cvt->buf);\n    Sint64 last_sample7 = (Sint64) ((Sint32) SDL_SwapLE32(src[7]));\n    Sint64 last_sample6 = (Sint64) ((Sint32) SDL_SwapLE32(src[6]));\n    Sint64 last_sample5 = (Sint64) ((Sint32) SDL_SwapLE32(src[5]));\n    Sint64 last_sample4 = (Sint64) ((Sint32) SDL_SwapLE32(src[4]));\n    Sint64 last_sample3 = (Sint64) ((Sint32) SDL_SwapLE32(src[3]));\n    Sint64 last_sample2 = (Sint64) ((Sint32) SDL_SwapLE32(src[2]));\n    Sint64 last_sample1 = (Sint64) ((Sint32) SDL_SwapLE32(src[1]));\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n    while (dst >= target) {\n        const Sint64 sample7 = (Sint64) ((Sint32) SDL_SwapLE32(src[7]));\n        const Sint64 sample6 = (Sint64) ((Sint32) SDL_SwapLE32(src[6]));\n        const Sint64 sample5 = (Sint64) ((Sint32) SDL_SwapLE32(src[5]));\n        const Sint64 sample4 = (Sint64) ((Sint32) SDL_SwapLE32(src[4]));\n        const Sint64 sample3 = (Sint64) ((Sint32) SDL_SwapLE32(src[3]));\n        const Sint64 sample2 = (Sint64) ((Sint32) SDL_SwapLE32(src[2]));\n        const Sint64 sample1 = (Sint64) ((Sint32) SDL_SwapLE32(src[1]));\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n        src -= 8;\n        dst[31] = (Sint32) ((sample7 + (3 * last_sample7)) >> 2);\n        dst[30] = (Sint32) ((sample6 + (3 * last_sample6)) >> 2);\n        dst[29] = (Sint32) ((sample5 + (3 * last_sample5)) >> 2);\n        dst[28] = (Sint32) ((sample4 + (3 * last_sample4)) >> 2);\n        dst[27] = (Sint32) ((sample3 + (3 * last_sample3)) >> 2);\n        dst[26] = (Sint32) ((sample2 + (3 * last_sample2)) >> 2);\n        dst[25] = (Sint32) ((sample1 + (3 * last_sample1)) >> 2);\n        dst[24] = (Sint32) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[23] = (Sint32) ((sample7 + last_sample7) >> 1);\n        dst[22] = (Sint32) ((sample6 + last_sample6) >> 1);\n        dst[21] = (Sint32) ((sample5 + last_sample5) >> 1);\n        dst[20] = (Sint32) ((sample4 + last_sample4) >> 1);\n        dst[19] = (Sint32) ((sample3 + last_sample3) >> 1);\n        dst[18] = (Sint32) ((sample2 + last_sample2) >> 1);\n        dst[17] = (Sint32) ((sample1 + last_sample1) >> 1);\n        dst[16] = (Sint32) ((sample0 + last_sample0) >> 1);\n        dst[15] = (Sint32) (((3 * sample7) + last_sample7) >> 2);\n        dst[14] = (Sint32) (((3 * sample6) + last_sample6) >> 2);\n        dst[13] = (Sint32) (((3 * sample5) + last_sample5) >> 2);\n        dst[12] = (Sint32) (((3 * sample4) + last_sample4) >> 2);\n        dst[11] = (Sint32) (((3 * sample3) + last_sample3) >> 2);\n        dst[10] = (Sint32) (((3 * sample2) + last_sample2) >> 2);\n        dst[9] = (Sint32) (((3 * sample1) + last_sample1) >> 2);\n        dst[8] = (Sint32) (((3 * sample0) + last_sample0) >> 2);\n        dst[7] = (Sint32) sample7;\n        dst[6] = (Sint32) sample6;\n        dst[5] = (Sint32) sample5;\n        dst[4] = (Sint32) sample4;\n        dst[3] = (Sint32) sample3;\n        dst[2] = (Sint32) sample2;\n        dst[1] = (Sint32) sample1;\n        dst[0] = (Sint32) sample0;\n        last_sample7 = sample7;\n        last_sample6 = sample6;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 32;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S32LSB_8c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_S32LSB, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Sint32 *dst = (Sint32 *) cvt->buf;\n    const Sint32 *src = (Sint32 *) cvt->buf;\n    const Sint32 *target = (const Sint32 *) (cvt->buf + dstsize);\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n    Sint64 last_sample1 = (Sint64) ((Sint32) SDL_SwapLE32(src[1]));\n    Sint64 last_sample2 = (Sint64) ((Sint32) SDL_SwapLE32(src[2]));\n    Sint64 last_sample3 = (Sint64) ((Sint32) SDL_SwapLE32(src[3]));\n    Sint64 last_sample4 = (Sint64) ((Sint32) SDL_SwapLE32(src[4]));\n    Sint64 last_sample5 = (Sint64) ((Sint32) SDL_SwapLE32(src[5]));\n    Sint64 last_sample6 = (Sint64) ((Sint32) SDL_SwapLE32(src[6]));\n    Sint64 last_sample7 = (Sint64) ((Sint32) SDL_SwapLE32(src[7]));\n    while (dst < target) {\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapLE32(src[0]));\n        const Sint64 sample1 = (Sint64) ((Sint32) SDL_SwapLE32(src[1]));\n        const Sint64 sample2 = (Sint64) ((Sint32) SDL_SwapLE32(src[2]));\n        const Sint64 sample3 = (Sint64) ((Sint32) SDL_SwapLE32(src[3]));\n        const Sint64 sample4 = (Sint64) ((Sint32) SDL_SwapLE32(src[4]));\n        const Sint64 sample5 = (Sint64) ((Sint32) SDL_SwapLE32(src[5]));\n        const Sint64 sample6 = (Sint64) ((Sint32) SDL_SwapLE32(src[6]));\n        const Sint64 sample7 = (Sint64) ((Sint32) SDL_SwapLE32(src[7]));\n        src += 32;\n        dst[0] = (Sint32) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint32) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Sint32) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Sint32) ((sample3 + last_sample3) >> 1);\n        dst[4] = (Sint32) ((sample4 + last_sample4) >> 1);\n        dst[5] = (Sint32) ((sample5 + last_sample5) >> 1);\n        dst[6] = (Sint32) ((sample6 + last_sample6) >> 1);\n        dst[7] = (Sint32) ((sample7 + last_sample7) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        last_sample6 = sample6;\n        last_sample7 = sample7;\n        dst += 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S32MSB_1c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_S32MSB, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Sint32 *dst = ((Sint32 *) (cvt->buf + dstsize)) - 1 * 2;\n    const Sint32 *src = ((Sint32 *) (cvt->buf + cvt->len_cvt)) - 1;\n    const Sint32 *target = ((const Sint32 *) cvt->buf);\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n    while (dst >= target) {\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n        src--;\n        dst[1] = (Sint32) ((sample0 + last_sample0) >> 1);\n        dst[0] = (Sint32) sample0;\n        last_sample0 = sample0;\n        dst -= 2;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S32MSB_1c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_S32MSB, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Sint32 *dst = (Sint32 *) cvt->buf;\n    const Sint32 *src = (Sint32 *) cvt->buf;\n    const Sint32 *target = (const Sint32 *) (cvt->buf + dstsize);\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n    while (dst < target) {\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n        src += 2;\n        dst[0] = (Sint32) ((sample0 + last_sample0) >> 1);\n        last_sample0 = sample0;\n        dst++;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S32MSB_1c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_S32MSB, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Sint32 *dst = ((Sint32 *) (cvt->buf + dstsize)) - 1 * 4;\n    const Sint32 *src = ((Sint32 *) (cvt->buf + cvt->len_cvt)) - 1;\n    const Sint32 *target = ((const Sint32 *) cvt->buf);\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n    while (dst >= target) {\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n        src--;\n        dst[3] = (Sint32) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[2] = (Sint32) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint32) (((3 * sample0) + last_sample0) >> 2);\n        dst[0] = (Sint32) sample0;\n        last_sample0 = sample0;\n        dst -= 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S32MSB_1c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_S32MSB, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Sint32 *dst = (Sint32 *) cvt->buf;\n    const Sint32 *src = (Sint32 *) cvt->buf;\n    const Sint32 *target = (const Sint32 *) (cvt->buf + dstsize);\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n    while (dst < target) {\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n        src += 4;\n        dst[0] = (Sint32) ((sample0 + last_sample0) >> 1);\n        last_sample0 = sample0;\n        dst++;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S32MSB_2c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_S32MSB, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Sint32 *dst = ((Sint32 *) (cvt->buf + dstsize)) - 2 * 2;\n    const Sint32 *src = ((Sint32 *) (cvt->buf + cvt->len_cvt)) - 2;\n    const Sint32 *target = ((const Sint32 *) cvt->buf);\n    Sint64 last_sample1 = (Sint64) ((Sint32) SDL_SwapBE32(src[1]));\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n    while (dst >= target) {\n        const Sint64 sample1 = (Sint64) ((Sint32) SDL_SwapBE32(src[1]));\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n        src -= 2;\n        dst[3] = (Sint32) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Sint32) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint32) sample1;\n        dst[0] = (Sint32) sample0;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S32MSB_2c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_S32MSB, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Sint32 *dst = (Sint32 *) cvt->buf;\n    const Sint32 *src = (Sint32 *) cvt->buf;\n    const Sint32 *target = (const Sint32 *) (cvt->buf + dstsize);\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n    Sint64 last_sample1 = (Sint64) ((Sint32) SDL_SwapBE32(src[1]));\n    while (dst < target) {\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n        const Sint64 sample1 = (Sint64) ((Sint32) SDL_SwapBE32(src[1]));\n        src += 4;\n        dst[0] = (Sint32) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint32) ((sample1 + last_sample1) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        dst += 2;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S32MSB_2c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_S32MSB, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Sint32 *dst = ((Sint32 *) (cvt->buf + dstsize)) - 2 * 4;\n    const Sint32 *src = ((Sint32 *) (cvt->buf + cvt->len_cvt)) - 2;\n    const Sint32 *target = ((const Sint32 *) cvt->buf);\n    Sint64 last_sample1 = (Sint64) ((Sint32) SDL_SwapBE32(src[1]));\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n    while (dst >= target) {\n        const Sint64 sample1 = (Sint64) ((Sint32) SDL_SwapBE32(src[1]));\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n        src -= 2;\n        dst[7] = (Sint32) ((sample1 + (3 * last_sample1)) >> 2);\n        dst[6] = (Sint32) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[5] = (Sint32) ((sample1 + last_sample1) >> 1);\n        dst[4] = (Sint32) ((sample0 + last_sample0) >> 1);\n        dst[3] = (Sint32) (((3 * sample1) + last_sample1) >> 2);\n        dst[2] = (Sint32) (((3 * sample0) + last_sample0) >> 2);\n        dst[1] = (Sint32) sample1;\n        dst[0] = (Sint32) sample0;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S32MSB_2c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_S32MSB, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Sint32 *dst = (Sint32 *) cvt->buf;\n    const Sint32 *src = (Sint32 *) cvt->buf;\n    const Sint32 *target = (const Sint32 *) (cvt->buf + dstsize);\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n    Sint64 last_sample1 = (Sint64) ((Sint32) SDL_SwapBE32(src[1]));\n    while (dst < target) {\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n        const Sint64 sample1 = (Sint64) ((Sint32) SDL_SwapBE32(src[1]));\n        src += 8;\n        dst[0] = (Sint32) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint32) ((sample1 + last_sample1) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        dst += 2;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S32MSB_4c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_S32MSB, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Sint32 *dst = ((Sint32 *) (cvt->buf + dstsize)) - 4 * 2;\n    const Sint32 *src = ((Sint32 *) (cvt->buf + cvt->len_cvt)) - 4;\n    const Sint32 *target = ((const Sint32 *) cvt->buf);\n    Sint64 last_sample3 = (Sint64) ((Sint32) SDL_SwapBE32(src[3]));\n    Sint64 last_sample2 = (Sint64) ((Sint32) SDL_SwapBE32(src[2]));\n    Sint64 last_sample1 = (Sint64) ((Sint32) SDL_SwapBE32(src[1]));\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n    while (dst >= target) {\n        const Sint64 sample3 = (Sint64) ((Sint32) SDL_SwapBE32(src[3]));\n        const Sint64 sample2 = (Sint64) ((Sint32) SDL_SwapBE32(src[2]));\n        const Sint64 sample1 = (Sint64) ((Sint32) SDL_SwapBE32(src[1]));\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n        src -= 4;\n        dst[7] = (Sint32) ((sample3 + last_sample3) >> 1);\n        dst[6] = (Sint32) ((sample2 + last_sample2) >> 1);\n        dst[5] = (Sint32) ((sample1 + last_sample1) >> 1);\n        dst[4] = (Sint32) ((sample0 + last_sample0) >> 1);\n        dst[3] = (Sint32) sample3;\n        dst[2] = (Sint32) sample2;\n        dst[1] = (Sint32) sample1;\n        dst[0] = (Sint32) sample0;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S32MSB_4c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_S32MSB, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Sint32 *dst = (Sint32 *) cvt->buf;\n    const Sint32 *src = (Sint32 *) cvt->buf;\n    const Sint32 *target = (const Sint32 *) (cvt->buf + dstsize);\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n    Sint64 last_sample1 = (Sint64) ((Sint32) SDL_SwapBE32(src[1]));\n    Sint64 last_sample2 = (Sint64) ((Sint32) SDL_SwapBE32(src[2]));\n    Sint64 last_sample3 = (Sint64) ((Sint32) SDL_SwapBE32(src[3]));\n    while (dst < target) {\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n        const Sint64 sample1 = (Sint64) ((Sint32) SDL_SwapBE32(src[1]));\n        const Sint64 sample2 = (Sint64) ((Sint32) SDL_SwapBE32(src[2]));\n        const Sint64 sample3 = (Sint64) ((Sint32) SDL_SwapBE32(src[3]));\n        src += 8;\n        dst[0] = (Sint32) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint32) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Sint32) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Sint32) ((sample3 + last_sample3) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        dst += 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S32MSB_4c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_S32MSB, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Sint32 *dst = ((Sint32 *) (cvt->buf + dstsize)) - 4 * 4;\n    const Sint32 *src = ((Sint32 *) (cvt->buf + cvt->len_cvt)) - 4;\n    const Sint32 *target = ((const Sint32 *) cvt->buf);\n    Sint64 last_sample3 = (Sint64) ((Sint32) SDL_SwapBE32(src[3]));\n    Sint64 last_sample2 = (Sint64) ((Sint32) SDL_SwapBE32(src[2]));\n    Sint64 last_sample1 = (Sint64) ((Sint32) SDL_SwapBE32(src[1]));\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n    while (dst >= target) {\n        const Sint64 sample3 = (Sint64) ((Sint32) SDL_SwapBE32(src[3]));\n        const Sint64 sample2 = (Sint64) ((Sint32) SDL_SwapBE32(src[2]));\n        const Sint64 sample1 = (Sint64) ((Sint32) SDL_SwapBE32(src[1]));\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n        src -= 4;\n        dst[15] = (Sint32) ((sample3 + (3 * last_sample3)) >> 2);\n        dst[14] = (Sint32) ((sample2 + (3 * last_sample2)) >> 2);\n        dst[13] = (Sint32) ((sample1 + (3 * last_sample1)) >> 2);\n        dst[12] = (Sint32) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[11] = (Sint32) ((sample3 + last_sample3) >> 1);\n        dst[10] = (Sint32) ((sample2 + last_sample2) >> 1);\n        dst[9] = (Sint32) ((sample1 + last_sample1) >> 1);\n        dst[8] = (Sint32) ((sample0 + last_sample0) >> 1);\n        dst[7] = (Sint32) (((3 * sample3) + last_sample3) >> 2);\n        dst[6] = (Sint32) (((3 * sample2) + last_sample2) >> 2);\n        dst[5] = (Sint32) (((3 * sample1) + last_sample1) >> 2);\n        dst[4] = (Sint32) (((3 * sample0) + last_sample0) >> 2);\n        dst[3] = (Sint32) sample3;\n        dst[2] = (Sint32) sample2;\n        dst[1] = (Sint32) sample1;\n        dst[0] = (Sint32) sample0;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 16;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S32MSB_4c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_S32MSB, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Sint32 *dst = (Sint32 *) cvt->buf;\n    const Sint32 *src = (Sint32 *) cvt->buf;\n    const Sint32 *target = (const Sint32 *) (cvt->buf + dstsize);\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n    Sint64 last_sample1 = (Sint64) ((Sint32) SDL_SwapBE32(src[1]));\n    Sint64 last_sample2 = (Sint64) ((Sint32) SDL_SwapBE32(src[2]));\n    Sint64 last_sample3 = (Sint64) ((Sint32) SDL_SwapBE32(src[3]));\n    while (dst < target) {\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n        const Sint64 sample1 = (Sint64) ((Sint32) SDL_SwapBE32(src[1]));\n        const Sint64 sample2 = (Sint64) ((Sint32) SDL_SwapBE32(src[2]));\n        const Sint64 sample3 = (Sint64) ((Sint32) SDL_SwapBE32(src[3]));\n        src += 16;\n        dst[0] = (Sint32) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint32) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Sint32) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Sint32) ((sample3 + last_sample3) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        dst += 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S32MSB_6c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_S32MSB, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Sint32 *dst = ((Sint32 *) (cvt->buf + dstsize)) - 6 * 2;\n    const Sint32 *src = ((Sint32 *) (cvt->buf + cvt->len_cvt)) - 6;\n    const Sint32 *target = ((const Sint32 *) cvt->buf);\n    Sint64 last_sample5 = (Sint64) ((Sint32) SDL_SwapBE32(src[5]));\n    Sint64 last_sample4 = (Sint64) ((Sint32) SDL_SwapBE32(src[4]));\n    Sint64 last_sample3 = (Sint64) ((Sint32) SDL_SwapBE32(src[3]));\n    Sint64 last_sample2 = (Sint64) ((Sint32) SDL_SwapBE32(src[2]));\n    Sint64 last_sample1 = (Sint64) ((Sint32) SDL_SwapBE32(src[1]));\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n    while (dst >= target) {\n        const Sint64 sample5 = (Sint64) ((Sint32) SDL_SwapBE32(src[5]));\n        const Sint64 sample4 = (Sint64) ((Sint32) SDL_SwapBE32(src[4]));\n        const Sint64 sample3 = (Sint64) ((Sint32) SDL_SwapBE32(src[3]));\n        const Sint64 sample2 = (Sint64) ((Sint32) SDL_SwapBE32(src[2]));\n        const Sint64 sample1 = (Sint64) ((Sint32) SDL_SwapBE32(src[1]));\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n        src -= 6;\n        dst[11] = (Sint32) ((sample5 + last_sample5) >> 1);\n        dst[10] = (Sint32) ((sample4 + last_sample4) >> 1);\n        dst[9] = (Sint32) ((sample3 + last_sample3) >> 1);\n        dst[8] = (Sint32) ((sample2 + last_sample2) >> 1);\n        dst[7] = (Sint32) ((sample1 + last_sample1) >> 1);\n        dst[6] = (Sint32) ((sample0 + last_sample0) >> 1);\n        dst[5] = (Sint32) sample5;\n        dst[4] = (Sint32) sample4;\n        dst[3] = (Sint32) sample3;\n        dst[2] = (Sint32) sample2;\n        dst[1] = (Sint32) sample1;\n        dst[0] = (Sint32) sample0;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 12;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S32MSB_6c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_S32MSB, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Sint32 *dst = (Sint32 *) cvt->buf;\n    const Sint32 *src = (Sint32 *) cvt->buf;\n    const Sint32 *target = (const Sint32 *) (cvt->buf + dstsize);\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n    Sint64 last_sample1 = (Sint64) ((Sint32) SDL_SwapBE32(src[1]));\n    Sint64 last_sample2 = (Sint64) ((Sint32) SDL_SwapBE32(src[2]));\n    Sint64 last_sample3 = (Sint64) ((Sint32) SDL_SwapBE32(src[3]));\n    Sint64 last_sample4 = (Sint64) ((Sint32) SDL_SwapBE32(src[4]));\n    Sint64 last_sample5 = (Sint64) ((Sint32) SDL_SwapBE32(src[5]));\n    while (dst < target) {\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n        const Sint64 sample1 = (Sint64) ((Sint32) SDL_SwapBE32(src[1]));\n        const Sint64 sample2 = (Sint64) ((Sint32) SDL_SwapBE32(src[2]));\n        const Sint64 sample3 = (Sint64) ((Sint32) SDL_SwapBE32(src[3]));\n        const Sint64 sample4 = (Sint64) ((Sint32) SDL_SwapBE32(src[4]));\n        const Sint64 sample5 = (Sint64) ((Sint32) SDL_SwapBE32(src[5]));\n        src += 12;\n        dst[0] = (Sint32) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint32) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Sint32) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Sint32) ((sample3 + last_sample3) >> 1);\n        dst[4] = (Sint32) ((sample4 + last_sample4) >> 1);\n        dst[5] = (Sint32) ((sample5 + last_sample5) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        dst += 6;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S32MSB_6c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_S32MSB, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Sint32 *dst = ((Sint32 *) (cvt->buf + dstsize)) - 6 * 4;\n    const Sint32 *src = ((Sint32 *) (cvt->buf + cvt->len_cvt)) - 6;\n    const Sint32 *target = ((const Sint32 *) cvt->buf);\n    Sint64 last_sample5 = (Sint64) ((Sint32) SDL_SwapBE32(src[5]));\n    Sint64 last_sample4 = (Sint64) ((Sint32) SDL_SwapBE32(src[4]));\n    Sint64 last_sample3 = (Sint64) ((Sint32) SDL_SwapBE32(src[3]));\n    Sint64 last_sample2 = (Sint64) ((Sint32) SDL_SwapBE32(src[2]));\n    Sint64 last_sample1 = (Sint64) ((Sint32) SDL_SwapBE32(src[1]));\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n    while (dst >= target) {\n        const Sint64 sample5 = (Sint64) ((Sint32) SDL_SwapBE32(src[5]));\n        const Sint64 sample4 = (Sint64) ((Sint32) SDL_SwapBE32(src[4]));\n        const Sint64 sample3 = (Sint64) ((Sint32) SDL_SwapBE32(src[3]));\n        const Sint64 sample2 = (Sint64) ((Sint32) SDL_SwapBE32(src[2]));\n        const Sint64 sample1 = (Sint64) ((Sint32) SDL_SwapBE32(src[1]));\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n        src -= 6;\n        dst[23] = (Sint32) ((sample5 + (3 * last_sample5)) >> 2);\n        dst[22] = (Sint32) ((sample4 + (3 * last_sample4)) >> 2);\n        dst[21] = (Sint32) ((sample3 + (3 * last_sample3)) >> 2);\n        dst[20] = (Sint32) ((sample2 + (3 * last_sample2)) >> 2);\n        dst[19] = (Sint32) ((sample1 + (3 * last_sample1)) >> 2);\n        dst[18] = (Sint32) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[17] = (Sint32) ((sample5 + last_sample5) >> 1);\n        dst[16] = (Sint32) ((sample4 + last_sample4) >> 1);\n        dst[15] = (Sint32) ((sample3 + last_sample3) >> 1);\n        dst[14] = (Sint32) ((sample2 + last_sample2) >> 1);\n        dst[13] = (Sint32) ((sample1 + last_sample1) >> 1);\n        dst[12] = (Sint32) ((sample0 + last_sample0) >> 1);\n        dst[11] = (Sint32) (((3 * sample5) + last_sample5) >> 2);\n        dst[10] = (Sint32) (((3 * sample4) + last_sample4) >> 2);\n        dst[9] = (Sint32) (((3 * sample3) + last_sample3) >> 2);\n        dst[8] = (Sint32) (((3 * sample2) + last_sample2) >> 2);\n        dst[7] = (Sint32) (((3 * sample1) + last_sample1) >> 2);\n        dst[6] = (Sint32) (((3 * sample0) + last_sample0) >> 2);\n        dst[5] = (Sint32) sample5;\n        dst[4] = (Sint32) sample4;\n        dst[3] = (Sint32) sample3;\n        dst[2] = (Sint32) sample2;\n        dst[1] = (Sint32) sample1;\n        dst[0] = (Sint32) sample0;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 24;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S32MSB_6c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_S32MSB, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Sint32 *dst = (Sint32 *) cvt->buf;\n    const Sint32 *src = (Sint32 *) cvt->buf;\n    const Sint32 *target = (const Sint32 *) (cvt->buf + dstsize);\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n    Sint64 last_sample1 = (Sint64) ((Sint32) SDL_SwapBE32(src[1]));\n    Sint64 last_sample2 = (Sint64) ((Sint32) SDL_SwapBE32(src[2]));\n    Sint64 last_sample3 = (Sint64) ((Sint32) SDL_SwapBE32(src[3]));\n    Sint64 last_sample4 = (Sint64) ((Sint32) SDL_SwapBE32(src[4]));\n    Sint64 last_sample5 = (Sint64) ((Sint32) SDL_SwapBE32(src[5]));\n    while (dst < target) {\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n        const Sint64 sample1 = (Sint64) ((Sint32) SDL_SwapBE32(src[1]));\n        const Sint64 sample2 = (Sint64) ((Sint32) SDL_SwapBE32(src[2]));\n        const Sint64 sample3 = (Sint64) ((Sint32) SDL_SwapBE32(src[3]));\n        const Sint64 sample4 = (Sint64) ((Sint32) SDL_SwapBE32(src[4]));\n        const Sint64 sample5 = (Sint64) ((Sint32) SDL_SwapBE32(src[5]));\n        src += 24;\n        dst[0] = (Sint32) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint32) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Sint32) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Sint32) ((sample3 + last_sample3) >> 1);\n        dst[4] = (Sint32) ((sample4 + last_sample4) >> 1);\n        dst[5] = (Sint32) ((sample5 + last_sample5) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        dst += 6;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S32MSB_8c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_S32MSB, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    Sint32 *dst = ((Sint32 *) (cvt->buf + dstsize)) - 8 * 2;\n    const Sint32 *src = ((Sint32 *) (cvt->buf + cvt->len_cvt)) - 8;\n    const Sint32 *target = ((const Sint32 *) cvt->buf);\n    Sint64 last_sample7 = (Sint64) ((Sint32) SDL_SwapBE32(src[7]));\n    Sint64 last_sample6 = (Sint64) ((Sint32) SDL_SwapBE32(src[6]));\n    Sint64 last_sample5 = (Sint64) ((Sint32) SDL_SwapBE32(src[5]));\n    Sint64 last_sample4 = (Sint64) ((Sint32) SDL_SwapBE32(src[4]));\n    Sint64 last_sample3 = (Sint64) ((Sint32) SDL_SwapBE32(src[3]));\n    Sint64 last_sample2 = (Sint64) ((Sint32) SDL_SwapBE32(src[2]));\n    Sint64 last_sample1 = (Sint64) ((Sint32) SDL_SwapBE32(src[1]));\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n    while (dst >= target) {\n        const Sint64 sample7 = (Sint64) ((Sint32) SDL_SwapBE32(src[7]));\n        const Sint64 sample6 = (Sint64) ((Sint32) SDL_SwapBE32(src[6]));\n        const Sint64 sample5 = (Sint64) ((Sint32) SDL_SwapBE32(src[5]));\n        const Sint64 sample4 = (Sint64) ((Sint32) SDL_SwapBE32(src[4]));\n        const Sint64 sample3 = (Sint64) ((Sint32) SDL_SwapBE32(src[3]));\n        const Sint64 sample2 = (Sint64) ((Sint32) SDL_SwapBE32(src[2]));\n        const Sint64 sample1 = (Sint64) ((Sint32) SDL_SwapBE32(src[1]));\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n        src -= 8;\n        dst[15] = (Sint32) ((sample7 + last_sample7) >> 1);\n        dst[14] = (Sint32) ((sample6 + last_sample6) >> 1);\n        dst[13] = (Sint32) ((sample5 + last_sample5) >> 1);\n        dst[12] = (Sint32) ((sample4 + last_sample4) >> 1);\n        dst[11] = (Sint32) ((sample3 + last_sample3) >> 1);\n        dst[10] = (Sint32) ((sample2 + last_sample2) >> 1);\n        dst[9] = (Sint32) ((sample1 + last_sample1) >> 1);\n        dst[8] = (Sint32) ((sample0 + last_sample0) >> 1);\n        dst[7] = (Sint32) sample7;\n        dst[6] = (Sint32) sample6;\n        dst[5] = (Sint32) sample5;\n        dst[4] = (Sint32) sample4;\n        dst[3] = (Sint32) sample3;\n        dst[2] = (Sint32) sample2;\n        dst[1] = (Sint32) sample1;\n        dst[0] = (Sint32) sample0;\n        last_sample7 = sample7;\n        last_sample6 = sample6;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 16;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S32MSB_8c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_S32MSB, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    Sint32 *dst = (Sint32 *) cvt->buf;\n    const Sint32 *src = (Sint32 *) cvt->buf;\n    const Sint32 *target = (const Sint32 *) (cvt->buf + dstsize);\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n    Sint64 last_sample1 = (Sint64) ((Sint32) SDL_SwapBE32(src[1]));\n    Sint64 last_sample2 = (Sint64) ((Sint32) SDL_SwapBE32(src[2]));\n    Sint64 last_sample3 = (Sint64) ((Sint32) SDL_SwapBE32(src[3]));\n    Sint64 last_sample4 = (Sint64) ((Sint32) SDL_SwapBE32(src[4]));\n    Sint64 last_sample5 = (Sint64) ((Sint32) SDL_SwapBE32(src[5]));\n    Sint64 last_sample6 = (Sint64) ((Sint32) SDL_SwapBE32(src[6]));\n    Sint64 last_sample7 = (Sint64) ((Sint32) SDL_SwapBE32(src[7]));\n    while (dst < target) {\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n        const Sint64 sample1 = (Sint64) ((Sint32) SDL_SwapBE32(src[1]));\n        const Sint64 sample2 = (Sint64) ((Sint32) SDL_SwapBE32(src[2]));\n        const Sint64 sample3 = (Sint64) ((Sint32) SDL_SwapBE32(src[3]));\n        const Sint64 sample4 = (Sint64) ((Sint32) SDL_SwapBE32(src[4]));\n        const Sint64 sample5 = (Sint64) ((Sint32) SDL_SwapBE32(src[5]));\n        const Sint64 sample6 = (Sint64) ((Sint32) SDL_SwapBE32(src[6]));\n        const Sint64 sample7 = (Sint64) ((Sint32) SDL_SwapBE32(src[7]));\n        src += 16;\n        dst[0] = (Sint32) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint32) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Sint32) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Sint32) ((sample3 + last_sample3) >> 1);\n        dst[4] = (Sint32) ((sample4 + last_sample4) >> 1);\n        dst[5] = (Sint32) ((sample5 + last_sample5) >> 1);\n        dst[6] = (Sint32) ((sample6 + last_sample6) >> 1);\n        dst[7] = (Sint32) ((sample7 + last_sample7) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        last_sample6 = sample6;\n        last_sample7 = sample7;\n        dst += 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_S32MSB_8c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_S32MSB, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    Sint32 *dst = ((Sint32 *) (cvt->buf + dstsize)) - 8 * 4;\n    const Sint32 *src = ((Sint32 *) (cvt->buf + cvt->len_cvt)) - 8;\n    const Sint32 *target = ((const Sint32 *) cvt->buf);\n    Sint64 last_sample7 = (Sint64) ((Sint32) SDL_SwapBE32(src[7]));\n    Sint64 last_sample6 = (Sint64) ((Sint32) SDL_SwapBE32(src[6]));\n    Sint64 last_sample5 = (Sint64) ((Sint32) SDL_SwapBE32(src[5]));\n    Sint64 last_sample4 = (Sint64) ((Sint32) SDL_SwapBE32(src[4]));\n    Sint64 last_sample3 = (Sint64) ((Sint32) SDL_SwapBE32(src[3]));\n    Sint64 last_sample2 = (Sint64) ((Sint32) SDL_SwapBE32(src[2]));\n    Sint64 last_sample1 = (Sint64) ((Sint32) SDL_SwapBE32(src[1]));\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n    while (dst >= target) {\n        const Sint64 sample7 = (Sint64) ((Sint32) SDL_SwapBE32(src[7]));\n        const Sint64 sample6 = (Sint64) ((Sint32) SDL_SwapBE32(src[6]));\n        const Sint64 sample5 = (Sint64) ((Sint32) SDL_SwapBE32(src[5]));\n        const Sint64 sample4 = (Sint64) ((Sint32) SDL_SwapBE32(src[4]));\n        const Sint64 sample3 = (Sint64) ((Sint32) SDL_SwapBE32(src[3]));\n        const Sint64 sample2 = (Sint64) ((Sint32) SDL_SwapBE32(src[2]));\n        const Sint64 sample1 = (Sint64) ((Sint32) SDL_SwapBE32(src[1]));\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n        src -= 8;\n        dst[31] = (Sint32) ((sample7 + (3 * last_sample7)) >> 2);\n        dst[30] = (Sint32) ((sample6 + (3 * last_sample6)) >> 2);\n        dst[29] = (Sint32) ((sample5 + (3 * last_sample5)) >> 2);\n        dst[28] = (Sint32) ((sample4 + (3 * last_sample4)) >> 2);\n        dst[27] = (Sint32) ((sample3 + (3 * last_sample3)) >> 2);\n        dst[26] = (Sint32) ((sample2 + (3 * last_sample2)) >> 2);\n        dst[25] = (Sint32) ((sample1 + (3 * last_sample1)) >> 2);\n        dst[24] = (Sint32) ((sample0 + (3 * last_sample0)) >> 2);\n        dst[23] = (Sint32) ((sample7 + last_sample7) >> 1);\n        dst[22] = (Sint32) ((sample6 + last_sample6) >> 1);\n        dst[21] = (Sint32) ((sample5 + last_sample5) >> 1);\n        dst[20] = (Sint32) ((sample4 + last_sample4) >> 1);\n        dst[19] = (Sint32) ((sample3 + last_sample3) >> 1);\n        dst[18] = (Sint32) ((sample2 + last_sample2) >> 1);\n        dst[17] = (Sint32) ((sample1 + last_sample1) >> 1);\n        dst[16] = (Sint32) ((sample0 + last_sample0) >> 1);\n        dst[15] = (Sint32) (((3 * sample7) + last_sample7) >> 2);\n        dst[14] = (Sint32) (((3 * sample6) + last_sample6) >> 2);\n        dst[13] = (Sint32) (((3 * sample5) + last_sample5) >> 2);\n        dst[12] = (Sint32) (((3 * sample4) + last_sample4) >> 2);\n        dst[11] = (Sint32) (((3 * sample3) + last_sample3) >> 2);\n        dst[10] = (Sint32) (((3 * sample2) + last_sample2) >> 2);\n        dst[9] = (Sint32) (((3 * sample1) + last_sample1) >> 2);\n        dst[8] = (Sint32) (((3 * sample0) + last_sample0) >> 2);\n        dst[7] = (Sint32) sample7;\n        dst[6] = (Sint32) sample6;\n        dst[5] = (Sint32) sample5;\n        dst[4] = (Sint32) sample4;\n        dst[3] = (Sint32) sample3;\n        dst[2] = (Sint32) sample2;\n        dst[1] = (Sint32) sample1;\n        dst[0] = (Sint32) sample0;\n        last_sample7 = sample7;\n        last_sample6 = sample6;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 32;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_S32MSB_8c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_S32MSB, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    Sint32 *dst = (Sint32 *) cvt->buf;\n    const Sint32 *src = (Sint32 *) cvt->buf;\n    const Sint32 *target = (const Sint32 *) (cvt->buf + dstsize);\n    Sint64 last_sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n    Sint64 last_sample1 = (Sint64) ((Sint32) SDL_SwapBE32(src[1]));\n    Sint64 last_sample2 = (Sint64) ((Sint32) SDL_SwapBE32(src[2]));\n    Sint64 last_sample3 = (Sint64) ((Sint32) SDL_SwapBE32(src[3]));\n    Sint64 last_sample4 = (Sint64) ((Sint32) SDL_SwapBE32(src[4]));\n    Sint64 last_sample5 = (Sint64) ((Sint32) SDL_SwapBE32(src[5]));\n    Sint64 last_sample6 = (Sint64) ((Sint32) SDL_SwapBE32(src[6]));\n    Sint64 last_sample7 = (Sint64) ((Sint32) SDL_SwapBE32(src[7]));\n    while (dst < target) {\n        const Sint64 sample0 = (Sint64) ((Sint32) SDL_SwapBE32(src[0]));\n        const Sint64 sample1 = (Sint64) ((Sint32) SDL_SwapBE32(src[1]));\n        const Sint64 sample2 = (Sint64) ((Sint32) SDL_SwapBE32(src[2]));\n        const Sint64 sample3 = (Sint64) ((Sint32) SDL_SwapBE32(src[3]));\n        const Sint64 sample4 = (Sint64) ((Sint32) SDL_SwapBE32(src[4]));\n        const Sint64 sample5 = (Sint64) ((Sint32) SDL_SwapBE32(src[5]));\n        const Sint64 sample6 = (Sint64) ((Sint32) SDL_SwapBE32(src[6]));\n        const Sint64 sample7 = (Sint64) ((Sint32) SDL_SwapBE32(src[7]));\n        src += 32;\n        dst[0] = (Sint32) ((sample0 + last_sample0) >> 1);\n        dst[1] = (Sint32) ((sample1 + last_sample1) >> 1);\n        dst[2] = (Sint32) ((sample2 + last_sample2) >> 1);\n        dst[3] = (Sint32) ((sample3 + last_sample3) >> 1);\n        dst[4] = (Sint32) ((sample4 + last_sample4) >> 1);\n        dst[5] = (Sint32) ((sample5 + last_sample5) >> 1);\n        dst[6] = (Sint32) ((sample6 + last_sample6) >> 1);\n        dst[7] = (Sint32) ((sample7 + last_sample7) >> 1);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        last_sample6 = sample6;\n        last_sample7 = sample7;\n        dst += 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_F32LSB_1c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_F32LSB, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    float *dst = ((float *) (cvt->buf + dstsize)) - 1 * 2;\n    const float *src = ((float *) (cvt->buf + cvt->len_cvt)) - 1;\n    const float *target = ((const float *) cvt->buf);\n    double last_sample0 = (double) SDL_SwapFloatLE(src[0]);\n    while (dst >= target) {\n        const double sample0 = (double) SDL_SwapFloatLE(src[0]);\n        src--;\n        dst[1] = (float) ((sample0 + last_sample0) * 0.5);\n        dst[0] = (float) sample0;\n        last_sample0 = sample0;\n        dst -= 2;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_F32LSB_1c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_F32LSB, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    float *dst = (float *) cvt->buf;\n    const float *src = (float *) cvt->buf;\n    const float *target = (const float *) (cvt->buf + dstsize);\n    double last_sample0 = (double) SDL_SwapFloatLE(src[0]);\n    while (dst < target) {\n        const double sample0 = (double) SDL_SwapFloatLE(src[0]);\n        src += 2;\n        dst[0] = (float) ((sample0 + last_sample0) * 0.5);\n        last_sample0 = sample0;\n        dst++;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_F32LSB_1c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_F32LSB, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    float *dst = ((float *) (cvt->buf + dstsize)) - 1 * 4;\n    const float *src = ((float *) (cvt->buf + cvt->len_cvt)) - 1;\n    const float *target = ((const float *) cvt->buf);\n    double last_sample0 = (double) SDL_SwapFloatLE(src[0]);\n    while (dst >= target) {\n        const double sample0 = (double) SDL_SwapFloatLE(src[0]);\n        src--;\n        dst[3] = (float) ((sample0 + (3.0 * last_sample0)) * 0.25);\n        dst[2] = (float) ((sample0 + last_sample0) * 0.5);\n        dst[1] = (float) (((3.0 * sample0) + last_sample0) * 0.25);\n        dst[0] = (float) sample0;\n        last_sample0 = sample0;\n        dst -= 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_F32LSB_1c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_F32LSB, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    float *dst = (float *) cvt->buf;\n    const float *src = (float *) cvt->buf;\n    const float *target = (const float *) (cvt->buf + dstsize);\n    double last_sample0 = (double) SDL_SwapFloatLE(src[0]);\n    while (dst < target) {\n        const double sample0 = (double) SDL_SwapFloatLE(src[0]);\n        src += 4;\n        dst[0] = (float) ((sample0 + last_sample0) * 0.5);\n        last_sample0 = sample0;\n        dst++;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_F32LSB_2c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_F32LSB, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    float *dst = ((float *) (cvt->buf + dstsize)) - 2 * 2;\n    const float *src = ((float *) (cvt->buf + cvt->len_cvt)) - 2;\n    const float *target = ((const float *) cvt->buf);\n    double last_sample1 = (double) SDL_SwapFloatLE(src[1]);\n    double last_sample0 = (double) SDL_SwapFloatLE(src[0]);\n    while (dst >= target) {\n        const double sample1 = (double) SDL_SwapFloatLE(src[1]);\n        const double sample0 = (double) SDL_SwapFloatLE(src[0]);\n        src -= 2;\n        dst[3] = (float) ((sample1 + last_sample1) * 0.5);\n        dst[2] = (float) ((sample0 + last_sample0) * 0.5);\n        dst[1] = (float) sample1;\n        dst[0] = (float) sample0;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_F32LSB_2c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_F32LSB, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    float *dst = (float *) cvt->buf;\n    const float *src = (float *) cvt->buf;\n    const float *target = (const float *) (cvt->buf + dstsize);\n    double last_sample0 = (double) SDL_SwapFloatLE(src[0]);\n    double last_sample1 = (double) SDL_SwapFloatLE(src[1]);\n    while (dst < target) {\n        const double sample0 = (double) SDL_SwapFloatLE(src[0]);\n        const double sample1 = (double) SDL_SwapFloatLE(src[1]);\n        src += 4;\n        dst[0] = (float) ((sample0 + last_sample0) * 0.5);\n        dst[1] = (float) ((sample1 + last_sample1) * 0.5);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        dst += 2;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_F32LSB_2c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_F32LSB, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    float *dst = ((float *) (cvt->buf + dstsize)) - 2 * 4;\n    const float *src = ((float *) (cvt->buf + cvt->len_cvt)) - 2;\n    const float *target = ((const float *) cvt->buf);\n    double last_sample1 = (double) SDL_SwapFloatLE(src[1]);\n    double last_sample0 = (double) SDL_SwapFloatLE(src[0]);\n    while (dst >= target) {\n        const double sample1 = (double) SDL_SwapFloatLE(src[1]);\n        const double sample0 = (double) SDL_SwapFloatLE(src[0]);\n        src -= 2;\n        dst[7] = (float) ((sample1 + (3.0 * last_sample1)) * 0.25);\n        dst[6] = (float) ((sample0 + (3.0 * last_sample0)) * 0.25);\n        dst[5] = (float) ((sample1 + last_sample1) * 0.5);\n        dst[4] = (float) ((sample0 + last_sample0) * 0.5);\n        dst[3] = (float) (((3.0 * sample1) + last_sample1) * 0.25);\n        dst[2] = (float) (((3.0 * sample0) + last_sample0) * 0.25);\n        dst[1] = (float) sample1;\n        dst[0] = (float) sample0;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_F32LSB_2c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_F32LSB, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    float *dst = (float *) cvt->buf;\n    const float *src = (float *) cvt->buf;\n    const float *target = (const float *) (cvt->buf + dstsize);\n    double last_sample0 = (double) SDL_SwapFloatLE(src[0]);\n    double last_sample1 = (double) SDL_SwapFloatLE(src[1]);\n    while (dst < target) {\n        const double sample0 = (double) SDL_SwapFloatLE(src[0]);\n        const double sample1 = (double) SDL_SwapFloatLE(src[1]);\n        src += 8;\n        dst[0] = (float) ((sample0 + last_sample0) * 0.5);\n        dst[1] = (float) ((sample1 + last_sample1) * 0.5);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        dst += 2;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_F32LSB_4c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_F32LSB, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    float *dst = ((float *) (cvt->buf + dstsize)) - 4 * 2;\n    const float *src = ((float *) (cvt->buf + cvt->len_cvt)) - 4;\n    const float *target = ((const float *) cvt->buf);\n    double last_sample3 = (double) SDL_SwapFloatLE(src[3]);\n    double last_sample2 = (double) SDL_SwapFloatLE(src[2]);\n    double last_sample1 = (double) SDL_SwapFloatLE(src[1]);\n    double last_sample0 = (double) SDL_SwapFloatLE(src[0]);\n    while (dst >= target) {\n        const double sample3 = (double) SDL_SwapFloatLE(src[3]);\n        const double sample2 = (double) SDL_SwapFloatLE(src[2]);\n        const double sample1 = (double) SDL_SwapFloatLE(src[1]);\n        const double sample0 = (double) SDL_SwapFloatLE(src[0]);\n        src -= 4;\n        dst[7] = (float) ((sample3 + last_sample3) * 0.5);\n        dst[6] = (float) ((sample2 + last_sample2) * 0.5);\n        dst[5] = (float) ((sample1 + last_sample1) * 0.5);\n        dst[4] = (float) ((sample0 + last_sample0) * 0.5);\n        dst[3] = (float) sample3;\n        dst[2] = (float) sample2;\n        dst[1] = (float) sample1;\n        dst[0] = (float) sample0;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_F32LSB_4c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_F32LSB, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    float *dst = (float *) cvt->buf;\n    const float *src = (float *) cvt->buf;\n    const float *target = (const float *) (cvt->buf + dstsize);\n    double last_sample0 = (double) SDL_SwapFloatLE(src[0]);\n    double last_sample1 = (double) SDL_SwapFloatLE(src[1]);\n    double last_sample2 = (double) SDL_SwapFloatLE(src[2]);\n    double last_sample3 = (double) SDL_SwapFloatLE(src[3]);\n    while (dst < target) {\n        const double sample0 = (double) SDL_SwapFloatLE(src[0]);\n        const double sample1 = (double) SDL_SwapFloatLE(src[1]);\n        const double sample2 = (double) SDL_SwapFloatLE(src[2]);\n        const double sample3 = (double) SDL_SwapFloatLE(src[3]);\n        src += 8;\n        dst[0] = (float) ((sample0 + last_sample0) * 0.5);\n        dst[1] = (float) ((sample1 + last_sample1) * 0.5);\n        dst[2] = (float) ((sample2 + last_sample2) * 0.5);\n        dst[3] = (float) ((sample3 + last_sample3) * 0.5);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        dst += 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_F32LSB_4c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_F32LSB, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    float *dst = ((float *) (cvt->buf + dstsize)) - 4 * 4;\n    const float *src = ((float *) (cvt->buf + cvt->len_cvt)) - 4;\n    const float *target = ((const float *) cvt->buf);\n    double last_sample3 = (double) SDL_SwapFloatLE(src[3]);\n    double last_sample2 = (double) SDL_SwapFloatLE(src[2]);\n    double last_sample1 = (double) SDL_SwapFloatLE(src[1]);\n    double last_sample0 = (double) SDL_SwapFloatLE(src[0]);\n    while (dst >= target) {\n        const double sample3 = (double) SDL_SwapFloatLE(src[3]);\n        const double sample2 = (double) SDL_SwapFloatLE(src[2]);\n        const double sample1 = (double) SDL_SwapFloatLE(src[1]);\n        const double sample0 = (double) SDL_SwapFloatLE(src[0]);\n        src -= 4;\n        dst[15] = (float) ((sample3 + (3.0 * last_sample3)) * 0.25);\n        dst[14] = (float) ((sample2 + (3.0 * last_sample2)) * 0.25);\n        dst[13] = (float) ((sample1 + (3.0 * last_sample1)) * 0.25);\n        dst[12] = (float) ((sample0 + (3.0 * last_sample0)) * 0.25);\n        dst[11] = (float) ((sample3 + last_sample3) * 0.5);\n        dst[10] = (float) ((sample2 + last_sample2) * 0.5);\n        dst[9] = (float) ((sample1 + last_sample1) * 0.5);\n        dst[8] = (float) ((sample0 + last_sample0) * 0.5);\n        dst[7] = (float) (((3.0 * sample3) + last_sample3) * 0.25);\n        dst[6] = (float) (((3.0 * sample2) + last_sample2) * 0.25);\n        dst[5] = (float) (((3.0 * sample1) + last_sample1) * 0.25);\n        dst[4] = (float) (((3.0 * sample0) + last_sample0) * 0.25);\n        dst[3] = (float) sample3;\n        dst[2] = (float) sample2;\n        dst[1] = (float) sample1;\n        dst[0] = (float) sample0;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 16;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_F32LSB_4c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_F32LSB, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    float *dst = (float *) cvt->buf;\n    const float *src = (float *) cvt->buf;\n    const float *target = (const float *) (cvt->buf + dstsize);\n    double last_sample0 = (double) SDL_SwapFloatLE(src[0]);\n    double last_sample1 = (double) SDL_SwapFloatLE(src[1]);\n    double last_sample2 = (double) SDL_SwapFloatLE(src[2]);\n    double last_sample3 = (double) SDL_SwapFloatLE(src[3]);\n    while (dst < target) {\n        const double sample0 = (double) SDL_SwapFloatLE(src[0]);\n        const double sample1 = (double) SDL_SwapFloatLE(src[1]);\n        const double sample2 = (double) SDL_SwapFloatLE(src[2]);\n        const double sample3 = (double) SDL_SwapFloatLE(src[3]);\n        src += 16;\n        dst[0] = (float) ((sample0 + last_sample0) * 0.5);\n        dst[1] = (float) ((sample1 + last_sample1) * 0.5);\n        dst[2] = (float) ((sample2 + last_sample2) * 0.5);\n        dst[3] = (float) ((sample3 + last_sample3) * 0.5);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        dst += 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_F32LSB_6c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_F32LSB, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    float *dst = ((float *) (cvt->buf + dstsize)) - 6 * 2;\n    const float *src = ((float *) (cvt->buf + cvt->len_cvt)) - 6;\n    const float *target = ((const float *) cvt->buf);\n    double last_sample5 = (double) SDL_SwapFloatLE(src[5]);\n    double last_sample4 = (double) SDL_SwapFloatLE(src[4]);\n    double last_sample3 = (double) SDL_SwapFloatLE(src[3]);\n    double last_sample2 = (double) SDL_SwapFloatLE(src[2]);\n    double last_sample1 = (double) SDL_SwapFloatLE(src[1]);\n    double last_sample0 = (double) SDL_SwapFloatLE(src[0]);\n    while (dst >= target) {\n        const double sample5 = (double) SDL_SwapFloatLE(src[5]);\n        const double sample4 = (double) SDL_SwapFloatLE(src[4]);\n        const double sample3 = (double) SDL_SwapFloatLE(src[3]);\n        const double sample2 = (double) SDL_SwapFloatLE(src[2]);\n        const double sample1 = (double) SDL_SwapFloatLE(src[1]);\n        const double sample0 = (double) SDL_SwapFloatLE(src[0]);\n        src -= 6;\n        dst[11] = (float) ((sample5 + last_sample5) * 0.5);\n        dst[10] = (float) ((sample4 + last_sample4) * 0.5);\n        dst[9] = (float) ((sample3 + last_sample3) * 0.5);\n        dst[8] = (float) ((sample2 + last_sample2) * 0.5);\n        dst[7] = (float) ((sample1 + last_sample1) * 0.5);\n        dst[6] = (float) ((sample0 + last_sample0) * 0.5);\n        dst[5] = (float) sample5;\n        dst[4] = (float) sample4;\n        dst[3] = (float) sample3;\n        dst[2] = (float) sample2;\n        dst[1] = (float) sample1;\n        dst[0] = (float) sample0;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 12;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_F32LSB_6c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_F32LSB, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    float *dst = (float *) cvt->buf;\n    const float *src = (float *) cvt->buf;\n    const float *target = (const float *) (cvt->buf + dstsize);\n    double last_sample0 = (double) SDL_SwapFloatLE(src[0]);\n    double last_sample1 = (double) SDL_SwapFloatLE(src[1]);\n    double last_sample2 = (double) SDL_SwapFloatLE(src[2]);\n    double last_sample3 = (double) SDL_SwapFloatLE(src[3]);\n    double last_sample4 = (double) SDL_SwapFloatLE(src[4]);\n    double last_sample5 = (double) SDL_SwapFloatLE(src[5]);\n    while (dst < target) {\n        const double sample0 = (double) SDL_SwapFloatLE(src[0]);\n        const double sample1 = (double) SDL_SwapFloatLE(src[1]);\n        const double sample2 = (double) SDL_SwapFloatLE(src[2]);\n        const double sample3 = (double) SDL_SwapFloatLE(src[3]);\n        const double sample4 = (double) SDL_SwapFloatLE(src[4]);\n        const double sample5 = (double) SDL_SwapFloatLE(src[5]);\n        src += 12;\n        dst[0] = (float) ((sample0 + last_sample0) * 0.5);\n        dst[1] = (float) ((sample1 + last_sample1) * 0.5);\n        dst[2] = (float) ((sample2 + last_sample2) * 0.5);\n        dst[3] = (float) ((sample3 + last_sample3) * 0.5);\n        dst[4] = (float) ((sample4 + last_sample4) * 0.5);\n        dst[5] = (float) ((sample5 + last_sample5) * 0.5);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        dst += 6;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_F32LSB_6c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_F32LSB, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    float *dst = ((float *) (cvt->buf + dstsize)) - 6 * 4;\n    const float *src = ((float *) (cvt->buf + cvt->len_cvt)) - 6;\n    const float *target = ((const float *) cvt->buf);\n    double last_sample5 = (double) SDL_SwapFloatLE(src[5]);\n    double last_sample4 = (double) SDL_SwapFloatLE(src[4]);\n    double last_sample3 = (double) SDL_SwapFloatLE(src[3]);\n    double last_sample2 = (double) SDL_SwapFloatLE(src[2]);\n    double last_sample1 = (double) SDL_SwapFloatLE(src[1]);\n    double last_sample0 = (double) SDL_SwapFloatLE(src[0]);\n    while (dst >= target) {\n        const double sample5 = (double) SDL_SwapFloatLE(src[5]);\n        const double sample4 = (double) SDL_SwapFloatLE(src[4]);\n        const double sample3 = (double) SDL_SwapFloatLE(src[3]);\n        const double sample2 = (double) SDL_SwapFloatLE(src[2]);\n        const double sample1 = (double) SDL_SwapFloatLE(src[1]);\n        const double sample0 = (double) SDL_SwapFloatLE(src[0]);\n        src -= 6;\n        dst[23] = (float) ((sample5 + (3.0 * last_sample5)) * 0.25);\n        dst[22] = (float) ((sample4 + (3.0 * last_sample4)) * 0.25);\n        dst[21] = (float) ((sample3 + (3.0 * last_sample3)) * 0.25);\n        dst[20] = (float) ((sample2 + (3.0 * last_sample2)) * 0.25);\n        dst[19] = (float) ((sample1 + (3.0 * last_sample1)) * 0.25);\n        dst[18] = (float) ((sample0 + (3.0 * last_sample0)) * 0.25);\n        dst[17] = (float) ((sample5 + last_sample5) * 0.5);\n        dst[16] = (float) ((sample4 + last_sample4) * 0.5);\n        dst[15] = (float) ((sample3 + last_sample3) * 0.5);\n        dst[14] = (float) ((sample2 + last_sample2) * 0.5);\n        dst[13] = (float) ((sample1 + last_sample1) * 0.5);\n        dst[12] = (float) ((sample0 + last_sample0) * 0.5);\n        dst[11] = (float) (((3.0 * sample5) + last_sample5) * 0.25);\n        dst[10] = (float) (((3.0 * sample4) + last_sample4) * 0.25);\n        dst[9] = (float) (((3.0 * sample3) + last_sample3) * 0.25);\n        dst[8] = (float) (((3.0 * sample2) + last_sample2) * 0.25);\n        dst[7] = (float) (((3.0 * sample1) + last_sample1) * 0.25);\n        dst[6] = (float) (((3.0 * sample0) + last_sample0) * 0.25);\n        dst[5] = (float) sample5;\n        dst[4] = (float) sample4;\n        dst[3] = (float) sample3;\n        dst[2] = (float) sample2;\n        dst[1] = (float) sample1;\n        dst[0] = (float) sample0;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 24;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_F32LSB_6c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_F32LSB, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    float *dst = (float *) cvt->buf;\n    const float *src = (float *) cvt->buf;\n    const float *target = (const float *) (cvt->buf + dstsize);\n    double last_sample0 = (double) SDL_SwapFloatLE(src[0]);\n    double last_sample1 = (double) SDL_SwapFloatLE(src[1]);\n    double last_sample2 = (double) SDL_SwapFloatLE(src[2]);\n    double last_sample3 = (double) SDL_SwapFloatLE(src[3]);\n    double last_sample4 = (double) SDL_SwapFloatLE(src[4]);\n    double last_sample5 = (double) SDL_SwapFloatLE(src[5]);\n    while (dst < target) {\n        const double sample0 = (double) SDL_SwapFloatLE(src[0]);\n        const double sample1 = (double) SDL_SwapFloatLE(src[1]);\n        const double sample2 = (double) SDL_SwapFloatLE(src[2]);\n        const double sample3 = (double) SDL_SwapFloatLE(src[3]);\n        const double sample4 = (double) SDL_SwapFloatLE(src[4]);\n        const double sample5 = (double) SDL_SwapFloatLE(src[5]);\n        src += 24;\n        dst[0] = (float) ((sample0 + last_sample0) * 0.5);\n        dst[1] = (float) ((sample1 + last_sample1) * 0.5);\n        dst[2] = (float) ((sample2 + last_sample2) * 0.5);\n        dst[3] = (float) ((sample3 + last_sample3) * 0.5);\n        dst[4] = (float) ((sample4 + last_sample4) * 0.5);\n        dst[5] = (float) ((sample5 + last_sample5) * 0.5);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        dst += 6;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_F32LSB_8c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_F32LSB, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    float *dst = ((float *) (cvt->buf + dstsize)) - 8 * 2;\n    const float *src = ((float *) (cvt->buf + cvt->len_cvt)) - 8;\n    const float *target = ((const float *) cvt->buf);\n    double last_sample7 = (double) SDL_SwapFloatLE(src[7]);\n    double last_sample6 = (double) SDL_SwapFloatLE(src[6]);\n    double last_sample5 = (double) SDL_SwapFloatLE(src[5]);\n    double last_sample4 = (double) SDL_SwapFloatLE(src[4]);\n    double last_sample3 = (double) SDL_SwapFloatLE(src[3]);\n    double last_sample2 = (double) SDL_SwapFloatLE(src[2]);\n    double last_sample1 = (double) SDL_SwapFloatLE(src[1]);\n    double last_sample0 = (double) SDL_SwapFloatLE(src[0]);\n    while (dst >= target) {\n        const double sample7 = (double) SDL_SwapFloatLE(src[7]);\n        const double sample6 = (double) SDL_SwapFloatLE(src[6]);\n        const double sample5 = (double) SDL_SwapFloatLE(src[5]);\n        const double sample4 = (double) SDL_SwapFloatLE(src[4]);\n        const double sample3 = (double) SDL_SwapFloatLE(src[3]);\n        const double sample2 = (double) SDL_SwapFloatLE(src[2]);\n        const double sample1 = (double) SDL_SwapFloatLE(src[1]);\n        const double sample0 = (double) SDL_SwapFloatLE(src[0]);\n        src -= 8;\n        dst[15] = (float) ((sample7 + last_sample7) * 0.5);\n        dst[14] = (float) ((sample6 + last_sample6) * 0.5);\n        dst[13] = (float) ((sample5 + last_sample5) * 0.5);\n        dst[12] = (float) ((sample4 + last_sample4) * 0.5);\n        dst[11] = (float) ((sample3 + last_sample3) * 0.5);\n        dst[10] = (float) ((sample2 + last_sample2) * 0.5);\n        dst[9] = (float) ((sample1 + last_sample1) * 0.5);\n        dst[8] = (float) ((sample0 + last_sample0) * 0.5);\n        dst[7] = (float) sample7;\n        dst[6] = (float) sample6;\n        dst[5] = (float) sample5;\n        dst[4] = (float) sample4;\n        dst[3] = (float) sample3;\n        dst[2] = (float) sample2;\n        dst[1] = (float) sample1;\n        dst[0] = (float) sample0;\n        last_sample7 = sample7;\n        last_sample6 = sample6;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 16;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_F32LSB_8c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_F32LSB, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    float *dst = (float *) cvt->buf;\n    const float *src = (float *) cvt->buf;\n    const float *target = (const float *) (cvt->buf + dstsize);\n    double last_sample0 = (double) SDL_SwapFloatLE(src[0]);\n    double last_sample1 = (double) SDL_SwapFloatLE(src[1]);\n    double last_sample2 = (double) SDL_SwapFloatLE(src[2]);\n    double last_sample3 = (double) SDL_SwapFloatLE(src[3]);\n    double last_sample4 = (double) SDL_SwapFloatLE(src[4]);\n    double last_sample5 = (double) SDL_SwapFloatLE(src[5]);\n    double last_sample6 = (double) SDL_SwapFloatLE(src[6]);\n    double last_sample7 = (double) SDL_SwapFloatLE(src[7]);\n    while (dst < target) {\n        const double sample0 = (double) SDL_SwapFloatLE(src[0]);\n        const double sample1 = (double) SDL_SwapFloatLE(src[1]);\n        const double sample2 = (double) SDL_SwapFloatLE(src[2]);\n        const double sample3 = (double) SDL_SwapFloatLE(src[3]);\n        const double sample4 = (double) SDL_SwapFloatLE(src[4]);\n        const double sample5 = (double) SDL_SwapFloatLE(src[5]);\n        const double sample6 = (double) SDL_SwapFloatLE(src[6]);\n        const double sample7 = (double) SDL_SwapFloatLE(src[7]);\n        src += 16;\n        dst[0] = (float) ((sample0 + last_sample0) * 0.5);\n        dst[1] = (float) ((sample1 + last_sample1) * 0.5);\n        dst[2] = (float) ((sample2 + last_sample2) * 0.5);\n        dst[3] = (float) ((sample3 + last_sample3) * 0.5);\n        dst[4] = (float) ((sample4 + last_sample4) * 0.5);\n        dst[5] = (float) ((sample5 + last_sample5) * 0.5);\n        dst[6] = (float) ((sample6 + last_sample6) * 0.5);\n        dst[7] = (float) ((sample7 + last_sample7) * 0.5);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        last_sample6 = sample6;\n        last_sample7 = sample7;\n        dst += 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_F32LSB_8c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_F32LSB, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    float *dst = ((float *) (cvt->buf + dstsize)) - 8 * 4;\n    const float *src = ((float *) (cvt->buf + cvt->len_cvt)) - 8;\n    const float *target = ((const float *) cvt->buf);\n    double last_sample7 = (double) SDL_SwapFloatLE(src[7]);\n    double last_sample6 = (double) SDL_SwapFloatLE(src[6]);\n    double last_sample5 = (double) SDL_SwapFloatLE(src[5]);\n    double last_sample4 = (double) SDL_SwapFloatLE(src[4]);\n    double last_sample3 = (double) SDL_SwapFloatLE(src[3]);\n    double last_sample2 = (double) SDL_SwapFloatLE(src[2]);\n    double last_sample1 = (double) SDL_SwapFloatLE(src[1]);\n    double last_sample0 = (double) SDL_SwapFloatLE(src[0]);\n    while (dst >= target) {\n        const double sample7 = (double) SDL_SwapFloatLE(src[7]);\n        const double sample6 = (double) SDL_SwapFloatLE(src[6]);\n        const double sample5 = (double) SDL_SwapFloatLE(src[5]);\n        const double sample4 = (double) SDL_SwapFloatLE(src[4]);\n        const double sample3 = (double) SDL_SwapFloatLE(src[3]);\n        const double sample2 = (double) SDL_SwapFloatLE(src[2]);\n        const double sample1 = (double) SDL_SwapFloatLE(src[1]);\n        const double sample0 = (double) SDL_SwapFloatLE(src[0]);\n        src -= 8;\n        dst[31] = (float) ((sample7 + (3.0 * last_sample7)) * 0.25);\n        dst[30] = (float) ((sample6 + (3.0 * last_sample6)) * 0.25);\n        dst[29] = (float) ((sample5 + (3.0 * last_sample5)) * 0.25);\n        dst[28] = (float) ((sample4 + (3.0 * last_sample4)) * 0.25);\n        dst[27] = (float) ((sample3 + (3.0 * last_sample3)) * 0.25);\n        dst[26] = (float) ((sample2 + (3.0 * last_sample2)) * 0.25);\n        dst[25] = (float) ((sample1 + (3.0 * last_sample1)) * 0.25);\n        dst[24] = (float) ((sample0 + (3.0 * last_sample0)) * 0.25);\n        dst[23] = (float) ((sample7 + last_sample7) * 0.5);\n        dst[22] = (float) ((sample6 + last_sample6) * 0.5);\n        dst[21] = (float) ((sample5 + last_sample5) * 0.5);\n        dst[20] = (float) ((sample4 + last_sample4) * 0.5);\n        dst[19] = (float) ((sample3 + last_sample3) * 0.5);\n        dst[18] = (float) ((sample2 + last_sample2) * 0.5);\n        dst[17] = (float) ((sample1 + last_sample1) * 0.5);\n        dst[16] = (float) ((sample0 + last_sample0) * 0.5);\n        dst[15] = (float) (((3.0 * sample7) + last_sample7) * 0.25);\n        dst[14] = (float) (((3.0 * sample6) + last_sample6) * 0.25);\n        dst[13] = (float) (((3.0 * sample5) + last_sample5) * 0.25);\n        dst[12] = (float) (((3.0 * sample4) + last_sample4) * 0.25);\n        dst[11] = (float) (((3.0 * sample3) + last_sample3) * 0.25);\n        dst[10] = (float) (((3.0 * sample2) + last_sample2) * 0.25);\n        dst[9] = (float) (((3.0 * sample1) + last_sample1) * 0.25);\n        dst[8] = (float) (((3.0 * sample0) + last_sample0) * 0.25);\n        dst[7] = (float) sample7;\n        dst[6] = (float) sample6;\n        dst[5] = (float) sample5;\n        dst[4] = (float) sample4;\n        dst[3] = (float) sample3;\n        dst[2] = (float) sample2;\n        dst[1] = (float) sample1;\n        dst[0] = (float) sample0;\n        last_sample7 = sample7;\n        last_sample6 = sample6;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 32;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_F32LSB_8c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_F32LSB, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    float *dst = (float *) cvt->buf;\n    const float *src = (float *) cvt->buf;\n    const float *target = (const float *) (cvt->buf + dstsize);\n    double last_sample0 = (double) SDL_SwapFloatLE(src[0]);\n    double last_sample1 = (double) SDL_SwapFloatLE(src[1]);\n    double last_sample2 = (double) SDL_SwapFloatLE(src[2]);\n    double last_sample3 = (double) SDL_SwapFloatLE(src[3]);\n    double last_sample4 = (double) SDL_SwapFloatLE(src[4]);\n    double last_sample5 = (double) SDL_SwapFloatLE(src[5]);\n    double last_sample6 = (double) SDL_SwapFloatLE(src[6]);\n    double last_sample7 = (double) SDL_SwapFloatLE(src[7]);\n    while (dst < target) {\n        const double sample0 = (double) SDL_SwapFloatLE(src[0]);\n        const double sample1 = (double) SDL_SwapFloatLE(src[1]);\n        const double sample2 = (double) SDL_SwapFloatLE(src[2]);\n        const double sample3 = (double) SDL_SwapFloatLE(src[3]);\n        const double sample4 = (double) SDL_SwapFloatLE(src[4]);\n        const double sample5 = (double) SDL_SwapFloatLE(src[5]);\n        const double sample6 = (double) SDL_SwapFloatLE(src[6]);\n        const double sample7 = (double) SDL_SwapFloatLE(src[7]);\n        src += 32;\n        dst[0] = (float) ((sample0 + last_sample0) * 0.5);\n        dst[1] = (float) ((sample1 + last_sample1) * 0.5);\n        dst[2] = (float) ((sample2 + last_sample2) * 0.5);\n        dst[3] = (float) ((sample3 + last_sample3) * 0.5);\n        dst[4] = (float) ((sample4 + last_sample4) * 0.5);\n        dst[5] = (float) ((sample5 + last_sample5) * 0.5);\n        dst[6] = (float) ((sample6 + last_sample6) * 0.5);\n        dst[7] = (float) ((sample7 + last_sample7) * 0.5);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        last_sample6 = sample6;\n        last_sample7 = sample7;\n        dst += 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_F32MSB_1c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_F32MSB, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    float *dst = ((float *) (cvt->buf + dstsize)) - 1 * 2;\n    const float *src = ((float *) (cvt->buf + cvt->len_cvt)) - 1;\n    const float *target = ((const float *) cvt->buf);\n    double last_sample0 = (double) SDL_SwapFloatBE(src[0]);\n    while (dst >= target) {\n        const double sample0 = (double) SDL_SwapFloatBE(src[0]);\n        src--;\n        dst[1] = (float) ((sample0 + last_sample0) * 0.5);\n        dst[0] = (float) sample0;\n        last_sample0 = sample0;\n        dst -= 2;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_F32MSB_1c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_F32MSB, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    float *dst = (float *) cvt->buf;\n    const float *src = (float *) cvt->buf;\n    const float *target = (const float *) (cvt->buf + dstsize);\n    double last_sample0 = (double) SDL_SwapFloatBE(src[0]);\n    while (dst < target) {\n        const double sample0 = (double) SDL_SwapFloatBE(src[0]);\n        src += 2;\n        dst[0] = (float) ((sample0 + last_sample0) * 0.5);\n        last_sample0 = sample0;\n        dst++;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_F32MSB_1c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_F32MSB, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    float *dst = ((float *) (cvt->buf + dstsize)) - 1 * 4;\n    const float *src = ((float *) (cvt->buf + cvt->len_cvt)) - 1;\n    const float *target = ((const float *) cvt->buf);\n    double last_sample0 = (double) SDL_SwapFloatBE(src[0]);\n    while (dst >= target) {\n        const double sample0 = (double) SDL_SwapFloatBE(src[0]);\n        src--;\n        dst[3] = (float) ((sample0 + (3.0 * last_sample0)) * 0.25);\n        dst[2] = (float) ((sample0 + last_sample0) * 0.5);\n        dst[1] = (float) (((3.0 * sample0) + last_sample0) * 0.25);\n        dst[0] = (float) sample0;\n        last_sample0 = sample0;\n        dst -= 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_F32MSB_1c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_F32MSB, 1 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    float *dst = (float *) cvt->buf;\n    const float *src = (float *) cvt->buf;\n    const float *target = (const float *) (cvt->buf + dstsize);\n    double last_sample0 = (double) SDL_SwapFloatBE(src[0]);\n    while (dst < target) {\n        const double sample0 = (double) SDL_SwapFloatBE(src[0]);\n        src += 4;\n        dst[0] = (float) ((sample0 + last_sample0) * 0.5);\n        last_sample0 = sample0;\n        dst++;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_F32MSB_2c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_F32MSB, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    float *dst = ((float *) (cvt->buf + dstsize)) - 2 * 2;\n    const float *src = ((float *) (cvt->buf + cvt->len_cvt)) - 2;\n    const float *target = ((const float *) cvt->buf);\n    double last_sample1 = (double) SDL_SwapFloatBE(src[1]);\n    double last_sample0 = (double) SDL_SwapFloatBE(src[0]);\n    while (dst >= target) {\n        const double sample1 = (double) SDL_SwapFloatBE(src[1]);\n        const double sample0 = (double) SDL_SwapFloatBE(src[0]);\n        src -= 2;\n        dst[3] = (float) ((sample1 + last_sample1) * 0.5);\n        dst[2] = (float) ((sample0 + last_sample0) * 0.5);\n        dst[1] = (float) sample1;\n        dst[0] = (float) sample0;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_F32MSB_2c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_F32MSB, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    float *dst = (float *) cvt->buf;\n    const float *src = (float *) cvt->buf;\n    const float *target = (const float *) (cvt->buf + dstsize);\n    double last_sample0 = (double) SDL_SwapFloatBE(src[0]);\n    double last_sample1 = (double) SDL_SwapFloatBE(src[1]);\n    while (dst < target) {\n        const double sample0 = (double) SDL_SwapFloatBE(src[0]);\n        const double sample1 = (double) SDL_SwapFloatBE(src[1]);\n        src += 4;\n        dst[0] = (float) ((sample0 + last_sample0) * 0.5);\n        dst[1] = (float) ((sample1 + last_sample1) * 0.5);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        dst += 2;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_F32MSB_2c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_F32MSB, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    float *dst = ((float *) (cvt->buf + dstsize)) - 2 * 4;\n    const float *src = ((float *) (cvt->buf + cvt->len_cvt)) - 2;\n    const float *target = ((const float *) cvt->buf);\n    double last_sample1 = (double) SDL_SwapFloatBE(src[1]);\n    double last_sample0 = (double) SDL_SwapFloatBE(src[0]);\n    while (dst >= target) {\n        const double sample1 = (double) SDL_SwapFloatBE(src[1]);\n        const double sample0 = (double) SDL_SwapFloatBE(src[0]);\n        src -= 2;\n        dst[7] = (float) ((sample1 + (3.0 * last_sample1)) * 0.25);\n        dst[6] = (float) ((sample0 + (3.0 * last_sample0)) * 0.25);\n        dst[5] = (float) ((sample1 + last_sample1) * 0.5);\n        dst[4] = (float) ((sample0 + last_sample0) * 0.5);\n        dst[3] = (float) (((3.0 * sample1) + last_sample1) * 0.25);\n        dst[2] = (float) (((3.0 * sample0) + last_sample0) * 0.25);\n        dst[1] = (float) sample1;\n        dst[0] = (float) sample0;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_F32MSB_2c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_F32MSB, 2 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    float *dst = (float *) cvt->buf;\n    const float *src = (float *) cvt->buf;\n    const float *target = (const float *) (cvt->buf + dstsize);\n    double last_sample0 = (double) SDL_SwapFloatBE(src[0]);\n    double last_sample1 = (double) SDL_SwapFloatBE(src[1]);\n    while (dst < target) {\n        const double sample0 = (double) SDL_SwapFloatBE(src[0]);\n        const double sample1 = (double) SDL_SwapFloatBE(src[1]);\n        src += 8;\n        dst[0] = (float) ((sample0 + last_sample0) * 0.5);\n        dst[1] = (float) ((sample1 + last_sample1) * 0.5);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        dst += 2;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_F32MSB_4c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_F32MSB, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    float *dst = ((float *) (cvt->buf + dstsize)) - 4 * 2;\n    const float *src = ((float *) (cvt->buf + cvt->len_cvt)) - 4;\n    const float *target = ((const float *) cvt->buf);\n    double last_sample3 = (double) SDL_SwapFloatBE(src[3]);\n    double last_sample2 = (double) SDL_SwapFloatBE(src[2]);\n    double last_sample1 = (double) SDL_SwapFloatBE(src[1]);\n    double last_sample0 = (double) SDL_SwapFloatBE(src[0]);\n    while (dst >= target) {\n        const double sample3 = (double) SDL_SwapFloatBE(src[3]);\n        const double sample2 = (double) SDL_SwapFloatBE(src[2]);\n        const double sample1 = (double) SDL_SwapFloatBE(src[1]);\n        const double sample0 = (double) SDL_SwapFloatBE(src[0]);\n        src -= 4;\n        dst[7] = (float) ((sample3 + last_sample3) * 0.5);\n        dst[6] = (float) ((sample2 + last_sample2) * 0.5);\n        dst[5] = (float) ((sample1 + last_sample1) * 0.5);\n        dst[4] = (float) ((sample0 + last_sample0) * 0.5);\n        dst[3] = (float) sample3;\n        dst[2] = (float) sample2;\n        dst[1] = (float) sample1;\n        dst[0] = (float) sample0;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_F32MSB_4c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_F32MSB, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    float *dst = (float *) cvt->buf;\n    const float *src = (float *) cvt->buf;\n    const float *target = (const float *) (cvt->buf + dstsize);\n    double last_sample0 = (double) SDL_SwapFloatBE(src[0]);\n    double last_sample1 = (double) SDL_SwapFloatBE(src[1]);\n    double last_sample2 = (double) SDL_SwapFloatBE(src[2]);\n    double last_sample3 = (double) SDL_SwapFloatBE(src[3]);\n    while (dst < target) {\n        const double sample0 = (double) SDL_SwapFloatBE(src[0]);\n        const double sample1 = (double) SDL_SwapFloatBE(src[1]);\n        const double sample2 = (double) SDL_SwapFloatBE(src[2]);\n        const double sample3 = (double) SDL_SwapFloatBE(src[3]);\n        src += 8;\n        dst[0] = (float) ((sample0 + last_sample0) * 0.5);\n        dst[1] = (float) ((sample1 + last_sample1) * 0.5);\n        dst[2] = (float) ((sample2 + last_sample2) * 0.5);\n        dst[3] = (float) ((sample3 + last_sample3) * 0.5);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        dst += 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_F32MSB_4c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_F32MSB, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    float *dst = ((float *) (cvt->buf + dstsize)) - 4 * 4;\n    const float *src = ((float *) (cvt->buf + cvt->len_cvt)) - 4;\n    const float *target = ((const float *) cvt->buf);\n    double last_sample3 = (double) SDL_SwapFloatBE(src[3]);\n    double last_sample2 = (double) SDL_SwapFloatBE(src[2]);\n    double last_sample1 = (double) SDL_SwapFloatBE(src[1]);\n    double last_sample0 = (double) SDL_SwapFloatBE(src[0]);\n    while (dst >= target) {\n        const double sample3 = (double) SDL_SwapFloatBE(src[3]);\n        const double sample2 = (double) SDL_SwapFloatBE(src[2]);\n        const double sample1 = (double) SDL_SwapFloatBE(src[1]);\n        const double sample0 = (double) SDL_SwapFloatBE(src[0]);\n        src -= 4;\n        dst[15] = (float) ((sample3 + (3.0 * last_sample3)) * 0.25);\n        dst[14] = (float) ((sample2 + (3.0 * last_sample2)) * 0.25);\n        dst[13] = (float) ((sample1 + (3.0 * last_sample1)) * 0.25);\n        dst[12] = (float) ((sample0 + (3.0 * last_sample0)) * 0.25);\n        dst[11] = (float) ((sample3 + last_sample3) * 0.5);\n        dst[10] = (float) ((sample2 + last_sample2) * 0.5);\n        dst[9] = (float) ((sample1 + last_sample1) * 0.5);\n        dst[8] = (float) ((sample0 + last_sample0) * 0.5);\n        dst[7] = (float) (((3.0 * sample3) + last_sample3) * 0.25);\n        dst[6] = (float) (((3.0 * sample2) + last_sample2) * 0.25);\n        dst[5] = (float) (((3.0 * sample1) + last_sample1) * 0.25);\n        dst[4] = (float) (((3.0 * sample0) + last_sample0) * 0.25);\n        dst[3] = (float) sample3;\n        dst[2] = (float) sample2;\n        dst[1] = (float) sample1;\n        dst[0] = (float) sample0;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 16;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_F32MSB_4c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_F32MSB, 4 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    float *dst = (float *) cvt->buf;\n    const float *src = (float *) cvt->buf;\n    const float *target = (const float *) (cvt->buf + dstsize);\n    double last_sample0 = (double) SDL_SwapFloatBE(src[0]);\n    double last_sample1 = (double) SDL_SwapFloatBE(src[1]);\n    double last_sample2 = (double) SDL_SwapFloatBE(src[2]);\n    double last_sample3 = (double) SDL_SwapFloatBE(src[3]);\n    while (dst < target) {\n        const double sample0 = (double) SDL_SwapFloatBE(src[0]);\n        const double sample1 = (double) SDL_SwapFloatBE(src[1]);\n        const double sample2 = (double) SDL_SwapFloatBE(src[2]);\n        const double sample3 = (double) SDL_SwapFloatBE(src[3]);\n        src += 16;\n        dst[0] = (float) ((sample0 + last_sample0) * 0.5);\n        dst[1] = (float) ((sample1 + last_sample1) * 0.5);\n        dst[2] = (float) ((sample2 + last_sample2) * 0.5);\n        dst[3] = (float) ((sample3 + last_sample3) * 0.5);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        dst += 4;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_F32MSB_6c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_F32MSB, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    float *dst = ((float *) (cvt->buf + dstsize)) - 6 * 2;\n    const float *src = ((float *) (cvt->buf + cvt->len_cvt)) - 6;\n    const float *target = ((const float *) cvt->buf);\n    double last_sample5 = (double) SDL_SwapFloatBE(src[5]);\n    double last_sample4 = (double) SDL_SwapFloatBE(src[4]);\n    double last_sample3 = (double) SDL_SwapFloatBE(src[3]);\n    double last_sample2 = (double) SDL_SwapFloatBE(src[2]);\n    double last_sample1 = (double) SDL_SwapFloatBE(src[1]);\n    double last_sample0 = (double) SDL_SwapFloatBE(src[0]);\n    while (dst >= target) {\n        const double sample5 = (double) SDL_SwapFloatBE(src[5]);\n        const double sample4 = (double) SDL_SwapFloatBE(src[4]);\n        const double sample3 = (double) SDL_SwapFloatBE(src[3]);\n        const double sample2 = (double) SDL_SwapFloatBE(src[2]);\n        const double sample1 = (double) SDL_SwapFloatBE(src[1]);\n        const double sample0 = (double) SDL_SwapFloatBE(src[0]);\n        src -= 6;\n        dst[11] = (float) ((sample5 + last_sample5) * 0.5);\n        dst[10] = (float) ((sample4 + last_sample4) * 0.5);\n        dst[9] = (float) ((sample3 + last_sample3) * 0.5);\n        dst[8] = (float) ((sample2 + last_sample2) * 0.5);\n        dst[7] = (float) ((sample1 + last_sample1) * 0.5);\n        dst[6] = (float) ((sample0 + last_sample0) * 0.5);\n        dst[5] = (float) sample5;\n        dst[4] = (float) sample4;\n        dst[3] = (float) sample3;\n        dst[2] = (float) sample2;\n        dst[1] = (float) sample1;\n        dst[0] = (float) sample0;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 12;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_F32MSB_6c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_F32MSB, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    float *dst = (float *) cvt->buf;\n    const float *src = (float *) cvt->buf;\n    const float *target = (const float *) (cvt->buf + dstsize);\n    double last_sample0 = (double) SDL_SwapFloatBE(src[0]);\n    double last_sample1 = (double) SDL_SwapFloatBE(src[1]);\n    double last_sample2 = (double) SDL_SwapFloatBE(src[2]);\n    double last_sample3 = (double) SDL_SwapFloatBE(src[3]);\n    double last_sample4 = (double) SDL_SwapFloatBE(src[4]);\n    double last_sample5 = (double) SDL_SwapFloatBE(src[5]);\n    while (dst < target) {\n        const double sample0 = (double) SDL_SwapFloatBE(src[0]);\n        const double sample1 = (double) SDL_SwapFloatBE(src[1]);\n        const double sample2 = (double) SDL_SwapFloatBE(src[2]);\n        const double sample3 = (double) SDL_SwapFloatBE(src[3]);\n        const double sample4 = (double) SDL_SwapFloatBE(src[4]);\n        const double sample5 = (double) SDL_SwapFloatBE(src[5]);\n        src += 12;\n        dst[0] = (float) ((sample0 + last_sample0) * 0.5);\n        dst[1] = (float) ((sample1 + last_sample1) * 0.5);\n        dst[2] = (float) ((sample2 + last_sample2) * 0.5);\n        dst[3] = (float) ((sample3 + last_sample3) * 0.5);\n        dst[4] = (float) ((sample4 + last_sample4) * 0.5);\n        dst[5] = (float) ((sample5 + last_sample5) * 0.5);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        dst += 6;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_F32MSB_6c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_F32MSB, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    float *dst = ((float *) (cvt->buf + dstsize)) - 6 * 4;\n    const float *src = ((float *) (cvt->buf + cvt->len_cvt)) - 6;\n    const float *target = ((const float *) cvt->buf);\n    double last_sample5 = (double) SDL_SwapFloatBE(src[5]);\n    double last_sample4 = (double) SDL_SwapFloatBE(src[4]);\n    double last_sample3 = (double) SDL_SwapFloatBE(src[3]);\n    double last_sample2 = (double) SDL_SwapFloatBE(src[2]);\n    double last_sample1 = (double) SDL_SwapFloatBE(src[1]);\n    double last_sample0 = (double) SDL_SwapFloatBE(src[0]);\n    while (dst >= target) {\n        const double sample5 = (double) SDL_SwapFloatBE(src[5]);\n        const double sample4 = (double) SDL_SwapFloatBE(src[4]);\n        const double sample3 = (double) SDL_SwapFloatBE(src[3]);\n        const double sample2 = (double) SDL_SwapFloatBE(src[2]);\n        const double sample1 = (double) SDL_SwapFloatBE(src[1]);\n        const double sample0 = (double) SDL_SwapFloatBE(src[0]);\n        src -= 6;\n        dst[23] = (float) ((sample5 + (3.0 * last_sample5)) * 0.25);\n        dst[22] = (float) ((sample4 + (3.0 * last_sample4)) * 0.25);\n        dst[21] = (float) ((sample3 + (3.0 * last_sample3)) * 0.25);\n        dst[20] = (float) ((sample2 + (3.0 * last_sample2)) * 0.25);\n        dst[19] = (float) ((sample1 + (3.0 * last_sample1)) * 0.25);\n        dst[18] = (float) ((sample0 + (3.0 * last_sample0)) * 0.25);\n        dst[17] = (float) ((sample5 + last_sample5) * 0.5);\n        dst[16] = (float) ((sample4 + last_sample4) * 0.5);\n        dst[15] = (float) ((sample3 + last_sample3) * 0.5);\n        dst[14] = (float) ((sample2 + last_sample2) * 0.5);\n        dst[13] = (float) ((sample1 + last_sample1) * 0.5);\n        dst[12] = (float) ((sample0 + last_sample0) * 0.5);\n        dst[11] = (float) (((3.0 * sample5) + last_sample5) * 0.25);\n        dst[10] = (float) (((3.0 * sample4) + last_sample4) * 0.25);\n        dst[9] = (float) (((3.0 * sample3) + last_sample3) * 0.25);\n        dst[8] = (float) (((3.0 * sample2) + last_sample2) * 0.25);\n        dst[7] = (float) (((3.0 * sample1) + last_sample1) * 0.25);\n        dst[6] = (float) (((3.0 * sample0) + last_sample0) * 0.25);\n        dst[5] = (float) sample5;\n        dst[4] = (float) sample4;\n        dst[3] = (float) sample3;\n        dst[2] = (float) sample2;\n        dst[1] = (float) sample1;\n        dst[0] = (float) sample0;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 24;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_F32MSB_6c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_F32MSB, 6 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    float *dst = (float *) cvt->buf;\n    const float *src = (float *) cvt->buf;\n    const float *target = (const float *) (cvt->buf + dstsize);\n    double last_sample0 = (double) SDL_SwapFloatBE(src[0]);\n    double last_sample1 = (double) SDL_SwapFloatBE(src[1]);\n    double last_sample2 = (double) SDL_SwapFloatBE(src[2]);\n    double last_sample3 = (double) SDL_SwapFloatBE(src[3]);\n    double last_sample4 = (double) SDL_SwapFloatBE(src[4]);\n    double last_sample5 = (double) SDL_SwapFloatBE(src[5]);\n    while (dst < target) {\n        const double sample0 = (double) SDL_SwapFloatBE(src[0]);\n        const double sample1 = (double) SDL_SwapFloatBE(src[1]);\n        const double sample2 = (double) SDL_SwapFloatBE(src[2]);\n        const double sample3 = (double) SDL_SwapFloatBE(src[3]);\n        const double sample4 = (double) SDL_SwapFloatBE(src[4]);\n        const double sample5 = (double) SDL_SwapFloatBE(src[5]);\n        src += 24;\n        dst[0] = (float) ((sample0 + last_sample0) * 0.5);\n        dst[1] = (float) ((sample1 + last_sample1) * 0.5);\n        dst[2] = (float) ((sample2 + last_sample2) * 0.5);\n        dst[3] = (float) ((sample3 + last_sample3) * 0.5);\n        dst[4] = (float) ((sample4 + last_sample4) * 0.5);\n        dst[5] = (float) ((sample5 + last_sample5) * 0.5);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        dst += 6;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_F32MSB_8c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x2) AUDIO_F32MSB, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 2;\n    float *dst = ((float *) (cvt->buf + dstsize)) - 8 * 2;\n    const float *src = ((float *) (cvt->buf + cvt->len_cvt)) - 8;\n    const float *target = ((const float *) cvt->buf);\n    double last_sample7 = (double) SDL_SwapFloatBE(src[7]);\n    double last_sample6 = (double) SDL_SwapFloatBE(src[6]);\n    double last_sample5 = (double) SDL_SwapFloatBE(src[5]);\n    double last_sample4 = (double) SDL_SwapFloatBE(src[4]);\n    double last_sample3 = (double) SDL_SwapFloatBE(src[3]);\n    double last_sample2 = (double) SDL_SwapFloatBE(src[2]);\n    double last_sample1 = (double) SDL_SwapFloatBE(src[1]);\n    double last_sample0 = (double) SDL_SwapFloatBE(src[0]);\n    while (dst >= target) {\n        const double sample7 = (double) SDL_SwapFloatBE(src[7]);\n        const double sample6 = (double) SDL_SwapFloatBE(src[6]);\n        const double sample5 = (double) SDL_SwapFloatBE(src[5]);\n        const double sample4 = (double) SDL_SwapFloatBE(src[4]);\n        const double sample3 = (double) SDL_SwapFloatBE(src[3]);\n        const double sample2 = (double) SDL_SwapFloatBE(src[2]);\n        const double sample1 = (double) SDL_SwapFloatBE(src[1]);\n        const double sample0 = (double) SDL_SwapFloatBE(src[0]);\n        src -= 8;\n        dst[15] = (float) ((sample7 + last_sample7) * 0.5);\n        dst[14] = (float) ((sample6 + last_sample6) * 0.5);\n        dst[13] = (float) ((sample5 + last_sample5) * 0.5);\n        dst[12] = (float) ((sample4 + last_sample4) * 0.5);\n        dst[11] = (float) ((sample3 + last_sample3) * 0.5);\n        dst[10] = (float) ((sample2 + last_sample2) * 0.5);\n        dst[9] = (float) ((sample1 + last_sample1) * 0.5);\n        dst[8] = (float) ((sample0 + last_sample0) * 0.5);\n        dst[7] = (float) sample7;\n        dst[6] = (float) sample6;\n        dst[5] = (float) sample5;\n        dst[4] = (float) sample4;\n        dst[3] = (float) sample3;\n        dst[2] = (float) sample2;\n        dst[1] = (float) sample1;\n        dst[0] = (float) sample0;\n        last_sample7 = sample7;\n        last_sample6 = sample6;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 16;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_F32MSB_8c_x2(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x2) AUDIO_F32MSB, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 2;\n    float *dst = (float *) cvt->buf;\n    const float *src = (float *) cvt->buf;\n    const float *target = (const float *) (cvt->buf + dstsize);\n    double last_sample0 = (double) SDL_SwapFloatBE(src[0]);\n    double last_sample1 = (double) SDL_SwapFloatBE(src[1]);\n    double last_sample2 = (double) SDL_SwapFloatBE(src[2]);\n    double last_sample3 = (double) SDL_SwapFloatBE(src[3]);\n    double last_sample4 = (double) SDL_SwapFloatBE(src[4]);\n    double last_sample5 = (double) SDL_SwapFloatBE(src[5]);\n    double last_sample6 = (double) SDL_SwapFloatBE(src[6]);\n    double last_sample7 = (double) SDL_SwapFloatBE(src[7]);\n    while (dst < target) {\n        const double sample0 = (double) SDL_SwapFloatBE(src[0]);\n        const double sample1 = (double) SDL_SwapFloatBE(src[1]);\n        const double sample2 = (double) SDL_SwapFloatBE(src[2]);\n        const double sample3 = (double) SDL_SwapFloatBE(src[3]);\n        const double sample4 = (double) SDL_SwapFloatBE(src[4]);\n        const double sample5 = (double) SDL_SwapFloatBE(src[5]);\n        const double sample6 = (double) SDL_SwapFloatBE(src[6]);\n        const double sample7 = (double) SDL_SwapFloatBE(src[7]);\n        src += 16;\n        dst[0] = (float) ((sample0 + last_sample0) * 0.5);\n        dst[1] = (float) ((sample1 + last_sample1) * 0.5);\n        dst[2] = (float) ((sample2 + last_sample2) * 0.5);\n        dst[3] = (float) ((sample3 + last_sample3) * 0.5);\n        dst[4] = (float) ((sample4 + last_sample4) * 0.5);\n        dst[5] = (float) ((sample5 + last_sample5) * 0.5);\n        dst[6] = (float) ((sample6 + last_sample6) * 0.5);\n        dst[7] = (float) ((sample7 + last_sample7) * 0.5);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        last_sample6 = sample6;\n        last_sample7 = sample7;\n        dst += 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Upsample_F32MSB_8c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Upsample (x4) AUDIO_F32MSB, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt * 4;\n    float *dst = ((float *) (cvt->buf + dstsize)) - 8 * 4;\n    const float *src = ((float *) (cvt->buf + cvt->len_cvt)) - 8;\n    const float *target = ((const float *) cvt->buf);\n    double last_sample7 = (double) SDL_SwapFloatBE(src[7]);\n    double last_sample6 = (double) SDL_SwapFloatBE(src[6]);\n    double last_sample5 = (double) SDL_SwapFloatBE(src[5]);\n    double last_sample4 = (double) SDL_SwapFloatBE(src[4]);\n    double last_sample3 = (double) SDL_SwapFloatBE(src[3]);\n    double last_sample2 = (double) SDL_SwapFloatBE(src[2]);\n    double last_sample1 = (double) SDL_SwapFloatBE(src[1]);\n    double last_sample0 = (double) SDL_SwapFloatBE(src[0]);\n    while (dst >= target) {\n        const double sample7 = (double) SDL_SwapFloatBE(src[7]);\n        const double sample6 = (double) SDL_SwapFloatBE(src[6]);\n        const double sample5 = (double) SDL_SwapFloatBE(src[5]);\n        const double sample4 = (double) SDL_SwapFloatBE(src[4]);\n        const double sample3 = (double) SDL_SwapFloatBE(src[3]);\n        const double sample2 = (double) SDL_SwapFloatBE(src[2]);\n        const double sample1 = (double) SDL_SwapFloatBE(src[1]);\n        const double sample0 = (double) SDL_SwapFloatBE(src[0]);\n        src -= 8;\n        dst[31] = (float) ((sample7 + (3.0 * last_sample7)) * 0.25);\n        dst[30] = (float) ((sample6 + (3.0 * last_sample6)) * 0.25);\n        dst[29] = (float) ((sample5 + (3.0 * last_sample5)) * 0.25);\n        dst[28] = (float) ((sample4 + (3.0 * last_sample4)) * 0.25);\n        dst[27] = (float) ((sample3 + (3.0 * last_sample3)) * 0.25);\n        dst[26] = (float) ((sample2 + (3.0 * last_sample2)) * 0.25);\n        dst[25] = (float) ((sample1 + (3.0 * last_sample1)) * 0.25);\n        dst[24] = (float) ((sample0 + (3.0 * last_sample0)) * 0.25);\n        dst[23] = (float) ((sample7 + last_sample7) * 0.5);\n        dst[22] = (float) ((sample6 + last_sample6) * 0.5);\n        dst[21] = (float) ((sample5 + last_sample5) * 0.5);\n        dst[20] = (float) ((sample4 + last_sample4) * 0.5);\n        dst[19] = (float) ((sample3 + last_sample3) * 0.5);\n        dst[18] = (float) ((sample2 + last_sample2) * 0.5);\n        dst[17] = (float) ((sample1 + last_sample1) * 0.5);\n        dst[16] = (float) ((sample0 + last_sample0) * 0.5);\n        dst[15] = (float) (((3.0 * sample7) + last_sample7) * 0.25);\n        dst[14] = (float) (((3.0 * sample6) + last_sample6) * 0.25);\n        dst[13] = (float) (((3.0 * sample5) + last_sample5) * 0.25);\n        dst[12] = (float) (((3.0 * sample4) + last_sample4) * 0.25);\n        dst[11] = (float) (((3.0 * sample3) + last_sample3) * 0.25);\n        dst[10] = (float) (((3.0 * sample2) + last_sample2) * 0.25);\n        dst[9] = (float) (((3.0 * sample1) + last_sample1) * 0.25);\n        dst[8] = (float) (((3.0 * sample0) + last_sample0) * 0.25);\n        dst[7] = (float) sample7;\n        dst[6] = (float) sample6;\n        dst[5] = (float) sample5;\n        dst[4] = (float) sample4;\n        dst[3] = (float) sample3;\n        dst[2] = (float) sample2;\n        dst[1] = (float) sample1;\n        dst[0] = (float) sample0;\n        last_sample7 = sample7;\n        last_sample6 = sample6;\n        last_sample5 = sample5;\n        last_sample4 = sample4;\n        last_sample3 = sample3;\n        last_sample2 = sample2;\n        last_sample1 = sample1;\n        last_sample0 = sample0;\n        dst -= 32;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\nstatic void SDLCALL\nSDL_Downsample_F32MSB_8c_x4(SDL_AudioCVT * cvt, SDL_AudioFormat format)\n{\n#if DEBUG_CONVERT\n    fprintf(stderr, \"Downsample (x4) AUDIO_F32MSB, 8 channels.\\n\");\n#endif\n\n    const int dstsize = cvt->len_cvt / 4;\n    float *dst = (float *) cvt->buf;\n    const float *src = (float *) cvt->buf;\n    const float *target = (const float *) (cvt->buf + dstsize);\n    double last_sample0 = (double) SDL_SwapFloatBE(src[0]);\n    double last_sample1 = (double) SDL_SwapFloatBE(src[1]);\n    double last_sample2 = (double) SDL_SwapFloatBE(src[2]);\n    double last_sample3 = (double) SDL_SwapFloatBE(src[3]);\n    double last_sample4 = (double) SDL_SwapFloatBE(src[4]);\n    double last_sample5 = (double) SDL_SwapFloatBE(src[5]);\n    double last_sample6 = (double) SDL_SwapFloatBE(src[6]);\n    double last_sample7 = (double) SDL_SwapFloatBE(src[7]);\n    while (dst < target) {\n        const double sample0 = (double) SDL_SwapFloatBE(src[0]);\n        const double sample1 = (double) SDL_SwapFloatBE(src[1]);\n        const double sample2 = (double) SDL_SwapFloatBE(src[2]);\n        const double sample3 = (double) SDL_SwapFloatBE(src[3]);\n        const double sample4 = (double) SDL_SwapFloatBE(src[4]);\n        const double sample5 = (double) SDL_SwapFloatBE(src[5]);\n        const double sample6 = (double) SDL_SwapFloatBE(src[6]);\n        const double sample7 = (double) SDL_SwapFloatBE(src[7]);\n        src += 32;\n        dst[0] = (float) ((sample0 + last_sample0) * 0.5);\n        dst[1] = (float) ((sample1 + last_sample1) * 0.5);\n        dst[2] = (float) ((sample2 + last_sample2) * 0.5);\n        dst[3] = (float) ((sample3 + last_sample3) * 0.5);\n        dst[4] = (float) ((sample4 + last_sample4) * 0.5);\n        dst[5] = (float) ((sample5 + last_sample5) * 0.5);\n        dst[6] = (float) ((sample6 + last_sample6) * 0.5);\n        dst[7] = (float) ((sample7 + last_sample7) * 0.5);\n        last_sample0 = sample0;\n        last_sample1 = sample1;\n        last_sample2 = sample2;\n        last_sample3 = sample3;\n        last_sample4 = sample4;\n        last_sample5 = sample5;\n        last_sample6 = sample6;\n        last_sample7 = sample7;\n        dst += 8;\n    }\n\n    cvt->len_cvt = dstsize;\n    if (cvt->filters[++cvt->filter_index]) {\n        cvt->filters[cvt->filter_index] (cvt, format);\n    }\n}\n\n#endif  /* !LESS_RESAMPLERS */\n#endif  /* !NO_RESAMPLERS */\n\n\nconst SDL_AudioRateFilters sdl_audio_rate_filters[] =\n{\n#if !NO_RESAMPLERS\n    { AUDIO_U8, 1, 0, 0, SDL_Downsample_U8_1c },\n    { AUDIO_U8, 1, 1, 0, SDL_Upsample_U8_1c },\n    { AUDIO_U8, 2, 0, 0, SDL_Downsample_U8_2c },\n    { AUDIO_U8, 2, 1, 0, SDL_Upsample_U8_2c },\n    { AUDIO_U8, 4, 0, 0, SDL_Downsample_U8_4c },\n    { AUDIO_U8, 4, 1, 0, SDL_Upsample_U8_4c },\n    { AUDIO_U8, 6, 0, 0, SDL_Downsample_U8_6c },\n    { AUDIO_U8, 6, 1, 0, SDL_Upsample_U8_6c },\n    { AUDIO_U8, 8, 0, 0, SDL_Downsample_U8_8c },\n    { AUDIO_U8, 8, 1, 0, SDL_Upsample_U8_8c },\n    { AUDIO_S8, 1, 0, 0, SDL_Downsample_S8_1c },\n    { AUDIO_S8, 1, 1, 0, SDL_Upsample_S8_1c },\n    { AUDIO_S8, 2, 0, 0, SDL_Downsample_S8_2c },\n    { AUDIO_S8, 2, 1, 0, SDL_Upsample_S8_2c },\n    { AUDIO_S8, 4, 0, 0, SDL_Downsample_S8_4c },\n    { AUDIO_S8, 4, 1, 0, SDL_Upsample_S8_4c },\n    { AUDIO_S8, 6, 0, 0, SDL_Downsample_S8_6c },\n    { AUDIO_S8, 6, 1, 0, SDL_Upsample_S8_6c },\n    { AUDIO_S8, 8, 0, 0, SDL_Downsample_S8_8c },\n    { AUDIO_S8, 8, 1, 0, SDL_Upsample_S8_8c },\n    { AUDIO_U16LSB, 1, 0, 0, SDL_Downsample_U16LSB_1c },\n    { AUDIO_U16LSB, 1, 1, 0, SDL_Upsample_U16LSB_1c },\n    { AUDIO_U16LSB, 2, 0, 0, SDL_Downsample_U16LSB_2c },\n    { AUDIO_U16LSB, 2, 1, 0, SDL_Upsample_U16LSB_2c },\n    { AUDIO_U16LSB, 4, 0, 0, SDL_Downsample_U16LSB_4c },\n    { AUDIO_U16LSB, 4, 1, 0, SDL_Upsample_U16LSB_4c },\n    { AUDIO_U16LSB, 6, 0, 0, SDL_Downsample_U16LSB_6c },\n    { AUDIO_U16LSB, 6, 1, 0, SDL_Upsample_U16LSB_6c },\n    { AUDIO_U16LSB, 8, 0, 0, SDL_Downsample_U16LSB_8c },\n    { AUDIO_U16LSB, 8, 1, 0, SDL_Upsample_U16LSB_8c },\n    { AUDIO_S16LSB, 1, 0, 0, SDL_Downsample_S16LSB_1c },\n    { AUDIO_S16LSB, 1, 1, 0, SDL_Upsample_S16LSB_1c },\n    { AUDIO_S16LSB, 2, 0, 0, SDL_Downsample_S16LSB_2c },\n    { AUDIO_S16LSB, 2, 1, 0, SDL_Upsample_S16LSB_2c },\n    { AUDIO_S16LSB, 4, 0, 0, SDL_Downsample_S16LSB_4c },\n    { AUDIO_S16LSB, 4, 1, 0, SDL_Upsample_S16LSB_4c },\n    { AUDIO_S16LSB, 6, 0, 0, SDL_Downsample_S16LSB_6c },\n    { AUDIO_S16LSB, 6, 1, 0, SDL_Upsample_S16LSB_6c },\n    { AUDIO_S16LSB, 8, 0, 0, SDL_Downsample_S16LSB_8c },\n    { AUDIO_S16LSB, 8, 1, 0, SDL_Upsample_S16LSB_8c },\n    { AUDIO_U16MSB, 1, 0, 0, SDL_Downsample_U16MSB_1c },\n    { AUDIO_U16MSB, 1, 1, 0, SDL_Upsample_U16MSB_1c },\n    { AUDIO_U16MSB, 2, 0, 0, SDL_Downsample_U16MSB_2c },\n    { AUDIO_U16MSB, 2, 1, 0, SDL_Upsample_U16MSB_2c },\n    { AUDIO_U16MSB, 4, 0, 0, SDL_Downsample_U16MSB_4c },\n    { AUDIO_U16MSB, 4, 1, 0, SDL_Upsample_U16MSB_4c },\n    { AUDIO_U16MSB, 6, 0, 0, SDL_Downsample_U16MSB_6c },\n    { AUDIO_U16MSB, 6, 1, 0, SDL_Upsample_U16MSB_6c },\n    { AUDIO_U16MSB, 8, 0, 0, SDL_Downsample_U16MSB_8c },\n    { AUDIO_U16MSB, 8, 1, 0, SDL_Upsample_U16MSB_8c },\n    { AUDIO_S16MSB, 1, 0, 0, SDL_Downsample_S16MSB_1c },\n    { AUDIO_S16MSB, 1, 1, 0, SDL_Upsample_S16MSB_1c },\n    { AUDIO_S16MSB, 2, 0, 0, SDL_Downsample_S16MSB_2c },\n    { AUDIO_S16MSB, 2, 1, 0, SDL_Upsample_S16MSB_2c },\n    { AUDIO_S16MSB, 4, 0, 0, SDL_Downsample_S16MSB_4c },\n    { AUDIO_S16MSB, 4, 1, 0, SDL_Upsample_S16MSB_4c },\n    { AUDIO_S16MSB, 6, 0, 0, SDL_Downsample_S16MSB_6c },\n    { AUDIO_S16MSB, 6, 1, 0, SDL_Upsample_S16MSB_6c },\n    { AUDIO_S16MSB, 8, 0, 0, SDL_Downsample_S16MSB_8c },\n    { AUDIO_S16MSB, 8, 1, 0, SDL_Upsample_S16MSB_8c },\n    { AUDIO_S32LSB, 1, 0, 0, SDL_Downsample_S32LSB_1c },\n    { AUDIO_S32LSB, 1, 1, 0, SDL_Upsample_S32LSB_1c },\n    { AUDIO_S32LSB, 2, 0, 0, SDL_Downsample_S32LSB_2c },\n    { AUDIO_S32LSB, 2, 1, 0, SDL_Upsample_S32LSB_2c },\n    { AUDIO_S32LSB, 4, 0, 0, SDL_Downsample_S32LSB_4c },\n    { AUDIO_S32LSB, 4, 1, 0, SDL_Upsample_S32LSB_4c },\n    { AUDIO_S32LSB, 6, 0, 0, SDL_Downsample_S32LSB_6c },\n    { AUDIO_S32LSB, 6, 1, 0, SDL_Upsample_S32LSB_6c },\n    { AUDIO_S32LSB, 8, 0, 0, SDL_Downsample_S32LSB_8c },\n    { AUDIO_S32LSB, 8, 1, 0, SDL_Upsample_S32LSB_8c },\n    { AUDIO_S32MSB, 1, 0, 0, SDL_Downsample_S32MSB_1c },\n    { AUDIO_S32MSB, 1, 1, 0, SDL_Upsample_S32MSB_1c },\n    { AUDIO_S32MSB, 2, 0, 0, SDL_Downsample_S32MSB_2c },\n    { AUDIO_S32MSB, 2, 1, 0, SDL_Upsample_S32MSB_2c },\n    { AUDIO_S32MSB, 4, 0, 0, SDL_Downsample_S32MSB_4c },\n    { AUDIO_S32MSB, 4, 1, 0, SDL_Upsample_S32MSB_4c },\n    { AUDIO_S32MSB, 6, 0, 0, SDL_Downsample_S32MSB_6c },\n    { AUDIO_S32MSB, 6, 1, 0, SDL_Upsample_S32MSB_6c },\n    { AUDIO_S32MSB, 8, 0, 0, SDL_Downsample_S32MSB_8c },\n    { AUDIO_S32MSB, 8, 1, 0, SDL_Upsample_S32MSB_8c },\n    { AUDIO_F32LSB, 1, 0, 0, SDL_Downsample_F32LSB_1c },\n    { AUDIO_F32LSB, 1, 1, 0, SDL_Upsample_F32LSB_1c },\n    { AUDIO_F32LSB, 2, 0, 0, SDL_Downsample_F32LSB_2c },\n    { AUDIO_F32LSB, 2, 1, 0, SDL_Upsample_F32LSB_2c },\n    { AUDIO_F32LSB, 4, 0, 0, SDL_Downsample_F32LSB_4c },\n    { AUDIO_F32LSB, 4, 1, 0, SDL_Upsample_F32LSB_4c },\n    { AUDIO_F32LSB, 6, 0, 0, SDL_Downsample_F32LSB_6c },\n    { AUDIO_F32LSB, 6, 1, 0, SDL_Upsample_F32LSB_6c },\n    { AUDIO_F32LSB, 8, 0, 0, SDL_Downsample_F32LSB_8c },\n    { AUDIO_F32LSB, 8, 1, 0, SDL_Upsample_F32LSB_8c },\n    { AUDIO_F32MSB, 1, 0, 0, SDL_Downsample_F32MSB_1c },\n    { AUDIO_F32MSB, 1, 1, 0, SDL_Upsample_F32MSB_1c },\n    { AUDIO_F32MSB, 2, 0, 0, SDL_Downsample_F32MSB_2c },\n    { AUDIO_F32MSB, 2, 1, 0, SDL_Upsample_F32MSB_2c },\n    { AUDIO_F32MSB, 4, 0, 0, SDL_Downsample_F32MSB_4c },\n    { AUDIO_F32MSB, 4, 1, 0, SDL_Upsample_F32MSB_4c },\n    { AUDIO_F32MSB, 6, 0, 0, SDL_Downsample_F32MSB_6c },\n    { AUDIO_F32MSB, 6, 1, 0, SDL_Upsample_F32MSB_6c },\n    { AUDIO_F32MSB, 8, 0, 0, SDL_Downsample_F32MSB_8c },\n    { AUDIO_F32MSB, 8, 1, 0, SDL_Upsample_F32MSB_8c },\n#if !LESS_RESAMPLERS\n    { AUDIO_U8, 1, 0, 2, SDL_Downsample_U8_1c_x2 },\n    { AUDIO_U8, 1, 1, 2, SDL_Upsample_U8_1c_x2 },\n    { AUDIO_U8, 1, 0, 4, SDL_Downsample_U8_1c_x4 },\n    { AUDIO_U8, 1, 1, 4, SDL_Upsample_U8_1c_x4 },\n    { AUDIO_U8, 2, 0, 2, SDL_Downsample_U8_2c_x2 },\n    { AUDIO_U8, 2, 1, 2, SDL_Upsample_U8_2c_x2 },\n    { AUDIO_U8, 2, 0, 4, SDL_Downsample_U8_2c_x4 },\n    { AUDIO_U8, 2, 1, 4, SDL_Upsample_U8_2c_x4 },\n    { AUDIO_U8, 4, 0, 2, SDL_Downsample_U8_4c_x2 },\n    { AUDIO_U8, 4, 1, 2, SDL_Upsample_U8_4c_x2 },\n    { AUDIO_U8, 4, 0, 4, SDL_Downsample_U8_4c_x4 },\n    { AUDIO_U8, 4, 1, 4, SDL_Upsample_U8_4c_x4 },\n    { AUDIO_U8, 6, 0, 2, SDL_Downsample_U8_6c_x2 },\n    { AUDIO_U8, 6, 1, 2, SDL_Upsample_U8_6c_x2 },\n    { AUDIO_U8, 6, 0, 4, SDL_Downsample_U8_6c_x4 },\n    { AUDIO_U8, 6, 1, 4, SDL_Upsample_U8_6c_x4 },\n    { AUDIO_U8, 8, 0, 2, SDL_Downsample_U8_8c_x2 },\n    { AUDIO_U8, 8, 1, 2, SDL_Upsample_U8_8c_x2 },\n    { AUDIO_U8, 8, 0, 4, SDL_Downsample_U8_8c_x4 },\n    { AUDIO_U8, 8, 1, 4, SDL_Upsample_U8_8c_x4 },\n    { AUDIO_S8, 1, 0, 2, SDL_Downsample_S8_1c_x2 },\n    { AUDIO_S8, 1, 1, 2, SDL_Upsample_S8_1c_x2 },\n    { AUDIO_S8, 1, 0, 4, SDL_Downsample_S8_1c_x4 },\n    { AUDIO_S8, 1, 1, 4, SDL_Upsample_S8_1c_x4 },\n    { AUDIO_S8, 2, 0, 2, SDL_Downsample_S8_2c_x2 },\n    { AUDIO_S8, 2, 1, 2, SDL_Upsample_S8_2c_x2 },\n    { AUDIO_S8, 2, 0, 4, SDL_Downsample_S8_2c_x4 },\n    { AUDIO_S8, 2, 1, 4, SDL_Upsample_S8_2c_x4 },\n    { AUDIO_S8, 4, 0, 2, SDL_Downsample_S8_4c_x2 },\n    { AUDIO_S8, 4, 1, 2, SDL_Upsample_S8_4c_x2 },\n    { AUDIO_S8, 4, 0, 4, SDL_Downsample_S8_4c_x4 },\n    { AUDIO_S8, 4, 1, 4, SDL_Upsample_S8_4c_x4 },\n    { AUDIO_S8, 6, 0, 2, SDL_Downsample_S8_6c_x2 },\n    { AUDIO_S8, 6, 1, 2, SDL_Upsample_S8_6c_x2 },\n    { AUDIO_S8, 6, 0, 4, SDL_Downsample_S8_6c_x4 },\n    { AUDIO_S8, 6, 1, 4, SDL_Upsample_S8_6c_x4 },\n    { AUDIO_S8, 8, 0, 2, SDL_Downsample_S8_8c_x2 },\n    { AUDIO_S8, 8, 1, 2, SDL_Upsample_S8_8c_x2 },\n    { AUDIO_S8, 8, 0, 4, SDL_Downsample_S8_8c_x4 },\n    { AUDIO_S8, 8, 1, 4, SDL_Upsample_S8_8c_x4 },\n    { AUDIO_U16LSB, 1, 0, 2, SDL_Downsample_U16LSB_1c_x2 },\n    { AUDIO_U16LSB, 1, 1, 2, SDL_Upsample_U16LSB_1c_x2 },\n    { AUDIO_U16LSB, 1, 0, 4, SDL_Downsample_U16LSB_1c_x4 },\n    { AUDIO_U16LSB, 1, 1, 4, SDL_Upsample_U16LSB_1c_x4 },\n    { AUDIO_U16LSB, 2, 0, 2, SDL_Downsample_U16LSB_2c_x2 },\n    { AUDIO_U16LSB, 2, 1, 2, SDL_Upsample_U16LSB_2c_x2 },\n    { AUDIO_U16LSB, 2, 0, 4, SDL_Downsample_U16LSB_2c_x4 },\n    { AUDIO_U16LSB, 2, 1, 4, SDL_Upsample_U16LSB_2c_x4 },\n    { AUDIO_U16LSB, 4, 0, 2, SDL_Downsample_U16LSB_4c_x2 },\n    { AUDIO_U16LSB, 4, 1, 2, SDL_Upsample_U16LSB_4c_x2 },\n    { AUDIO_U16LSB, 4, 0, 4, SDL_Downsample_U16LSB_4c_x4 },\n    { AUDIO_U16LSB, 4, 1, 4, SDL_Upsample_U16LSB_4c_x4 },\n    { AUDIO_U16LSB, 6, 0, 2, SDL_Downsample_U16LSB_6c_x2 },\n    { AUDIO_U16LSB, 6, 1, 2, SDL_Upsample_U16LSB_6c_x2 },\n    { AUDIO_U16LSB, 6, 0, 4, SDL_Downsample_U16LSB_6c_x4 },\n    { AUDIO_U16LSB, 6, 1, 4, SDL_Upsample_U16LSB_6c_x4 },\n    { AUDIO_U16LSB, 8, 0, 2, SDL_Downsample_U16LSB_8c_x2 },\n    { AUDIO_U16LSB, 8, 1, 2, SDL_Upsample_U16LSB_8c_x2 },\n    { AUDIO_U16LSB, 8, 0, 4, SDL_Downsample_U16LSB_8c_x4 },\n    { AUDIO_U16LSB, 8, 1, 4, SDL_Upsample_U16LSB_8c_x4 },\n    { AUDIO_S16LSB, 1, 0, 2, SDL_Downsample_S16LSB_1c_x2 },\n    { AUDIO_S16LSB, 1, 1, 2, SDL_Upsample_S16LSB_1c_x2 },\n    { AUDIO_S16LSB, 1, 0, 4, SDL_Downsample_S16LSB_1c_x4 },\n    { AUDIO_S16LSB, 1, 1, 4, SDL_Upsample_S16LSB_1c_x4 },\n    { AUDIO_S16LSB, 2, 0, 2, SDL_Downsample_S16LSB_2c_x2 },\n    { AUDIO_S16LSB, 2, 1, 2, SDL_Upsample_S16LSB_2c_x2 },\n    { AUDIO_S16LSB, 2, 0, 4, SDL_Downsample_S16LSB_2c_x4 },\n    { AUDIO_S16LSB, 2, 1, 4, SDL_Upsample_S16LSB_2c_x4 },\n    { AUDIO_S16LSB, 4, 0, 2, SDL_Downsample_S16LSB_4c_x2 },\n    { AUDIO_S16LSB, 4, 1, 2, SDL_Upsample_S16LSB_4c_x2 },\n    { AUDIO_S16LSB, 4, 0, 4, SDL_Downsample_S16LSB_4c_x4 },\n    { AUDIO_S16LSB, 4, 1, 4, SDL_Upsample_S16LSB_4c_x4 },\n    { AUDIO_S16LSB, 6, 0, 2, SDL_Downsample_S16LSB_6c_x2 },\n    { AUDIO_S16LSB, 6, 1, 2, SDL_Upsample_S16LSB_6c_x2 },\n    { AUDIO_S16LSB, 6, 0, 4, SDL_Downsample_S16LSB_6c_x4 },\n    { AUDIO_S16LSB, 6, 1, 4, SDL_Upsample_S16LSB_6c_x4 },\n    { AUDIO_S16LSB, 8, 0, 2, SDL_Downsample_S16LSB_8c_x2 },\n    { AUDIO_S16LSB, 8, 1, 2, SDL_Upsample_S16LSB_8c_x2 },\n    { AUDIO_S16LSB, 8, 0, 4, SDL_Downsample_S16LSB_8c_x4 },\n    { AUDIO_S16LSB, 8, 1, 4, SDL_Upsample_S16LSB_8c_x4 },\n    { AUDIO_U16MSB, 1, 0, 2, SDL_Downsample_U16MSB_1c_x2 },\n    { AUDIO_U16MSB, 1, 1, 2, SDL_Upsample_U16MSB_1c_x2 },\n    { AUDIO_U16MSB, 1, 0, 4, SDL_Downsample_U16MSB_1c_x4 },\n    { AUDIO_U16MSB, 1, 1, 4, SDL_Upsample_U16MSB_1c_x4 },\n    { AUDIO_U16MSB, 2, 0, 2, SDL_Downsample_U16MSB_2c_x2 },\n    { AUDIO_U16MSB, 2, 1, 2, SDL_Upsample_U16MSB_2c_x2 },\n    { AUDIO_U16MSB, 2, 0, 4, SDL_Downsample_U16MSB_2c_x4 },\n    { AUDIO_U16MSB, 2, 1, 4, SDL_Upsample_U16MSB_2c_x4 },\n    { AUDIO_U16MSB, 4, 0, 2, SDL_Downsample_U16MSB_4c_x2 },\n    { AUDIO_U16MSB, 4, 1, 2, SDL_Upsample_U16MSB_4c_x2 },\n    { AUDIO_U16MSB, 4, 0, 4, SDL_Downsample_U16MSB_4c_x4 },\n    { AUDIO_U16MSB, 4, 1, 4, SDL_Upsample_U16MSB_4c_x4 },\n    { AUDIO_U16MSB, 6, 0, 2, SDL_Downsample_U16MSB_6c_x2 },\n    { AUDIO_U16MSB, 6, 1, 2, SDL_Upsample_U16MSB_6c_x2 },\n    { AUDIO_U16MSB, 6, 0, 4, SDL_Downsample_U16MSB_6c_x4 },\n    { AUDIO_U16MSB, 6, 1, 4, SDL_Upsample_U16MSB_6c_x4 },\n    { AUDIO_U16MSB, 8, 0, 2, SDL_Downsample_U16MSB_8c_x2 },\n    { AUDIO_U16MSB, 8, 1, 2, SDL_Upsample_U16MSB_8c_x2 },\n    { AUDIO_U16MSB, 8, 0, 4, SDL_Downsample_U16MSB_8c_x4 },\n    { AUDIO_U16MSB, 8, 1, 4, SDL_Upsample_U16MSB_8c_x4 },\n    { AUDIO_S16MSB, 1, 0, 2, SDL_Downsample_S16MSB_1c_x2 },\n    { AUDIO_S16MSB, 1, 1, 2, SDL_Upsample_S16MSB_1c_x2 },\n    { AUDIO_S16MSB, 1, 0, 4, SDL_Downsample_S16MSB_1c_x4 },\n    { AUDIO_S16MSB, 1, 1, 4, SDL_Upsample_S16MSB_1c_x4 },\n    { AUDIO_S16MSB, 2, 0, 2, SDL_Downsample_S16MSB_2c_x2 },\n    { AUDIO_S16MSB, 2, 1, 2, SDL_Upsample_S16MSB_2c_x2 },\n    { AUDIO_S16MSB, 2, 0, 4, SDL_Downsample_S16MSB_2c_x4 },\n    { AUDIO_S16MSB, 2, 1, 4, SDL_Upsample_S16MSB_2c_x4 },\n    { AUDIO_S16MSB, 4, 0, 2, SDL_Downsample_S16MSB_4c_x2 },\n    { AUDIO_S16MSB, 4, 1, 2, SDL_Upsample_S16MSB_4c_x2 },\n    { AUDIO_S16MSB, 4, 0, 4, SDL_Downsample_S16MSB_4c_x4 },\n    { AUDIO_S16MSB, 4, 1, 4, SDL_Upsample_S16MSB_4c_x4 },\n    { AUDIO_S16MSB, 6, 0, 2, SDL_Downsample_S16MSB_6c_x2 },\n    { AUDIO_S16MSB, 6, 1, 2, SDL_Upsample_S16MSB_6c_x2 },\n    { AUDIO_S16MSB, 6, 0, 4, SDL_Downsample_S16MSB_6c_x4 },\n    { AUDIO_S16MSB, 6, 1, 4, SDL_Upsample_S16MSB_6c_x4 },\n    { AUDIO_S16MSB, 8, 0, 2, SDL_Downsample_S16MSB_8c_x2 },\n    { AUDIO_S16MSB, 8, 1, 2, SDL_Upsample_S16MSB_8c_x2 },\n    { AUDIO_S16MSB, 8, 0, 4, SDL_Downsample_S16MSB_8c_x4 },\n    { AUDIO_S16MSB, 8, 1, 4, SDL_Upsample_S16MSB_8c_x4 },\n    { AUDIO_S32LSB, 1, 0, 2, SDL_Downsample_S32LSB_1c_x2 },\n    { AUDIO_S32LSB, 1, 1, 2, SDL_Upsample_S32LSB_1c_x2 },\n    { AUDIO_S32LSB, 1, 0, 4, SDL_Downsample_S32LSB_1c_x4 },\n    { AUDIO_S32LSB, 1, 1, 4, SDL_Upsample_S32LSB_1c_x4 },\n    { AUDIO_S32LSB, 2, 0, 2, SDL_Downsample_S32LSB_2c_x2 },\n    { AUDIO_S32LSB, 2, 1, 2, SDL_Upsample_S32LSB_2c_x2 },\n    { AUDIO_S32LSB, 2, 0, 4, SDL_Downsample_S32LSB_2c_x4 },\n    { AUDIO_S32LSB, 2, 1, 4, SDL_Upsample_S32LSB_2c_x4 },\n    { AUDIO_S32LSB, 4, 0, 2, SDL_Downsample_S32LSB_4c_x2 },\n    { AUDIO_S32LSB, 4, 1, 2, SDL_Upsample_S32LSB_4c_x2 },\n    { AUDIO_S32LSB, 4, 0, 4, SDL_Downsample_S32LSB_4c_x4 },\n    { AUDIO_S32LSB, 4, 1, 4, SDL_Upsample_S32LSB_4c_x4 },\n    { AUDIO_S32LSB, 6, 0, 2, SDL_Downsample_S32LSB_6c_x2 },\n    { AUDIO_S32LSB, 6, 1, 2, SDL_Upsample_S32LSB_6c_x2 },\n    { AUDIO_S32LSB, 6, 0, 4, SDL_Downsample_S32LSB_6c_x4 },\n    { AUDIO_S32LSB, 6, 1, 4, SDL_Upsample_S32LSB_6c_x4 },\n    { AUDIO_S32LSB, 8, 0, 2, SDL_Downsample_S32LSB_8c_x2 },\n    { AUDIO_S32LSB, 8, 1, 2, SDL_Upsample_S32LSB_8c_x2 },\n    { AUDIO_S32LSB, 8, 0, 4, SDL_Downsample_S32LSB_8c_x4 },\n    { AUDIO_S32LSB, 8, 1, 4, SDL_Upsample_S32LSB_8c_x4 },\n    { AUDIO_S32MSB, 1, 0, 2, SDL_Downsample_S32MSB_1c_x2 },\n    { AUDIO_S32MSB, 1, 1, 2, SDL_Upsample_S32MSB_1c_x2 },\n    { AUDIO_S32MSB, 1, 0, 4, SDL_Downsample_S32MSB_1c_x4 },\n    { AUDIO_S32MSB, 1, 1, 4, SDL_Upsample_S32MSB_1c_x4 },\n    { AUDIO_S32MSB, 2, 0, 2, SDL_Downsample_S32MSB_2c_x2 },\n    { AUDIO_S32MSB, 2, 1, 2, SDL_Upsample_S32MSB_2c_x2 },\n    { AUDIO_S32MSB, 2, 0, 4, SDL_Downsample_S32MSB_2c_x4 },\n    { AUDIO_S32MSB, 2, 1, 4, SDL_Upsample_S32MSB_2c_x4 },\n    { AUDIO_S32MSB, 4, 0, 2, SDL_Downsample_S32MSB_4c_x2 },\n    { AUDIO_S32MSB, 4, 1, 2, SDL_Upsample_S32MSB_4c_x2 },\n    { AUDIO_S32MSB, 4, 0, 4, SDL_Downsample_S32MSB_4c_x4 },\n    { AUDIO_S32MSB, 4, 1, 4, SDL_Upsample_S32MSB_4c_x4 },\n    { AUDIO_S32MSB, 6, 0, 2, SDL_Downsample_S32MSB_6c_x2 },\n    { AUDIO_S32MSB, 6, 1, 2, SDL_Upsample_S32MSB_6c_x2 },\n    { AUDIO_S32MSB, 6, 0, 4, SDL_Downsample_S32MSB_6c_x4 },\n    { AUDIO_S32MSB, 6, 1, 4, SDL_Upsample_S32MSB_6c_x4 },\n    { AUDIO_S32MSB, 8, 0, 2, SDL_Downsample_S32MSB_8c_x2 },\n    { AUDIO_S32MSB, 8, 1, 2, SDL_Upsample_S32MSB_8c_x2 },\n    { AUDIO_S32MSB, 8, 0, 4, SDL_Downsample_S32MSB_8c_x4 },\n    { AUDIO_S32MSB, 8, 1, 4, SDL_Upsample_S32MSB_8c_x4 },\n    { AUDIO_F32LSB, 1, 0, 2, SDL_Downsample_F32LSB_1c_x2 },\n    { AUDIO_F32LSB, 1, 1, 2, SDL_Upsample_F32LSB_1c_x2 },\n    { AUDIO_F32LSB, 1, 0, 4, SDL_Downsample_F32LSB_1c_x4 },\n    { AUDIO_F32LSB, 1, 1, 4, SDL_Upsample_F32LSB_1c_x4 },\n    { AUDIO_F32LSB, 2, 0, 2, SDL_Downsample_F32LSB_2c_x2 },\n    { AUDIO_F32LSB, 2, 1, 2, SDL_Upsample_F32LSB_2c_x2 },\n    { AUDIO_F32LSB, 2, 0, 4, SDL_Downsample_F32LSB_2c_x4 },\n    { AUDIO_F32LSB, 2, 1, 4, SDL_Upsample_F32LSB_2c_x4 },\n    { AUDIO_F32LSB, 4, 0, 2, SDL_Downsample_F32LSB_4c_x2 },\n    { AUDIO_F32LSB, 4, 1, 2, SDL_Upsample_F32LSB_4c_x2 },\n    { AUDIO_F32LSB, 4, 0, 4, SDL_Downsample_F32LSB_4c_x4 },\n    { AUDIO_F32LSB, 4, 1, 4, SDL_Upsample_F32LSB_4c_x4 },\n    { AUDIO_F32LSB, 6, 0, 2, SDL_Downsample_F32LSB_6c_x2 },\n    { AUDIO_F32LSB, 6, 1, 2, SDL_Upsample_F32LSB_6c_x2 },\n    { AUDIO_F32LSB, 6, 0, 4, SDL_Downsample_F32LSB_6c_x4 },\n    { AUDIO_F32LSB, 6, 1, 4, SDL_Upsample_F32LSB_6c_x4 },\n    { AUDIO_F32LSB, 8, 0, 2, SDL_Downsample_F32LSB_8c_x2 },\n    { AUDIO_F32LSB, 8, 1, 2, SDL_Upsample_F32LSB_8c_x2 },\n    { AUDIO_F32LSB, 8, 0, 4, SDL_Downsample_F32LSB_8c_x4 },\n    { AUDIO_F32LSB, 8, 1, 4, SDL_Upsample_F32LSB_8c_x4 },\n    { AUDIO_F32MSB, 1, 0, 2, SDL_Downsample_F32MSB_1c_x2 },\n    { AUDIO_F32MSB, 1, 1, 2, SDL_Upsample_F32MSB_1c_x2 },\n    { AUDIO_F32MSB, 1, 0, 4, SDL_Downsample_F32MSB_1c_x4 },\n    { AUDIO_F32MSB, 1, 1, 4, SDL_Upsample_F32MSB_1c_x4 },\n    { AUDIO_F32MSB, 2, 0, 2, SDL_Downsample_F32MSB_2c_x2 },\n    { AUDIO_F32MSB, 2, 1, 2, SDL_Upsample_F32MSB_2c_x2 },\n    { AUDIO_F32MSB, 2, 0, 4, SDL_Downsample_F32MSB_2c_x4 },\n    { AUDIO_F32MSB, 2, 1, 4, SDL_Upsample_F32MSB_2c_x4 },\n    { AUDIO_F32MSB, 4, 0, 2, SDL_Downsample_F32MSB_4c_x2 },\n    { AUDIO_F32MSB, 4, 1, 2, SDL_Upsample_F32MSB_4c_x2 },\n    { AUDIO_F32MSB, 4, 0, 4, SDL_Downsample_F32MSB_4c_x4 },\n    { AUDIO_F32MSB, 4, 1, 4, SDL_Upsample_F32MSB_4c_x4 },\n    { AUDIO_F32MSB, 6, 0, 2, SDL_Downsample_F32MSB_6c_x2 },\n    { AUDIO_F32MSB, 6, 1, 2, SDL_Upsample_F32MSB_6c_x2 },\n    { AUDIO_F32MSB, 6, 0, 4, SDL_Downsample_F32MSB_6c_x4 },\n    { AUDIO_F32MSB, 6, 1, 4, SDL_Upsample_F32MSB_6c_x4 },\n    { AUDIO_F32MSB, 8, 0, 2, SDL_Downsample_F32MSB_8c_x2 },\n    { AUDIO_F32MSB, 8, 1, 2, SDL_Upsample_F32MSB_8c_x2 },\n    { AUDIO_F32MSB, 8, 0, 4, SDL_Downsample_F32MSB_8c_x4 },\n    { AUDIO_F32MSB, 8, 1, 4, SDL_Upsample_F32MSB_8c_x4 },\n#endif  /* !LESS_RESAMPLERS */\n#endif  /* !NO_RESAMPLERS */\n    { 0, 0, 0, 0, NULL }\n};\n\n/* 390 converters generated. */\n\n/* *INDENT-ON* */\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../SDL_internal.h\"\n\n/* General keyboard handling code for SDL */\n\n#include \"SDL_timer.h\"\n#include \"SDL_events.h\"\n#include \"SDL_events_c.h\"\n#include \"SDL_assert.h\"\n#include \"../video/SDL_sysvideo.h\"\n\n\n/* #define DEBUG_KEYBOARD */\n\n/* Global keyboard information */\n\ntypedef struct SDL_Keyboard SDL_Keyboard;\n\nstruct SDL_Keyboard\n{\n    /* Data common to all keyboards */\n    SDL_Window *focus;\n    Uint16 modstate;\n    Uint8 keystate[SDL_NUM_SCANCODES];\n    SDL_Keycode keymap[SDL_NUM_SCANCODES];\n};\n\nstatic SDL_Keyboard SDL_keyboard;\n\nstatic const SDL_Keycode SDL_default_keymap[SDL_NUM_SCANCODES] = {\n    0, 0, 0, 0,\n    'a',\n    'b',\n    'c',\n    'd',\n    'e',\n    'f',\n    'g',\n    'h',\n    'i',\n    'j',\n    'k',\n    'l',\n    'm',\n    'n',\n    'o',\n    'p',\n    'q',\n    'r',\n    's',\n    't',\n    'u',\n    'v',\n    'w',\n    'x',\n    'y',\n    'z',\n    '1',\n    '2',\n    '3',\n    '4',\n    '5',\n    '6',\n    '7',\n    '8',\n    '9',\n    '0',\n    SDLK_RETURN,\n    SDLK_ESCAPE,\n    SDLK_BACKSPACE,\n    SDLK_TAB,\n    SDLK_SPACE,\n    '-',\n    '=',\n    '[',\n    ']',\n    '\\\\',\n    '#',\n    ';',\n    '\\'',\n    '`',\n    ',',\n    '.',\n    '/',\n    SDLK_CAPSLOCK,\n    SDLK_F1,\n    SDLK_F2,\n    SDLK_F3,\n    SDLK_F4,\n    SDLK_F5,\n    SDLK_F6,\n    SDLK_F7,\n    SDLK_F8,\n    SDLK_F9,\n    SDLK_F10,\n    SDLK_F11,\n    SDLK_F12,\n    SDLK_PRINTSCREEN,\n    SDLK_SCROLLLOCK,\n    SDLK_PAUSE,\n    SDLK_INSERT,\n    SDLK_HOME,\n    SDLK_PAGEUP,\n    SDLK_DELETE,\n    SDLK_END,\n    SDLK_PAGEDOWN,\n    SDLK_RIGHT,\n    SDLK_LEFT,\n    SDLK_DOWN,\n    SDLK_UP,\n    SDLK_NUMLOCKCLEAR,\n    SDLK_KP_DIVIDE,\n    SDLK_KP_MULTIPLY,\n    SDLK_KP_MINUS,\n    SDLK_KP_PLUS,\n    SDLK_KP_ENTER,\n    SDLK_KP_1,\n    SDLK_KP_2,\n    SDLK_KP_3,\n    SDLK_KP_4,\n    SDLK_KP_5,\n    SDLK_KP_6,\n    SDLK_KP_7,\n    SDLK_KP_8,\n    SDLK_KP_9,\n    SDLK_KP_0,\n    SDLK_KP_PERIOD,\n    0,\n    SDLK_APPLICATION,\n    SDLK_POWER,\n    SDLK_KP_EQUALS,\n    SDLK_F13,\n    SDLK_F14,\n    SDLK_F15,\n    SDLK_F16,\n    SDLK_F17,\n    SDLK_F18,\n    SDLK_F19,\n    SDLK_F20,\n    SDLK_F21,\n    SDLK_F22,\n    SDLK_F23,\n    SDLK_F24,\n    SDLK_EXECUTE,\n    SDLK_HELP,\n    SDLK_MENU,\n    SDLK_SELECT,\n    SDLK_STOP,\n    SDLK_AGAIN,\n    SDLK_UNDO,\n    SDLK_CUT,\n    SDLK_COPY,\n    SDLK_PASTE,\n    SDLK_FIND,\n    SDLK_MUTE,\n    SDLK_VOLUMEUP,\n    SDLK_VOLUMEDOWN,\n    0, 0, 0,\n    SDLK_KP_COMMA,\n    SDLK_KP_EQUALSAS400,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    SDLK_ALTERASE,\n    SDLK_SYSREQ,\n    SDLK_CANCEL,\n    SDLK_CLEAR,\n    SDLK_PRIOR,\n    SDLK_RETURN2,\n    SDLK_SEPARATOR,\n    SDLK_OUT,\n    SDLK_OPER,\n    SDLK_CLEARAGAIN,\n    SDLK_CRSEL,\n    SDLK_EXSEL,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    SDLK_KP_00,\n    SDLK_KP_000,\n    SDLK_THOUSANDSSEPARATOR,\n    SDLK_DECIMALSEPARATOR,\n    SDLK_CURRENCYUNIT,\n    SDLK_CURRENCYSUBUNIT,\n    SDLK_KP_LEFTPAREN,\n    SDLK_KP_RIGHTPAREN,\n    SDLK_KP_LEFTBRACE,\n    SDLK_KP_RIGHTBRACE,\n    SDLK_KP_TAB,\n    SDLK_KP_BACKSPACE,\n    SDLK_KP_A,\n    SDLK_KP_B,\n    SDLK_KP_C,\n    SDLK_KP_D,\n    SDLK_KP_E,\n    SDLK_KP_F,\n    SDLK_KP_XOR,\n    SDLK_KP_POWER,\n    SDLK_KP_PERCENT,\n    SDLK_KP_LESS,\n    SDLK_KP_GREATER,\n    SDLK_KP_AMPERSAND,\n    SDLK_KP_DBLAMPERSAND,\n    SDLK_KP_VERTICALBAR,\n    SDLK_KP_DBLVERTICALBAR,\n    SDLK_KP_COLON,\n    SDLK_KP_HASH,\n    SDLK_KP_SPACE,\n    SDLK_KP_AT,\n    SDLK_KP_EXCLAM,\n    SDLK_KP_MEMSTORE,\n    SDLK_KP_MEMRECALL,\n    SDLK_KP_MEMCLEAR,\n    SDLK_KP_MEMADD,\n    SDLK_KP_MEMSUBTRACT,\n    SDLK_KP_MEMMULTIPLY,\n    SDLK_KP_MEMDIVIDE,\n    SDLK_KP_PLUSMINUS,\n    SDLK_KP_CLEAR,\n    SDLK_KP_CLEARENTRY,\n    SDLK_KP_BINARY,\n    SDLK_KP_OCTAL,\n    SDLK_KP_DECIMAL,\n    SDLK_KP_HEXADECIMAL,\n    0, 0,\n    SDLK_LCTRL,\n    SDLK_LSHIFT,\n    SDLK_LALT,\n    SDLK_LGUI,\n    SDLK_RCTRL,\n    SDLK_RSHIFT,\n    SDLK_RALT,\n    SDLK_RGUI,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    SDLK_MODE,\n    SDLK_AUDIONEXT,\n    SDLK_AUDIOPREV,\n    SDLK_AUDIOSTOP,\n    SDLK_AUDIOPLAY,\n    SDLK_AUDIOMUTE,\n    SDLK_MEDIASELECT,\n    SDLK_WWW,\n    SDLK_MAIL,\n    SDLK_CALCULATOR,\n    SDLK_COMPUTER,\n    SDLK_AC_SEARCH,\n    SDLK_AC_HOME,\n    SDLK_AC_BACK,\n    SDLK_AC_FORWARD,\n    SDLK_AC_STOP,\n    SDLK_AC_REFRESH,\n    SDLK_AC_BOOKMARKS,\n    SDLK_BRIGHTNESSDOWN,\n    SDLK_BRIGHTNESSUP,\n    SDLK_DISPLAYSWITCH,\n    SDLK_KBDILLUMTOGGLE,\n    SDLK_KBDILLUMDOWN,\n    SDLK_KBDILLUMUP,\n    SDLK_EJECT,\n    SDLK_SLEEP,\n};\n\nstatic const char *SDL_scancode_names[SDL_NUM_SCANCODES] = {\n    NULL, NULL, NULL, NULL,\n    \"A\",\n    \"B\",\n    \"C\",\n    \"D\",\n    \"E\",\n    \"F\",\n    \"G\",\n    \"H\",\n    \"I\",\n    \"J\",\n    \"K\",\n    \"L\",\n    \"M\",\n    \"N\",\n    \"O\",\n    \"P\",\n    \"Q\",\n    \"R\",\n    \"S\",\n    \"T\",\n    \"U\",\n    \"V\",\n    \"W\",\n    \"X\",\n    \"Y\",\n    \"Z\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"0\",\n    \"Return\",\n    \"Escape\",\n    \"Backspace\",\n    \"Tab\",\n    \"Space\",\n    \"-\",\n    \"=\",\n    \"[\",\n    \"]\",\n    \"\\\\\",\n    \"#\",\n    \";\",\n    \"'\",\n    \"`\",\n    \",\",\n    \".\",\n    \"/\",\n    \"CapsLock\",\n    \"F1\",\n    \"F2\",\n    \"F3\",\n    \"F4\",\n    \"F5\",\n    \"F6\",\n    \"F7\",\n    \"F8\",\n    \"F9\",\n    \"F10\",\n    \"F11\",\n    \"F12\",\n    \"PrintScreen\",\n    \"ScrollLock\",\n    \"Pause\",\n    \"Insert\",\n    \"Home\",\n    \"PageUp\",\n    \"Delete\",\n    \"End\",\n    \"PageDown\",\n    \"Right\",\n    \"Left\",\n    \"Down\",\n    \"Up\",\n    \"Numlock\",\n    \"Keypad /\",\n    \"Keypad *\",\n    \"Keypad -\",\n    \"Keypad +\",\n    \"Keypad Enter\",\n    \"Keypad 1\",\n    \"Keypad 2\",\n    \"Keypad 3\",\n    \"Keypad 4\",\n    \"Keypad 5\",\n    \"Keypad 6\",\n    \"Keypad 7\",\n    \"Keypad 8\",\n    \"Keypad 9\",\n    \"Keypad 0\",\n    \"Keypad .\",\n    NULL,\n    \"Application\",\n    \"Power\",\n    \"Keypad =\",\n    \"F13\",\n    \"F14\",\n    \"F15\",\n    \"F16\",\n    \"F17\",\n    \"F18\",\n    \"F19\",\n    \"F20\",\n    \"F21\",\n    \"F22\",\n    \"F23\",\n    \"F24\",\n    \"Execute\",\n    \"Help\",\n    \"Menu\",\n    \"Select\",\n    \"Stop\",\n    \"Again\",\n    \"Undo\",\n    \"Cut\",\n    \"Copy\",\n    \"Paste\",\n    \"Find\",\n    \"Mute\",\n    \"VolumeUp\",\n    \"VolumeDown\",\n    NULL, NULL, NULL,\n    \"Keypad ,\",\n    \"Keypad = (AS400)\",\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL, NULL, NULL,\n    \"AltErase\",\n    \"SysReq\",\n    \"Cancel\",\n    \"Clear\",\n    \"Prior\",\n    \"Return\",\n    \"Separator\",\n    \"Out\",\n    \"Oper\",\n    \"Clear / Again\",\n    \"CrSel\",\n    \"ExSel\",\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n    \"Keypad 00\",\n    \"Keypad 000\",\n    \"ThousandsSeparator\",\n    \"DecimalSeparator\",\n    \"CurrencyUnit\",\n    \"CurrencySubUnit\",\n    \"Keypad (\",\n    \"Keypad )\",\n    \"Keypad {\",\n    \"Keypad }\",\n    \"Keypad Tab\",\n    \"Keypad Backspace\",\n    \"Keypad A\",\n    \"Keypad B\",\n    \"Keypad C\",\n    \"Keypad D\",\n    \"Keypad E\",\n    \"Keypad F\",\n    \"Keypad XOR\",\n    \"Keypad ^\",\n    \"Keypad %\",\n    \"Keypad <\",\n    \"Keypad >\",\n    \"Keypad &\",\n    \"Keypad &&\",\n    \"Keypad |\",\n    \"Keypad ||\",\n    \"Keypad :\",\n    \"Keypad #\",\n    \"Keypad Space\",\n    \"Keypad @\",\n    \"Keypad !\",\n    \"Keypad MemStore\",\n    \"Keypad MemRecall\",\n    \"Keypad MemClear\",\n    \"Keypad MemAdd\",\n    \"Keypad MemSubtract\",\n    \"Keypad MemMultiply\",\n    \"Keypad MemDivide\",\n    \"Keypad +/-\",\n    \"Keypad Clear\",\n    \"Keypad ClearEntry\",\n    \"Keypad Binary\",\n    \"Keypad Octal\",\n    \"Keypad Decimal\",\n    \"Keypad Hexadecimal\",\n    NULL, NULL,\n    \"Left Ctrl\",\n    \"Left Shift\",\n    \"Left Alt\",\n    \"Left GUI\",\n    \"Right Ctrl\",\n    \"Right Shift\",\n    \"Right Alt\",\n    \"Right GUI\",\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n    NULL,\n    \"ModeSwitch\",\n    \"AudioNext\",\n    \"AudioPrev\",\n    \"AudioStop\",\n    \"AudioPlay\",\n    \"AudioMute\",\n    \"MediaSelect\",\n    \"WWW\",\n    \"Mail\",\n    \"Calculator\",\n    \"Computer\",\n    \"AC Search\",\n    \"AC Home\",\n    \"AC Back\",\n    \"AC Forward\",\n    \"AC Stop\",\n    \"AC Refresh\",\n    \"AC Bookmarks\",\n    \"BrightnessDown\",\n    \"BrightnessUp\",\n    \"DisplaySwitch\",\n    \"KBDIllumToggle\",\n    \"KBDIllumDown\",\n    \"KBDIllumUp\",\n    \"Eject\",\n    \"Sleep\",\n};\n\n/* Taken from SDL_iconv() */\nchar *\nSDL_UCS4ToUTF8(Uint32 ch, char *dst)\n{\n    Uint8 *p = (Uint8 *) dst;\n    if (ch <= 0x7F) {\n        *p = (Uint8) ch;\n        ++dst;\n    } else if (ch <= 0x7FF) {\n        p[0] = 0xC0 | (Uint8) ((ch >> 6) & 0x1F);\n        p[1] = 0x80 | (Uint8) (ch & 0x3F);\n        dst += 2;\n    } else if (ch <= 0xFFFF) {\n        p[0] = 0xE0 | (Uint8) ((ch >> 12) & 0x0F);\n        p[1] = 0x80 | (Uint8) ((ch >> 6) & 0x3F);\n        p[2] = 0x80 | (Uint8) (ch & 0x3F);\n        dst += 3;\n    } else if (ch <= 0x1FFFFF) {\n        p[0] = 0xF0 | (Uint8) ((ch >> 18) & 0x07);\n        p[1] = 0x80 | (Uint8) ((ch >> 12) & 0x3F);\n        p[2] = 0x80 | (Uint8) ((ch >> 6) & 0x3F);\n        p[3] = 0x80 | (Uint8) (ch & 0x3F);\n        dst += 4;\n    } else if (ch <= 0x3FFFFFF) {\n        p[0] = 0xF8 | (Uint8) ((ch >> 24) & 0x03);\n        p[1] = 0x80 | (Uint8) ((ch >> 18) & 0x3F);\n        p[2] = 0x80 | (Uint8) ((ch >> 12) & 0x3F);\n        p[3] = 0x80 | (Uint8) ((ch >> 6) & 0x3F);\n        p[4] = 0x80 | (Uint8) (ch & 0x3F);\n        dst += 5;\n    } else {\n        p[0] = 0xFC | (Uint8) ((ch >> 30) & 0x01);\n        p[1] = 0x80 | (Uint8) ((ch >> 24) & 0x3F);\n        p[2] = 0x80 | (Uint8) ((ch >> 18) & 0x3F);\n        p[3] = 0x80 | (Uint8) ((ch >> 12) & 0x3F);\n        p[4] = 0x80 | (Uint8) ((ch >> 6) & 0x3F);\n        p[5] = 0x80 | (Uint8) (ch & 0x3F);\n        dst += 6;\n    }\n    return dst;\n}\n\n/* Public functions */\nint\nSDL_KeyboardInit(void)\n{\n    SDL_Keyboard *keyboard = &SDL_keyboard;\n\n    /* Set the default keymap */\n    SDL_memcpy(keyboard->keymap, SDL_default_keymap, sizeof(SDL_default_keymap));\n    return (0);\n}\n\nvoid\nSDL_ResetKeyboard(void)\n{\n    SDL_Keyboard *keyboard = &SDL_keyboard;\n    SDL_Scancode scancode;\n\n#ifdef DEBUG_KEYBOARD\n    printf(\"Resetting keyboard\\n\");\n#endif\n    for (scancode = 0; scancode < SDL_NUM_SCANCODES; ++scancode) {\n        if (keyboard->keystate[scancode] == SDL_PRESSED) {\n            SDL_SendKeyboardKey(SDL_RELEASED, scancode);\n        }\n    }\n}\n\nvoid\nSDL_GetDefaultKeymap(SDL_Keycode * keymap)\n{\n    SDL_memcpy(keymap, SDL_default_keymap, sizeof(SDL_default_keymap));\n}\n\nvoid\nSDL_SetKeymap(int start, SDL_Keycode * keys, int length)\n{\n    SDL_Keyboard *keyboard = &SDL_keyboard;\n\n    if (start < 0 || start + length > SDL_NUM_SCANCODES) {\n        return;\n    }\n\n    SDL_memcpy(&keyboard->keymap[start], keys, sizeof(*keys) * length);\n}\n\nvoid\nSDL_SetScancodeName(SDL_Scancode scancode, const char *name)\n{\n    SDL_scancode_names[scancode] = name;\n}\n\nSDL_Window *\nSDL_GetKeyboardFocus(void)\n{\n    SDL_Keyboard *keyboard = &SDL_keyboard;\n\n    return keyboard->focus;\n}\n\nvoid\nSDL_SetKeyboardFocus(SDL_Window * window)\n{\n    SDL_Keyboard *keyboard = &SDL_keyboard;\n\n    if (keyboard->focus && !window) {\n        /* We won't get anymore keyboard messages, so reset keyboard state */\n        SDL_ResetKeyboard();\n    }\n\n    /* See if the current window has lost focus */\n    if (keyboard->focus && keyboard->focus != window) {\n\n        /* new window shouldn't think it has mouse captured. */\n        SDL_assert(!window || !(window->flags & SDL_WINDOW_MOUSE_CAPTURE));\n\n        /* old window must lose an existing mouse capture. */\n        if (keyboard->focus->flags & SDL_WINDOW_MOUSE_CAPTURE) {\n            SDL_CaptureMouse(SDL_FALSE);  /* drop the capture. */\n            SDL_assert(!(keyboard->focus->flags & SDL_WINDOW_MOUSE_CAPTURE));\n        }\n\n        SDL_SendWindowEvent(keyboard->focus, SDL_WINDOWEVENT_FOCUS_LOST,\n                            0, 0);\n\n        /* Ensures IME compositions are committed */\n        if (SDL_EventState(SDL_TEXTINPUT, SDL_QUERY)) {\n            SDL_VideoDevice *video = SDL_GetVideoDevice();\n            if (video && video->StopTextInput) {\n                video->StopTextInput(video);\n            }\n        }\n    }\n\n    keyboard->focus = window;\n\n    if (keyboard->focus) {\n        SDL_SendWindowEvent(keyboard->focus, SDL_WINDOWEVENT_FOCUS_GAINED,\n                            0, 0);\n\n        if (SDL_EventState(SDL_TEXTINPUT, SDL_QUERY)) {\n            SDL_VideoDevice *video = SDL_GetVideoDevice();\n            if (video && video->StartTextInput) {\n                video->StartTextInput(video);\n            }\n        }\n    }\n}\n\nint\nSDL_SendKeyboardKey(Uint8 state, SDL_Scancode scancode)\n{\n    SDL_Keyboard *keyboard = &SDL_keyboard;\n    int posted;\n    Uint16 modstate;\n    Uint32 type;\n    Uint8 repeat;\n\n    if (!scancode) {\n        return 0;\n    }\n#ifdef DEBUG_KEYBOARD\n    printf(\"The '%s' key has been %s\\n\", SDL_GetScancodeName(scancode),\n           state == SDL_PRESSED ? \"pressed\" : \"released\");\n#endif\n    if (state == SDL_PRESSED) {\n        modstate = keyboard->modstate;\n        switch (scancode) {\n        case SDL_SCANCODE_NUMLOCKCLEAR:\n            keyboard->modstate ^= KMOD_NUM;\n            break;\n        case SDL_SCANCODE_CAPSLOCK:\n            keyboard->modstate ^= KMOD_CAPS;\n            break;\n        case SDL_SCANCODE_LCTRL:\n            keyboard->modstate |= KMOD_LCTRL;\n            break;\n        case SDL_SCANCODE_RCTRL:\n            keyboard->modstate |= KMOD_RCTRL;\n            break;\n        case SDL_SCANCODE_LSHIFT:\n            keyboard->modstate |= KMOD_LSHIFT;\n            break;\n        case SDL_SCANCODE_RSHIFT:\n            keyboard->modstate |= KMOD_RSHIFT;\n            break;\n        case SDL_SCANCODE_LALT:\n            keyboard->modstate |= KMOD_LALT;\n            break;\n        case SDL_SCANCODE_RALT:\n            keyboard->modstate |= KMOD_RALT;\n            break;\n        case SDL_SCANCODE_LGUI:\n            keyboard->modstate |= KMOD_LGUI;\n            break;\n        case SDL_SCANCODE_RGUI:\n            keyboard->modstate |= KMOD_RGUI;\n            break;\n        case SDL_SCANCODE_MODE:\n            keyboard->modstate |= KMOD_MODE;\n            break;\n        default:\n            break;\n        }\n    } else {\n        switch (scancode) {\n        case SDL_SCANCODE_NUMLOCKCLEAR:\n        case SDL_SCANCODE_CAPSLOCK:\n            break;\n        case SDL_SCANCODE_LCTRL:\n            keyboard->modstate &= ~KMOD_LCTRL;\n            break;\n        case SDL_SCANCODE_RCTRL:\n            keyboard->modstate &= ~KMOD_RCTRL;\n            break;\n        case SDL_SCANCODE_LSHIFT:\n            keyboard->modstate &= ~KMOD_LSHIFT;\n            break;\n        case SDL_SCANCODE_RSHIFT:\n            keyboard->modstate &= ~KMOD_RSHIFT;\n            break;\n        case SDL_SCANCODE_LALT:\n            keyboard->modstate &= ~KMOD_LALT;\n            break;\n        case SDL_SCANCODE_RALT:\n            keyboard->modstate &= ~KMOD_RALT;\n            break;\n        case SDL_SCANCODE_LGUI:\n            keyboard->modstate &= ~KMOD_LGUI;\n            break;\n        case SDL_SCANCODE_RGUI:\n            keyboard->modstate &= ~KMOD_RGUI;\n            break;\n        case SDL_SCANCODE_MODE:\n            keyboard->modstate &= ~KMOD_MODE;\n            break;\n        default:\n            break;\n        }\n        modstate = keyboard->modstate;\n    }\n\n    /* Figure out what type of event this is */\n    switch (state) {\n    case SDL_PRESSED:\n        type = SDL_KEYDOWN;\n        break;\n    case SDL_RELEASED:\n        type = SDL_KEYUP;\n        break;\n    default:\n        /* Invalid state -- bail */\n        return 0;\n    }\n\n    /* Drop events that don't change state */\n    repeat = (state && keyboard->keystate[scancode]);\n    if (keyboard->keystate[scancode] == state && !repeat) {\n#if 0\n        printf(\"Keyboard event didn't change state - dropped!\\n\");\n#endif\n        return 0;\n    }\n\n    /* Update internal keyboard state */\n    keyboard->keystate[scancode] = state;\n\n    /* Post the event, if desired */\n    posted = 0;\n    if (SDL_GetEventState(type) == SDL_ENABLE) {\n        SDL_Event event;\n        event.key.type = type;\n        event.key.state = state;\n        event.key.repeat = repeat;\n        event.key.keysym.scancode = scancode;\n        event.key.keysym.sym = keyboard->keymap[scancode];\n        event.key.keysym.mod = modstate;\n        event.key.windowID = keyboard->focus ? keyboard->focus->id : 0;\n        posted = (SDL_PushEvent(&event) > 0);\n    }\n    return (posted);\n}\n\nint\nSDL_SendKeyboardText(const char *text)\n{\n    SDL_Keyboard *keyboard = &SDL_keyboard;\n    int posted;\n\n    /* Don't post text events for unprintable characters */\n    if ((unsigned char)*text < ' ' || *text == 127) {\n        return 0;\n    }\n\n    /* Post the event, if desired */\n    posted = 0;\n    if (SDL_GetEventState(SDL_TEXTINPUT) == SDL_ENABLE) {\n        SDL_Event event;\n        event.text.type = SDL_TEXTINPUT;\n        event.text.windowID = keyboard->focus ? keyboard->focus->id : 0;\n        SDL_utf8strlcpy(event.text.text, text, SDL_arraysize(event.text.text));\n        posted = (SDL_PushEvent(&event) > 0);\n    }\n    return (posted);\n}\n\nint\nSDL_SendEditingText(const char *text, int start, int length)\n{\n    SDL_Keyboard *keyboard = &SDL_keyboard;\n    int posted;\n\n    /* Post the event, if desired */\n    posted = 0;\n    if (SDL_GetEventState(SDL_TEXTEDITING) == SDL_ENABLE) {\n        SDL_Event event;\n        event.edit.type = SDL_TEXTEDITING;\n        event.edit.windowID = keyboard->focus ? keyboard->focus->id : 0;\n        event.edit.start = start;\n        event.edit.length = length;\n        SDL_utf8strlcpy(event.edit.text, text, SDL_arraysize(event.edit.text));\n        posted = (SDL_PushEvent(&event) > 0);\n    }\n    return (posted);\n}\n\nvoid\nSDL_KeyboardQuit(void)\n{\n}\n\nconst Uint8 *\nSDL_GetKeyboardState(int *numkeys)\n{\n    SDL_Keyboard *keyboard = &SDL_keyboard;\n\n    if (numkeys != (int *) 0) {\n        *numkeys = SDL_NUM_SCANCODES;\n    }\n    return keyboard->keystate;\n}\n\nSDL_Keymod\nSDL_GetModState(void)\n{\n    SDL_Keyboard *keyboard = &SDL_keyboard;\n\n    return keyboard->modstate;\n}\n\nvoid\nSDL_SetModState(SDL_Keymod modstate)\n{\n    SDL_Keyboard *keyboard = &SDL_keyboard;\n\n    keyboard->modstate = modstate;\n}\n\nSDL_Keycode\nSDL_GetKeyFromScancode(SDL_Scancode scancode)\n{\n    SDL_Keyboard *keyboard = &SDL_keyboard;\n\n    if (scancode < SDL_SCANCODE_UNKNOWN || scancode >= SDL_NUM_SCANCODES) {\n          SDL_InvalidParamError(\"scancode\");\n          return 0;\n    }\n\n    return keyboard->keymap[scancode];\n}\n\nSDL_Scancode\nSDL_GetScancodeFromKey(SDL_Keycode key)\n{\n    SDL_Keyboard *keyboard = &SDL_keyboard;\n    SDL_Scancode scancode;\n\n    for (scancode = SDL_SCANCODE_UNKNOWN; scancode < SDL_NUM_SCANCODES;\n         ++scancode) {\n        if (keyboard->keymap[scancode] == key) {\n            return scancode;\n        }\n    }\n    return SDL_SCANCODE_UNKNOWN;\n}\n\nconst char *\nSDL_GetScancodeName(SDL_Scancode scancode)\n{\n    const char *name;\n    if (scancode < SDL_SCANCODE_UNKNOWN || scancode >= SDL_NUM_SCANCODES) {\n          SDL_InvalidParamError(\"scancode\");\n          return \"\";\n    }\n\n    name = SDL_scancode_names[scancode];\n    if (name)\n        return name;\n    else\n        return \"\";\n}\n\nSDL_Scancode SDL_GetScancodeFromName(const char *name)\n{\n    int i;\n\n    if (!name || !*name) {\n            SDL_InvalidParamError(\"name\");\n        return SDL_SCANCODE_UNKNOWN;\n    }\n\n    for (i = 0; i < SDL_arraysize(SDL_scancode_names); ++i) {\n        if (!SDL_scancode_names[i]) {\n            continue;\n        }\n        if (SDL_strcasecmp(name, SDL_scancode_names[i]) == 0) {\n            return (SDL_Scancode)i;\n        }\n    }\n\n    SDL_InvalidParamError(\"name\");\n    return SDL_SCANCODE_UNKNOWN;\n}\n\nconst char *\nSDL_GetKeyName(SDL_Keycode key)\n{\n    static char name[8];\n    char *end;\n\n    if (key & SDLK_SCANCODE_MASK) {\n        return\n            SDL_GetScancodeName((SDL_Scancode) (key & ~SDLK_SCANCODE_MASK));\n    }\n\n    switch (key) {\n    case SDLK_RETURN:\n        return SDL_GetScancodeName(SDL_SCANCODE_RETURN);\n    case SDLK_ESCAPE:\n        return SDL_GetScancodeName(SDL_SCANCODE_ESCAPE);\n    case SDLK_BACKSPACE:\n        return SDL_GetScancodeName(SDL_SCANCODE_BACKSPACE);\n    case SDLK_TAB:\n        return SDL_GetScancodeName(SDL_SCANCODE_TAB);\n    case SDLK_SPACE:\n        return SDL_GetScancodeName(SDL_SCANCODE_SPACE);\n    case SDLK_DELETE:\n        return SDL_GetScancodeName(SDL_SCANCODE_DELETE);\n    default:\n        /* Unaccented letter keys on latin keyboards are normally\n           labeled in upper case (and probably on others like Greek or\n           Cyrillic too, so if you happen to know for sure, please\n           adapt this). */\n        if (key >= 'a' && key <= 'z') {\n            key -= 32;\n        }\n\n        end = SDL_UCS4ToUTF8((Uint32) key, name);\n        *end = '\\0';\n        return name;\n    }\n}\n\nSDL_Keycode\nSDL_GetKeyFromName(const char *name)\n{\n    SDL_Keycode key;\n\n        /* Check input */\n        if (name == NULL) return SDLK_UNKNOWN;\n\n    /* If it's a single UTF-8 character, then that's the keycode itself */\n    key = *(const unsigned char *)name;\n    if (key >= 0xF0) {\n        if (SDL_strlen(name) == 4) {\n            int i = 0;\n            key  = (Uint16)(name[i]&0x07) << 18;\n            key |= (Uint16)(name[++i]&0x3F) << 12;\n            key |= (Uint16)(name[++i]&0x3F) << 6;\n            key |= (Uint16)(name[++i]&0x3F);\n            return key;\n        }\n        return SDLK_UNKNOWN;\n    } else if (key >= 0xE0) {\n        if (SDL_strlen(name) == 3) {\n            int i = 0;\n            key  = (Uint16)(name[i]&0x0F) << 12;\n            key |= (Uint16)(name[++i]&0x3F) << 6;\n            key |= (Uint16)(name[++i]&0x3F);\n            return key;\n        }\n        return SDLK_UNKNOWN;\n    } else if (key >= 0xC0) {\n        if (SDL_strlen(name) == 2) {\n            int i = 0;\n            key  = (Uint16)(name[i]&0x1F) << 6;\n            key |= (Uint16)(name[++i]&0x3F);\n            return key;\n        }\n        return SDLK_UNKNOWN;\n    } else {\n        if (SDL_strlen(name) == 1) {\n            if (key >= 'A' && key <= 'Z') {\n                key += 32;\n            }\n            return key;\n        }\n\n        /* Get the scancode for this name, and the associated keycode */\n        return SDL_default_keymap[SDL_GetScancodeFromName(name)];\n    }\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../SDL_internal.h\"\n\n/* General mouse handling code for SDL */\n\n#include \"SDL_assert.h\"\n#include \"SDL_hints.h\"\n#include \"SDL_timer.h\"\n#include \"SDL_events.h\"\n#include \"SDL_events_c.h\"\n#include \"default_cursor.h\"\n#include \"../video/SDL_sysvideo.h\"\n\n/* #define DEBUG_MOUSE */\n\n/* The mouse state */\nstatic SDL_Mouse SDL_mouse;\nstatic Uint32 SDL_double_click_time = 500;\nstatic int SDL_double_click_radius = 1;\n\nstatic int\nSDL_PrivateSendMouseMotion(SDL_Window * window, SDL_MouseID mouseID, int relative, int x, int y);\n\n/* Public functions */\nint\nSDL_MouseInit(void)\n{\n    SDL_Mouse *mouse = SDL_GetMouse();\n\n    mouse->cursor_shown = SDL_TRUE;\n\n    return (0);\n}\n\nvoid\nSDL_SetDefaultCursor(SDL_Cursor * cursor)\n{\n    SDL_Mouse *mouse = SDL_GetMouse();\n\n    mouse->def_cursor = cursor;\n    if (!mouse->cur_cursor) {\n        SDL_SetCursor(cursor);\n    }\n}\n\nSDL_Mouse *\nSDL_GetMouse(void)\n{\n    return &SDL_mouse;\n}\n\nvoid\nSDL_SetDoubleClickTime(Uint32 interval)\n{\n    SDL_double_click_time = interval;\n}\n\nSDL_Window *\nSDL_GetMouseFocus(void)\n{\n    SDL_Mouse *mouse = SDL_GetMouse();\n\n    return mouse->focus;\n}\n\nvoid\nSDL_ResetMouse(void)\n{\n    SDL_Mouse *mouse = SDL_GetMouse();\n    Uint8 i;\n\n#ifdef DEBUG_MOUSE\n    printf(\"Resetting mouse\\n\");\n#endif\n    for (i = 1; i <= sizeof(mouse->buttonstate)*8; ++i) {\n        if (mouse->buttonstate & SDL_BUTTON(i)) {\n            SDL_SendMouseButton(mouse->focus, mouse->mouseID, SDL_RELEASED, i);\n        }\n    }\n    SDL_assert(mouse->buttonstate == 0);\n}\n\nvoid\nSDL_SetMouseFocus(SDL_Window * window)\n{\n    SDL_Mouse *mouse = SDL_GetMouse();\n\n    if (mouse->focus == window) {\n        return;\n    }\n\n    /* Actually, this ends up being a bad idea, because most operating\n       systems have an implicit grab when you press the mouse button down\n       so you can drag things out of the window and then get the mouse up\n       when it happens.  So, #if 0...\n    */\n#if 0\n    if (mouse->focus && !window) {\n        /* We won't get anymore mouse messages, so reset mouse state */\n        SDL_ResetMouse();\n    }\n#endif\n\n    /* See if the current window has lost focus */\n    if (mouse->focus) {\n        SDL_SendWindowEvent(mouse->focus, SDL_WINDOWEVENT_LEAVE, 0, 0);\n    }\n\n    mouse->focus = window;\n\n    if (mouse->focus) {\n        SDL_SendWindowEvent(mouse->focus, SDL_WINDOWEVENT_ENTER, 0, 0);\n    }\n\n    /* Update cursor visibility */\n    SDL_SetCursor(NULL);\n}\n\n/* Check to see if we need to synthesize focus events */\nstatic SDL_bool\nSDL_UpdateMouseFocus(SDL_Window * window, int x, int y, Uint32 buttonstate)\n{\n    SDL_Mouse *mouse = SDL_GetMouse();\n    SDL_bool inWindow = SDL_TRUE;\n\n    if (window && ((window->flags & SDL_WINDOW_MOUSE_CAPTURE) == 0)) {\n        int w, h;\n        SDL_GetWindowSize(window, &w, &h);\n        if (x < 0 || y < 0 || x >= w || y >= h) {\n            inWindow = SDL_FALSE;\n        }\n    }\n\n/* Linux doesn't give you mouse events outside your window unless you grab\n   the pointer.\n\n   Windows doesn't give you mouse events outside your window unless you call\n   SetCapture().\n\n   Both of these are slightly scary changes, so for now we'll punt and if the\n   mouse leaves the window you'll lose mouse focus and reset button state.\n*/\n#ifdef SUPPORT_DRAG_OUTSIDE_WINDOW\n    if (!inWindow && !buttonstate) {\n#else\n    if (!inWindow) {\n#endif\n        if (window == mouse->focus) {\n#ifdef DEBUG_MOUSE\n            printf(\"Mouse left window, synthesizing move & focus lost event\\n\");\n#endif\n            SDL_PrivateSendMouseMotion(window, mouse->mouseID, 0, x, y);\n            SDL_SetMouseFocus(NULL);\n        }\n        return SDL_FALSE;\n    }\n\n    if (window != mouse->focus) {\n#ifdef DEBUG_MOUSE\n         printf(\"Mouse entered window, synthesizing focus gain & move event\\n\");\n#endif\n         SDL_SetMouseFocus(window);\n         SDL_PrivateSendMouseMotion(window, mouse->mouseID, 0, x, y);\n    }\n    return SDL_TRUE;\n}\n\nint\nSDL_SendMouseMotion(SDL_Window * window, SDL_MouseID mouseID, int relative, int x, int y)\n{\n    if (window && !relative) {\n        SDL_Mouse *mouse = SDL_GetMouse();\n        if (!SDL_UpdateMouseFocus(window, x, y, mouse->buttonstate)) {\n            return 0;\n        }\n    }\n\n    return SDL_PrivateSendMouseMotion(window, mouseID, relative, x, y);\n}\n\nstatic int\nSDL_PrivateSendMouseMotion(SDL_Window * window, SDL_MouseID mouseID, int relative, int x, int y)\n{\n    SDL_Mouse *mouse = SDL_GetMouse();\n    int posted;\n    int xrel;\n    int yrel;\n\n    if (mouse->relative_mode_warp) {\n        int center_x = 0, center_y = 0;\n        SDL_GetWindowSize(window, &center_x, &center_y);\n        center_x /= 2;\n        center_y /= 2;\n        if (x == center_x && y == center_y) {\n            mouse->last_x = center_x;\n            mouse->last_y = center_y;\n            return 0;\n        }\n        SDL_WarpMouseInWindow(window, center_x, center_y);\n    }\n\n    if (relative) {\n        xrel = x;\n        yrel = y;\n        x = (mouse->last_x + xrel);\n        y = (mouse->last_y + yrel);\n    } else {\n        xrel = x - mouse->last_x;\n        yrel = y - mouse->last_y;\n    }\n\n    /* Drop events that don't change state */\n    if (!xrel && !yrel) {\n#ifdef DEBUG_MOUSE\n        printf(\"Mouse event didn't change state - dropped!\\n\");\n#endif\n        return 0;\n    }\n\n    /* Update internal mouse coordinates */\n    if (!mouse->relative_mode) {\n        mouse->x = x;\n        mouse->y = y;\n    } else {\n        mouse->x += xrel;\n        mouse->y += yrel;\n    }\n\n    /* make sure that the pointers find themselves inside the windows,\n       unless we have the mouse captured. */\n    if (window && ((window->flags & SDL_WINDOW_MOUSE_CAPTURE) == 0)) {\n        int x_max = 0, y_max = 0;\n\n        // !!! FIXME: shouldn't this be (window) instead of (mouse->focus)?\n        SDL_GetWindowSize(mouse->focus, &x_max, &y_max);\n        --x_max;\n        --y_max;\n\n        if (mouse->x > x_max) {\n            mouse->x = x_max;\n        }\n        if (mouse->x < 0) {\n            mouse->x = 0;\n        }\n\n        if (mouse->y > y_max) {\n            mouse->y = y_max;\n        }\n        if (mouse->y < 0) {\n            mouse->y = 0;\n        }\n    }\n\n    mouse->xdelta += xrel;\n    mouse->ydelta += yrel;\n\n    /* Move the mouse cursor, if needed */\n    if (mouse->cursor_shown && !mouse->relative_mode &&\n        mouse->MoveCursor && mouse->cur_cursor) {\n        mouse->MoveCursor(mouse->cur_cursor);\n    }\n\n    /* Post the event, if desired */\n    posted = 0;\n    if (SDL_GetEventState(SDL_MOUSEMOTION) == SDL_ENABLE) {\n        SDL_Event event;\n        event.motion.type = SDL_MOUSEMOTION;\n        event.motion.windowID = mouse->focus ? mouse->focus->id : 0;\n        event.motion.which = mouseID;\n        event.motion.state = mouse->buttonstate;\n        event.motion.x = mouse->x;\n        event.motion.y = mouse->y;\n        event.motion.xrel = xrel;\n        event.motion.yrel = yrel;\n        posted = (SDL_PushEvent(&event) > 0);\n    }\n    /* Use unclamped values if we're getting events outside the window */\n    mouse->last_x = x;\n    mouse->last_y = y;\n    return posted;\n}\n\nstatic SDL_MouseClickState *GetMouseClickState(SDL_Mouse *mouse, Uint8 button)\n{\n    if (button >= mouse->num_clickstates) {\n        int i, count = button + 1;\n        SDL_MouseClickState *clickstate = (SDL_MouseClickState *)SDL_realloc(mouse->clickstate, count * sizeof(*mouse->clickstate));\n        if (!clickstate) {\n            return NULL;\n        }\n        mouse->clickstate = clickstate;\n\n        for (i = mouse->num_clickstates; i < count; ++i) {\n            SDL_zero(mouse->clickstate[i]);\n        }\n        mouse->num_clickstates = count;\n    }\n    return &mouse->clickstate[button];\n}\n\nint\nSDL_SendMouseButton(SDL_Window * window, SDL_MouseID mouseID, Uint8 state, Uint8 button)\n{\n    SDL_Mouse *mouse = SDL_GetMouse();\n    int posted;\n    Uint32 type;\n    Uint32 buttonstate = mouse->buttonstate;\n    SDL_MouseClickState *clickstate = GetMouseClickState(mouse, button);\n    Uint8 click_count;\n\n    /* Figure out which event to perform */\n    switch (state) {\n    case SDL_PRESSED:\n        type = SDL_MOUSEBUTTONDOWN;\n        buttonstate |= SDL_BUTTON(button);\n        break;\n    case SDL_RELEASED:\n        type = SDL_MOUSEBUTTONUP;\n        buttonstate &= ~SDL_BUTTON(button);\n        break;\n    default:\n        /* Invalid state -- bail */\n        return 0;\n    }\n\n    /* We do this after calculating buttonstate so button presses gain focus */\n    if (window && state == SDL_PRESSED) {\n        SDL_UpdateMouseFocus(window, mouse->x, mouse->y, buttonstate);\n    }\n\n    if (buttonstate == mouse->buttonstate) {\n        /* Ignore this event, no state change */\n        return 0;\n    }\n    mouse->buttonstate = buttonstate;\n\n    if (clickstate) {\n        if (state == SDL_PRESSED) {\n            Uint32 now = SDL_GetTicks();\n\n            if (SDL_TICKS_PASSED(now, clickstate->last_timestamp + SDL_double_click_time) ||\n                SDL_abs(mouse->x - clickstate->last_x) > SDL_double_click_radius ||\n                SDL_abs(mouse->y - clickstate->last_y) > SDL_double_click_radius) {\n                clickstate->click_count = 0;\n            }\n            clickstate->last_timestamp = now;\n            clickstate->last_x = mouse->x;\n            clickstate->last_y = mouse->y;\n            if (clickstate->click_count < 255) {\n                ++clickstate->click_count;\n            }\n        }\n        click_count = clickstate->click_count;\n    } else {\n        click_count = 1;\n    }\n\n    /* Post the event, if desired */\n    posted = 0;\n    if (SDL_GetEventState(type) == SDL_ENABLE) {\n        SDL_Event event;\n        event.type = type;\n        event.button.windowID = mouse->focus ? mouse->focus->id : 0;\n        event.button.which = mouseID;\n        event.button.state = state;\n        event.button.button = button;\n        event.button.clicks = click_count;\n        event.button.x = mouse->x;\n        event.button.y = mouse->y;\n        posted = (SDL_PushEvent(&event) > 0);\n    }\n\n    /* We do this after dispatching event so button releases can lose focus */\n    if (window && state == SDL_RELEASED) {\n        SDL_UpdateMouseFocus(window, mouse->x, mouse->y, buttonstate);\n    }\n\n    return posted;\n}\n\nint\nSDL_SendMouseWheel(SDL_Window * window, SDL_MouseID mouseID, int x, int y, SDL_MouseWheelDirection direction)\n{\n    SDL_Mouse *mouse = SDL_GetMouse();\n    int posted;\n\n    if (window) {\n        SDL_SetMouseFocus(window);\n    }\n\n    if (!x && !y) {\n        return 0;\n    }\n\n    /* Post the event, if desired */\n    posted = 0;\n    if (SDL_GetEventState(SDL_MOUSEWHEEL) == SDL_ENABLE) {\n        SDL_Event event;\n        event.type = SDL_MOUSEWHEEL;\n        event.wheel.windowID = mouse->focus ? mouse->focus->id : 0;\n        event.wheel.which = mouseID;\n        event.wheel.x = x;\n        event.wheel.y = y;\n        event.wheel.direction = (Uint32)direction;\n        posted = (SDL_PushEvent(&event) > 0);\n    }\n    return posted;\n}\n\nvoid\nSDL_MouseQuit(void)\n{\n    SDL_Cursor *cursor, *next;\n    SDL_Mouse *mouse = SDL_GetMouse();\n\n    if (mouse->CaptureMouse) {\n        SDL_CaptureMouse(SDL_FALSE);\n    }\n    SDL_SetRelativeMouseMode(SDL_FALSE);\n    SDL_ShowCursor(1);\n\n    cursor = mouse->cursors;\n    while (cursor) {\n        next = cursor->next;\n        SDL_FreeCursor(cursor);\n        cursor = next;\n    }\n\n    if (mouse->def_cursor && mouse->FreeCursor) {\n        mouse->FreeCursor(mouse->def_cursor);\n    }\n\n    if (mouse->clickstate) {\n        SDL_free(mouse->clickstate);\n    }\n\n    SDL_zerop(mouse);\n}\n\nUint32\nSDL_GetMouseState(int *x, int *y)\n{\n    SDL_Mouse *mouse = SDL_GetMouse();\n\n    if (x) {\n        *x = mouse->x;\n    }\n    if (y) {\n        *y = mouse->y;\n    }\n    return mouse->buttonstate;\n}\n\nUint32\nSDL_GetRelativeMouseState(int *x, int *y)\n{\n    SDL_Mouse *mouse = SDL_GetMouse();\n\n    if (x) {\n        *x = mouse->xdelta;\n    }\n    if (y) {\n        *y = mouse->ydelta;\n    }\n    mouse->xdelta = 0;\n    mouse->ydelta = 0;\n    return mouse->buttonstate;\n}\n\nUint32\nSDL_GetGlobalMouseState(int *x, int *y)\n{\n    SDL_Mouse *mouse = SDL_GetMouse();\n    int tmpx, tmpy;\n\n    /* make sure these are never NULL for the backend implementations... */\n    if (!x) {\n        x = &tmpx;\n    }\n    if (!y) {\n        y = &tmpy;\n    }\n\n    *x = *y = 0;\n\n    if (!mouse->GetGlobalMouseState) {\n        SDL_assert(0 && \"This should really be implemented for every target.\");\n        return 0;\n    }\n\n    return mouse->GetGlobalMouseState(x, y);\n}\n\nvoid\nSDL_WarpMouseInWindow(SDL_Window * window, int x, int y)\n{\n    SDL_Mouse *mouse = SDL_GetMouse();\n\n    if (window == NULL) {\n        window = mouse->focus;\n    }\n\n    if (window == NULL) {\n        return;\n    }\n\n    if (mouse->WarpMouse) {\n        mouse->WarpMouse(window, x, y);\n    } else {\n        SDL_SendMouseMotion(window, mouse->mouseID, 0, x, y);\n    }\n}\n\nvoid\nSDL_WarpMouseGlobal(int x, int y)\n{\n    SDL_Mouse *mouse = SDL_GetMouse();\n\n    if (mouse->WarpMouseGlobal) {\n        mouse->WarpMouseGlobal(x, y);\n    }\n}\n\nstatic SDL_bool\nShouldUseRelativeModeWarp(SDL_Mouse *mouse)\n{\n    const char *hint;\n\n    if (!mouse->SetRelativeMouseMode) {\n        return SDL_TRUE;\n    }\n\n    hint = SDL_GetHint(SDL_HINT_MOUSE_RELATIVE_MODE_WARP);\n    if (hint) {\n        if (*hint == '0') {\n            return SDL_FALSE;\n        } else {\n            return SDL_TRUE;\n        }\n    }\n    return SDL_FALSE;\n}\n\nint\nSDL_SetRelativeMouseMode(SDL_bool enabled)\n{\n    SDL_Mouse *mouse = SDL_GetMouse();\n    SDL_Window *focusWindow = SDL_GetKeyboardFocus();\n\n    if (enabled == mouse->relative_mode) {\n        return 0;\n    }\n\n    if (enabled && focusWindow) {\n        /* Center it in the focused window to prevent clicks from going through\n         * to background windows.\n         */\n        SDL_SetMouseFocus(focusWindow);\n        SDL_WarpMouseInWindow(focusWindow, focusWindow->w/2, focusWindow->h/2);\n    }\n\n    /* Set the relative mode */\n    if (!enabled && mouse->relative_mode_warp) {\n        mouse->relative_mode_warp = SDL_FALSE;\n    } else if (enabled && ShouldUseRelativeModeWarp(mouse)) {\n        mouse->relative_mode_warp = SDL_TRUE;\n    } else if (mouse->SetRelativeMouseMode(enabled) < 0) {\n        if (enabled) {\n            /* Fall back to warp mode if native relative mode failed */\n            mouse->relative_mode_warp = SDL_TRUE;\n        }\n    }\n    mouse->relative_mode = enabled;\n\n    if (mouse->focus) {\n        SDL_UpdateWindowGrab(mouse->focus);\n\n        /* Put the cursor back to where the application expects it */\n        if (!enabled) {\n            SDL_WarpMouseInWindow(mouse->focus, mouse->x, mouse->y);\n        }\n    }\n\n    /* Flush pending mouse motion - ideally we would pump events, but that's not always safe */\n    SDL_FlushEvent(SDL_MOUSEMOTION);\n\n    /* Update cursor visibility */\n    SDL_SetCursor(NULL);\n\n    return 0;\n}\n\nSDL_bool\nSDL_GetRelativeMouseMode()\n{\n    SDL_Mouse *mouse = SDL_GetMouse();\n\n    return mouse->relative_mode;\n}\n\nint\nSDL_CaptureMouse(SDL_bool enabled)\n{\n    SDL_Mouse *mouse = SDL_GetMouse();\n    SDL_Window *focusWindow;\n    SDL_bool isCaptured;\n\n    if (!mouse->CaptureMouse) {\n        return SDL_Unsupported();\n    }\n\n    focusWindow = SDL_GetKeyboardFocus();\n\n    isCaptured = focusWindow && (focusWindow->flags & SDL_WINDOW_MOUSE_CAPTURE);\n    if (isCaptured == enabled) {\n        return 0;  /* already done! */\n    }\n\n    if (enabled) {\n        if (!focusWindow) {\n            return SDL_SetError(\"No window has focus\");\n        } else if (mouse->CaptureMouse(focusWindow) == -1) {\n            return -1;  /* CaptureMouse() should call SetError */\n        }\n        focusWindow->flags |= SDL_WINDOW_MOUSE_CAPTURE;\n    } else {\n        if (mouse->CaptureMouse(NULL) == -1) {\n            return -1;  /* CaptureMouse() should call SetError */\n        }\n        focusWindow->flags &= ~SDL_WINDOW_MOUSE_CAPTURE;\n    }\n\n    return 0;\n}\n\nSDL_Cursor *\nSDL_CreateCursor(const Uint8 * data, const Uint8 * mask,\n                 int w, int h, int hot_x, int hot_y)\n{\n    SDL_Surface *surface;\n    SDL_Cursor *cursor;\n    int x, y;\n    Uint32 *pixel;\n    Uint8 datab = 0, maskb = 0;\n    const Uint32 black = 0xFF000000;\n    const Uint32 white = 0xFFFFFFFF;\n    const Uint32 transparent = 0x00000000;\n\n    /* Make sure the width is a multiple of 8 */\n    w = ((w + 7) & ~7);\n\n    /* Create the surface from a bitmap */\n    surface = SDL_CreateRGBSurface(0, w, h, 32,\n                                   0x00FF0000,\n                                   0x0000FF00,\n                                   0x000000FF,\n                                   0xFF000000);\n    if (!surface) {\n        return NULL;\n    }\n    for (y = 0; y < h; ++y) {\n        pixel = (Uint32 *) ((Uint8 *) surface->pixels + y * surface->pitch);\n        for (x = 0; x < w; ++x) {\n            if ((x % 8) == 0) {\n                datab = *data++;\n                maskb = *mask++;\n            }\n            if (maskb & 0x80) {\n                *pixel++ = (datab & 0x80) ? black : white;\n            } else {\n                *pixel++ = (datab & 0x80) ? black : transparent;\n            }\n            datab <<= 1;\n            maskb <<= 1;\n        }\n    }\n\n    cursor = SDL_CreateColorCursor(surface, hot_x, hot_y);\n\n    SDL_FreeSurface(surface);\n\n    return cursor;\n}\n\nSDL_Cursor *\nSDL_CreateColorCursor(SDL_Surface *surface, int hot_x, int hot_y)\n{\n    SDL_Mouse *mouse = SDL_GetMouse();\n    SDL_Surface *temp = NULL;\n    SDL_Cursor *cursor;\n\n    if (!surface) {\n        SDL_SetError(\"Passed NULL cursor surface\");\n        return NULL;\n    }\n\n    if (!mouse->CreateCursor) {\n        SDL_SetError(\"Cursors are not currently supported\");\n        return NULL;\n    }\n\n    /* Sanity check the hot spot */\n    if ((hot_x < 0) || (hot_y < 0) ||\n        (hot_x >= surface->w) || (hot_y >= surface->h)) {\n        SDL_SetError(\"Cursor hot spot doesn't lie within cursor\");\n        return NULL;\n    }\n\n    if (surface->format->format != SDL_PIXELFORMAT_ARGB8888) {\n        temp = SDL_ConvertSurfaceFormat(surface, SDL_PIXELFORMAT_ARGB8888, 0);\n        if (!temp) {\n            return NULL;\n        }\n        surface = temp;\n    }\n\n    cursor = mouse->CreateCursor(surface, hot_x, hot_y);\n    if (cursor) {\n        cursor->next = mouse->cursors;\n        mouse->cursors = cursor;\n    }\n\n    SDL_FreeSurface(temp);\n\n    return cursor;\n}\n\nSDL_Cursor *\nSDL_CreateSystemCursor(SDL_SystemCursor id)\n{\n    SDL_Mouse *mouse = SDL_GetMouse();\n    SDL_Cursor *cursor;\n\n    if (!mouse->CreateSystemCursor) {\n        SDL_SetError(\"CreateSystemCursor is not currently supported\");\n        return NULL;\n    }\n\n    cursor = mouse->CreateSystemCursor(id);\n    if (cursor) {\n        cursor->next = mouse->cursors;\n        mouse->cursors = cursor;\n    }\n\n    return cursor;\n}\n\n/* SDL_SetCursor(NULL) can be used to force the cursor redraw,\n   if this is desired for any reason.  This is used when setting\n   the video mode and when the SDL window gains the mouse focus.\n */\nvoid\nSDL_SetCursor(SDL_Cursor * cursor)\n{\n    SDL_Mouse *mouse = SDL_GetMouse();\n\n    /* Set the new cursor */\n    if (cursor) {\n        /* Make sure the cursor is still valid for this mouse */\n        if (cursor != mouse->def_cursor) {\n            SDL_Cursor *found;\n            for (found = mouse->cursors; found; found = found->next) {\n                if (found == cursor) {\n                    break;\n                }\n            }\n            if (!found) {\n                SDL_SetError(\"Cursor not associated with the current mouse\");\n                return;\n            }\n        }\n        mouse->cur_cursor = cursor;\n    } else {\n        if (mouse->focus) {\n            cursor = mouse->cur_cursor;\n        } else {\n            cursor = mouse->def_cursor;\n        }\n    }\n\n    if (cursor && mouse->cursor_shown && !mouse->relative_mode) {\n        if (mouse->ShowCursor) {\n            mouse->ShowCursor(cursor);\n        }\n    } else {\n        if (mouse->ShowCursor) {\n            mouse->ShowCursor(NULL);\n        }\n    }\n}\n\nSDL_Cursor *\nSDL_GetCursor(void)\n{\n    SDL_Mouse *mouse = SDL_GetMouse();\n\n    if (!mouse) {\n        return NULL;\n    }\n    return mouse->cur_cursor;\n}\n\nSDL_Cursor *\nSDL_GetDefaultCursor(void)\n{\n    SDL_Mouse *mouse = SDL_GetMouse();\n\n    if (!mouse) {\n        return NULL;\n    }\n    return mouse->def_cursor;\n}\n\nvoid\nSDL_FreeCursor(SDL_Cursor * cursor)\n{\n    SDL_Mouse *mouse = SDL_GetMouse();\n    SDL_Cursor *curr, *prev;\n\n    if (!cursor) {\n        return;\n    }\n\n    if (cursor == mouse->def_cursor) {\n        return;\n    }\n    if (cursor == mouse->cur_cursor) {\n        SDL_SetCursor(mouse->def_cursor);\n    }\n\n    for (prev = NULL, curr = mouse->cursors; curr;\n         prev = curr, curr = curr->next) {\n        if (curr == cursor) {\n            if (prev) {\n                prev->next = curr->next;\n            } else {\n                mouse->cursors = curr->next;\n            }\n\n            if (mouse->FreeCursor) {\n                mouse->FreeCursor(curr);\n            }\n            return;\n        }\n    }\n}\n\nint\nSDL_ShowCursor(int toggle)\n{\n    SDL_Mouse *mouse = SDL_GetMouse();\n    SDL_bool shown;\n\n    if (!mouse) {\n        return 0;\n    }\n\n    shown = mouse->cursor_shown;\n    if (toggle >= 0) {\n        if (toggle) {\n            mouse->cursor_shown = SDL_TRUE;\n        } else {\n            mouse->cursor_shown = SDL_FALSE;\n        }\n        if (mouse->cursor_shown != shown) {\n            SDL_SetCursor(NULL);\n        }\n    }\n    return shown;\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../SDL_internal.h\"\n\n/* General quit handling code for SDL */\n\n#ifdef HAVE_SIGNAL_H\n#include <signal.h>\n#endif\n\n#include \"SDL_events.h\"\n#include \"SDL_events_c.h\"\n\n\n#ifdef HAVE_SIGNAL_H\nstatic void\nSDL_HandleSIG(int sig)\n{\n    /* Reset the signal handler */\n    signal(sig, SDL_HandleSIG);\n\n    /* Signal a quit interrupt */\n    SDL_SendQuit();\n}\n#endif /* HAVE_SIGNAL_H */\n\n/* Public functions */\nint\nSDL_QuitInit(void)\n{\n#ifdef HAVE_SIGACTION\n    struct sigaction action;\n    sigaction(SIGINT, NULL, &action);\n#ifdef HAVE_SA_SIGACTION\n    if ( action.sa_handler == SIG_DFL && action.sa_sigaction == (void*)SIG_DFL ) {\n#else\n    if ( action.sa_handler == SIG_DFL ) {\n#endif\n        action.sa_handler = SDL_HandleSIG;\n        sigaction(SIGINT, &action, NULL);\n    }\n    sigaction(SIGTERM, NULL, &action);\n\n#ifdef HAVE_SA_SIGACTION\n    if ( action.sa_handler == SIG_DFL && action.sa_sigaction == (void*)SIG_DFL ) {\n#else\n    if ( action.sa_handler == SIG_DFL ) {\n#endif\n        action.sa_handler = SDL_HandleSIG;\n        sigaction(SIGTERM, &action, NULL);\n    }\n#elif HAVE_SIGNAL_H\n    void (*ohandler) (int);\n\n    /* Both SIGINT and SIGTERM are translated into quit interrupts */\n    ohandler = signal(SIGINT, SDL_HandleSIG);\n    if (ohandler != SIG_DFL)\n        signal(SIGINT, ohandler);\n    ohandler = signal(SIGTERM, SDL_HandleSIG);\n    if (ohandler != SIG_DFL)\n        signal(SIGTERM, ohandler);\n#endif /* HAVE_SIGNAL_H */\n\n    /* That's it! */\n    return (0);\n}\n\nvoid\nSDL_QuitQuit(void)\n{\n#ifdef HAVE_SIGACTION\n    struct sigaction action;\n    sigaction(SIGINT, NULL, &action);\n    if ( action.sa_handler == SDL_HandleSIG ) {\n        action.sa_handler = SIG_DFL;\n        sigaction(SIGINT, &action, NULL);\n    }\n    sigaction(SIGTERM, NULL, &action);\n    if ( action.sa_handler == SDL_HandleSIG ) {\n        action.sa_handler = SIG_DFL;\n        sigaction(SIGTERM, &action, NULL);\n    }\n#elif HAVE_SIGNAL_H\n    void (*ohandler) (int);\n\n    ohandler = signal(SIGINT, SIG_DFL);\n    if (ohandler != SDL_HandleSIG)\n        signal(SIGINT, ohandler);\n    ohandler = signal(SIGTERM, SIG_DFL);\n    if (ohandler != SDL_HandleSIG)\n        signal(SIGTERM, ohandler);\n#endif /* HAVE_SIGNAL_H */\n}\n\n/* This function returns 1 if it's okay to close the application window */\nint\nSDL_SendQuit(void)\n{\n    return SDL_SendAppEvent(SDL_QUIT);\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../SDL_internal.h\"\n\n/* General touch handling code for SDL */\n\n#include \"SDL_assert.h\"\n#include \"SDL_events.h\"\n#include \"SDL_events_c.h\"\n\n\nstatic int SDL_num_touch = 0;\nstatic SDL_Touch **SDL_touchDevices = NULL;\n\n\n/* Public functions */\nint\nSDL_TouchInit(void)\n{\n    return (0);\n}\n\nint\nSDL_GetNumTouchDevices(void)\n{\n    return SDL_num_touch;\n}\n\nSDL_TouchID\nSDL_GetTouchDevice(int index)\n{\n    if (index < 0 || index >= SDL_num_touch) {\n        SDL_SetError(\"Unknown touch device\");\n        return 0;\n    }\n    return SDL_touchDevices[index]->id;\n}\n\nstatic int\nSDL_GetTouchIndex(SDL_TouchID id)\n{\n    int index;\n    SDL_Touch *touch;\n\n    for (index = 0; index < SDL_num_touch; ++index) {\n        touch = SDL_touchDevices[index];\n        if (touch->id == id) {\n            return index;\n        }\n    }\n    return -1;\n}\n\nSDL_Touch *\nSDL_GetTouch(SDL_TouchID id)\n{\n    int index = SDL_GetTouchIndex(id);\n    if (index < 0 || index >= SDL_num_touch) {\n        SDL_SetError(\"Unknown touch device\");\n        return NULL;\n    }\n    return SDL_touchDevices[index];\n}\n\nstatic int\nSDL_GetFingerIndex(const SDL_Touch * touch, SDL_FingerID fingerid)\n{\n    int index;\n    for (index = 0; index < touch->num_fingers; ++index) {\n        if (touch->fingers[index]->id == fingerid) {\n            return index;\n        }\n    }\n    return -1;\n}\n\nSDL_Finger *\nSDL_GetFinger(const SDL_Touch * touch, SDL_FingerID id)\n{\n    int index = SDL_GetFingerIndex(touch, id);\n    if (index < 0 || index >= touch->num_fingers) {\n        return NULL;\n    }\n    return touch->fingers[index];\n}\n\nint\nSDL_GetNumTouchFingers(SDL_TouchID touchID)\n{\n    SDL_Touch *touch = SDL_GetTouch(touchID);\n    if (touch) {\n        return touch->num_fingers;\n    }\n    return 0;\n}\n\nSDL_Finger *\nSDL_GetTouchFinger(SDL_TouchID touchID, int index)\n{\n    SDL_Touch *touch = SDL_GetTouch(touchID);\n    if (!touch) {\n        return NULL;\n    }\n    if (index < 0 || index >= touch->num_fingers) {\n        SDL_SetError(\"Unknown touch finger\");\n        return NULL;\n    }\n    return touch->fingers[index];\n}\n\nint\nSDL_AddTouch(SDL_TouchID touchID, const char *name)\n{\n    SDL_Touch **touchDevices;\n    int index;\n\n    index = SDL_GetTouchIndex(touchID);\n    if (index >= 0) {\n        return index;\n    }\n\n    /* Add the touch to the list of touch */\n    touchDevices = (SDL_Touch **) SDL_realloc(SDL_touchDevices,\n                                      (SDL_num_touch + 1) * sizeof(*touchDevices));\n    if (!touchDevices) {\n        return SDL_OutOfMemory();\n    }\n\n    SDL_touchDevices = touchDevices;\n    index = SDL_num_touch++;\n\n    SDL_touchDevices[index] = (SDL_Touch *) SDL_malloc(sizeof(*SDL_touchDevices[index]));\n    if (!SDL_touchDevices[index]) {\n        return SDL_OutOfMemory();\n    }\n\n    /* we're setting the touch properties */\n    SDL_touchDevices[index]->id = touchID;\n    SDL_touchDevices[index]->num_fingers = 0;\n    SDL_touchDevices[index]->max_fingers = 0;\n    SDL_touchDevices[index]->fingers = NULL;\n\n    /* Record this touch device for gestures */\n    /* We could do this on the fly in the gesture code if we wanted */\n    SDL_GestureAddTouch(touchID);\n\n    return index;\n}\n\nstatic int\nSDL_AddFinger(SDL_Touch *touch, SDL_FingerID fingerid, float x, float y, float pressure)\n{\n    SDL_Finger *finger;\n\n    if (touch->num_fingers == touch->max_fingers) {\n        SDL_Finger **new_fingers;\n        new_fingers = (SDL_Finger **)SDL_realloc(touch->fingers, (touch->max_fingers+1)*sizeof(*touch->fingers));\n        if (!new_fingers) {\n            return SDL_OutOfMemory();\n        }\n        touch->fingers = new_fingers;\n        touch->fingers[touch->max_fingers] = (SDL_Finger *)SDL_malloc(sizeof(*finger));\n        if (!touch->fingers[touch->max_fingers]) {\n            return SDL_OutOfMemory();\n        }\n        touch->max_fingers++;\n    }\n\n    finger = touch->fingers[touch->num_fingers++];\n    finger->id = fingerid;\n    finger->x = x;\n    finger->y = y;\n    finger->pressure = pressure;\n    return 0;\n}\n\nstatic int\nSDL_DelFinger(SDL_Touch* touch, SDL_FingerID fingerid)\n{\n    SDL_Finger *temp;\n\n    int index = SDL_GetFingerIndex(touch, fingerid);\n    if (index < 0) {\n        return -1;\n    }\n\n    touch->num_fingers--;\n    temp = touch->fingers[index];\n    touch->fingers[index] = touch->fingers[touch->num_fingers];\n    touch->fingers[touch->num_fingers] = temp;\n    return 0;\n}\n\nint\nSDL_SendTouch(SDL_TouchID id, SDL_FingerID fingerid,\n              SDL_bool down, float x, float y, float pressure)\n{\n    int posted;\n    SDL_Finger *finger;\n\n    SDL_Touch* touch = SDL_GetTouch(id);\n    if (!touch) {\n        return -1;\n    }\n\n    finger = SDL_GetFinger(touch, fingerid);\n    if (down) {\n        if (finger) {\n            /* This finger is already down */\n            return 0;\n        }\n\n        if (SDL_AddFinger(touch, fingerid, x, y, pressure) < 0) {\n            return 0;\n        }\n\n        posted = 0;\n        if (SDL_GetEventState(SDL_FINGERDOWN) == SDL_ENABLE) {\n            SDL_Event event;\n            event.tfinger.type = SDL_FINGERDOWN;\n            event.tfinger.touchId = id;\n            event.tfinger.fingerId = fingerid;\n            event.tfinger.x = x;\n            event.tfinger.y = y;\n            event.tfinger.dx = 0;\n            event.tfinger.dy = 0;\n            event.tfinger.pressure = pressure;\n            posted = (SDL_PushEvent(&event) > 0);\n        }\n    } else {\n        if (!finger) {\n            /* This finger is already up */\n            return 0;\n        }\n\n        posted = 0;\n        if (SDL_GetEventState(SDL_FINGERUP) == SDL_ENABLE) {\n            SDL_Event event;\n            event.tfinger.type = SDL_FINGERUP;\n            event.tfinger.touchId =  id;\n            event.tfinger.fingerId = fingerid;\n            /* I don't trust the coordinates passed on fingerUp */\n            event.tfinger.x = finger->x;\n            event.tfinger.y = finger->y;\n            event.tfinger.dx = 0;\n            event.tfinger.dy = 0;\n            event.tfinger.pressure = pressure;\n            posted = (SDL_PushEvent(&event) > 0);\n        }\n\n        SDL_DelFinger(touch, fingerid);\n    }\n    return posted;\n}\n\nint\nSDL_SendTouchMotion(SDL_TouchID id, SDL_FingerID fingerid,\n                    float x, float y, float pressure)\n{\n    SDL_Touch *touch;\n    SDL_Finger *finger;\n    int posted;\n    float xrel, yrel, prel;\n\n    touch = SDL_GetTouch(id);\n    if (!touch) {\n        return -1;\n    }\n\n    finger = SDL_GetFinger(touch,fingerid);\n    if (!finger) {\n        return SDL_SendTouch(id, fingerid, SDL_TRUE, x, y, pressure);\n    }\n\n    xrel = x - finger->x;\n    yrel = y - finger->y;\n    prel = pressure - finger->pressure;\n\n    /* Drop events that don't change state */\n    if (!xrel && !yrel && !prel) {\n#if 0\n        printf(\"Touch event didn't change state - dropped!\\n\");\n#endif\n        return 0;\n    }\n\n    /* Update internal touch coordinates */\n    finger->x = x;\n    finger->y = y;\n    finger->pressure = pressure;\n\n    /* Post the event, if desired */\n    posted = 0;\n    if (SDL_GetEventState(SDL_FINGERMOTION) == SDL_ENABLE) {\n        SDL_Event event;\n        event.tfinger.type = SDL_FINGERMOTION;\n        event.tfinger.touchId = id;\n        event.tfinger.fingerId = fingerid;\n        event.tfinger.x = x;\n        event.tfinger.y = y;\n        event.tfinger.dx = xrel;\n        event.tfinger.dy = yrel;\n        event.tfinger.pressure = pressure;\n        posted = (SDL_PushEvent(&event) > 0);\n    }\n    return posted;\n}\n\nvoid\nSDL_DelTouch(SDL_TouchID id)\n{\n    int i;\n    int index = SDL_GetTouchIndex(id);\n    SDL_Touch *touch = SDL_GetTouch(id);\n\n    if (!touch) {\n        return;\n    }\n\n    for (i = 0; i < touch->max_fingers; ++i) {\n        SDL_free(touch->fingers[i]);\n    }\n    SDL_free(touch->fingers);\n    SDL_free(touch);\n\n    SDL_num_touch--;\n    SDL_touchDevices[index] = SDL_touchDevices[SDL_num_touch];\n}\n\nvoid\nSDL_TouchQuit(void)\n{\n    int i;\n\n    for (i = SDL_num_touch; i--; ) {\n        SDL_DelTouch(SDL_touchDevices[i]->id);\n    }\n    SDL_assert(SDL_num_touch == 0);\n\n    SDL_free(SDL_touchDevices);\n    SDL_touchDevices = NULL;\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../SDL_internal.h\"\n\n/* Window event handling code for SDL */\n\n#include \"SDL_events.h\"\n#include \"SDL_events_c.h\"\n#include \"SDL_mouse_c.h\"\n#include \"../video/SDL_sysvideo.h\"\n\n\nstatic int\nRemovePendingResizedEvents(void * userdata, SDL_Event *event)\n{\n    SDL_Event *new_event = (SDL_Event *)userdata;\n\n    if (event->type == SDL_WINDOWEVENT &&\n        event->window.event == SDL_WINDOWEVENT_RESIZED &&\n        event->window.windowID == new_event->window.windowID) {\n        /* We're about to post a new size event, drop the old one */\n        return 0;\n    }\n    return 1;\n}\n\nstatic int\nRemovePendingSizeChangedEvents(void * userdata, SDL_Event *event)\n{\n    SDL_Event *new_event = (SDL_Event *)userdata;\n\n    if (event->type == SDL_WINDOWEVENT &&\n        event->window.event == SDL_WINDOWEVENT_SIZE_CHANGED &&\n        event->window.windowID == new_event->window.windowID) {\n        /* We're about to post a new size event, drop the old one */\n        return 0;\n    }\n    return 1;\n}\n\nstatic int\nRemovePendingMoveEvents(void * userdata, SDL_Event *event)\n{\n    SDL_Event *new_event = (SDL_Event *)userdata;\n\n    if (event->type == SDL_WINDOWEVENT &&\n        event->window.event == SDL_WINDOWEVENT_MOVED &&\n        event->window.windowID == new_event->window.windowID) {\n        /* We're about to post a new move event, drop the old one */\n        return 0;\n    }\n    return 1;\n}\n\nint\nSDL_SendWindowEvent(SDL_Window * window, Uint8 windowevent, int data1,\n                    int data2)\n{\n    int posted;\n\n    if (!window) {\n        return 0;\n    }\n    switch (windowevent) {\n    case SDL_WINDOWEVENT_SHOWN:\n        if (window->flags & SDL_WINDOW_SHOWN) {\n            return 0;\n        }\n        window->flags &= ~SDL_WINDOW_HIDDEN;\n        window->flags |= SDL_WINDOW_SHOWN;\n        SDL_OnWindowShown(window);\n        break;\n    case SDL_WINDOWEVENT_HIDDEN:\n        if (!(window->flags & SDL_WINDOW_SHOWN)) {\n            return 0;\n        }\n        window->flags &= ~SDL_WINDOW_SHOWN;\n        window->flags |= SDL_WINDOW_HIDDEN;\n        SDL_OnWindowHidden(window);\n        break;\n    case SDL_WINDOWEVENT_MOVED:\n        if (SDL_WINDOWPOS_ISUNDEFINED(data1) ||\n            SDL_WINDOWPOS_ISUNDEFINED(data2)) {\n            return 0;\n        }\n        if (!(window->flags & SDL_WINDOW_FULLSCREEN)) {\n            window->windowed.x = data1;\n            window->windowed.y = data2;\n        }\n        if (data1 == window->x && data2 == window->y) {\n            return 0;\n        }\n        window->x = data1;\n        window->y = data2;\n        break;\n    case SDL_WINDOWEVENT_RESIZED:\n        if (!(window->flags & SDL_WINDOW_FULLSCREEN)) {\n            window->windowed.w = data1;\n            window->windowed.h = data2;\n        }\n        if (data1 == window->w && data2 == window->h) {\n            return 0;\n        }\n        window->w = data1;\n        window->h = data2;\n        SDL_OnWindowResized(window);\n        break;\n    case SDL_WINDOWEVENT_MINIMIZED:\n        if (window->flags & SDL_WINDOW_MINIMIZED) {\n            return 0;\n        }\n        window->flags |= SDL_WINDOW_MINIMIZED;\n        SDL_OnWindowMinimized(window);\n        break;\n    case SDL_WINDOWEVENT_MAXIMIZED:\n        if (window->flags & SDL_WINDOW_MAXIMIZED) {\n            return 0;\n        }\n        window->flags |= SDL_WINDOW_MAXIMIZED;\n        break;\n    case SDL_WINDOWEVENT_RESTORED:\n        if (!(window->flags & (SDL_WINDOW_MINIMIZED | SDL_WINDOW_MAXIMIZED))) {\n            return 0;\n        }\n        window->flags &= ~(SDL_WINDOW_MINIMIZED | SDL_WINDOW_MAXIMIZED);\n        SDL_OnWindowRestored(window);\n        break;\n    case SDL_WINDOWEVENT_ENTER:\n        if (window->flags & SDL_WINDOW_MOUSE_FOCUS) {\n            return 0;\n        }\n        window->flags |= SDL_WINDOW_MOUSE_FOCUS;\n        SDL_OnWindowEnter(window);\n        break;\n    case SDL_WINDOWEVENT_LEAVE:\n        if (!(window->flags & SDL_WINDOW_MOUSE_FOCUS)) {\n            return 0;\n        }\n        window->flags &= ~SDL_WINDOW_MOUSE_FOCUS;\n        SDL_OnWindowLeave(window);\n        break;\n    case SDL_WINDOWEVENT_FOCUS_GAINED:\n        if (window->flags & SDL_WINDOW_INPUT_FOCUS) {\n            return 0;\n        }\n        window->flags |= SDL_WINDOW_INPUT_FOCUS;\n        SDL_OnWindowFocusGained(window);\n        break;\n    case SDL_WINDOWEVENT_FOCUS_LOST:\n        if (!(window->flags & SDL_WINDOW_INPUT_FOCUS)) {\n            return 0;\n        }\n        window->flags &= ~SDL_WINDOW_INPUT_FOCUS;\n        SDL_OnWindowFocusLost(window);\n        break;\n    }\n\n    /* Post the event, if desired */\n    posted = 0;\n    if (SDL_GetEventState(SDL_WINDOWEVENT) == SDL_ENABLE) {\n        SDL_Event event;\n        event.type = SDL_WINDOWEVENT;\n        event.window.event = windowevent;\n        event.window.data1 = data1;\n        event.window.data2 = data2;\n        event.window.windowID = window->id;\n\n        /* Fixes queue overflow with resize events that aren't processed */\n        if (windowevent == SDL_WINDOWEVENT_RESIZED) {\n            SDL_FilterEvents(RemovePendingResizedEvents, &event);\n        }\n        if (windowevent == SDL_WINDOWEVENT_SIZE_CHANGED) {\n            SDL_FilterEvents(RemovePendingSizeChangedEvents, &event);\n        }\n        if (windowevent == SDL_WINDOWEVENT_MOVED) {\n            SDL_FilterEvents(RemovePendingMoveEvents, &event);\n        }\n\n        posted = (SDL_PushEvent(&event) > 0);\n    }\n\n    if (windowevent == SDL_WINDOWEVENT_CLOSE) {\n        if ( !window->prev && !window->next ) {\n            /* This is the last window in the list so send the SDL_QUIT event */\n            SDL_SendQuit();\n        }\n    }\n\n    return (posted);\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../../SDL_internal.h\"\n\n#if !SDL_RENDER_DISABLED\n\n#include \"SDL_draw.h\"\n#include \"SDL_blendfillrect.h\"\n\n\nstatic int\nSDL_BlendFillRect_RGB555(SDL_Surface * dst, const SDL_Rect * rect,\n                         SDL_BlendMode blendMode, Uint8 r, Uint8 g, Uint8 b, Uint8 a)\n{\n    unsigned inva = 0xff - a;\n\n    switch (blendMode) {\n    case SDL_BLENDMODE_BLEND:\n        FILLRECT(Uint16, DRAW_SETPIXEL_BLEND_RGB555);\n        break;\n    case SDL_BLENDMODE_ADD:\n        FILLRECT(Uint16, DRAW_SETPIXEL_ADD_RGB555);\n        break;\n    case SDL_BLENDMODE_MOD:\n        FILLRECT(Uint16, DRAW_SETPIXEL_MOD_RGB555);\n        break;\n    default:\n        FILLRECT(Uint16, DRAW_SETPIXEL_RGB555);\n        break;\n    }\n    return 0;\n}\n\nstatic int\nSDL_BlendFillRect_RGB565(SDL_Surface * dst, const SDL_Rect * rect,\n                         SDL_BlendMode blendMode, Uint8 r, Uint8 g, Uint8 b, Uint8 a)\n{\n    unsigned inva = 0xff - a;\n\n    switch (blendMode) {\n    case SDL_BLENDMODE_BLEND:\n        FILLRECT(Uint16, DRAW_SETPIXEL_BLEND_RGB565);\n        break;\n    case SDL_BLENDMODE_ADD:\n        FILLRECT(Uint16, DRAW_SETPIXEL_ADD_RGB565);\n        break;\n    case SDL_BLENDMODE_MOD:\n        FILLRECT(Uint16, DRAW_SETPIXEL_MOD_RGB565);\n        break;\n    default:\n        FILLRECT(Uint16, DRAW_SETPIXEL_RGB565);\n        break;\n    }\n    return 0;\n}\n\nstatic int\nSDL_BlendFillRect_RGB888(SDL_Surface * dst, const SDL_Rect * rect,\n                         SDL_BlendMode blendMode, Uint8 r, Uint8 g, Uint8 b, Uint8 a)\n{\n    unsigned inva = 0xff - a;\n\n    switch (blendMode) {\n    case SDL_BLENDMODE_BLEND:\n        FILLRECT(Uint32, DRAW_SETPIXEL_BLEND_RGB888);\n        break;\n    case SDL_BLENDMODE_ADD:\n        FILLRECT(Uint32, DRAW_SETPIXEL_ADD_RGB888);\n        break;\n    case SDL_BLENDMODE_MOD:\n        FILLRECT(Uint32, DRAW_SETPIXEL_MOD_RGB888);\n        break;\n    default:\n        FILLRECT(Uint32, DRAW_SETPIXEL_RGB888);\n        break;\n    }\n    return 0;\n}\n\nstatic int\nSDL_BlendFillRect_ARGB8888(SDL_Surface * dst, const SDL_Rect * rect,\n                           SDL_BlendMode blendMode, Uint8 r, Uint8 g, Uint8 b, Uint8 a)\n{\n    unsigned inva = 0xff - a;\n\n    switch (blendMode) {\n    case SDL_BLENDMODE_BLEND:\n        FILLRECT(Uint32, DRAW_SETPIXEL_BLEND_ARGB8888);\n        break;\n    case SDL_BLENDMODE_ADD:\n        FILLRECT(Uint32, DRAW_SETPIXEL_ADD_ARGB8888);\n        break;\n    case SDL_BLENDMODE_MOD:\n        FILLRECT(Uint32, DRAW_SETPIXEL_MOD_ARGB8888);\n        break;\n    default:\n        FILLRECT(Uint32, DRAW_SETPIXEL_ARGB8888);\n        break;\n    }\n    return 0;\n}\n\nstatic int\nSDL_BlendFillRect_RGB(SDL_Surface * dst, const SDL_Rect * rect,\n                      SDL_BlendMode blendMode, Uint8 r, Uint8 g, Uint8 b, Uint8 a)\n{\n    SDL_PixelFormat *fmt = dst->format;\n    unsigned inva = 0xff - a;\n\n    switch (fmt->BytesPerPixel) {\n    case 2:\n        switch (blendMode) {\n        case SDL_BLENDMODE_BLEND:\n            FILLRECT(Uint16, DRAW_SETPIXEL_BLEND_RGB);\n            break;\n        case SDL_BLENDMODE_ADD:\n            FILLRECT(Uint16, DRAW_SETPIXEL_ADD_RGB);\n            break;\n        case SDL_BLENDMODE_MOD:\n            FILLRECT(Uint16, DRAW_SETPIXEL_MOD_RGB);\n            break;\n        default:\n            FILLRECT(Uint16, DRAW_SETPIXEL_RGB);\n            break;\n        }\n        return 0;\n    case 4:\n        switch (blendMode) {\n        case SDL_BLENDMODE_BLEND:\n            FILLRECT(Uint32, DRAW_SETPIXEL_BLEND_RGB);\n            break;\n        case SDL_BLENDMODE_ADD:\n            FILLRECT(Uint32, DRAW_SETPIXEL_ADD_RGB);\n            break;\n        case SDL_BLENDMODE_MOD:\n            FILLRECT(Uint32, DRAW_SETPIXEL_MOD_RGB);\n            break;\n        default:\n            FILLRECT(Uint32, DRAW_SETPIXEL_RGB);\n            break;\n        }\n        return 0;\n    default:\n        return SDL_Unsupported();\n    }\n}\n\nstatic int\nSDL_BlendFillRect_RGBA(SDL_Surface * dst, const SDL_Rect * rect,\n                       SDL_BlendMode blendMode, Uint8 r, Uint8 g, Uint8 b, Uint8 a)\n{\n    SDL_PixelFormat *fmt = dst->format;\n    unsigned inva = 0xff - a;\n\n    switch (fmt->BytesPerPixel) {\n    case 4:\n        switch (blendMode) {\n        case SDL_BLENDMODE_BLEND:\n            FILLRECT(Uint32, DRAW_SETPIXEL_BLEND_RGBA);\n            break;\n        case SDL_BLENDMODE_ADD:\n            FILLRECT(Uint32, DRAW_SETPIXEL_ADD_RGBA);\n            break;\n        case SDL_BLENDMODE_MOD:\n            FILLRECT(Uint32, DRAW_SETPIXEL_MOD_RGBA);\n            break;\n        default:\n            FILLRECT(Uint32, DRAW_SETPIXEL_RGBA);\n            break;\n        }\n        return 0;\n    default:\n        return SDL_Unsupported();\n    }\n}\n\nint\nSDL_BlendFillRect(SDL_Surface * dst, const SDL_Rect * rect,\n                  SDL_BlendMode blendMode, Uint8 r, Uint8 g, Uint8 b, Uint8 a)\n{\n    SDL_Rect clipped;\n\n    if (!dst) {\n        return SDL_SetError(\"Passed NULL destination surface\");\n    }\n\n    /* This function doesn't work on surfaces < 8 bpp */\n    if (dst->format->BitsPerPixel < 8) {\n        return SDL_SetError(\"SDL_BlendFillRect(): Unsupported surface format\");\n    }\n\n    /* If 'rect' == NULL, then fill the whole surface */\n    if (rect) {\n        /* Perform clipping */\n        if (!SDL_IntersectRect(rect, &dst->clip_rect, &clipped)) {\n            return 0;\n        }\n        rect = &clipped;\n    } else {\n        rect = &dst->clip_rect;\n    }\n\n    if (blendMode == SDL_BLENDMODE_BLEND || blendMode == SDL_BLENDMODE_ADD) {\n        r = DRAW_MUL(r, a);\n        g = DRAW_MUL(g, a);\n        b = DRAW_MUL(b, a);\n    }\n\n    switch (dst->format->BitsPerPixel) {\n    case 15:\n        switch (dst->format->Rmask) {\n        case 0x7C00:\n            return SDL_BlendFillRect_RGB555(dst, rect, blendMode, r, g, b, a);\n        }\n        break;\n    case 16:\n        switch (dst->format->Rmask) {\n        case 0xF800:\n            return SDL_BlendFillRect_RGB565(dst, rect, blendMode, r, g, b, a);\n        }\n        break;\n    case 32:\n        switch (dst->format->Rmask) {\n        case 0x00FF0000:\n            if (!dst->format->Amask) {\n                return SDL_BlendFillRect_RGB888(dst, rect, blendMode, r, g, b, a);\n            } else {\n                return SDL_BlendFillRect_ARGB8888(dst, rect, blendMode, r, g, b, a);\n            }\n            break;\n        }\n        break;\n    default:\n        break;\n    }\n\n    if (!dst->format->Amask) {\n        return SDL_BlendFillRect_RGB(dst, rect, blendMode, r, g, b, a);\n    } else {\n        return SDL_BlendFillRect_RGBA(dst, rect, blendMode, r, g, b, a);\n    }\n}\n\nint\nSDL_BlendFillRects(SDL_Surface * dst, const SDL_Rect * rects, int count,\n                   SDL_BlendMode blendMode, Uint8 r, Uint8 g, Uint8 b, Uint8 a)\n{\n    SDL_Rect rect;\n    int i;\n    int (*func)(SDL_Surface * dst, const SDL_Rect * rect,\n                SDL_BlendMode blendMode, Uint8 r, Uint8 g, Uint8 b, Uint8 a) = NULL;\n    int status = 0;\n\n    if (!dst) {\n        return SDL_SetError(\"Passed NULL destination surface\");\n    }\n\n    /* This function doesn't work on surfaces < 8 bpp */\n    if (dst->format->BitsPerPixel < 8) {\n        return SDL_SetError(\"SDL_BlendFillRects(): Unsupported surface format\");\n    }\n\n    if (blendMode == SDL_BLENDMODE_BLEND || blendMode == SDL_BLENDMODE_ADD) {\n        r = DRAW_MUL(r, a);\n        g = DRAW_MUL(g, a);\n        b = DRAW_MUL(b, a);\n    }\n\n    /* FIXME: Does this function pointer slow things down significantly? */\n    switch (dst->format->BitsPerPixel) {\n    case 15:\n        switch (dst->format->Rmask) {\n        case 0x7C00:\n            func = SDL_BlendFillRect_RGB555;\n        }\n        break;\n    case 16:\n        switch (dst->format->Rmask) {\n        case 0xF800:\n            func = SDL_BlendFillRect_RGB565;\n        }\n        break;\n    case 32:\n        switch (dst->format->Rmask) {\n        case 0x00FF0000:\n            if (!dst->format->Amask) {\n                func = SDL_BlendFillRect_RGB888;\n            } else {\n                func = SDL_BlendFillRect_ARGB8888;\n            }\n            break;\n        }\n        break;\n    default:\n        break;\n    }\n\n    if (!func) {\n        if (!dst->format->Amask) {\n            func = SDL_BlendFillRect_RGB;\n        } else {\n            func = SDL_BlendFillRect_RGBA;\n        }\n    }\n\n    for (i = 0; i < count; ++i) {\n        /* Perform clipping */\n        if (!SDL_IntersectRect(&rects[i], &dst->clip_rect, &rect)) {\n            continue;\n        }\n        status = func(dst, &rect, blendMode, r, g, b, a);\n    }\n    return status;\n}\n\n#endif /* !SDL_RENDER_DISABLED */\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../../SDL_internal.h\"\n\n#if !SDL_RENDER_DISABLED\n\n#include \"SDL_draw.h\"\n#include \"SDL_blendline.h\"\n#include \"SDL_blendpoint.h\"\n\n\nstatic void\nSDL_BlendLine_RGB2(SDL_Surface * dst, int x1, int y1, int x2, int y2,\n                   SDL_BlendMode blendMode, Uint8 _r, Uint8 _g, Uint8 _b, Uint8 _a,\n                   SDL_bool draw_end)\n{\n    const SDL_PixelFormat *fmt = dst->format;\n    unsigned r, g, b, a, inva;\n\n    if (blendMode == SDL_BLENDMODE_BLEND || blendMode == SDL_BLENDMODE_ADD) {\n        r = DRAW_MUL(_r, _a);\n        g = DRAW_MUL(_g, _a);\n        b = DRAW_MUL(_b, _a);\n        a = _a;\n    } else {\n        r = _r;\n        g = _g;\n        b = _b;\n        a = _a;\n    }\n    inva = (a ^ 0xff);\n\n    if (y1 == y2) {\n        switch (blendMode) {\n        case SDL_BLENDMODE_BLEND:\n            HLINE(Uint16, DRAW_SETPIXEL_BLEND_RGB, draw_end);\n            break;\n        case SDL_BLENDMODE_ADD:\n            HLINE(Uint16, DRAW_SETPIXEL_ADD_RGB, draw_end);\n            break;\n        case SDL_BLENDMODE_MOD:\n            HLINE(Uint16, DRAW_SETPIXEL_MOD_RGB, draw_end);\n            break;\n        default:\n            HLINE(Uint16, DRAW_SETPIXEL_RGB, draw_end);\n            break;\n        }\n    } else if (x1 == x2) {\n        switch (blendMode) {\n        case SDL_BLENDMODE_BLEND:\n            VLINE(Uint16, DRAW_SETPIXEL_BLEND_RGB, draw_end);\n            break;\n        case SDL_BLENDMODE_ADD:\n            VLINE(Uint16, DRAW_SETPIXEL_ADD_RGB, draw_end);\n            break;\n        case SDL_BLENDMODE_MOD:\n            VLINE(Uint16, DRAW_SETPIXEL_MOD_RGB, draw_end);\n            break;\n        default:\n            VLINE(Uint16, DRAW_SETPIXEL_RGB, draw_end);\n            break;\n        }\n    } else if (ABS(x1 - x2) == ABS(y1 - y2)) {\n        switch (blendMode) {\n        case SDL_BLENDMODE_BLEND:\n            DLINE(Uint16, DRAW_SETPIXEL_BLEND_RGB, draw_end);\n            break;\n        case SDL_BLENDMODE_ADD:\n            DLINE(Uint16, DRAW_SETPIXEL_ADD_RGB, draw_end);\n            break;\n        case SDL_BLENDMODE_MOD:\n            DLINE(Uint16, DRAW_SETPIXEL_MOD_RGB, draw_end);\n            break;\n        default:\n            DLINE(Uint16, DRAW_SETPIXEL_RGB, draw_end);\n            break;\n        }\n    } else {\n        switch (blendMode) {\n        case SDL_BLENDMODE_BLEND:\n            AALINE(x1, y1, x2, y2,\n                   DRAW_SETPIXELXY2_BLEND_RGB, DRAW_SETPIXELXY2_BLEND_RGB,\n                   draw_end);\n            break;\n        case SDL_BLENDMODE_ADD:\n            AALINE(x1, y1, x2, y2,\n                   DRAW_SETPIXELXY2_ADD_RGB, DRAW_SETPIXELXY2_ADD_RGB,\n                   draw_end);\n            break;\n        case SDL_BLENDMODE_MOD:\n            AALINE(x1, y1, x2, y2,\n                   DRAW_SETPIXELXY2_MOD_RGB, DRAW_SETPIXELXY2_MOD_RGB,\n                   draw_end);\n            break;\n        default:\n            AALINE(x1, y1, x2, y2,\n                   DRAW_SETPIXELXY2_RGB, DRAW_SETPIXELXY2_BLEND_RGB,\n                   draw_end);\n            break;\n        }\n    }\n}\n\nstatic void\nSDL_BlendLine_RGB555(SDL_Surface * dst, int x1, int y1, int x2, int y2,\n                     SDL_BlendMode blendMode, Uint8 _r, Uint8 _g, Uint8 _b, Uint8 _a,\n                     SDL_bool draw_end)\n{\n    unsigned r, g, b, a, inva;\n\n    if (blendMode == SDL_BLENDMODE_BLEND || blendMode == SDL_BLENDMODE_ADD) {\n        r = DRAW_MUL(_r, _a);\n        g = DRAW_MUL(_g, _a);\n        b = DRAW_MUL(_b, _a);\n        a = _a;\n    } else {\n        r = _r;\n        g = _g;\n        b = _b;\n        a = _a;\n    }\n    inva = (a ^ 0xff);\n\n    if (y1 == y2) {\n        switch (blendMode) {\n        case SDL_BLENDMODE_BLEND:\n            HLINE(Uint16, DRAW_SETPIXEL_BLEND_RGB555, draw_end);\n            break;\n        case SDL_BLENDMODE_ADD:\n            HLINE(Uint16, DRAW_SETPIXEL_ADD_RGB555, draw_end);\n            break;\n        case SDL_BLENDMODE_MOD:\n            HLINE(Uint16, DRAW_SETPIXEL_MOD_RGB555, draw_end);\n            break;\n        default:\n            HLINE(Uint16, DRAW_SETPIXEL_RGB555, draw_end);\n            break;\n        }\n    } else if (x1 == x2) {\n        switch (blendMode) {\n        case SDL_BLENDMODE_BLEND:\n            VLINE(Uint16, DRAW_SETPIXEL_BLEND_RGB555, draw_end);\n            break;\n        case SDL_BLENDMODE_ADD:\n            VLINE(Uint16, DRAW_SETPIXEL_ADD_RGB555, draw_end);\n            break;\n        case SDL_BLENDMODE_MOD:\n            VLINE(Uint16, DRAW_SETPIXEL_MOD_RGB555, draw_end);\n            break;\n        default:\n            VLINE(Uint16, DRAW_SETPIXEL_RGB555, draw_end);\n            break;\n        }\n    } else if (ABS(x1 - x2) == ABS(y1 - y2)) {\n        switch (blendMode) {\n        case SDL_BLENDMODE_BLEND:\n            DLINE(Uint16, DRAW_SETPIXEL_BLEND_RGB555, draw_end);\n            break;\n        case SDL_BLENDMODE_ADD:\n            DLINE(Uint16, DRAW_SETPIXEL_ADD_RGB555, draw_end);\n            break;\n        case SDL_BLENDMODE_MOD:\n            DLINE(Uint16, DRAW_SETPIXEL_MOD_RGB555, draw_end);\n            break;\n        default:\n            DLINE(Uint16, DRAW_SETPIXEL_RGB555, draw_end);\n            break;\n        }\n    } else {\n        switch (blendMode) {\n        case SDL_BLENDMODE_BLEND:\n            AALINE(x1, y1, x2, y2,\n                   DRAW_SETPIXELXY_BLEND_RGB555, DRAW_SETPIXELXY_BLEND_RGB555,\n                   draw_end);\n            break;\n        case SDL_BLENDMODE_ADD:\n            AALINE(x1, y1, x2, y2,\n                   DRAW_SETPIXELXY_ADD_RGB555, DRAW_SETPIXELXY_ADD_RGB555,\n                   draw_end);\n            break;\n        case SDL_BLENDMODE_MOD:\n            AALINE(x1, y1, x2, y2,\n                   DRAW_SETPIXELXY_MOD_RGB555, DRAW_SETPIXELXY_MOD_RGB555,\n                   draw_end);\n            break;\n        default:\n            AALINE(x1, y1, x2, y2,\n                   DRAW_SETPIXELXY_RGB555, DRAW_SETPIXELXY_BLEND_RGB555,\n                   draw_end);\n            break;\n        }\n    }\n}\n\nstatic void\nSDL_BlendLine_RGB565(SDL_Surface * dst, int x1, int y1, int x2, int y2,\n                     SDL_BlendMode blendMode, Uint8 _r, Uint8 _g, Uint8 _b, Uint8 _a,\n                     SDL_bool draw_end)\n{\n    unsigned r, g, b, a, inva;\n\n    if (blendMode == SDL_BLENDMODE_BLEND || blendMode == SDL_BLENDMODE_ADD) {\n        r = DRAW_MUL(_r, _a);\n        g = DRAW_MUL(_g, _a);\n        b = DRAW_MUL(_b, _a);\n        a = _a;\n    } else {\n        r = _r;\n        g = _g;\n        b = _b;\n        a = _a;\n    }\n    inva = (a ^ 0xff);\n\n    if (y1 == y2) {\n        switch (blendMode) {\n        case SDL_BLENDMODE_BLEND:\n            HLINE(Uint16, DRAW_SETPIXEL_BLEND_RGB565, draw_end);\n            break;\n        case SDL_BLENDMODE_ADD:\n            HLINE(Uint16, DRAW_SETPIXEL_ADD_RGB565, draw_end);\n            break;\n        case SDL_BLENDMODE_MOD:\n            HLINE(Uint16, DRAW_SETPIXEL_MOD_RGB565, draw_end);\n            break;\n        default:\n            HLINE(Uint16, DRAW_SETPIXEL_RGB565, draw_end);\n            break;\n        }\n    } else if (x1 == x2) {\n        switch (blendMode) {\n        case SDL_BLENDMODE_BLEND:\n            VLINE(Uint16, DRAW_SETPIXEL_BLEND_RGB565, draw_end);\n            break;\n        case SDL_BLENDMODE_ADD:\n            VLINE(Uint16, DRAW_SETPIXEL_ADD_RGB565, draw_end);\n            break;\n        case SDL_BLENDMODE_MOD:\n            VLINE(Uint16, DRAW_SETPIXEL_MOD_RGB565, draw_end);\n            break;\n        default:\n            VLINE(Uint16, DRAW_SETPIXEL_RGB565, draw_end);\n            break;\n        }\n    } else if (ABS(x1 - x2) == ABS(y1 - y2)) {\n        switch (blendMode) {\n        case SDL_BLENDMODE_BLEND:\n            DLINE(Uint16, DRAW_SETPIXEL_BLEND_RGB565, draw_end);\n            break;\n        case SDL_BLENDMODE_ADD:\n            DLINE(Uint16, DRAW_SETPIXEL_ADD_RGB565, draw_end);\n            break;\n        case SDL_BLENDMODE_MOD:\n            DLINE(Uint16, DRAW_SETPIXEL_MOD_RGB565, draw_end);\n            break;\n        default:\n            DLINE(Uint16, DRAW_SETPIXEL_RGB565, draw_end);\n            break;\n        }\n    } else {\n        switch (blendMode) {\n        case SDL_BLENDMODE_BLEND:\n            AALINE(x1, y1, x2, y2,\n                   DRAW_SETPIXELXY_BLEND_RGB565, DRAW_SETPIXELXY_BLEND_RGB565,\n                   draw_end);\n            break;\n        case SDL_BLENDMODE_ADD:\n            AALINE(x1, y1, x2, y2,\n                   DRAW_SETPIXELXY_ADD_RGB565, DRAW_SETPIXELXY_ADD_RGB565,\n                   draw_end);\n            break;\n        case SDL_BLENDMODE_MOD:\n            AALINE(x1, y1, x2, y2,\n                   DRAW_SETPIXELXY_MOD_RGB565, DRAW_SETPIXELXY_MOD_RGB565,\n                   draw_end);\n            break;\n        default:\n            AALINE(x1, y1, x2, y2,\n                   DRAW_SETPIXELXY_RGB565, DRAW_SETPIXELXY_BLEND_RGB565,\n                   draw_end);\n            break;\n        }\n    }\n}\n\nstatic void\nSDL_BlendLine_RGB4(SDL_Surface * dst, int x1, int y1, int x2, int y2,\n                   SDL_BlendMode blendMode, Uint8 _r, Uint8 _g, Uint8 _b, Uint8 _a,\n                   SDL_bool draw_end)\n{\n    const SDL_PixelFormat *fmt = dst->format;\n    unsigned r, g, b, a, inva;\n\n    if (blendMode == SDL_BLENDMODE_BLEND || blendMode == SDL_BLENDMODE_ADD) {\n        r = DRAW_MUL(_r, _a);\n        g = DRAW_MUL(_g, _a);\n        b = DRAW_MUL(_b, _a);\n        a = _a;\n    } else {\n        r = _r;\n        g = _g;\n        b = _b;\n        a = _a;\n    }\n    inva = (a ^ 0xff);\n\n    if (y1 == y2) {\n        switch (blendMode) {\n        case SDL_BLENDMODE_BLEND:\n            HLINE(Uint32, DRAW_SETPIXEL_BLEND_RGB, draw_end);\n            break;\n        case SDL_BLENDMODE_ADD:\n            HLINE(Uint32, DRAW_SETPIXEL_ADD_RGB, draw_end);\n            break;\n        case SDL_BLENDMODE_MOD:\n            HLINE(Uint32, DRAW_SETPIXEL_MOD_RGB, draw_end);\n            break;\n        default:\n            HLINE(Uint32, DRAW_SETPIXEL_RGB, draw_end);\n            break;\n        }\n    } else if (x1 == x2) {\n        switch (blendMode) {\n        case SDL_BLENDMODE_BLEND:\n            VLINE(Uint32, DRAW_SETPIXEL_BLEND_RGB, draw_end);\n            break;\n        case SDL_BLENDMODE_ADD:\n            VLINE(Uint32, DRAW_SETPIXEL_ADD_RGB, draw_end);\n            break;\n        case SDL_BLENDMODE_MOD:\n            VLINE(Uint32, DRAW_SETPIXEL_MOD_RGB, draw_end);\n            break;\n        default:\n            VLINE(Uint32, DRAW_SETPIXEL_RGB, draw_end);\n            break;\n        }\n    } else if (ABS(x1 - x2) == ABS(y1 - y2)) {\n        switch (blendMode) {\n        case SDL_BLENDMODE_BLEND:\n            DLINE(Uint32, DRAW_SETPIXEL_BLEND_RGB, draw_end);\n            break;\n        case SDL_BLENDMODE_ADD:\n            DLINE(Uint32, DRAW_SETPIXEL_ADD_RGB, draw_end);\n            break;\n        case SDL_BLENDMODE_MOD:\n            DLINE(Uint32, DRAW_SETPIXEL_MOD_RGB, draw_end);\n            break;\n        default:\n            DLINE(Uint32, DRAW_SETPIXEL_RGB, draw_end);\n            break;\n        }\n    } else {\n        switch (blendMode) {\n        case SDL_BLENDMODE_BLEND:\n            AALINE(x1, y1, x2, y2,\n                   DRAW_SETPIXELXY4_BLEND_RGB, DRAW_SETPIXELXY4_BLEND_RGB,\n                   draw_end);\n            break;\n        case SDL_BLENDMODE_ADD:\n            AALINE(x1, y1, x2, y2,\n                   DRAW_SETPIXELXY4_ADD_RGB, DRAW_SETPIXELXY4_ADD_RGB,\n                   draw_end);\n            break;\n        case SDL_BLENDMODE_MOD:\n            AALINE(x1, y1, x2, y2,\n                   DRAW_SETPIXELXY4_MOD_RGB, DRAW_SETPIXELXY4_MOD_RGB,\n                   draw_end);\n            break;\n        default:\n            AALINE(x1, y1, x2, y2,\n                   DRAW_SETPIXELXY4_RGB, DRAW_SETPIXELXY4_BLEND_RGB,\n                   draw_end);\n            break;\n        }\n    }\n}\n\nstatic void\nSDL_BlendLine_RGBA4(SDL_Surface * dst, int x1, int y1, int x2, int y2,\n                    SDL_BlendMode blendMode, Uint8 _r, Uint8 _g, Uint8 _b, Uint8 _a,\n                    SDL_bool draw_end)\n{\n    const SDL_PixelFormat *fmt = dst->format;\n    unsigned r, g, b, a, inva;\n\n    if (blendMode == SDL_BLENDMODE_BLEND || blendMode == SDL_BLENDMODE_ADD) {\n        r = DRAW_MUL(_r, _a);\n        g = DRAW_MUL(_g, _a);\n        b = DRAW_MUL(_b, _a);\n        a = _a;\n    } else {\n        r = _r;\n        g = _g;\n        b = _b;\n        a = _a;\n    }\n    inva = (a ^ 0xff);\n\n    if (y1 == y2) {\n        switch (blendMode) {\n        case SDL_BLENDMODE_BLEND:\n            HLINE(Uint32, DRAW_SETPIXEL_BLEND_RGBA, draw_end);\n            break;\n        case SDL_BLENDMODE_ADD:\n            HLINE(Uint32, DRAW_SETPIXEL_ADD_RGBA, draw_end);\n            break;\n        case SDL_BLENDMODE_MOD:\n            HLINE(Uint32, DRAW_SETPIXEL_MOD_RGBA, draw_end);\n            break;\n        default:\n            HLINE(Uint32, DRAW_SETPIXEL_RGBA, draw_end);\n            break;\n        }\n    } else if (x1 == x2) {\n        switch (blendMode) {\n        case SDL_BLENDMODE_BLEND:\n            VLINE(Uint32, DRAW_SETPIXEL_BLEND_RGBA, draw_end);\n            break;\n        case SDL_BLENDMODE_ADD:\n            VLINE(Uint32, DRAW_SETPIXEL_ADD_RGBA, draw_end);\n            break;\n        case SDL_BLENDMODE_MOD:\n            VLINE(Uint32, DRAW_SETPIXEL_MOD_RGBA, draw_end);\n            break;\n        default:\n            VLINE(Uint32, DRAW_SETPIXEL_RGBA, draw_end);\n            break;\n        }\n    } else if (ABS(x1 - x2) == ABS(y1 - y2)) {\n        switch (blendMode) {\n        case SDL_BLENDMODE_BLEND:\n            DLINE(Uint32, DRAW_SETPIXEL_BLEND_RGBA, draw_end);\n            break;\n        case SDL_BLENDMODE_ADD:\n            DLINE(Uint32, DRAW_SETPIXEL_ADD_RGBA, draw_end);\n            break;\n        case SDL_BLENDMODE_MOD:\n            DLINE(Uint32, DRAW_SETPIXEL_MOD_RGBA, draw_end);\n            break;\n        default:\n            DLINE(Uint32, DRAW_SETPIXEL_RGBA, draw_end);\n            break;\n        }\n    } else {\n        switch (blendMode) {\n        case SDL_BLENDMODE_BLEND:\n            AALINE(x1, y1, x2, y2,\n                   DRAW_SETPIXELXY4_BLEND_RGBA, DRAW_SETPIXELXY4_BLEND_RGBA,\n                   draw_end);\n            break;\n        case SDL_BLENDMODE_ADD:\n            AALINE(x1, y1, x2, y2,\n                   DRAW_SETPIXELXY4_ADD_RGBA, DRAW_SETPIXELXY4_ADD_RGBA,\n                   draw_end);\n            break;\n        case SDL_BLENDMODE_MOD:\n            AALINE(x1, y1, x2, y2,\n                   DRAW_SETPIXELXY4_MOD_RGBA, DRAW_SETPIXELXY4_MOD_RGBA,\n                   draw_end);\n            break;\n        default:\n            AALINE(x1, y1, x2, y2,\n                   DRAW_SETPIXELXY4_RGBA, DRAW_SETPIXELXY4_BLEND_RGBA,\n                   draw_end);\n            break;\n        }\n    }\n}\n\nstatic void\nSDL_BlendLine_RGB888(SDL_Surface * dst, int x1, int y1, int x2, int y2,\n                     SDL_BlendMode blendMode, Uint8 _r, Uint8 _g, Uint8 _b, Uint8 _a,\n                     SDL_bool draw_end)\n{\n    unsigned r, g, b, a, inva;\n\n    if (blendMode == SDL_BLENDMODE_BLEND || blendMode == SDL_BLENDMODE_ADD) {\n        r = DRAW_MUL(_r, _a);\n        g = DRAW_MUL(_g, _a);\n        b = DRAW_MUL(_b, _a);\n        a = _a;\n    } else {\n        r = _r;\n        g = _g;\n        b = _b;\n        a = _a;\n    }\n    inva = (a ^ 0xff);\n\n    if (y1 == y2) {\n        switch (blendMode) {\n        case SDL_BLENDMODE_BLEND:\n            HLINE(Uint32, DRAW_SETPIXEL_BLEND_RGB888, draw_end);\n            break;\n        case SDL_BLENDMODE_ADD:\n            HLINE(Uint32, DRAW_SETPIXEL_ADD_RGB888, draw_end);\n            break;\n        case SDL_BLENDMODE_MOD:\n            HLINE(Uint32, DRAW_SETPIXEL_MOD_RGB888, draw_end);\n            break;\n        default:\n            HLINE(Uint32, DRAW_SETPIXEL_RGB888, draw_end);\n            break;\n        }\n    } else if (x1 == x2) {\n        switch (blendMode) {\n        case SDL_BLENDMODE_BLEND:\n            VLINE(Uint32, DRAW_SETPIXEL_BLEND_RGB888, draw_end);\n            break;\n        case SDL_BLENDMODE_ADD:\n            VLINE(Uint32, DRAW_SETPIXEL_ADD_RGB888, draw_end);\n            break;\n        case SDL_BLENDMODE_MOD:\n            VLINE(Uint32, DRAW_SETPIXEL_MOD_RGB888, draw_end);\n            break;\n        default:\n            VLINE(Uint32, DRAW_SETPIXEL_RGB888, draw_end);\n            break;\n        }\n    } else if (ABS(x1 - x2) == ABS(y1 - y2)) {\n        switch (blendMode) {\n        case SDL_BLENDMODE_BLEND:\n            DLINE(Uint32, DRAW_SETPIXEL_BLEND_RGB888, draw_end);\n            break;\n        case SDL_BLENDMODE_ADD:\n            DLINE(Uint32, DRAW_SETPIXEL_ADD_RGB888, draw_end);\n            break;\n        case SDL_BLENDMODE_MOD:\n            DLINE(Uint32, DRAW_SETPIXEL_MOD_RGB888, draw_end);\n            break;\n        default:\n            DLINE(Uint32, DRAW_SETPIXEL_RGB888, draw_end);\n            break;\n        }\n    } else {\n        switch (blendMode) {\n        case SDL_BLENDMODE_BLEND:\n            AALINE(x1, y1, x2, y2,\n                   DRAW_SETPIXELXY_BLEND_RGB888, DRAW_SETPIXELXY_BLEND_RGB888,\n                   draw_end);\n            break;\n        case SDL_BLENDMODE_ADD:\n            AALINE(x1, y1, x2, y2,\n                   DRAW_SETPIXELXY_ADD_RGB888, DRAW_SETPIXELXY_ADD_RGB888,\n                   draw_end);\n            break;\n        case SDL_BLENDMODE_MOD:\n            AALINE(x1, y1, x2, y2,\n                   DRAW_SETPIXELXY_MOD_RGB888, DRAW_SETPIXELXY_MOD_RGB888,\n                   draw_end);\n            break;\n        default:\n            AALINE(x1, y1, x2, y2,\n                   DRAW_SETPIXELXY_RGB888, DRAW_SETPIXELXY_BLEND_RGB888,\n                   draw_end);\n            break;\n        }\n    }\n}\n\nstatic void\nSDL_BlendLine_ARGB8888(SDL_Surface * dst, int x1, int y1, int x2, int y2,\n                       SDL_BlendMode blendMode, Uint8 _r, Uint8 _g, Uint8 _b, Uint8 _a,\n                       SDL_bool draw_end)\n{\n    unsigned r, g, b, a, inva;\n\n    if (blendMode == SDL_BLENDMODE_BLEND || blendMode == SDL_BLENDMODE_ADD) {\n        r = DRAW_MUL(_r, _a);\n        g = DRAW_MUL(_g, _a);\n        b = DRAW_MUL(_b, _a);\n        a = _a;\n    } else {\n        r = _r;\n        g = _g;\n        b = _b;\n        a = _a;\n    }\n    inva = (a ^ 0xff);\n\n    if (y1 == y2) {\n        switch (blendMode) {\n        case SDL_BLENDMODE_BLEND:\n            HLINE(Uint32, DRAW_SETPIXEL_BLEND_ARGB8888, draw_end);\n            break;\n        case SDL_BLENDMODE_ADD:\n            HLINE(Uint32, DRAW_SETPIXEL_ADD_ARGB8888, draw_end);\n            break;\n        case SDL_BLENDMODE_MOD:\n            HLINE(Uint32, DRAW_SETPIXEL_MOD_ARGB8888, draw_end);\n            break;\n        default:\n            HLINE(Uint32, DRAW_SETPIXEL_ARGB8888, draw_end);\n            break;\n        }\n    } else if (x1 == x2) {\n        switch (blendMode) {\n        case SDL_BLENDMODE_BLEND:\n            VLINE(Uint32, DRAW_SETPIXEL_BLEND_ARGB8888, draw_end);\n            break;\n        case SDL_BLENDMODE_ADD:\n            VLINE(Uint32, DRAW_SETPIXEL_ADD_ARGB8888, draw_end);\n            break;\n        case SDL_BLENDMODE_MOD:\n            VLINE(Uint32, DRAW_SETPIXEL_MOD_ARGB8888, draw_end);\n            break;\n        default:\n            VLINE(Uint32, DRAW_SETPIXEL_ARGB8888, draw_end);\n            break;\n        }\n    } else if (ABS(x1 - x2) == ABS(y1 - y2)) {\n        switch (blendMode) {\n        case SDL_BLENDMODE_BLEND:\n            DLINE(Uint32, DRAW_SETPIXEL_BLEND_ARGB8888, draw_end);\n            break;\n        case SDL_BLENDMODE_ADD:\n            DLINE(Uint32, DRAW_SETPIXEL_ADD_ARGB8888, draw_end);\n            break;\n        case SDL_BLENDMODE_MOD:\n            DLINE(Uint32, DRAW_SETPIXEL_MOD_ARGB8888, draw_end);\n            break;\n        default:\n            DLINE(Uint32, DRAW_SETPIXEL_ARGB8888, draw_end);\n            break;\n        }\n    } else {\n        switch (blendMode) {\n        case SDL_BLENDMODE_BLEND:\n            AALINE(x1, y1, x2, y2,\n                   DRAW_SETPIXELXY_BLEND_ARGB8888, DRAW_SETPIXELXY_BLEND_ARGB8888,\n                   draw_end);\n            break;\n        case SDL_BLENDMODE_ADD:\n            AALINE(x1, y1, x2, y2,\n                   DRAW_SETPIXELXY_ADD_ARGB8888, DRAW_SETPIXELXY_ADD_ARGB8888,\n                   draw_end);\n            break;\n        case SDL_BLENDMODE_MOD:\n            AALINE(x1, y1, x2, y2,\n                   DRAW_SETPIXELXY_MOD_ARGB8888, DRAW_SETPIXELXY_MOD_ARGB8888,\n                   draw_end);\n            break;\n        default:\n            AALINE(x1, y1, x2, y2,\n                   DRAW_SETPIXELXY_ARGB8888, DRAW_SETPIXELXY_BLEND_ARGB8888,\n                   draw_end);\n            break;\n        }\n    }\n}\n\ntypedef void (*BlendLineFunc) (SDL_Surface * dst,\n                               int x1, int y1, int x2, int y2,\n                               SDL_BlendMode blendMode,\n                               Uint8 r, Uint8 g, Uint8 b, Uint8 a,\n                               SDL_bool draw_end);\n\nstatic BlendLineFunc\nSDL_CalculateBlendLineFunc(const SDL_PixelFormat * fmt)\n{\n    switch (fmt->BytesPerPixel) {\n    case 2:\n        if (fmt->Rmask == 0x7C00) {\n            return SDL_BlendLine_RGB555;\n        } else if (fmt->Rmask == 0xF800) {\n            return SDL_BlendLine_RGB565;\n        } else {\n            return SDL_BlendLine_RGB2;\n        }\n        break;\n    case 4:\n        if (fmt->Rmask == 0x00FF0000) {\n            if (fmt->Amask) {\n                return SDL_BlendLine_ARGB8888;\n            } else {\n                return SDL_BlendLine_RGB888;\n            }\n        } else {\n            if (fmt->Amask) {\n                return SDL_BlendLine_RGBA4;\n            } else {\n                return SDL_BlendLine_RGB4;\n            }\n        }\n    }\n    return NULL;\n}\n\nint\nSDL_BlendLine(SDL_Surface * dst, int x1, int y1, int x2, int y2,\n              SDL_BlendMode blendMode, Uint8 r, Uint8 g, Uint8 b, Uint8 a)\n{\n    BlendLineFunc func;\n\n    if (!dst) {\n        return SDL_SetError(\"SDL_BlendLine(): Passed NULL destination surface\");\n    }\n\n    func = SDL_CalculateBlendLineFunc(dst->format);\n    if (!func) {\n        return SDL_SetError(\"SDL_BlendLine(): Unsupported surface format\");\n    }\n\n    /* Perform clipping */\n    /* FIXME: We don't actually want to clip, as it may change line slope */\n    if (!SDL_IntersectRectAndLine(&dst->clip_rect, &x1, &y1, &x2, &y2)) {\n        return 0;\n    }\n\n    func(dst, x1, y1, x2, y2, blendMode, r, g, b, a, SDL_TRUE);\n    return 0;\n}\n\nint\nSDL_BlendLines(SDL_Surface * dst, const SDL_Point * points, int count,\n               SDL_BlendMode blendMode, Uint8 r, Uint8 g, Uint8 b, Uint8 a)\n{\n    int i;\n    int x1, y1;\n    int x2, y2;\n    SDL_bool draw_end;\n    BlendLineFunc func;\n\n    if (!dst) {\n        return SDL_SetError(\"SDL_BlendLines(): Passed NULL destination surface\");\n    }\n\n    func = SDL_CalculateBlendLineFunc(dst->format);\n    if (!func) {\n        return SDL_SetError(\"SDL_BlendLines(): Unsupported surface format\");\n    }\n\n    for (i = 1; i < count; ++i) {\n        x1 = points[i-1].x;\n        y1 = points[i-1].y;\n        x2 = points[i].x;\n        y2 = points[i].y;\n\n        /* Perform clipping */\n        /* FIXME: We don't actually want to clip, as it may change line slope */\n        if (!SDL_IntersectRectAndLine(&dst->clip_rect, &x1, &y1, &x2, &y2)) {\n            continue;\n        }\n\n        /* Draw the end if it was clipped */\n        draw_end = (x2 != points[i].x || y2 != points[i].y);\n\n        func(dst, x1, y1, x2, y2, blendMode, r, g, b, a, draw_end);\n    }\n    if (points[0].x != points[count-1].x || points[0].y != points[count-1].y) {\n        SDL_BlendPoint(dst, points[count-1].x, points[count-1].y,\n                       blendMode, r, g, b, a);\n    }\n    return 0;\n}\n\n#endif /* !SDL_RENDER_DISABLED */\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../../SDL_internal.h\"\n\n#if !SDL_RENDER_DISABLED\n\n#include \"SDL_draw.h\"\n#include \"SDL_blendpoint.h\"\n\n\nstatic int\nSDL_BlendPoint_RGB555(SDL_Surface * dst, int x, int y, SDL_BlendMode blendMode, Uint8 r,\n                      Uint8 g, Uint8 b, Uint8 a)\n{\n    unsigned inva = 0xff - a;\n\n    switch (blendMode) {\n    case SDL_BLENDMODE_BLEND:\n        DRAW_SETPIXELXY_BLEND_RGB555(x, y);\n        break;\n    case SDL_BLENDMODE_ADD:\n        DRAW_SETPIXELXY_ADD_RGB555(x, y);\n        break;\n    case SDL_BLENDMODE_MOD:\n        DRAW_SETPIXELXY_MOD_RGB555(x, y);\n        break;\n    default:\n        DRAW_SETPIXELXY_RGB555(x, y);\n        break;\n    }\n    return 0;\n}\n\nstatic int\nSDL_BlendPoint_RGB565(SDL_Surface * dst, int x, int y, SDL_BlendMode blendMode, Uint8 r,\n                      Uint8 g, Uint8 b, Uint8 a)\n{\n    unsigned inva = 0xff - a;\n\n    switch (blendMode) {\n    case SDL_BLENDMODE_BLEND:\n        DRAW_SETPIXELXY_BLEND_RGB565(x, y);\n        break;\n    case SDL_BLENDMODE_ADD:\n        DRAW_SETPIXELXY_ADD_RGB565(x, y);\n        break;\n    case SDL_BLENDMODE_MOD:\n        DRAW_SETPIXELXY_MOD_RGB565(x, y);\n        break;\n    default:\n        DRAW_SETPIXELXY_RGB565(x, y);\n        break;\n    }\n    return 0;\n}\n\nstatic int\nSDL_BlendPoint_RGB888(SDL_Surface * dst, int x, int y, SDL_BlendMode blendMode, Uint8 r,\n                      Uint8 g, Uint8 b, Uint8 a)\n{\n    unsigned inva = 0xff - a;\n\n    switch (blendMode) {\n    case SDL_BLENDMODE_BLEND:\n        DRAW_SETPIXELXY_BLEND_RGB888(x, y);\n        break;\n    case SDL_BLENDMODE_ADD:\n        DRAW_SETPIXELXY_ADD_RGB888(x, y);\n        break;\n    case SDL_BLENDMODE_MOD:\n        DRAW_SETPIXELXY_MOD_RGB888(x, y);\n        break;\n    default:\n        DRAW_SETPIXELXY_RGB888(x, y);\n        break;\n    }\n    return 0;\n}\n\nstatic int\nSDL_BlendPoint_ARGB8888(SDL_Surface * dst, int x, int y, SDL_BlendMode blendMode,\n                        Uint8 r, Uint8 g, Uint8 b, Uint8 a)\n{\n    unsigned inva = 0xff - a;\n\n    switch (blendMode) {\n    case SDL_BLENDMODE_BLEND:\n        DRAW_SETPIXELXY_BLEND_ARGB8888(x, y);\n        break;\n    case SDL_BLENDMODE_ADD:\n        DRAW_SETPIXELXY_ADD_ARGB8888(x, y);\n        break;\n    case SDL_BLENDMODE_MOD:\n        DRAW_SETPIXELXY_MOD_ARGB8888(x, y);\n        break;\n    default:\n        DRAW_SETPIXELXY_ARGB8888(x, y);\n        break;\n    }\n    return 0;\n}\n\nstatic int\nSDL_BlendPoint_RGB(SDL_Surface * dst, int x, int y, SDL_BlendMode blendMode, Uint8 r,\n                   Uint8 g, Uint8 b, Uint8 a)\n{\n    SDL_PixelFormat *fmt = dst->format;\n    unsigned inva = 0xff - a;\n\n    switch (fmt->BytesPerPixel) {\n    case 2:\n        switch (blendMode) {\n        case SDL_BLENDMODE_BLEND:\n            DRAW_SETPIXELXY2_BLEND_RGB(x, y);\n            break;\n        case SDL_BLENDMODE_ADD:\n            DRAW_SETPIXELXY2_ADD_RGB(x, y);\n            break;\n        case SDL_BLENDMODE_MOD:\n            DRAW_SETPIXELXY2_MOD_RGB(x, y);\n            break;\n        default:\n            DRAW_SETPIXELXY2_RGB(x, y);\n            break;\n        }\n        return 0;\n    case 4:\n        switch (blendMode) {\n        case SDL_BLENDMODE_BLEND:\n            DRAW_SETPIXELXY4_BLEND_RGB(x, y);\n            break;\n        case SDL_BLENDMODE_ADD:\n            DRAW_SETPIXELXY4_ADD_RGB(x, y);\n            break;\n        case SDL_BLENDMODE_MOD:\n            DRAW_SETPIXELXY4_MOD_RGB(x, y);\n            break;\n        default:\n            DRAW_SETPIXELXY4_RGB(x, y);\n            break;\n        }\n        return 0;\n    default:\n        return SDL_Unsupported();\n    }\n}\n\nstatic int\nSDL_BlendPoint_RGBA(SDL_Surface * dst, int x, int y, SDL_BlendMode blendMode, Uint8 r,\n                    Uint8 g, Uint8 b, Uint8 a)\n{\n    SDL_PixelFormat *fmt = dst->format;\n    unsigned inva = 0xff - a;\n\n    switch (fmt->BytesPerPixel) {\n    case 4:\n        switch (blendMode) {\n        case SDL_BLENDMODE_BLEND:\n            DRAW_SETPIXELXY4_BLEND_RGBA(x, y);\n            break;\n        case SDL_BLENDMODE_ADD:\n            DRAW_SETPIXELXY4_ADD_RGBA(x, y);\n            break;\n        case SDL_BLENDMODE_MOD:\n            DRAW_SETPIXELXY4_MOD_RGBA(x, y);\n            break;\n        default:\n            DRAW_SETPIXELXY4_RGBA(x, y);\n            break;\n        }\n        return 0;\n    default:\n        return SDL_Unsupported();\n    }\n}\n\nint\nSDL_BlendPoint(SDL_Surface * dst, int x, int y, SDL_BlendMode blendMode, Uint8 r,\n               Uint8 g, Uint8 b, Uint8 a)\n{\n    if (!dst) {\n        return SDL_SetError(\"Passed NULL destination surface\");\n    }\n\n    /* This function doesn't work on surfaces < 8 bpp */\n    if (dst->format->BitsPerPixel < 8) {\n        return SDL_SetError(\"SDL_BlendPoint(): Unsupported surface format\");\n    }\n\n    /* Perform clipping */\n    if (x < dst->clip_rect.x || y < dst->clip_rect.y ||\n        x >= (dst->clip_rect.x + dst->clip_rect.w) ||\n        y >= (dst->clip_rect.y + dst->clip_rect.h)) {\n        return 0;\n    }\n\n    if (blendMode == SDL_BLENDMODE_BLEND || blendMode == SDL_BLENDMODE_ADD) {\n        r = DRAW_MUL(r, a);\n        g = DRAW_MUL(g, a);\n        b = DRAW_MUL(b, a);\n    }\n\n    switch (dst->format->BitsPerPixel) {\n    case 15:\n        switch (dst->format->Rmask) {\n        case 0x7C00:\n            return SDL_BlendPoint_RGB555(dst, x, y, blendMode, r, g, b, a);\n        }\n        break;\n    case 16:\n        switch (dst->format->Rmask) {\n        case 0xF800:\n            return SDL_BlendPoint_RGB565(dst, x, y, blendMode, r, g, b, a);\n        }\n        break;\n    case 32:\n        switch (dst->format->Rmask) {\n        case 0x00FF0000:\n            if (!dst->format->Amask) {\n                return SDL_BlendPoint_RGB888(dst, x, y, blendMode, r, g, b,\n                                             a);\n            } else {\n                return SDL_BlendPoint_ARGB8888(dst, x, y, blendMode, r, g, b,\n                                               a);\n            }\n            break;\n        }\n        break;\n    default:\n        break;\n    }\n\n    if (!dst->format->Amask) {\n        return SDL_BlendPoint_RGB(dst, x, y, blendMode, r, g, b, a);\n    } else {\n        return SDL_BlendPoint_RGBA(dst, x, y, blendMode, r, g, b, a);\n    }\n}\n\nint\nSDL_BlendPoints(SDL_Surface * dst, const SDL_Point * points, int count,\n                SDL_BlendMode blendMode, Uint8 r, Uint8 g, Uint8 b, Uint8 a)\n{\n    int minx, miny;\n    int maxx, maxy;\n    int i;\n    int x, y;\n    int (*func)(SDL_Surface * dst, int x, int y,\n                SDL_BlendMode blendMode, Uint8 r, Uint8 g, Uint8 b, Uint8 a) = NULL;\n    int status = 0;\n\n    if (!dst) {\n        return SDL_SetError(\"Passed NULL destination surface\");\n    }\n\n    /* This function doesn't work on surfaces < 8 bpp */\n    if (dst->format->BitsPerPixel < 8) {\n        return SDL_SetError(\"SDL_BlendPoints(): Unsupported surface format\");\n    }\n\n    if (blendMode == SDL_BLENDMODE_BLEND || blendMode == SDL_BLENDMODE_ADD) {\n        r = DRAW_MUL(r, a);\n        g = DRAW_MUL(g, a);\n        b = DRAW_MUL(b, a);\n    }\n\n    /* FIXME: Does this function pointer slow things down significantly? */\n    switch (dst->format->BitsPerPixel) {\n    case 15:\n        switch (dst->format->Rmask) {\n        case 0x7C00:\n            func = SDL_BlendPoint_RGB555;\n            break;\n        }\n        break;\n    case 16:\n        switch (dst->format->Rmask) {\n        case 0xF800:\n            func = SDL_BlendPoint_RGB565;\n            break;\n        }\n        break;\n    case 32:\n        switch (dst->format->Rmask) {\n        case 0x00FF0000:\n            if (!dst->format->Amask) {\n                func = SDL_BlendPoint_RGB888;\n            } else {\n                func = SDL_BlendPoint_ARGB8888;\n            }\n            break;\n        }\n        break;\n    default:\n        break;\n    }\n\n    if (!func) {\n        if (!dst->format->Amask) {\n            func = SDL_BlendPoint_RGB;\n        } else {\n            func = SDL_BlendPoint_RGBA;\n        }\n    }\n\n    minx = dst->clip_rect.x;\n    maxx = dst->clip_rect.x + dst->clip_rect.w - 1;\n    miny = dst->clip_rect.y;\n    maxy = dst->clip_rect.y + dst->clip_rect.h - 1;\n\n    for (i = 0; i < count; ++i) {\n        x = points[i].x;\n        y = points[i].y;\n\n        if (x < minx || x > maxx || y < miny || y > maxy) {\n            continue;\n        }\n        status = func(dst, x, y, blendMode, r, g, b, a);\n    }\n    return status;\n}\n\n#endif /* !SDL_RENDER_DISABLED */\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../../SDL_internal.h\"\n\n#if !SDL_RENDER_DISABLED\n\n#include \"SDL_draw.h\"\n#include \"SDL_drawline.h\"\n#include \"SDL_drawpoint.h\"\n\n\nstatic void\nSDL_DrawLine1(SDL_Surface * dst, int x1, int y1, int x2, int y2, Uint32 color,\n              SDL_bool draw_end)\n{\n    if (y1 == y2) {\n        int length;\n        int pitch = (dst->pitch / dst->format->BytesPerPixel);\n        Uint8 *pixel;\n        if (x1 <= x2) {\n            pixel = (Uint8 *)dst->pixels + y1 * pitch + x1;\n            length = draw_end ? (x2-x1+1) : (x2-x1);\n        } else {\n            pixel = (Uint8 *)dst->pixels + y1 * pitch + x2;\n            if (!draw_end) {\n                ++pixel;\n            }\n            length = draw_end ? (x1-x2+1) : (x1-x2);\n        }\n        SDL_memset(pixel, color, length);\n    } else if (x1 == x2) {\n        VLINE(Uint8, DRAW_FASTSETPIXEL1, draw_end);\n    } else if (ABS(x1 - x2) == ABS(y1 - y2)) {\n        DLINE(Uint8, DRAW_FASTSETPIXEL1, draw_end);\n    } else {\n        BLINE(x1, y1, x2, y2, DRAW_FASTSETPIXELXY1, draw_end);\n    }\n}\n\nstatic void\nSDL_DrawLine2(SDL_Surface * dst, int x1, int y1, int x2, int y2, Uint32 color,\n              SDL_bool draw_end)\n{\n    if (y1 == y2) {\n        HLINE(Uint16, DRAW_FASTSETPIXEL2, draw_end);\n    } else if (x1 == x2) {\n        VLINE(Uint16, DRAW_FASTSETPIXEL2, draw_end);\n    } else if (ABS(x1 - x2) == ABS(y1 - y2)) {\n        DLINE(Uint16, DRAW_FASTSETPIXEL2, draw_end);\n    } else {\n        Uint8 _r, _g, _b, _a;\n        const SDL_PixelFormat * fmt = dst->format;\n        SDL_GetRGBA(color, fmt, &_r, &_g, &_b, &_a);\n        if (fmt->Rmask == 0x7C00) {\n            AALINE(x1, y1, x2, y2,\n                   DRAW_FASTSETPIXELXY2, DRAW_SETPIXELXY_BLEND_RGB555,\n                   draw_end);\n        } else if (fmt->Rmask == 0xF800) {\n            AALINE(x1, y1, x2, y2,\n                   DRAW_FASTSETPIXELXY2, DRAW_SETPIXELXY_BLEND_RGB565,\n                   draw_end);\n        } else {\n            AALINE(x1, y1, x2, y2,\n                   DRAW_FASTSETPIXELXY2, DRAW_SETPIXELXY2_BLEND_RGB,\n                   draw_end);\n        }\n    }\n}\n\nstatic void\nSDL_DrawLine4(SDL_Surface * dst, int x1, int y1, int x2, int y2, Uint32 color,\n              SDL_bool draw_end)\n{\n    if (y1 == y2) {\n        HLINE(Uint32, DRAW_FASTSETPIXEL4, draw_end);\n    } else if (x1 == x2) {\n        VLINE(Uint32, DRAW_FASTSETPIXEL4, draw_end);\n    } else if (ABS(x1 - x2) == ABS(y1 - y2)) {\n        DLINE(Uint32, DRAW_FASTSETPIXEL4, draw_end);\n    } else {\n        Uint8 _r, _g, _b, _a;\n        const SDL_PixelFormat * fmt = dst->format;\n        SDL_GetRGBA(color, fmt, &_r, &_g, &_b, &_a);\n        if (fmt->Rmask == 0x00FF0000) {\n            if (!fmt->Amask) {\n                AALINE(x1, y1, x2, y2,\n                       DRAW_FASTSETPIXELXY4, DRAW_SETPIXELXY_BLEND_RGB888,\n                       draw_end);\n            } else {\n                AALINE(x1, y1, x2, y2,\n                       DRAW_FASTSETPIXELXY4, DRAW_SETPIXELXY_BLEND_ARGB8888,\n                       draw_end);\n            }\n        } else {\n            AALINE(x1, y1, x2, y2,\n                   DRAW_FASTSETPIXELXY4, DRAW_SETPIXELXY4_BLEND_RGB,\n                   draw_end);\n        }\n    }\n}\n\ntypedef void (*DrawLineFunc) (SDL_Surface * dst,\n                              int x1, int y1, int x2, int y2,\n                              Uint32 color, SDL_bool draw_end);\n\nstatic DrawLineFunc\nSDL_CalculateDrawLineFunc(const SDL_PixelFormat * fmt)\n{\n    switch (fmt->BytesPerPixel) {\n    case 1:\n        if (fmt->BitsPerPixel < 8) {\n            break;\n        }\n        return SDL_DrawLine1;\n    case 2:\n        return SDL_DrawLine2;\n    case 4:\n        return SDL_DrawLine4;\n    }\n    return NULL;\n}\n\nint\nSDL_DrawLine(SDL_Surface * dst, int x1, int y1, int x2, int y2, Uint32 color)\n{\n    DrawLineFunc func;\n\n    if (!dst) {\n        return SDL_SetError(\"SDL_DrawLine(): Passed NULL destination surface\");\n    }\n\n    func = SDL_CalculateDrawLineFunc(dst->format);\n    if (!func) {\n        return SDL_SetError(\"SDL_DrawLine(): Unsupported surface format\");\n    }\n\n    /* Perform clipping */\n    /* FIXME: We don't actually want to clip, as it may change line slope */\n    if (!SDL_IntersectRectAndLine(&dst->clip_rect, &x1, &y1, &x2, &y2)) {\n        return 0;\n    }\n\n    func(dst, x1, y1, x2, y2, color, SDL_TRUE);\n    return 0;\n}\n\nint\nSDL_DrawLines(SDL_Surface * dst, const SDL_Point * points, int count,\n              Uint32 color)\n{\n    int i;\n    int x1, y1;\n    int x2, y2;\n    SDL_bool draw_end;\n    DrawLineFunc func;\n\n    if (!dst) {\n        return SDL_SetError(\"SDL_DrawLines(): Passed NULL destination surface\");\n    }\n\n    func = SDL_CalculateDrawLineFunc(dst->format);\n    if (!func) {\n        return SDL_SetError(\"SDL_DrawLines(): Unsupported surface format\");\n    }\n\n    for (i = 1; i < count; ++i) {\n        x1 = points[i-1].x;\n        y1 = points[i-1].y;\n        x2 = points[i].x;\n        y2 = points[i].y;\n\n        /* Perform clipping */\n        /* FIXME: We don't actually want to clip, as it may change line slope */\n        if (!SDL_IntersectRectAndLine(&dst->clip_rect, &x1, &y1, &x2, &y2)) {\n            continue;\n        }\n\n        /* Draw the end if it was clipped */\n        draw_end = (x2 != points[i].x || y2 != points[i].y);\n\n        func(dst, x1, y1, x2, y2, color, draw_end);\n    }\n    if (points[0].x != points[count-1].x || points[0].y != points[count-1].y) {\n        SDL_DrawPoint(dst, points[count-1].x, points[count-1].y, color);\n    }\n    return 0;\n}\n\n#endif /* !SDL_RENDER_DISABLED */\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../../SDL_internal.h\"\n\n#if !SDL_RENDER_DISABLED\n\n#include \"SDL_draw.h\"\n#include \"SDL_drawpoint.h\"\n\n\nint\nSDL_DrawPoint(SDL_Surface * dst, int x, int y, Uint32 color)\n{\n    if (!dst) {\n        return SDL_SetError(\"Passed NULL destination surface\");\n    }\n\n    /* This function doesn't work on surfaces < 8 bpp */\n    if (dst->format->BitsPerPixel < 8) {\n        return SDL_SetError(\"SDL_DrawPoint(): Unsupported surface format\");\n    }\n\n    /* Perform clipping */\n    if (x < dst->clip_rect.x || y < dst->clip_rect.y ||\n        x >= (dst->clip_rect.x + dst->clip_rect.w) ||\n        y >= (dst->clip_rect.y + dst->clip_rect.h)) {\n        return 0;\n    }\n\n    switch (dst->format->BytesPerPixel) {\n    case 1:\n        DRAW_FASTSETPIXELXY1(x, y);\n        break;\n    case 2:\n        DRAW_FASTSETPIXELXY2(x, y);\n        break;\n    case 3:\n        return SDL_Unsupported();\n    case 4:\n        DRAW_FASTSETPIXELXY4(x, y);\n        break;\n    }\n    return 0;\n}\n\nint\nSDL_DrawPoints(SDL_Surface * dst, const SDL_Point * points, int count,\n               Uint32 color)\n{\n    int minx, miny;\n    int maxx, maxy;\n    int i;\n    int x, y;\n\n    if (!dst) {\n        return SDL_SetError(\"Passed NULL destination surface\");\n    }\n\n    /* This function doesn't work on surfaces < 8 bpp */\n    if (dst->format->BitsPerPixel < 8) {\n        return SDL_SetError(\"SDL_DrawPoints(): Unsupported surface format\");\n    }\n\n    minx = dst->clip_rect.x;\n    maxx = dst->clip_rect.x + dst->clip_rect.w - 1;\n    miny = dst->clip_rect.y;\n    maxy = dst->clip_rect.y + dst->clip_rect.h - 1;\n\n    for (i = 0; i < count; ++i) {\n        x = points[i].x;\n        y = points[i].y;\n\n        if (x < minx || x > maxx || y < miny || y > maxy) {\n            continue;\n        }\n\n        switch (dst->format->BytesPerPixel) {\n        case 1:\n            DRAW_FASTSETPIXELXY1(x, y);\n            break;\n        case 2:\n            DRAW_FASTSETPIXELXY2(x, y);\n            break;\n        case 3:\n            return SDL_Unsupported();\n        case 4:\n            DRAW_FASTSETPIXELXY4(x, y);\n            break;\n        }\n    }\n    return 0;\n}\n\n#endif /* !SDL_RENDER_DISABLED */\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n\n#if defined(__clang_analyzer__) && !defined(SDL_DISABLE_ANALYZE_MACROS)\n#define SDL_DISABLE_ANALYZE_MACROS 1\n#endif\n\n#include \"../SDL_internal.h\"\n\n#if defined(__WIN32__)\n#include \"../core/windows/SDL_windows.h\"\n#endif\n\n#include \"SDL_stdinc.h\"\n\n#if defined(__WIN32__) && (!defined(HAVE_SETENV) || !defined(HAVE_GETENV))\n/* Note this isn't thread-safe! */\nstatic char *SDL_envmem = NULL; /* Ugh, memory leak */\nstatic size_t SDL_envmemlen = 0;\n#endif\n\n/* Put a variable into the environment */\n/* Note: Name may not contain a '=' character. (Reference: http://www.unix.com/man-page/Linux/3/setenv/) */\n#if defined(HAVE_SETENV)\nint\nSDL_setenv(const char *name, const char *value, int overwrite)\n{\n    /* Input validation */\n    if (!name || SDL_strlen(name) == 0 || SDL_strchr(name, '=') != NULL || !value) {\n        return (-1);\n    }\n    \n    return setenv(name, value, overwrite);\n}\n#elif defined(__WIN32__)\nint\nSDL_setenv(const char *name, const char *value, int overwrite)\n{\n    /* Input validation */\n    if (!name || SDL_strlen(name) == 0 || SDL_strchr(name, '=') != NULL || !value) {\n        return (-1);\n    }\n    \n    if (!overwrite) {\n        char ch = 0;\n        const size_t len = GetEnvironmentVariableA(name, &ch, sizeof (ch));\n        if (len > 0) {\n            return 0;  /* asked not to overwrite existing value. */\n        }\n    }\n    if (!SetEnvironmentVariableA(name, *value ? value : NULL)) {\n        return -1;\n    }\n    return 0;\n}\n/* We have a real environment table, but no real setenv? Fake it w/ putenv. */\n#elif (defined(HAVE_GETENV) && defined(HAVE_PUTENV) && !defined(HAVE_SETENV))\nint\nSDL_setenv(const char *name, const char *value, int overwrite)\n{\n    size_t len;\n    char *new_variable;\n\n    /* Input validation */\n    if (!name || SDL_strlen(name) == 0 || SDL_strchr(name, '=') != NULL || !value) {\n        return (-1);\n    }\n    \n    if (getenv(name) != NULL) {\n        if (overwrite) {\n            unsetenv(name);\n        } else {\n            return 0;  /* leave the existing one there. */\n        }\n    }\n\n    /* This leaks. Sorry. Get a better OS so we don't have to do this. */\n    len = SDL_strlen(name) + SDL_strlen(value) + 2;\n    new_variable = (char *) SDL_malloc(len);\n    if (!new_variable) {\n        return (-1);\n    }\n\n    SDL_snprintf(new_variable, len, \"%s=%s\", name, value);\n    return putenv(new_variable);\n}\n#else /* roll our own */\nstatic char **SDL_env = (char **) 0;\nint\nSDL_setenv(const char *name, const char *value, int overwrite)\n{\n    int added;\n    int len, i;\n    char **new_env;\n    char *new_variable;\n\n    /* Input validation */\n    if (!name || SDL_strlen(name) == 0 || SDL_strchr(name, '=') != NULL || !value) {\n        return (-1);\n    }\n\n    /* See if it already exists */\n    if (!overwrite && SDL_getenv(name)) {\n        return 0;\n    }\n\n    /* Allocate memory for the variable */\n    len = SDL_strlen(name) + SDL_strlen(value) + 2;\n    new_variable = (char *) SDL_malloc(len);\n    if (!new_variable) {\n        return (-1);\n    }\n\n    SDL_snprintf(new_variable, len, \"%s=%s\", name, value);\n    value = new_variable + SDL_strlen(name) + 1;\n    name = new_variable;\n\n    /* Actually put it into the environment */\n    added = 0;\n    i = 0;\n    if (SDL_env) {\n        /* Check to see if it's already there... */\n        len = (value - name);\n        for (; SDL_env[i]; ++i) {\n            if (SDL_strncmp(SDL_env[i], name, len) == 0) {\n                break;\n            }\n        }\n        /* If we found it, just replace the entry */\n        if (SDL_env[i]) {\n            SDL_free(SDL_env[i]);\n            SDL_env[i] = new_variable;\n            added = 1;\n        }\n    }\n\n    /* Didn't find it in the environment, expand and add */\n    if (!added) {\n        new_env = SDL_realloc(SDL_env, (i + 2) * sizeof(char *));\n        if (new_env) {\n            SDL_env = new_env;\n            SDL_env[i++] = new_variable;\n            SDL_env[i++] = (char *) 0;\n            added = 1;\n        } else {\n            SDL_free(new_variable);\n        }\n    }\n    return (added ? 0 : -1);\n}\n#endif\n\n/* Retrieve a variable named \"name\" from the environment */\n#if defined(HAVE_GETENV)\nchar *\nSDL_getenv(const char *name)\n{\n    /* Input validation */\n    if (!name || SDL_strlen(name)==0) {\n        return NULL;\n    }\n\n    return getenv(name);\n}\n#elif defined(__WIN32__)\nchar *\nSDL_getenv(const char *name)\n{\n    size_t bufferlen;\n\n    /* Input validation */\n    if (!name || SDL_strlen(name)==0) {\n        return NULL;\n    }\n    \n    bufferlen =\n        GetEnvironmentVariableA(name, SDL_envmem, (DWORD) SDL_envmemlen);\n    if (bufferlen == 0) {\n        return NULL;\n    }\n    if (bufferlen > SDL_envmemlen) {\n        char *newmem = (char *) SDL_realloc(SDL_envmem, bufferlen);\n        if (newmem == NULL) {\n            return NULL;\n        }\n        SDL_envmem = newmem;\n        SDL_envmemlen = bufferlen;\n        GetEnvironmentVariableA(name, SDL_envmem, (DWORD) SDL_envmemlen);\n    }\n    return SDL_envmem;\n}\n#else\nchar *\nSDL_getenv(const char *name)\n{\n    int len, i;\n    char *value;\n\n    /* Input validation */\n    if (!name || SDL_strlen(name)==0) {\n        return NULL;\n    }\n    \n    value = (char *) 0;\n    if (SDL_env) {\n        len = SDL_strlen(name);\n        for (i = 0; SDL_env[i] && !value; ++i) {\n            if ((SDL_strncmp(SDL_env[i], name, len) == 0) &&\n                (SDL_env[i][len] == '=')) {\n                value = &SDL_env[i][len + 1];\n            }\n        }\n    }\n    return value;\n}\n#endif\n\n\n#ifdef TEST_MAIN\n#include <stdio.h>\n\nint\nmain(int argc, char *argv[])\n{\n    char *value;\n\n    printf(\"Checking for non-existent variable... \");\n    fflush(stdout);\n    if (!SDL_getenv(\"EXISTS\")) {\n        printf(\"okay\\n\");\n    } else {\n        printf(\"failed\\n\");\n    }\n    printf(\"Setting FIRST=VALUE1 in the environment... \");\n    fflush(stdout);\n    if (SDL_setenv(\"FIRST\", \"VALUE1\", 0) == 0) {\n        printf(\"okay\\n\");\n    } else {\n        printf(\"failed\\n\");\n    }\n    printf(\"Getting FIRST from the environment... \");\n    fflush(stdout);\n    value = SDL_getenv(\"FIRST\");\n    if (value && (SDL_strcmp(value, \"VALUE1\") == 0)) {\n        printf(\"okay\\n\");\n    } else {\n        printf(\"failed\\n\");\n    }\n    printf(\"Setting SECOND=VALUE2 in the environment... \");\n    fflush(stdout);\n    if (SDL_setenv(\"SECOND\", \"VALUE2\", 0) == 0) {\n        printf(\"okay\\n\");\n    } else {\n        printf(\"failed\\n\");\n    }\n    printf(\"Getting SECOND from the environment... \");\n    fflush(stdout);\n    value = SDL_getenv(\"SECOND\");\n    if (value && (SDL_strcmp(value, \"VALUE2\") == 0)) {\n        printf(\"okay\\n\");\n    } else {\n        printf(\"failed\\n\");\n    }\n    printf(\"Setting FIRST=NOVALUE in the environment... \");\n    fflush(stdout);\n    if (SDL_setenv(\"FIRST\", \"NOVALUE\", 1) == 0) {\n        printf(\"okay\\n\");\n    } else {\n        printf(\"failed\\n\");\n    }\n    printf(\"Getting FIRST from the environment... \");\n    fflush(stdout);\n    value = SDL_getenv(\"FIRST\");\n    if (value && (SDL_strcmp(value, \"NOVALUE\") == 0)) {\n        printf(\"okay\\n\");\n    } else {\n        printf(\"failed\\n\");\n    }\n    printf(\"Checking for non-existent variable... \");\n    fflush(stdout);\n    if (!SDL_getenv(\"EXISTS\")) {\n        printf(\"okay\\n\");\n    } else {\n        printf(\"failed\\n\");\n    }\n    return (0);\n}\n#endif /* TEST_MAIN */\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/* qsort.c\n * (c) 1998 Gareth McCaughan\n *\n * This is a drop-in replacement for the C library's |qsort()| routine.\n *\n * Features:\n *   - Median-of-three pivoting (and more)\n *   - Truncation and final polishing by a single insertion sort\n *   - Early truncation when no swaps needed in pivoting step\n *   - Explicit recursion, guaranteed not to overflow\n *   - A few little wrinkles stolen from the GNU |qsort()|.\n *   - separate code for non-aligned / aligned / word-size objects\n *\n * This code may be reproduced freely provided\n *   - this file is retained unaltered apart from minor\n *     changes for portability and efficiency\n *   - no changes are made to this comment\n *   - any changes that *are* made are clearly flagged\n *   - the _ID string below is altered by inserting, after\n *     the date, the string \" altered\" followed at your option\n *     by other material. (Exceptions: you may change the name\n *     of the exported routine without changing the ID string.\n *     You may change the values of the macros TRUNC_* and\n *     PIVOT_THRESHOLD without changing the ID string, provided\n *     they remain constants with TRUNC_nonaligned, TRUNC_aligned\n *     and TRUNC_words/WORD_BYTES between 8 and 24, and\n *     PIVOT_THRESHOLD between 32 and 200.)\n *\n * You may use it in anything you like; you may make money\n * out of it; you may distribute it in object form or as\n * part of an executable without including source code;\n * you don't have to credit me. (But it would be nice if\n * you did.)\n *\n * If you find problems with this code, or find ways of\n * making it significantly faster, please let me know!\n * My e-mail address, valid as of early 1998 and certainly\n * OK for at least the next 18 months, is\n *    gjm11@dpmms.cam.ac.uk\n * Thanks!\n *\n * Gareth McCaughan   Peterhouse   Cambridge   1998\n */\n\n#if defined(__clang_analyzer__) && !defined(SDL_DISABLE_ANALYZE_MACROS)\n#define SDL_DISABLE_ANALYZE_MACROS 1\n#endif\n\n#include \"../SDL_internal.h\"\n\n/*\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n*/\n#include \"SDL_stdinc.h\"\n#include \"SDL_assert.h\"\n\n#if defined(HAVE_QSORT)\nvoid\nSDL_qsort(void *base, size_t nmemb, size_t size, int (*compare) (const void *, const void *))\n{\n    qsort(base, nmemb, size, compare);\n}\n#else\n\n#ifdef assert\n#undef assert\n#endif\n#define assert(X) SDL_assert(X)\n#ifdef malloc\n#undef malloc\n#endif\n#define malloc\tSDL_malloc\n#ifdef free\n#undef free\n#endif\n#define free\tSDL_free\n#ifdef memcpy\n#undef memcpy\n#endif\n#define memcpy\tSDL_memcpy\n#ifdef memmove\n#undef memmove\n#endif\n#define memmove\tSDL_memmove\n#ifdef qsort\n#undef qsort\n#endif\n#define qsort\tSDL_qsort\n\nstatic const char _ID[] = \"<qsort.c gjm 1.12 1998-03-19>\";\n\n/* How many bytes are there per word? (Must be a power of 2,\n * and must in fact equal sizeof(int).)\n */\n#define WORD_BYTES sizeof(int)\n\n/* How big does our stack need to be? Answer: one entry per\n * bit in a |size_t|.\n */\n#define STACK_SIZE (8*sizeof(size_t))\n\n/* Different situations have slightly different requirements,\n * and we make life epsilon easier by using different truncation\n * points for the three different cases.\n * So far, I have tuned TRUNC_words and guessed that the same\n * value might work well for the other two cases. Of course\n * what works well on my machine might work badly on yours.\n */\n#define TRUNC_nonaligned\t12\n#define TRUNC_aligned\t\t12\n#define TRUNC_words\t\t12*WORD_BYTES   /* nb different meaning */\n\n/* We use a simple pivoting algorithm for shortish sub-arrays\n * and a more complicated one for larger ones. The threshold\n * is PIVOT_THRESHOLD.\n */\n#define PIVOT_THRESHOLD 40\n\ntypedef struct\n{\n    char *first;\n    char *last;\n} stack_entry;\n#define pushLeft {stack[stacktop].first=ffirst;stack[stacktop++].last=last;}\n#define pushRight {stack[stacktop].first=first;stack[stacktop++].last=llast;}\n#define doLeft {first=ffirst;llast=last;continue;}\n#define doRight {ffirst=first;last=llast;continue;}\n#define pop {if (--stacktop<0) break;\\\n  first=ffirst=stack[stacktop].first;\\\n  last=llast=stack[stacktop].last;\\\n  continue;}\n\n/* Some comments on the implementation.\n * 1. When we finish partitioning the array into \"low\"\n *    and \"high\", we forget entirely about short subarrays,\n *    because they'll be done later by insertion sort.\n *    Doing lots of little insertion sorts might be a win\n *    on large datasets for locality-of-reference reasons,\n *    but it makes the code much nastier and increases\n *    bookkeeping overhead.\n * 2. We always save the shorter and get to work on the\n *    longer. This guarantees that every time we push\n *    an item onto the stack its size is <= 1/2 of that\n *    of its parent; so the stack can't need more than\n *    log_2(max-array-size) entries.\n * 3. We choose a pivot by looking at the first, last\n *    and middle elements. We arrange them into order\n *    because it's easy to do that in conjunction with\n *    choosing the pivot, and it makes things a little\n *    easier in the partitioning step. Anyway, the pivot\n *    is the middle of these three. It's still possible\n *    to construct datasets where the algorithm takes\n *    time of order n^2, but it simply never happens in\n *    practice.\n * 3' Newsflash: On further investigation I find that\n *    it's easy to construct datasets where median-of-3\n *    simply isn't good enough. So on large-ish subarrays\n *    we do a more sophisticated pivoting: we take three\n *    sets of 3 elements, find their medians, and then\n *    take the median of those.\n * 4. We copy the pivot element to a separate place\n *    because that way we can always do our comparisons\n *    directly against a pointer to that separate place,\n *    and don't have to wonder \"did we move the pivot\n *    element?\". This makes the inner loop better.\n * 5. It's possible to make the pivoting even more\n *    reliable by looking at more candidates when n\n *    is larger. (Taking this to its logical conclusion\n *    results in a variant of quicksort that doesn't\n *    have that n^2 worst case.) However, the overhead\n *    from the extra bookkeeping means that it's just\n *    not worth while.\n * 6. This is pretty clean and portable code. Here are\n *    all the potential portability pitfalls and problems\n *    I know of:\n *      - In one place (the insertion sort) I construct\n *        a pointer that points just past the end of the\n *        supplied array, and assume that (a) it won't\n *        compare equal to any pointer within the array,\n *        and (b) it will compare equal to a pointer\n *        obtained by stepping off the end of the array.\n *        These might fail on some segmented architectures.\n *      - I assume that there are 8 bits in a |char| when\n *        computing the size of stack needed. This would\n *        fail on machines with 9-bit or 16-bit bytes.\n *      - I assume that if |((int)base&(sizeof(int)-1))==0|\n *        and |(size&(sizeof(int)-1))==0| then it's safe to\n *        get at array elements via |int*|s, and that if\n *        actually |size==sizeof(int)| as well then it's\n *        safe to treat the elements as |int|s. This might\n *        fail on systems that convert pointers to integers\n *        in non-standard ways.\n *      - I assume that |8*sizeof(size_t)<=INT_MAX|. This\n *        would be false on a machine with 8-bit |char|s,\n *        16-bit |int|s and 4096-bit |size_t|s. :-)\n */\n\n/* The recursion logic is the same in each case: */\n#define Recurse(Trunc)\t\t\t\t\\\n      { size_t l=last-ffirst,r=llast-first;\t\\\n        if (l<Trunc) {\t\t\t\t\\\n          if (r>=Trunc) doRight\t\t\t\\\n          else pop\t\t\t\t\\\n        }\t\t\t\t\t\\\n        else if (l<=r) { pushLeft; doRight }\t\\\n        else if (r>=Trunc) { pushRight; doLeft }\\\n        else doLeft\t\t\t\t\\\n      }\n\n/* and so is the pivoting logic: */\n#define Pivot(swapper,sz)\t\t\t\\\n  if ((size_t)(last-first)>PIVOT_THRESHOLD*sz) mid=pivot_big(first,mid,last,sz,compare);\\\n  else {\t\\\n    if (compare(first,mid)<0) {\t\t\t\\\n      if (compare(mid,last)>0) {\t\t\\\n        swapper(mid,last);\t\t\t\\\n        if (compare(first,mid)>0) swapper(first,mid);\\\n      }\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\\\n    else {\t\t\t\t\t\\\n      if (compare(mid,last)>0) swapper(first,last)\\\n      else {\t\t\t\t\t\\\n        swapper(first,mid);\t\t\t\\\n        if (compare(mid,last)>0) swapper(mid,last);\\\n      }\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\\\n    first+=sz; last-=sz;\t\t\t\\\n  }\n\n#ifdef DEBUG_QSORT\n#include <stdio.h>\n#endif\n\n/* and so is the partitioning logic: */\n#define Partition(swapper,sz) {\t\t\t\\\n  int swapped=0;\t\t\t\t\\\n  do {\t\t\t\t\t\t\\\n    while (compare(first,pivot)<0) first+=sz;\t\\\n    while (compare(pivot,last)<0) last-=sz;\t\\\n    if (first<last) {\t\t\t\t\\\n      swapper(first,last); swapped=1;\t\t\\\n      first+=sz; last-=sz; }\t\t\t\\\n    else if (first==last) { first+=sz; last-=sz; break; }\\\n  } while (first<=last);\t\t\t\\\n  if (!swapped) pop\t\t\t\t\\\n}\n\n/* and so is the pre-insertion-sort operation of putting\n * the smallest element into place as a sentinel.\n * Doing this makes the inner loop nicer. I got this\n * idea from the GNU implementation of qsort().\n */\n#define PreInsertion(swapper,limit,sz)\t\t\\\n  first=base;\t\t\t\t\t\\\n  last=first + (nmemb>limit ? limit : nmemb-1)*sz;\\\n  while (last!=base) {\t\t\t\t\\\n    if (compare(first,last)>0) first=last;\t\\\n    last-=sz; }\t\t\t\t\t\\\n  if (first!=base) swapper(first,(char*)base);\n\n/* and so is the insertion sort, in the first two cases: */\n#define Insertion(swapper)\t\t\t\\\n  last=((char*)base)+nmemb*size;\t\t\\\n  for (first=((char*)base)+size;first!=last;first+=size) {\t\\\n    char *test;\t\t\t\t\t\\\n    /* Find the right place for |first|.\t\\\n     * My apologies for var reuse. */\t\t\\\n    for (test=first-size;compare(test,first)>0;test-=size) ;\t\\\n    test+=size;\t\t\t\t\t\\\n    if (test!=first) {\t\t\t\t\\\n      /* Shift everything in [test,first)\t\\\n       * up by one, and place |first|\t\t\\\n       * where |test| is. */\t\t\t\\\n      memcpy(pivot,first,size);\t\t\t\\\n      memmove(test+size,test,first-test);\t\\\n      memcpy(test,pivot,size);\t\t\t\\\n    }\t\t\t\t\t\t\\\n  }\n\n#define SWAP_nonaligned(a,b) { \\\n  register char *aa=(a),*bb=(b); \\\n  register size_t sz=size; \\\n  do { register char t=*aa; *aa++=*bb; *bb++=t; } while (--sz); }\n\n#define SWAP_aligned(a,b) { \\\n  register int *aa=(int*)(a),*bb=(int*)(b); \\\n  register size_t sz=size; \\\n  do { register int t=*aa;*aa++=*bb; *bb++=t; } while (sz-=WORD_BYTES); }\n\n#define SWAP_words(a,b) { \\\n  register int t=*((int*)a); *((int*)a)=*((int*)b); *((int*)b)=t; }\n\n/* ---------------------------------------------------------------------- */\n\nstatic char *\npivot_big(char *first, char *mid, char *last, size_t size,\n          int compare(const void *, const void *))\n{\n    size_t d = (((last - first) / size) >> 3) * size;\n    char *m1, *m2, *m3;\n    {\n        char *a = first, *b = first + d, *c = first + 2 * d;\n#ifdef DEBUG_QSORT\n        fprintf(stderr, \"< %d %d %d\\n\", *(int *) a, *(int *) b, *(int *) c);\n#endif\n        m1 = compare(a, b) < 0 ?\n            (compare(b, c) < 0 ? b : (compare(a, c) < 0 ? c : a))\n            : (compare(a, c) < 0 ? a : (compare(b, c) < 0 ? c : b));\n    }\n    {\n        char *a = mid - d, *b = mid, *c = mid + d;\n#ifdef DEBUG_QSORT\n        fprintf(stderr, \". %d %d %d\\n\", *(int *) a, *(int *) b, *(int *) c);\n#endif\n        m2 = compare(a, b) < 0 ?\n            (compare(b, c) < 0 ? b : (compare(a, c) < 0 ? c : a))\n            : (compare(a, c) < 0 ? a : (compare(b, c) < 0 ? c : b));\n    }\n    {\n        char *a = last - 2 * d, *b = last - d, *c = last;\n#ifdef DEBUG_QSORT\n        fprintf(stderr, \"> %d %d %d\\n\", *(int *) a, *(int *) b, *(int *) c);\n#endif\n        m3 = compare(a, b) < 0 ?\n            (compare(b, c) < 0 ? b : (compare(a, c) < 0 ? c : a))\n            : (compare(a, c) < 0 ? a : (compare(b, c) < 0 ? c : b));\n    }\n#ifdef DEBUG_QSORT\n    fprintf(stderr, \"-> %d %d %d\\n\", *(int *) m1, *(int *) m2, *(int *) m3);\n#endif\n    return compare(m1, m2) < 0 ?\n        (compare(m2, m3) < 0 ? m2 : (compare(m1, m3) < 0 ? m3 : m1))\n        : (compare(m1, m3) < 0 ? m1 : (compare(m2, m3) < 0 ? m3 : m2));\n}\n\n/* ---------------------------------------------------------------------- */\n\nstatic void\nqsort_nonaligned(void *base, size_t nmemb, size_t size,\n                 int (*compare) (const void *, const void *))\n{\n\n    stack_entry stack[STACK_SIZE];\n    int stacktop = 0;\n    char *first, *last;\n    char *pivot = malloc(size);\n    size_t trunc = TRUNC_nonaligned * size;\n    assert(pivot != 0);\n\n    first = (char *) base;\n    last = first + (nmemb - 1) * size;\n\n    if ((size_t) (last - first) > trunc) {\n        char *ffirst = first, *llast = last;\n        while (1) {\n            /* Select pivot */\n            {\n                char *mid = first + size * ((last - first) / size >> 1);\n                Pivot(SWAP_nonaligned, size);\n                memcpy(pivot, mid, size);\n            }\n            /* Partition. */\n            Partition(SWAP_nonaligned, size);\n            /* Prepare to recurse/iterate. */\n        Recurse(trunc)}\n    }\n    PreInsertion(SWAP_nonaligned, TRUNC_nonaligned, size);\n    Insertion(SWAP_nonaligned);\n    free(pivot);\n}\n\nstatic void\nqsort_aligned(void *base, size_t nmemb, size_t size,\n              int (*compare) (const void *, const void *))\n{\n\n    stack_entry stack[STACK_SIZE];\n    int stacktop = 0;\n    char *first, *last;\n    char *pivot = malloc(size);\n    size_t trunc = TRUNC_aligned * size;\n    assert(pivot != 0);\n\n    first = (char *) base;\n    last = first + (nmemb - 1) * size;\n\n    if ((size_t) (last - first) > trunc) {\n        char *ffirst = first, *llast = last;\n        while (1) {\n            /* Select pivot */\n            {\n                char *mid = first + size * ((last - first) / size >> 1);\n                Pivot(SWAP_aligned, size);\n                memcpy(pivot, mid, size);\n            }\n            /* Partition. */\n            Partition(SWAP_aligned, size);\n            /* Prepare to recurse/iterate. */\n        Recurse(trunc)}\n    }\n    PreInsertion(SWAP_aligned, TRUNC_aligned, size);\n    Insertion(SWAP_aligned);\n    free(pivot);\n}\n\nstatic void\nqsort_words(void *base, size_t nmemb,\n            int (*compare) (const void *, const void *))\n{\n\n    stack_entry stack[STACK_SIZE];\n    int stacktop = 0;\n    char *first, *last;\n    char *pivot = malloc(WORD_BYTES);\n    assert(pivot != 0);\n\n    first = (char *) base;\n    last = first + (nmemb - 1) * WORD_BYTES;\n\n    if (last - first > TRUNC_words) {\n        char *ffirst = first, *llast = last;\n        while (1) {\n#ifdef DEBUG_QSORT\n            fprintf(stderr, \"Doing %d:%d: \",\n                    (first - (char *) base) / WORD_BYTES,\n                    (last - (char *) base) / WORD_BYTES);\n#endif\n            /* Select pivot */\n            {\n                char *mid =\n                    first + WORD_BYTES * ((last - first) / (2 * WORD_BYTES));\n                Pivot(SWAP_words, WORD_BYTES);\n                *(int *) pivot = *(int *) mid;\n            }\n#ifdef DEBUG_QSORT\n            fprintf(stderr, \"pivot=%d\\n\", *(int *) pivot);\n#endif\n            /* Partition. */\n            Partition(SWAP_words, WORD_BYTES);\n            /* Prepare to recurse/iterate. */\n        Recurse(TRUNC_words)}\n    }\n    PreInsertion(SWAP_words, (TRUNC_words / WORD_BYTES), WORD_BYTES);\n    /* Now do insertion sort. */\n    last = ((char *) base) + nmemb * WORD_BYTES;\n    for (first = ((char *) base) + WORD_BYTES; first != last;\n         first += WORD_BYTES) {\n        /* Find the right place for |first|. My apologies for var reuse */\n        int *pl = (int *) (first - WORD_BYTES), *pr = (int *) first;\n        *(int *) pivot = *(int *) first;\n        for (; compare(pl, pivot) > 0; pr = pl, --pl) {\n            *pr = *pl;\n        }\n        if (pr != (int *) first)\n            *pr = *(int *) pivot;\n    }\n    free(pivot);\n}\n\n/* ---------------------------------------------------------------------- */\n\nvoid\nqsort(void *base, size_t nmemb, size_t size,\n      int (*compare) (const void *, const void *))\n{\n\n    if (nmemb <= 1)\n        return;\n    if (((uintptr_t) base | size) & (WORD_BYTES - 1))\n        qsort_nonaligned(base, nmemb, size, compare);\n    else if (size != WORD_BYTES)\n        qsort_aligned(base, nmemb, size, compare);\n    else\n        qsort_words(base, nmemb, compare);\n}\n\n#endif /* !SDL_qsort */\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../SDL_internal.h\"\n\n/* System independent thread management routines for SDL */\n\n#include \"SDL_assert.h\"\n#include \"SDL_thread.h\"\n#include \"SDL_thread_c.h\"\n#include \"SDL_systhread.h\"\n#include \"../SDL_error_c.h\"\n\n\nSDL_TLSID\nSDL_TLSCreate()\n{\n    static SDL_atomic_t SDL_tls_id;\n    return SDL_AtomicIncRef(&SDL_tls_id)+1;\n}\n\nvoid *\nSDL_TLSGet(SDL_TLSID id)\n{\n    SDL_TLSData *storage;\n\n    storage = SDL_SYS_GetTLSData();\n    if (!storage || id == 0 || id > storage->limit) {\n        return NULL;\n    }\n    return storage->array[id-1].data;\n}\n\nint\nSDL_TLSSet(SDL_TLSID id, const void *value, void (*destructor)(void *))\n{\n    SDL_TLSData *storage;\n\n    if (id == 0) {\n        return SDL_InvalidParamError(\"id\");\n    }\n\n    storage = SDL_SYS_GetTLSData();\n    if (!storage || (id > storage->limit)) {\n        unsigned int i, oldlimit, newlimit;\n\n        oldlimit = storage ? storage->limit : 0;\n        newlimit = (id + TLS_ALLOC_CHUNKSIZE);\n        storage = (SDL_TLSData *)SDL_realloc(storage, sizeof(*storage)+(newlimit-1)*sizeof(storage->array[0]));\n        if (!storage) {\n            return SDL_OutOfMemory();\n        }\n        storage->limit = newlimit;\n        for (i = oldlimit; i < newlimit; ++i) {\n            storage->array[i].data = NULL;\n            storage->array[i].destructor = NULL;\n        }\n        if (SDL_SYS_SetTLSData(storage) != 0) {\n            return -1;\n        }\n    }\n\n    storage->array[id-1].data = SDL_const_cast(void*, value);\n    storage->array[id-1].destructor = destructor;\n    return 0;\n}\n\nstatic void\nSDL_TLSCleanup()\n{\n    SDL_TLSData *storage;\n\n    storage = SDL_SYS_GetTLSData();\n    if (storage) {\n        unsigned int i;\n        for (i = 0; i < storage->limit; ++i) {\n            if (storage->array[i].destructor) {\n                storage->array[i].destructor(storage->array[i].data);\n            }\n        }\n        SDL_SYS_SetTLSData(NULL);\n        SDL_free(storage);\n    }\n}\n\n\n/* This is a generic implementation of thread-local storage which doesn't\n   require additional OS support.\n\n   It is not especially efficient and doesn't clean up thread-local storage\n   as threads exit.  If there is a real OS that doesn't support thread-local\n   storage this implementation should be improved to be production quality.\n*/\n\ntypedef struct SDL_TLSEntry {\n    SDL_threadID thread;\n    SDL_TLSData *storage;\n    struct SDL_TLSEntry *next;\n} SDL_TLSEntry;\n\nstatic SDL_mutex *SDL_generic_TLS_mutex;\nstatic SDL_TLSEntry *SDL_generic_TLS;\n\n\nSDL_TLSData *\nSDL_Generic_GetTLSData()\n{\n    SDL_threadID thread = SDL_ThreadID();\n    SDL_TLSEntry *entry;\n    SDL_TLSData *storage = NULL;\n\n#if !SDL_THREADS_DISABLED\n    if (!SDL_generic_TLS_mutex) {\n        static SDL_SpinLock tls_lock;\n        SDL_AtomicLock(&tls_lock);\n        if (!SDL_generic_TLS_mutex) {\n            SDL_mutex *mutex = SDL_CreateMutex();\n            SDL_MemoryBarrierRelease();\n            SDL_generic_TLS_mutex = mutex;\n            if (!SDL_generic_TLS_mutex) {\n                SDL_AtomicUnlock(&tls_lock);\n                return NULL;\n            }\n        }\n        SDL_AtomicUnlock(&tls_lock);\n    }\n#endif /* SDL_THREADS_DISABLED */\n\n    SDL_MemoryBarrierAcquire();\n    SDL_LockMutex(SDL_generic_TLS_mutex);\n    for (entry = SDL_generic_TLS; entry; entry = entry->next) {\n        if (entry->thread == thread) {\n            storage = entry->storage;\n            break;\n        }\n    }\n#if !SDL_THREADS_DISABLED\n    SDL_UnlockMutex(SDL_generic_TLS_mutex);\n#endif\n\n    return storage;\n}\n\nint\nSDL_Generic_SetTLSData(SDL_TLSData *storage)\n{\n    SDL_threadID thread = SDL_ThreadID();\n    SDL_TLSEntry *prev, *entry;\n\n    /* SDL_Generic_GetTLSData() is always called first, so we can assume SDL_generic_TLS_mutex */\n    SDL_LockMutex(SDL_generic_TLS_mutex);\n    prev = NULL;\n    for (entry = SDL_generic_TLS; entry; entry = entry->next) {\n        if (entry->thread == thread) {\n            if (storage) {\n                entry->storage = storage;\n            } else {\n                if (prev) {\n                    prev->next = entry->next;\n                } else {\n                    SDL_generic_TLS = entry->next;\n                }\n                SDL_free(entry);\n            }\n            break;\n        }\n        prev = entry;\n    }\n    if (!entry) {\n        entry = (SDL_TLSEntry *)SDL_malloc(sizeof(*entry));\n        if (entry) {\n            entry->thread = thread;\n            entry->storage = storage;\n            entry->next = SDL_generic_TLS;\n            SDL_generic_TLS = entry;\n        }\n    }\n    SDL_UnlockMutex(SDL_generic_TLS_mutex);\n\n    if (!entry) {\n        return SDL_OutOfMemory();\n    }\n    return 0;\n}\n\n/* Routine to get the thread-specific error variable */\nSDL_error *\nSDL_GetErrBuf(void)\n{\n    static SDL_SpinLock tls_lock;\n    static SDL_bool tls_being_created;\n    static SDL_TLSID tls_errbuf;\n    static SDL_error SDL_global_errbuf;\n    const SDL_error *ALLOCATION_IN_PROGRESS = (SDL_error *)-1;\n    SDL_error *errbuf;\n\n    /* tls_being_created is there simply to prevent recursion if SDL_TLSCreate() fails.\n       It also means it's possible for another thread to also use SDL_global_errbuf,\n       but that's very unlikely and hopefully won't cause issues.\n     */\n    if (!tls_errbuf && !tls_being_created) {\n        SDL_AtomicLock(&tls_lock);\n        if (!tls_errbuf) {\n            SDL_TLSID slot;\n            tls_being_created = SDL_TRUE;\n            slot = SDL_TLSCreate();\n            tls_being_created = SDL_FALSE;\n            SDL_MemoryBarrierRelease();\n            tls_errbuf = slot;\n        }\n        SDL_AtomicUnlock(&tls_lock);\n    }\n    if (!tls_errbuf) {\n        return &SDL_global_errbuf;\n    }\n\n    SDL_MemoryBarrierAcquire();\n    errbuf = (SDL_error *)SDL_TLSGet(tls_errbuf);\n    if (errbuf == ALLOCATION_IN_PROGRESS) {\n        return &SDL_global_errbuf;\n    }\n    if (!errbuf) {\n        /* Mark that we're in the middle of allocating our buffer */\n        SDL_TLSSet(tls_errbuf, ALLOCATION_IN_PROGRESS, NULL);\n        errbuf = (SDL_error *)SDL_malloc(sizeof(*errbuf));\n        if (!errbuf) {\n            SDL_TLSSet(tls_errbuf, NULL, NULL);\n            return &SDL_global_errbuf;\n        }\n        SDL_zerop(errbuf);\n        SDL_TLSSet(tls_errbuf, errbuf, SDL_free);\n    }\n    return errbuf;\n}\n\n\n/* Arguments and callback to setup and run the user thread function */\ntypedef struct\n{\n    int (SDLCALL * func) (void *);\n    void *data;\n    SDL_Thread *info;\n    SDL_sem *wait;\n} thread_args;\n\nvoid\nSDL_RunThread(void *data)\n{\n    thread_args *args = (thread_args *) data;\n    int (SDLCALL * userfunc) (void *) = args->func;\n    void *userdata = args->data;\n    SDL_Thread *thread = args->info;\n    int *statusloc = &thread->status;\n\n    /* Perform any system-dependent setup - this function may not fail */\n    SDL_SYS_SetupThread(thread->name);\n\n    /* Get the thread id */\n    thread->threadid = SDL_ThreadID();\n\n    /* Wake up the parent thread */\n    SDL_SemPost(args->wait);\n\n    /* Run the function */\n    *statusloc = userfunc(userdata);\n\n    /* Clean up thread-local storage */\n    SDL_TLSCleanup();\n\n    /* Mark us as ready to be joined (or detached) */\n    if (!SDL_AtomicCAS(&thread->state, SDL_THREAD_STATE_ALIVE, SDL_THREAD_STATE_ZOMBIE)) {\n        /* Clean up if something already detached us. */\n        if (SDL_AtomicCAS(&thread->state, SDL_THREAD_STATE_DETACHED, SDL_THREAD_STATE_CLEANED)) {\n            if (thread->name) {\n                SDL_free(thread->name);\n            }\n            SDL_free(thread);\n        }\n    }\n}\n\n#ifdef SDL_CreateThread\n#undef SDL_CreateThread\n#endif\n#if SDL_DYNAMIC_API\n#define SDL_CreateThread SDL_CreateThread_REAL\n#endif\n\n#ifdef SDL_PASSED_BEGINTHREAD_ENDTHREAD\nDECLSPEC SDL_Thread *SDLCALL\nSDL_CreateThread(int (SDLCALL * fn) (void *),\n                 const char *name, void *data,\n                 pfnSDL_CurrentBeginThread pfnBeginThread,\n                 pfnSDL_CurrentEndThread pfnEndThread)\n#else\nDECLSPEC SDL_Thread *SDLCALL\nSDL_CreateThread(int (SDLCALL * fn) (void *),\n                 const char *name, void *data)\n#endif\n{\n    SDL_Thread *thread;\n    thread_args *args;\n    int ret;\n\n    /* Allocate memory for the thread info structure */\n    thread = (SDL_Thread *) SDL_malloc(sizeof(*thread));\n    if (thread == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n    SDL_zerop(thread);\n    thread->status = -1;\n    SDL_AtomicSet(&thread->state, SDL_THREAD_STATE_ALIVE);\n\n    /* Set up the arguments for the thread */\n    if (name != NULL) {\n        thread->name = SDL_strdup(name);\n        if (thread->name == NULL) {\n            SDL_OutOfMemory();\n            SDL_free(thread);\n            return (NULL);\n        }\n    }\n\n    /* Set up the arguments for the thread */\n    args = (thread_args *) SDL_malloc(sizeof(*args));\n    if (args == NULL) {\n        SDL_OutOfMemory();\n        if (thread->name) {\n            SDL_free(thread->name);\n        }\n        SDL_free(thread);\n        return (NULL);\n    }\n    args->func = fn;\n    args->data = data;\n    args->info = thread;\n    args->wait = SDL_CreateSemaphore(0);\n    if (args->wait == NULL) {\n        if (thread->name) {\n            SDL_free(thread->name);\n        }\n        SDL_free(thread);\n        SDL_free(args);\n        return (NULL);\n    }\n\n    /* Create the thread and go! */\n#ifdef SDL_PASSED_BEGINTHREAD_ENDTHREAD\n    ret = SDL_SYS_CreateThread(thread, args, pfnBeginThread, pfnEndThread);\n#else\n    ret = SDL_SYS_CreateThread(thread, args);\n#endif\n    if (ret >= 0) {\n        /* Wait for the thread function to use arguments */\n        SDL_SemWait(args->wait);\n    } else {\n        /* Oops, failed.  Gotta free everything */\n        if (thread->name) {\n            SDL_free(thread->name);\n        }\n        SDL_free(thread);\n        thread = NULL;\n    }\n    SDL_DestroySemaphore(args->wait);\n    SDL_free(args);\n\n    /* Everything is running now */\n    return (thread);\n}\n\nSDL_threadID\nSDL_GetThreadID(SDL_Thread * thread)\n{\n    SDL_threadID id;\n\n    if (thread) {\n        id = thread->threadid;\n    } else {\n        id = SDL_ThreadID();\n    }\n    return id;\n}\n\nconst char *\nSDL_GetThreadName(SDL_Thread * thread)\n{\n    if (thread) {\n        return thread->name;\n    } else {\n        return NULL;\n    }\n}\n\nint\nSDL_SetThreadPriority(SDL_ThreadPriority priority)\n{\n    return SDL_SYS_SetThreadPriority(priority);\n}\n\nvoid\nSDL_WaitThread(SDL_Thread * thread, int *status)\n{\n    if (thread) {\n        SDL_SYS_WaitThread(thread);\n        if (status) {\n            *status = thread->status;\n        }\n        if (thread->name) {\n            SDL_free(thread->name);\n        }\n        SDL_free(thread);\n    }\n}\n\nvoid\nSDL_DetachThread(SDL_Thread * thread)\n{\n    if (!thread) {\n        return;\n    }\n\n    /* Grab dibs if the state is alive+joinable. */\n    if (SDL_AtomicCAS(&thread->state, SDL_THREAD_STATE_ALIVE, SDL_THREAD_STATE_DETACHED)) {\n        SDL_SYS_DetachThread(thread);\n    } else {\n        /* all other states are pretty final, see where we landed. */\n        const int thread_state = SDL_AtomicGet(&thread->state);\n        if ((thread_state == SDL_THREAD_STATE_DETACHED) || (thread_state == SDL_THREAD_STATE_CLEANED)) {\n            return;  /* already detached (you shouldn't call this twice!) */\n        } else if (thread_state == SDL_THREAD_STATE_ZOMBIE) {\n            SDL_WaitThread(thread, NULL);  /* already done, clean it up. */\n        } else {\n            SDL_assert(0 && \"Unexpected thread state\");\n        }\n    }\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../SDL_internal.h\"\n\n#include \"SDL_timer.h\"\n#include \"SDL_timer_c.h\"\n#include \"SDL_atomic.h\"\n#include \"SDL_cpuinfo.h\"\n#include \"SDL_thread.h\"\n\n/* #define DEBUG_TIMERS */\n\ntypedef struct _SDL_Timer\n{\n    int timerID;\n    SDL_TimerCallback callback;\n    void *param;\n    Uint32 interval;\n    Uint32 scheduled;\n    volatile SDL_bool canceled;\n    struct _SDL_Timer *next;\n} SDL_Timer;\n\ntypedef struct _SDL_TimerMap\n{\n    int timerID;\n    SDL_Timer *timer;\n    struct _SDL_TimerMap *next;\n} SDL_TimerMap;\n\n/* The timers are kept in a sorted list */\ntypedef struct {\n    /* Data used by the main thread */\n    SDL_Thread *thread;\n    SDL_atomic_t nextID;\n    SDL_TimerMap *timermap;\n    SDL_mutex *timermap_lock;\n\n    /* Padding to separate cache lines between threads */\n    char cache_pad[SDL_CACHELINE_SIZE];\n\n    /* Data used to communicate with the timer thread */\n    SDL_SpinLock lock;\n    SDL_sem *sem;\n    SDL_Timer * volatile pending;\n    SDL_Timer * volatile freelist;\n    volatile SDL_bool active;\n\n    /* List of timers - this is only touched by the timer thread */\n    SDL_Timer *timers;\n} SDL_TimerData;\n\nstatic SDL_TimerData SDL_timer_data;\n\n/* The idea here is that any thread might add a timer, but a single\n * thread manages the active timer queue, sorted by scheduling time.\n *\n * Timers are removed by simply setting a canceled flag\n */\n\nstatic void\nSDL_AddTimerInternal(SDL_TimerData *data, SDL_Timer *timer)\n{\n    SDL_Timer *prev, *curr;\n\n    prev = NULL;\n    for (curr = data->timers; curr; prev = curr, curr = curr->next) {\n        if ((Sint32)(timer->scheduled-curr->scheduled) < 0) {\n            break;\n        }\n    }\n\n    /* Insert the timer here! */\n    if (prev) {\n        prev->next = timer;\n    } else {\n        data->timers = timer;\n    }\n    timer->next = curr;\n}\n\nstatic int\nSDL_TimerThread(void *_data)\n{\n    SDL_TimerData *data = (SDL_TimerData *)_data;\n    SDL_Timer *pending;\n    SDL_Timer *current;\n    SDL_Timer *freelist_head = NULL;\n    SDL_Timer *freelist_tail = NULL;\n    Uint32 tick, now, interval, delay;\n\n    /* Threaded timer loop:\n     *  1. Queue timers added by other threads\n     *  2. Handle any timers that should dispatch this cycle\n     *  3. Wait until next dispatch time or new timer arrives\n     */\n    for ( ; ; ) {\n        /* Pending and freelist maintenance */\n        SDL_AtomicLock(&data->lock);\n        {\n            /* Get any timers ready to be queued */\n            pending = data->pending;\n            data->pending = NULL;\n\n            /* Make any unused timer structures available */\n            if (freelist_head) {\n                freelist_tail->next = data->freelist;\n                data->freelist = freelist_head;\n            }\n        }\n        SDL_AtomicUnlock(&data->lock);\n\n        /* Sort the pending timers into our list */\n        while (pending) {\n            current = pending;\n            pending = pending->next;\n            SDL_AddTimerInternal(data, current);\n        }\n        freelist_head = NULL;\n        freelist_tail = NULL;\n\n        /* Check to see if we're still running, after maintenance */\n        if (!data->active) {\n            break;\n        }\n\n        /* Initial delay if there are no timers */\n        delay = SDL_MUTEX_MAXWAIT;\n\n        tick = SDL_GetTicks();\n\n        /* Process all the pending timers for this tick */\n        while (data->timers) {\n            current = data->timers;\n\n            if ((Sint32)(tick-current->scheduled) < 0) {\n                /* Scheduled for the future, wait a bit */\n                delay = (current->scheduled - tick);\n                break;\n            }\n\n            /* We're going to do something with this timer */\n            data->timers = current->next;\n\n            if (current->canceled) {\n                interval = 0;\n            } else {\n                interval = current->callback(current->interval, current->param);\n            }\n\n            if (interval > 0) {\n                /* Reschedule this timer */\n                current->scheduled = tick + interval;\n                SDL_AddTimerInternal(data, current);\n            } else {\n                if (!freelist_head) {\n                    freelist_head = current;\n                }\n                if (freelist_tail) {\n                    freelist_tail->next = current;\n                }\n                freelist_tail = current;\n\n                current->canceled = SDL_TRUE;\n            }\n        }\n\n        /* Adjust the delay based on processing time */\n        now = SDL_GetTicks();\n        interval = (now - tick);\n        if (interval > delay) {\n            delay = 0;\n        } else {\n            delay -= interval;\n        }\n\n        /* Note that each time a timer is added, this will return\n           immediately, but we process the timers added all at once.\n           That's okay, it just means we run through the loop a few\n           extra times.\n         */\n        SDL_SemWaitTimeout(data->sem, delay);\n    }\n    return 0;\n}\n\nint\nSDL_TimerInit(void)\n{\n    SDL_TimerData *data = &SDL_timer_data;\n\n    if (!data->active) {\n        const char *name = \"SDLTimer\";\n        data->timermap_lock = SDL_CreateMutex();\n        if (!data->timermap_lock) {\n            return -1;\n        }\n\n        data->sem = SDL_CreateSemaphore(0);\n        if (!data->sem) {\n            SDL_DestroyMutex(data->timermap_lock);\n            return -1;\n        }\n\n        data->active = SDL_TRUE;\n        /* !!! FIXME: this is nasty. */\n#if defined(__WIN32__) && !defined(HAVE_LIBC)\n#undef SDL_CreateThread\n#if SDL_DYNAMIC_API\n        data->thread = SDL_CreateThread_REAL(SDL_TimerThread, name, data, NULL, NULL);\n#else\n        data->thread = SDL_CreateThread(SDL_TimerThread, name, data, NULL, NULL);\n#endif\n#else\n        data->thread = SDL_CreateThread(SDL_TimerThread, name, data);\n#endif\n        if (!data->thread) {\n            SDL_TimerQuit();\n            return -1;\n        }\n\n        SDL_AtomicSet(&data->nextID, 1);\n    }\n    return 0;\n}\n\nvoid\nSDL_TimerQuit(void)\n{\n    SDL_TimerData *data = &SDL_timer_data;\n    SDL_Timer *timer;\n    SDL_TimerMap *entry;\n\n    if (data->active) {\n        data->active = SDL_FALSE;\n\n        /* Shutdown the timer thread */\n        if (data->thread) {\n            SDL_SemPost(data->sem);\n            SDL_WaitThread(data->thread, NULL);\n            data->thread = NULL;\n        }\n\n        SDL_DestroySemaphore(data->sem);\n        data->sem = NULL;\n\n        /* Clean up the timer entries */\n        while (data->timers) {\n            timer = data->timers;\n            data->timers = timer->next;\n            SDL_free(timer);\n        }\n        while (data->freelist) {\n            timer = data->freelist;\n            data->freelist = timer->next;\n            SDL_free(timer);\n        }\n        while (data->timermap) {\n            entry = data->timermap;\n            data->timermap = entry->next;\n            SDL_free(entry);\n        }\n\n        SDL_DestroyMutex(data->timermap_lock);\n        data->timermap_lock = NULL;\n    }\n}\n\nSDL_TimerID\nSDL_AddTimer(Uint32 interval, SDL_TimerCallback callback, void *param)\n{\n    SDL_TimerData *data = &SDL_timer_data;\n    SDL_Timer *timer;\n    SDL_TimerMap *entry;\n\n    if (!data->active) {\n        int status = 0;\n\n        SDL_AtomicLock(&data->lock);\n        if (!data->active) {\n            status = SDL_TimerInit();\n        }\n        SDL_AtomicUnlock(&data->lock);\n\n        if (status < 0) {\n            return 0;\n        }\n    }\n\n    SDL_AtomicLock(&data->lock);\n    timer = data->freelist;\n    if (timer) {\n        data->freelist = timer->next;\n    }\n    SDL_AtomicUnlock(&data->lock);\n\n    if (timer) {\n        SDL_RemoveTimer(timer->timerID);\n    } else {\n        timer = (SDL_Timer *)SDL_malloc(sizeof(*timer));\n        if (!timer) {\n            SDL_OutOfMemory();\n            return 0;\n        }\n    }\n    timer->timerID = SDL_AtomicIncRef(&data->nextID);\n    timer->callback = callback;\n    timer->param = param;\n    timer->interval = interval;\n    timer->scheduled = SDL_GetTicks() + interval;\n    timer->canceled = SDL_FALSE;\n\n    entry = (SDL_TimerMap *)SDL_malloc(sizeof(*entry));\n    if (!entry) {\n        SDL_free(timer);\n        SDL_OutOfMemory();\n        return 0;\n    }\n    entry->timer = timer;\n    entry->timerID = timer->timerID;\n\n    SDL_LockMutex(data->timermap_lock);\n    entry->next = data->timermap;\n    data->timermap = entry;\n    SDL_UnlockMutex(data->timermap_lock);\n\n    /* Add the timer to the pending list for the timer thread */\n    SDL_AtomicLock(&data->lock);\n    timer->next = data->pending;\n    data->pending = timer;\n    SDL_AtomicUnlock(&data->lock);\n\n    /* Wake up the timer thread if necessary */\n    SDL_SemPost(data->sem);\n\n    return entry->timerID;\n}\n\nSDL_bool\nSDL_RemoveTimer(SDL_TimerID id)\n{\n    SDL_TimerData *data = &SDL_timer_data;\n    SDL_TimerMap *prev, *entry;\n    SDL_bool canceled = SDL_FALSE;\n\n    /* Find the timer */\n    SDL_LockMutex(data->timermap_lock);\n    prev = NULL;\n    for (entry = data->timermap; entry; prev = entry, entry = entry->next) {\n        if (entry->timerID == id) {\n            if (prev) {\n                prev->next = entry->next;\n            } else {\n                data->timermap = entry->next;\n            }\n            break;\n        }\n    }\n    SDL_UnlockMutex(data->timermap_lock);\n\n    if (entry) {\n        if (!entry->timer->canceled) {\n            entry->timer->canceled = SDL_TRUE;\n            canceled = SDL_TRUE;\n        }\n        SDL_free(entry);\n    }\n    return canceled;\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../SDL_internal.h\"\n\n#include \"SDL_video.h\"\n#include \"SDL_sysvideo.h\"\n#include \"SDL_blit.h\"\n#include \"SDL_blit_auto.h\"\n#include \"SDL_blit_copy.h\"\n#include \"SDL_blit_slow.h\"\n#include \"SDL_RLEaccel_c.h\"\n#include \"SDL_pixels_c.h\"\n\n/* The general purpose software blit routine */\nstatic int\nSDL_SoftBlit(SDL_Surface * src, SDL_Rect * srcrect,\n             SDL_Surface * dst, SDL_Rect * dstrect)\n{\n    int okay;\n    int src_locked;\n    int dst_locked;\n\n    /* Everything is okay at the beginning...  */\n    okay = 1;\n\n    /* Lock the destination if it's in hardware */\n    dst_locked = 0;\n    if (SDL_MUSTLOCK(dst)) {\n        if (SDL_LockSurface(dst) < 0) {\n            okay = 0;\n        } else {\n            dst_locked = 1;\n        }\n    }\n    /* Lock the source if it's in hardware */\n    src_locked = 0;\n    if (SDL_MUSTLOCK(src)) {\n        if (SDL_LockSurface(src) < 0) {\n            okay = 0;\n        } else {\n            src_locked = 1;\n        }\n    }\n\n    /* Set up source and destination buffer pointers, and BLIT! */\n    if (okay && !SDL_RectEmpty(srcrect)) {\n        SDL_BlitFunc RunBlit;\n        SDL_BlitInfo *info = &src->map->info;\n\n        /* Set up the blit information */\n        info->src = (Uint8 *) src->pixels +\n            (Uint16) srcrect->y * src->pitch +\n            (Uint16) srcrect->x * info->src_fmt->BytesPerPixel;\n        info->src_w = srcrect->w;\n        info->src_h = srcrect->h;\n        info->src_pitch = src->pitch;\n        info->src_skip =\n            info->src_pitch - info->src_w * info->src_fmt->BytesPerPixel;\n        info->dst =\n            (Uint8 *) dst->pixels + (Uint16) dstrect->y * dst->pitch +\n            (Uint16) dstrect->x * info->dst_fmt->BytesPerPixel;\n        info->dst_w = dstrect->w;\n        info->dst_h = dstrect->h;\n        info->dst_pitch = dst->pitch;\n        info->dst_skip =\n            info->dst_pitch - info->dst_w * info->dst_fmt->BytesPerPixel;\n        RunBlit = (SDL_BlitFunc) src->map->data;\n\n        /* Run the actual software blit */\n        RunBlit(info);\n    }\n\n    /* We need to unlock the surfaces if they're locked */\n    if (dst_locked) {\n        SDL_UnlockSurface(dst);\n    }\n    if (src_locked) {\n        SDL_UnlockSurface(src);\n    }\n    /* Blit is done! */\n    return (okay ? 0 : -1);\n}\n\n#ifdef __MACOSX__\n#include <sys/sysctl.h>\n\nstatic SDL_bool\nSDL_UseAltivecPrefetch()\n{\n    const char key[] = \"hw.l3cachesize\";\n    u_int64_t result = 0;\n    size_t typeSize = sizeof(result);\n\n    if (sysctlbyname(key, &result, &typeSize, NULL, 0) == 0 && result > 0) {\n        return SDL_TRUE;\n    } else {\n        return SDL_FALSE;\n    }\n}\n#else\nstatic SDL_bool\nSDL_UseAltivecPrefetch()\n{\n    /* Just guess G4 */\n    return SDL_TRUE;\n}\n#endif /* __MACOSX__ */\n\nstatic SDL_BlitFunc\nSDL_ChooseBlitFunc(Uint32 src_format, Uint32 dst_format, int flags,\n                   SDL_BlitFuncEntry * entries)\n{\n    int i, flagcheck;\n    static Uint32 features = 0xffffffff;\n\n    /* Get the available CPU features */\n    if (features == 0xffffffff) {\n        const char *override = SDL_getenv(\"SDL_BLIT_CPU_FEATURES\");\n\n        features = SDL_CPU_ANY;\n\n        /* Allow an override for testing .. */\n        if (override) {\n            SDL_sscanf(override, \"%u\", &features);\n        } else {\n            if (SDL_HasMMX()) {\n                features |= SDL_CPU_MMX;\n            }\n            if (SDL_Has3DNow()) {\n                features |= SDL_CPU_3DNOW;\n            }\n            if (SDL_HasSSE()) {\n                features |= SDL_CPU_SSE;\n            }\n            if (SDL_HasSSE2()) {\n                features |= SDL_CPU_SSE2;\n            }\n            if (SDL_HasAltiVec()) {\n                if (SDL_UseAltivecPrefetch()) {\n                    features |= SDL_CPU_ALTIVEC_PREFETCH;\n                } else {\n                    features |= SDL_CPU_ALTIVEC_NOPREFETCH;\n                }\n            }\n        }\n    }\n\n    for (i = 0; entries[i].func; ++i) {\n        /* Check for matching pixel formats */\n        if (src_format != entries[i].src_format) {\n            continue;\n        }\n        if (dst_format != entries[i].dst_format) {\n            continue;\n        }\n\n        /* Check modulation flags */\n        flagcheck =\n            (flags & (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA));\n        if ((flagcheck & entries[i].flags) != flagcheck) {\n            continue;\n        }\n\n        /* Check blend flags */\n        flagcheck =\n            (flags &\n             (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD));\n        if ((flagcheck & entries[i].flags) != flagcheck) {\n            continue;\n        }\n\n        /* Check colorkey flag */\n        flagcheck = (flags & SDL_COPY_COLORKEY);\n        if ((flagcheck & entries[i].flags) != flagcheck) {\n            continue;\n        }\n\n        /* Check scaling flags */\n        flagcheck = (flags & SDL_COPY_NEAREST);\n        if ((flagcheck & entries[i].flags) != flagcheck) {\n            continue;\n        }\n\n        /* Check CPU features */\n        flagcheck = entries[i].cpu;\n        if ((flagcheck & features) != flagcheck) {\n            continue;\n        }\n\n        /* We found the best one! */\n        return entries[i].func;\n    }\n    return NULL;\n}\n\n/* Figure out which of many blit routines to set up on a surface */\nint\nSDL_CalculateBlit(SDL_Surface * surface)\n{\n    SDL_BlitFunc blit = NULL;\n    SDL_BlitMap *map = surface->map;\n    SDL_Surface *dst = map->dst;\n\n    /* Clean everything out to start */\n    if ((surface->flags & SDL_RLEACCEL) == SDL_RLEACCEL) {\n        SDL_UnRLESurface(surface, 1);\n    }\n    map->blit = SDL_SoftBlit;\n    map->info.src_fmt = surface->format;\n    map->info.src_pitch = surface->pitch;\n    map->info.dst_fmt = dst->format;\n    map->info.dst_pitch = dst->pitch;\n\n    /* See if we can do RLE acceleration */\n    if (map->info.flags & SDL_COPY_RLE_DESIRED) {\n        if (SDL_RLESurface(surface) == 0) {\n            return 0;\n        }\n    }\n\n    /* Choose a standard blit function */\n    if (map->identity && !(map->info.flags & ~SDL_COPY_RLE_DESIRED)) {\n        blit = SDL_BlitCopy;\n    } else if (surface->format->BitsPerPixel < 8 &&\n               SDL_ISPIXELFORMAT_INDEXED(surface->format->format)) {\n        blit = SDL_CalculateBlit0(surface);\n    } else if (surface->format->BytesPerPixel == 1 &&\n               SDL_ISPIXELFORMAT_INDEXED(surface->format->format)) {\n        blit = SDL_CalculateBlit1(surface);\n    } else if (map->info.flags & SDL_COPY_BLEND) {\n        blit = SDL_CalculateBlitA(surface);\n    } else {\n        blit = SDL_CalculateBlitN(surface);\n    }\n    if (blit == NULL) {\n        Uint32 src_format = surface->format->format;\n        Uint32 dst_format = dst->format->format;\n\n        blit =\n            SDL_ChooseBlitFunc(src_format, dst_format, map->info.flags,\n                               SDL_GeneratedBlitFuncTable);\n    }\n#ifndef TEST_SLOW_BLIT\n    if (blit == NULL)\n#endif\n    {\n        Uint32 src_format = surface->format->format;\n        Uint32 dst_format = dst->format->format;\n\n        if (!SDL_ISPIXELFORMAT_INDEXED(src_format) &&\n            !SDL_ISPIXELFORMAT_FOURCC(src_format) &&\n            !SDL_ISPIXELFORMAT_INDEXED(dst_format) &&\n            !SDL_ISPIXELFORMAT_FOURCC(dst_format)) {\n            blit = SDL_Blit_Slow;\n        }\n    }\n    map->data = blit;\n\n    /* Make sure we have a blit function */\n    if (blit == NULL) {\n        SDL_InvalidateMap(map);\n        return SDL_SetError(\"Blit combination not supported\");\n    }\n\n    return 0;\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../SDL_internal.h\"\n\n#include \"SDL_video.h\"\n#include \"SDL_blit.h\"\n\n/* Functions to blit from bitmaps to other surfaces */\n\nstatic void\nBlitBto1(SDL_BlitInfo * info)\n{\n    int c;\n    int width, height;\n    Uint8 *src, *map, *dst;\n    int srcskip, dstskip;\n\n    /* Set up some basic variables */\n    width = info->dst_w;\n    height = info->dst_h;\n    src = info->src;\n    srcskip = info->src_skip;\n    dst = info->dst;\n    dstskip = info->dst_skip;\n    map = info->table;\n    srcskip += width - (width + 7) / 8;\n\n    if (map) {\n        while (height--) {\n            Uint8 byte = 0, bit;\n            for (c = 0; c < width; ++c) {\n                if ((c & 7) == 0) {\n                    byte = *src++;\n                }\n                bit = (byte & 0x80) >> 7;\n                if (1) {\n                    *dst = map[bit];\n                }\n                dst++;\n                byte <<= 1;\n            }\n            src += srcskip;\n            dst += dstskip;\n        }\n    } else {\n        while (height--) {\n            Uint8 byte = 0, bit;\n            for (c = 0; c < width; ++c) {\n                if ((c & 7) == 0) {\n                    byte = *src++;\n                }\n                bit = (byte & 0x80) >> 7;\n                if (1) {\n                    *dst = bit;\n                }\n                dst++;\n                byte <<= 1;\n            }\n            src += srcskip;\n            dst += dstskip;\n        }\n    }\n}\n\nstatic void\nBlitBto2(SDL_BlitInfo * info)\n{\n    int c;\n    int width, height;\n    Uint8 *src;\n    Uint16 *map, *dst;\n    int srcskip, dstskip;\n\n    /* Set up some basic variables */\n    width = info->dst_w;\n    height = info->dst_h;\n    src = info->src;\n    srcskip = info->src_skip;\n    dst = (Uint16 *) info->dst;\n    dstskip = info->dst_skip / 2;\n    map = (Uint16 *) info->table;\n    srcskip += width - (width + 7) / 8;\n\n    while (height--) {\n        Uint8 byte = 0, bit;\n        for (c = 0; c < width; ++c) {\n            if ((c & 7) == 0) {\n                byte = *src++;\n            }\n            bit = (byte & 0x80) >> 7;\n            if (1) {\n                *dst = map[bit];\n            }\n            byte <<= 1;\n            dst++;\n        }\n        src += srcskip;\n        dst += dstskip;\n    }\n}\n\nstatic void\nBlitBto3(SDL_BlitInfo * info)\n{\n    int c, o;\n    int width, height;\n    Uint8 *src, *map, *dst;\n    int srcskip, dstskip;\n\n    /* Set up some basic variables */\n    width = info->dst_w;\n    height = info->dst_h;\n    src = info->src;\n    srcskip = info->src_skip;\n    dst = info->dst;\n    dstskip = info->dst_skip;\n    map = info->table;\n    srcskip += width - (width + 7) / 8;\n\n    while (height--) {\n        Uint8 byte = 0, bit;\n        for (c = 0; c < width; ++c) {\n            if ((c & 7) == 0) {\n                byte = *src++;\n            }\n            bit = (byte & 0x80) >> 7;\n            if (1) {\n                o = bit * 4;\n                dst[0] = map[o++];\n                dst[1] = map[o++];\n                dst[2] = map[o++];\n            }\n            byte <<= 1;\n            dst += 3;\n        }\n        src += srcskip;\n        dst += dstskip;\n    }\n}\n\nstatic void\nBlitBto4(SDL_BlitInfo * info)\n{\n    int width, height;\n    Uint8 *src;\n    Uint32 *map, *dst;\n    int srcskip, dstskip;\n    int c;\n\n    /* Set up some basic variables */\n    width = info->dst_w;\n    height = info->dst_h;\n    src = info->src;\n    srcskip = info->src_skip;\n    dst = (Uint32 *) info->dst;\n    dstskip = info->dst_skip / 4;\n    map = (Uint32 *) info->table;\n    srcskip += width - (width + 7) / 8;\n\n    while (height--) {\n        Uint8 byte = 0, bit;\n        for (c = 0; c < width; ++c) {\n            if ((c & 7) == 0) {\n                byte = *src++;\n            }\n            bit = (byte & 0x80) >> 7;\n            if (1) {\n                *dst = map[bit];\n            }\n            byte <<= 1;\n            dst++;\n        }\n        src += srcskip;\n        dst += dstskip;\n    }\n}\n\nstatic void\nBlitBto1Key(SDL_BlitInfo * info)\n{\n    int width = info->dst_w;\n    int height = info->dst_h;\n    Uint8 *src = info->src;\n    Uint8 *dst = info->dst;\n    int srcskip = info->src_skip;\n    int dstskip = info->dst_skip;\n    Uint32 ckey = info->colorkey;\n    Uint8 *palmap = info->table;\n    int c;\n\n    /* Set up some basic variables */\n    srcskip += width - (width + 7) / 8;\n\n    if (palmap) {\n        while (height--) {\n            Uint8 byte = 0, bit;\n            for (c = 0; c < width; ++c) {\n                if ((c & 7) == 0) {\n                    byte = *src++;\n                }\n                bit = (byte & 0x80) >> 7;\n                if (bit != ckey) {\n                    *dst = palmap[bit];\n                }\n                dst++;\n                byte <<= 1;\n            }\n            src += srcskip;\n            dst += dstskip;\n        }\n    } else {\n        while (height--) {\n            Uint8 byte = 0, bit;\n            for (c = 0; c < width; ++c) {\n                if ((c & 7) == 0) {\n                    byte = *src++;\n                }\n                bit = (byte & 0x80) >> 7;\n                if (bit != ckey) {\n                    *dst = bit;\n                }\n                dst++;\n                byte <<= 1;\n            }\n            src += srcskip;\n            dst += dstskip;\n        }\n    }\n}\n\nstatic void\nBlitBto2Key(SDL_BlitInfo * info)\n{\n    int width = info->dst_w;\n    int height = info->dst_h;\n    Uint8 *src = info->src;\n    Uint16 *dstp = (Uint16 *) info->dst;\n    int srcskip = info->src_skip;\n    int dstskip = info->dst_skip;\n    Uint32 ckey = info->colorkey;\n    Uint8 *palmap = info->table;\n    int c;\n\n    /* Set up some basic variables */\n    srcskip += width - (width + 7) / 8;\n    dstskip /= 2;\n\n    while (height--) {\n        Uint8 byte = 0, bit;\n        for (c = 0; c < width; ++c) {\n            if ((c & 7) == 0) {\n                byte = *src++;\n            }\n            bit = (byte & 0x80) >> 7;\n            if (bit != ckey) {\n                *dstp = ((Uint16 *) palmap)[bit];\n            }\n            byte <<= 1;\n            dstp++;\n        }\n        src += srcskip;\n        dstp += dstskip;\n    }\n}\n\nstatic void\nBlitBto3Key(SDL_BlitInfo * info)\n{\n    int width = info->dst_w;\n    int height = info->dst_h;\n    Uint8 *src = info->src;\n    Uint8 *dst = info->dst;\n    int srcskip = info->src_skip;\n    int dstskip = info->dst_skip;\n    Uint32 ckey = info->colorkey;\n    Uint8 *palmap = info->table;\n    int c;\n\n    /* Set up some basic variables */\n    srcskip += width - (width + 7) / 8;\n\n    while (height--) {\n        Uint8 byte = 0, bit;\n        for (c = 0; c < width; ++c) {\n            if ((c & 7) == 0) {\n                byte = *src++;\n            }\n            bit = (byte & 0x80) >> 7;\n            if (bit != ckey) {\n                SDL_memcpy(dst, &palmap[bit * 4], 3);\n            }\n            byte <<= 1;\n            dst += 3;\n        }\n        src += srcskip;\n        dst += dstskip;\n    }\n}\n\nstatic void\nBlitBto4Key(SDL_BlitInfo * info)\n{\n    int width = info->dst_w;\n    int height = info->dst_h;\n    Uint8 *src = info->src;\n    Uint32 *dstp = (Uint32 *) info->dst;\n    int srcskip = info->src_skip;\n    int dstskip = info->dst_skip;\n    Uint32 ckey = info->colorkey;\n    Uint8 *palmap = info->table;\n    int c;\n\n    /* Set up some basic variables */\n    srcskip += width - (width + 7) / 8;\n    dstskip /= 4;\n\n    while (height--) {\n        Uint8 byte = 0, bit;\n        for (c = 0; c < width; ++c) {\n            if ((c & 7) == 0) {\n                byte = *src++;\n            }\n            bit = (byte & 0x80) >> 7;\n            if (bit != ckey) {\n                *dstp = ((Uint32 *) palmap)[bit];\n            }\n            byte <<= 1;\n            dstp++;\n        }\n        src += srcskip;\n        dstp += dstskip;\n    }\n}\n\nstatic void\nBlitBtoNAlpha(SDL_BlitInfo * info)\n{\n    int width = info->dst_w;\n    int height = info->dst_h;\n    Uint8 *src = info->src;\n    Uint8 *dst = info->dst;\n    int srcskip = info->src_skip;\n    int dstskip = info->dst_skip;\n    const SDL_Color *srcpal = info->src_fmt->palette->colors;\n    SDL_PixelFormat *dstfmt = info->dst_fmt;\n    int dstbpp;\n    int c;\n    Uint32 pixel;\n    unsigned sR, sG, sB;\n    unsigned dR, dG, dB, dA;\n    const unsigned A = info->a;\n\n    /* Set up some basic variables */\n    dstbpp = dstfmt->BytesPerPixel;\n    srcskip += width - (width + 7) / 8;\n\n    while (height--) {\n        Uint8 byte = 0, bit;\n        for (c = 0; c < width; ++c) {\n            if ((c & 7) == 0) {\n                byte = *src++;\n            }\n            bit = (byte & 0x80) >> 7;\n            if (1) {\n                sR = srcpal[bit].r;\n                sG = srcpal[bit].g;\n                sB = srcpal[bit].b;\n                DISEMBLE_RGBA(dst, dstbpp, dstfmt, pixel, dR, dG, dB, dA);\n                ALPHA_BLEND_RGBA(sR, sG, sB, A, dR, dG, dB, dA);\n                ASSEMBLE_RGBA(dst, dstbpp, dstfmt, dR, dG, dB, dA);\n            }\n            byte <<= 1;\n            dst += dstbpp;\n        }\n        src += srcskip;\n        dst += dstskip;\n    }\n}\n\nstatic void\nBlitBtoNAlphaKey(SDL_BlitInfo * info)\n{\n    int width = info->dst_w;\n    int height = info->dst_h;\n    Uint8 *src = info->src;\n    Uint8 *dst = info->dst;\n    int srcskip = info->src_skip;\n    int dstskip = info->dst_skip;\n    SDL_PixelFormat *srcfmt = info->src_fmt;\n    SDL_PixelFormat *dstfmt = info->dst_fmt;\n    const SDL_Color *srcpal = srcfmt->palette->colors;\n    int dstbpp;\n    int c;\n    Uint32 pixel;\n    unsigned sR, sG, sB;\n    unsigned dR, dG, dB, dA;\n    const unsigned A = info->a;\n    Uint32 ckey = info->colorkey;\n\n    /* Set up some basic variables */\n    dstbpp = dstfmt->BytesPerPixel;\n    srcskip += width - (width + 7) / 8;\n\n    while (height--) {\n        Uint8 byte = 0, bit;\n        for (c = 0; c < width; ++c) {\n            if ((c & 7) == 0) {\n                byte = *src++;\n            }\n            bit = (byte & 0x80) >> 7;\n            if (bit != ckey) {\n                sR = srcpal[bit].r;\n                sG = srcpal[bit].g;\n                sB = srcpal[bit].b;\n                DISEMBLE_RGBA(dst, dstbpp, dstfmt, pixel, dR, dG, dB, dA);\n                ALPHA_BLEND_RGBA(sR, sG, sB, A, dR, dG, dB, dA);\n                ASSEMBLE_RGBA(dst, dstbpp, dstfmt, dR, dG, dB, dA);\n            }\n            byte <<= 1;\n            dst += dstbpp;\n        }\n        src += srcskip;\n        dst += dstskip;\n    }\n}\n\nstatic const SDL_BlitFunc bitmap_blit[] = {\n    (SDL_BlitFunc) NULL, BlitBto1, BlitBto2, BlitBto3, BlitBto4\n};\n\nstatic const SDL_BlitFunc colorkey_blit[] = {\n    (SDL_BlitFunc) NULL, BlitBto1Key, BlitBto2Key, BlitBto3Key, BlitBto4Key\n};\n\nSDL_BlitFunc\nSDL_CalculateBlit0(SDL_Surface * surface)\n{\n    int which;\n\n    if (surface->format->BitsPerPixel != 1) {\n        /* We don't support sub 8-bit packed pixel modes */\n        return (SDL_BlitFunc) NULL;\n    }\n    if (surface->map->dst->format->BitsPerPixel < 8) {\n        which = 0;\n    } else {\n        which = surface->map->dst->format->BytesPerPixel;\n    }\n    switch (surface->map->info.flags & ~SDL_COPY_RLE_MASK) {\n    case 0:\n        return bitmap_blit[which];\n\n    case SDL_COPY_COLORKEY:\n        return colorkey_blit[which];\n\n    case SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND:\n        return which >= 2 ? BlitBtoNAlpha : (SDL_BlitFunc) NULL;\n\n    case SDL_COPY_COLORKEY | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND:\n        return which >= 2 ? BlitBtoNAlphaKey : (SDL_BlitFunc) NULL;\n    }\n    return (SDL_BlitFunc) NULL;\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../SDL_internal.h\"\n\n#include \"SDL_video.h\"\n#include \"SDL_blit.h\"\n#include \"SDL_sysvideo.h\"\n#include \"SDL_endian.h\"\n\n/* Functions to blit from 8-bit surfaces to other surfaces */\n\nstatic void\nBlit1to1(SDL_BlitInfo * info)\n{\n#ifndef USE_DUFFS_LOOP\n    int c;\n#endif\n    int width, height;\n    Uint8 *src, *map, *dst;\n    int srcskip, dstskip;\n\n    /* Set up some basic variables */\n    width = info->dst_w;\n    height = info->dst_h;\n    src = info->src;\n    srcskip = info->src_skip;\n    dst = info->dst;\n    dstskip = info->dst_skip;\n    map = info->table;\n\n    while (height--) {\n#ifdef USE_DUFFS_LOOP\n        /* *INDENT-OFF* */\n\t\tDUFFS_LOOP(\n\t\t\t{\n\t\t\t  *dst = map[*src];\n\t\t\t}\n\t\t\tdst++;\n\t\t\tsrc++;\n\t\t, width);\n        /* *INDENT-ON* */\n#else\n        for (c = width; c; --c) {\n            *dst = map[*src];\n            dst++;\n            src++;\n        }\n#endif\n        src += srcskip;\n        dst += dstskip;\n    }\n}\n\n/* This is now endian dependent */\n#if ( SDL_BYTEORDER == SDL_LIL_ENDIAN )\n#define HI\t1\n#define LO\t0\n#else /* ( SDL_BYTEORDER == SDL_BIG_ENDIAN ) */\n#define HI\t0\n#define LO\t1\n#endif\nstatic void\nBlit1to2(SDL_BlitInfo * info)\n{\n#ifndef USE_DUFFS_LOOP\n    int c;\n#endif\n    int width, height;\n    Uint8 *src, *dst;\n    Uint16 *map;\n    int srcskip, dstskip;\n\n    /* Set up some basic variables */\n    width = info->dst_w;\n    height = info->dst_h;\n    src = info->src;\n    srcskip = info->src_skip;\n    dst = info->dst;\n    dstskip = info->dst_skip;\n    map = (Uint16 *) info->table;\n\n#ifdef USE_DUFFS_LOOP\n    while (height--) {\n\t\t/* *INDENT-OFF* */\n\t\tDUFFS_LOOP(\n\t\t{\n\t\t\t*(Uint16 *)dst = map[*src++];\n\t\t\tdst += 2;\n\t\t},\n\t\twidth);\n\t\t/* *INDENT-ON* */\n        src += srcskip;\n        dst += dstskip;\n    }\n#else\n    /* Memory align at 4-byte boundary, if necessary */\n    if ((long) dst & 0x03) {\n        /* Don't do anything if width is 0 */\n        if (width == 0) {\n            return;\n        }\n        --width;\n\n        while (height--) {\n            /* Perform copy alignment */\n            *(Uint16 *) dst = map[*src++];\n            dst += 2;\n\n            /* Copy in 4 pixel chunks */\n            for (c = width / 4; c; --c) {\n                *(Uint32 *) dst = (map[src[HI]] << 16) | (map[src[LO]]);\n                src += 2;\n                dst += 4;\n                *(Uint32 *) dst = (map[src[HI]] << 16) | (map[src[LO]]);\n                src += 2;\n                dst += 4;\n            }\n            /* Get any leftovers */\n            switch (width & 3) {\n            case 3:\n                *(Uint16 *) dst = map[*src++];\n                dst += 2;\n            case 2:\n                *(Uint32 *) dst = (map[src[HI]] << 16) | (map[src[LO]]);\n                src += 2;\n                dst += 4;\n                break;\n            case 1:\n                *(Uint16 *) dst = map[*src++];\n                dst += 2;\n                break;\n            }\n            src += srcskip;\n            dst += dstskip;\n        }\n    } else {\n        while (height--) {\n            /* Copy in 4 pixel chunks */\n            for (c = width / 4; c; --c) {\n                *(Uint32 *) dst = (map[src[HI]] << 16) | (map[src[LO]]);\n                src += 2;\n                dst += 4;\n                *(Uint32 *) dst = (map[src[HI]] << 16) | (map[src[LO]]);\n                src += 2;\n                dst += 4;\n            }\n            /* Get any leftovers */\n            switch (width & 3) {\n            case 3:\n                *(Uint16 *) dst = map[*src++];\n                dst += 2;\n            case 2:\n                *(Uint32 *) dst = (map[src[HI]] << 16) | (map[src[LO]]);\n                src += 2;\n                dst += 4;\n                break;\n            case 1:\n                *(Uint16 *) dst = map[*src++];\n                dst += 2;\n                break;\n            }\n            src += srcskip;\n            dst += dstskip;\n        }\n    }\n#endif /* USE_DUFFS_LOOP */\n}\n\nstatic void\nBlit1to3(SDL_BlitInfo * info)\n{\n#ifndef USE_DUFFS_LOOP\n    int c;\n#endif\n    int o;\n    int width, height;\n    Uint8 *src, *map, *dst;\n    int srcskip, dstskip;\n\n    /* Set up some basic variables */\n    width = info->dst_w;\n    height = info->dst_h;\n    src = info->src;\n    srcskip = info->src_skip;\n    dst = info->dst;\n    dstskip = info->dst_skip;\n    map = info->table;\n\n    while (height--) {\n#ifdef USE_DUFFS_LOOP\n\t\t/* *INDENT-OFF* */\n\t\tDUFFS_LOOP(\n\t\t\t{\n\t\t\t\to = *src * 4;\n\t\t\t\tdst[0] = map[o++];\n\t\t\t\tdst[1] = map[o++];\n\t\t\t\tdst[2] = map[o++];\n\t\t\t}\n\t\t\tsrc++;\n\t\t\tdst += 3;\n\t\t, width);\n\t\t/* *INDENT-ON* */\n#else\n        for (c = width; c; --c) {\n            o = *src * 4;\n            dst[0] = map[o++];\n            dst[1] = map[o++];\n            dst[2] = map[o++];\n            src++;\n            dst += 3;\n        }\n#endif /* USE_DUFFS_LOOP */\n        src += srcskip;\n        dst += dstskip;\n    }\n}\n\nstatic void\nBlit1to4(SDL_BlitInfo * info)\n{\n#ifndef USE_DUFFS_LOOP\n    int c;\n#endif\n    int width, height;\n    Uint8 *src;\n    Uint32 *map, *dst;\n    int srcskip, dstskip;\n\n    /* Set up some basic variables */\n    width = info->dst_w;\n    height = info->dst_h;\n    src = info->src;\n    srcskip = info->src_skip;\n    dst = (Uint32 *) info->dst;\n    dstskip = info->dst_skip / 4;\n    map = (Uint32 *) info->table;\n\n    while (height--) {\n#ifdef USE_DUFFS_LOOP\n\t\t/* *INDENT-OFF* */\n\t\tDUFFS_LOOP(\n\t\t\t*dst++ = map[*src++];\n\t\t, width);\n\t\t/* *INDENT-ON* */\n#else\n        for (c = width / 4; c; --c) {\n            *dst++ = map[*src++];\n            *dst++ = map[*src++];\n            *dst++ = map[*src++];\n            *dst++ = map[*src++];\n        }\n        switch (width & 3) {\n        case 3:\n            *dst++ = map[*src++];\n        case 2:\n            *dst++ = map[*src++];\n        case 1:\n            *dst++ = map[*src++];\n        }\n#endif /* USE_DUFFS_LOOP */\n        src += srcskip;\n        dst += dstskip;\n    }\n}\n\nstatic void\nBlit1to1Key(SDL_BlitInfo * info)\n{\n    int width = info->dst_w;\n    int height = info->dst_h;\n    Uint8 *src = info->src;\n    int srcskip = info->src_skip;\n    Uint8 *dst = info->dst;\n    int dstskip = info->dst_skip;\n    Uint8 *palmap = info->table;\n    Uint32 ckey = info->colorkey;\n\n    if (palmap) {\n        while (height--) {\n\t\t\t/* *INDENT-OFF* */\n\t\t\tDUFFS_LOOP(\n\t\t\t{\n\t\t\t\tif ( *src != ckey ) {\n\t\t\t\t  *dst = palmap[*src];\n\t\t\t\t}\n\t\t\t\tdst++;\n\t\t\t\tsrc++;\n\t\t\t},\n\t\t\twidth);\n\t\t\t/* *INDENT-ON* */\n            src += srcskip;\n            dst += dstskip;\n        }\n    } else {\n        while (height--) {\n\t\t\t/* *INDENT-OFF* */\n\t\t\tDUFFS_LOOP(\n\t\t\t{\n\t\t\t\tif ( *src != ckey ) {\n\t\t\t\t  *dst = *src;\n\t\t\t\t}\n\t\t\t\tdst++;\n\t\t\t\tsrc++;\n\t\t\t},\n\t\t\twidth);\n\t\t\t/* *INDENT-ON* */\n            src += srcskip;\n            dst += dstskip;\n        }\n    }\n}\n\nstatic void\nBlit1to2Key(SDL_BlitInfo * info)\n{\n    int width = info->dst_w;\n    int height = info->dst_h;\n    Uint8 *src = info->src;\n    int srcskip = info->src_skip;\n    Uint16 *dstp = (Uint16 *) info->dst;\n    int dstskip = info->dst_skip;\n    Uint16 *palmap = (Uint16 *) info->table;\n    Uint32 ckey = info->colorkey;\n\n    /* Set up some basic variables */\n    dstskip /= 2;\n\n    while (height--) {\n\t\t/* *INDENT-OFF* */\n\t\tDUFFS_LOOP(\n\t\t{\n\t\t\tif ( *src != ckey ) {\n\t\t\t\t*dstp=palmap[*src];\n\t\t\t}\n\t\t\tsrc++;\n\t\t\tdstp++;\n\t\t},\n\t\twidth);\n\t\t/* *INDENT-ON* */\n        src += srcskip;\n        dstp += dstskip;\n    }\n}\n\nstatic void\nBlit1to3Key(SDL_BlitInfo * info)\n{\n    int width = info->dst_w;\n    int height = info->dst_h;\n    Uint8 *src = info->src;\n    int srcskip = info->src_skip;\n    Uint8 *dst = info->dst;\n    int dstskip = info->dst_skip;\n    Uint8 *palmap = info->table;\n    Uint32 ckey = info->colorkey;\n    int o;\n\n    while (height--) {\n\t\t/* *INDENT-OFF* */\n\t\tDUFFS_LOOP(\n\t\t{\n\t\t\tif ( *src != ckey ) {\n\t\t\t\to = *src * 4;\n\t\t\t\tdst[0] = palmap[o++];\n\t\t\t\tdst[1] = palmap[o++];\n\t\t\t\tdst[2] = palmap[o++];\n\t\t\t}\n\t\t\tsrc++;\n\t\t\tdst += 3;\n\t\t},\n\t\twidth);\n\t\t/* *INDENT-ON* */\n        src += srcskip;\n        dst += dstskip;\n    }\n}\n\nstatic void\nBlit1to4Key(SDL_BlitInfo * info)\n{\n    int width = info->dst_w;\n    int height = info->dst_h;\n    Uint8 *src = info->src;\n    int srcskip = info->src_skip;\n    Uint32 *dstp = (Uint32 *) info->dst;\n    int dstskip = info->dst_skip;\n    Uint32 *palmap = (Uint32 *) info->table;\n    Uint32 ckey = info->colorkey;\n\n    /* Set up some basic variables */\n    dstskip /= 4;\n\n    while (height--) {\n\t\t/* *INDENT-OFF* */\n\t\tDUFFS_LOOP(\n\t\t{\n\t\t\tif ( *src != ckey ) {\n\t\t\t\t*dstp = palmap[*src];\n\t\t\t}\n\t\t\tsrc++;\n\t\t\tdstp++;\n\t\t},\n\t\twidth);\n\t\t/* *INDENT-ON* */\n        src += srcskip;\n        dstp += dstskip;\n    }\n}\n\nstatic void\nBlit1toNAlpha(SDL_BlitInfo * info)\n{\n    int width = info->dst_w;\n    int height = info->dst_h;\n    Uint8 *src = info->src;\n    int srcskip = info->src_skip;\n    Uint8 *dst = info->dst;\n    int dstskip = info->dst_skip;\n    SDL_PixelFormat *dstfmt = info->dst_fmt;\n    const SDL_Color *srcpal = info->src_fmt->palette->colors;\n    int dstbpp;\n    Uint32 pixel;\n    unsigned sR, sG, sB;\n    unsigned dR, dG, dB, dA;\n    const unsigned A = info->a;\n\n    /* Set up some basic variables */\n    dstbpp = dstfmt->BytesPerPixel;\n\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP4(\n        {\n            sR = srcpal[*src].r;\n            sG = srcpal[*src].g;\n            sB = srcpal[*src].b;\n            DISEMBLE_RGBA(dst, dstbpp, dstfmt, pixel, dR, dG, dB, dA);\n            ALPHA_BLEND_RGBA(sR, sG, sB, A, dR, dG, dB, dA);\n            ASSEMBLE_RGBA(dst, dstbpp, dstfmt, dR, dG, dB, dA);\n            src++;\n            dst += dstbpp;\n        },\n        width);\n        /* *INDENT-ON* */\n        src += srcskip;\n        dst += dstskip;\n    }\n}\n\nstatic void\nBlit1toNAlphaKey(SDL_BlitInfo * info)\n{\n    int width = info->dst_w;\n    int height = info->dst_h;\n    Uint8 *src = info->src;\n    int srcskip = info->src_skip;\n    Uint8 *dst = info->dst;\n    int dstskip = info->dst_skip;\n    SDL_PixelFormat *dstfmt = info->dst_fmt;\n    const SDL_Color *srcpal = info->src_fmt->palette->colors;\n    Uint32 ckey = info->colorkey;\n    int dstbpp;\n    Uint32 pixel;\n    unsigned sR, sG, sB;\n    unsigned dR, dG, dB, dA;\n    const unsigned A = info->a;\n\n    /* Set up some basic variables */\n    dstbpp = dstfmt->BytesPerPixel;\n\n    while (height--) {\n\t\t/* *INDENT-OFF* */\n\t\tDUFFS_LOOP(\n\t\t{\n\t\t\tif ( *src != ckey ) {\n\t\t\t\tsR = srcpal[*src].r;\n\t\t\t\tsG = srcpal[*src].g;\n\t\t\t\tsB = srcpal[*src].b;\n\t\t\t\tDISEMBLE_RGBA(dst, dstbpp, dstfmt, pixel, dR, dG, dB, dA);\n\t\t\t\tALPHA_BLEND_RGBA(sR, sG, sB, A, dR, dG, dB, dA);\n\t\t\t  \tASSEMBLE_RGBA(dst, dstbpp, dstfmt, dR, dG, dB, dA);\n\t\t\t}\n\t\t\tsrc++;\n\t\t\tdst += dstbpp;\n\t\t},\n\t\twidth);\n\t\t/* *INDENT-ON* */\n        src += srcskip;\n        dst += dstskip;\n    }\n}\n\nstatic const SDL_BlitFunc one_blit[] = {\n    (SDL_BlitFunc) NULL, Blit1to1, Blit1to2, Blit1to3, Blit1to4\n};\n\nstatic const SDL_BlitFunc one_blitkey[] = {\n    (SDL_BlitFunc) NULL, Blit1to1Key, Blit1to2Key, Blit1to3Key, Blit1to4Key\n};\n\nSDL_BlitFunc\nSDL_CalculateBlit1(SDL_Surface * surface)\n{\n    int which;\n    SDL_PixelFormat *dstfmt;\n\n    dstfmt = surface->map->dst->format;\n    if (dstfmt->BitsPerPixel < 8) {\n        which = 0;\n    } else {\n        which = dstfmt->BytesPerPixel;\n    }\n    switch (surface->map->info.flags & ~SDL_COPY_RLE_MASK) {\n    case 0:\n        return one_blit[which];\n\n    case SDL_COPY_COLORKEY:\n        return one_blitkey[which];\n\n    case SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND:\n        /* Supporting 8bpp->8bpp alpha is doable but requires lots of\n           tables which consume space and takes time to precompute,\n           so is better left to the user */\n        return which >= 2 ? Blit1toNAlpha : (SDL_BlitFunc) NULL;\n\n    case SDL_COPY_COLORKEY | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND:\n        return which >= 2 ? Blit1toNAlphaKey : (SDL_BlitFunc) NULL;\n    }\n    return (SDL_BlitFunc) NULL;\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../SDL_internal.h\"\n\n#include \"SDL_video.h\"\n#include \"SDL_blit.h\"\n\n/* Functions to perform alpha blended blitting */\n\n/* N->1 blending with per-surface alpha */\nstatic void\nBlitNto1SurfaceAlpha(SDL_BlitInfo * info)\n{\n    int width = info->dst_w;\n    int height = info->dst_h;\n    Uint8 *src = info->src;\n    int srcskip = info->src_skip;\n    Uint8 *dst = info->dst;\n    int dstskip = info->dst_skip;\n    Uint8 *palmap = info->table;\n    SDL_PixelFormat *srcfmt = info->src_fmt;\n    SDL_PixelFormat *dstfmt = info->dst_fmt;\n    int srcbpp = srcfmt->BytesPerPixel;\n    Uint32 Pixel;\n    unsigned sR, sG, sB;\n    unsigned dR, dG, dB;\n    const unsigned A = info->a;\n\n    while (height--) {\n\t    /* *INDENT-OFF* */\n\t    DUFFS_LOOP4(\n\t    {\n\t\tDISEMBLE_RGB(src, srcbpp, srcfmt, Pixel, sR, sG, sB);\n\t\tdR = dstfmt->palette->colors[*dst].r;\n\t\tdG = dstfmt->palette->colors[*dst].g;\n\t\tdB = dstfmt->palette->colors[*dst].b;\n\t\tALPHA_BLEND_RGB(sR, sG, sB, A, dR, dG, dB);\n\t\tdR &= 0xff;\n\t\tdG &= 0xff;\n\t\tdB &= 0xff;\n\t\t/* Pack RGB into 8bit pixel */\n\t\tif ( palmap == NULL ) {\n\t\t    *dst =((dR>>5)<<(3+2))|((dG>>5)<<(2))|((dB>>6)<<(0));\n\t\t} else {\n\t\t    *dst = palmap[((dR>>5)<<(3+2))|((dG>>5)<<(2))|((dB>>6)<<(0))];\n\t\t}\n\t\tdst++;\n\t\tsrc += srcbpp;\n\t    },\n\t    width);\n\t    /* *INDENT-ON* */\n        src += srcskip;\n        dst += dstskip;\n    }\n}\n\n/* N->1 blending with pixel alpha */\nstatic void\nBlitNto1PixelAlpha(SDL_BlitInfo * info)\n{\n    int width = info->dst_w;\n    int height = info->dst_h;\n    Uint8 *src = info->src;\n    int srcskip = info->src_skip;\n    Uint8 *dst = info->dst;\n    int dstskip = info->dst_skip;\n    Uint8 *palmap = info->table;\n    SDL_PixelFormat *srcfmt = info->src_fmt;\n    SDL_PixelFormat *dstfmt = info->dst_fmt;\n    int srcbpp = srcfmt->BytesPerPixel;\n    Uint32 Pixel;\n    unsigned sR, sG, sB, sA;\n    unsigned dR, dG, dB;\n\n    while (height--) {\n\t    /* *INDENT-OFF* */\n\t    DUFFS_LOOP4(\n\t    {\n\t\tDISEMBLE_RGBA(src,srcbpp,srcfmt,Pixel,sR,sG,sB,sA);\n\t\tdR = dstfmt->palette->colors[*dst].r;\n\t\tdG = dstfmt->palette->colors[*dst].g;\n\t\tdB = dstfmt->palette->colors[*dst].b;\n\t\tALPHA_BLEND_RGB(sR, sG, sB, sA, dR, dG, dB);\n\t\tdR &= 0xff;\n\t\tdG &= 0xff;\n\t\tdB &= 0xff;\n\t\t/* Pack RGB into 8bit pixel */\n\t\tif ( palmap == NULL ) {\n\t\t    *dst =((dR>>5)<<(3+2))|((dG>>5)<<(2))|((dB>>6)<<(0));\n\t\t} else {\n\t\t    *dst = palmap[((dR>>5)<<(3+2))|((dG>>5)<<(2))|((dB>>6)<<(0))];\n\t\t}\n\t\tdst++;\n\t\tsrc += srcbpp;\n\t    },\n\t    width);\n\t    /* *INDENT-ON* */\n        src += srcskip;\n        dst += dstskip;\n    }\n}\n\n/* colorkeyed N->1 blending with per-surface alpha */\nstatic void\nBlitNto1SurfaceAlphaKey(SDL_BlitInfo * info)\n{\n    int width = info->dst_w;\n    int height = info->dst_h;\n    Uint8 *src = info->src;\n    int srcskip = info->src_skip;\n    Uint8 *dst = info->dst;\n    int dstskip = info->dst_skip;\n    Uint8 *palmap = info->table;\n    SDL_PixelFormat *srcfmt = info->src_fmt;\n    SDL_PixelFormat *dstfmt = info->dst_fmt;\n    int srcbpp = srcfmt->BytesPerPixel;\n    Uint32 ckey = info->colorkey;\n    Uint32 Pixel;\n    unsigned sR, sG, sB;\n    unsigned dR, dG, dB;\n    const unsigned A = info->a;\n\n    while (height--) {\n\t    /* *INDENT-OFF* */\n\t    DUFFS_LOOP(\n\t    {\n\t\tDISEMBLE_RGB(src, srcbpp, srcfmt, Pixel, sR, sG, sB);\n\t\tif ( Pixel != ckey ) {\n\t\t    dR = dstfmt->palette->colors[*dst].r;\n\t\t    dG = dstfmt->palette->colors[*dst].g;\n\t\t    dB = dstfmt->palette->colors[*dst].b;\n\t\t    ALPHA_BLEND_RGB(sR, sG, sB, A, dR, dG, dB);\n\t\t    dR &= 0xff;\n\t\t    dG &= 0xff;\n\t\t    dB &= 0xff;\n\t\t    /* Pack RGB into 8bit pixel */\n\t\t    if ( palmap == NULL ) {\n                *dst =((dR>>5)<<(3+2))|((dG>>5)<<(2))|((dB>>6)<<(0));\n\t\t    } else {\n                *dst = palmap[((dR>>5)<<(3+2))|((dG>>5)<<(2))|((dB>>6)<<(0))];\n\t\t    }\n\t\t}\n\t\tdst++;\n\t\tsrc += srcbpp;\n\t    },\n\t    width);\n\t    /* *INDENT-ON* */\n        src += srcskip;\n        dst += dstskip;\n    }\n}\n\n#ifdef __MMX__\n\n/* fast RGB888->(A)RGB888 blending with surface alpha=128 special case */\nstatic void\nBlitRGBtoRGBSurfaceAlpha128MMX(SDL_BlitInfo * info)\n{\n    int width = info->dst_w;\n    int height = info->dst_h;\n    Uint32 *srcp = (Uint32 *) info->src;\n    int srcskip = info->src_skip >> 2;\n    Uint32 *dstp = (Uint32 *) info->dst;\n    int dstskip = info->dst_skip >> 2;\n    Uint32 dalpha = info->dst_fmt->Amask;\n\n    __m64 src1, src2, dst1, dst2, lmask, hmask, dsta;\n\n    hmask = _mm_set_pi32(0x00fefefe, 0x00fefefe);       /* alpha128 mask -> hmask */\n    lmask = _mm_set_pi32(0x00010101, 0x00010101);       /* !alpha128 mask -> lmask */\n    dsta = _mm_set_pi32(dalpha, dalpha);        /* dst alpha mask -> dsta */\n\n    while (height--) {\n        int n = width;\n        if (n & 1) {\n            Uint32 s = *srcp++;\n            Uint32 d = *dstp;\n            *dstp++ = ((((s & 0x00fefefe) + (d & 0x00fefefe)) >> 1)\n                       + (s & d & 0x00010101)) | dalpha;\n            n--;\n        }\n\n        for (n >>= 1; n > 0; --n) {\n            dst1 = *(__m64 *) dstp;     /* 2 x dst -> dst1(ARGBARGB) */\n            dst2 = dst1;        /* 2 x dst -> dst2(ARGBARGB) */\n\n            src1 = *(__m64 *) srcp;     /* 2 x src -> src1(ARGBARGB) */\n            src2 = src1;        /* 2 x src -> src2(ARGBARGB) */\n\n            dst2 = _mm_and_si64(dst2, hmask);   /* dst & mask -> dst2 */\n            src2 = _mm_and_si64(src2, hmask);   /* src & mask -> src2 */\n            src2 = _mm_add_pi32(src2, dst2);    /* dst2 + src2 -> src2 */\n            src2 = _mm_srli_pi32(src2, 1);      /* src2 >> 1 -> src2 */\n\n            dst1 = _mm_and_si64(dst1, src1);    /* src & dst -> dst1 */\n            dst1 = _mm_and_si64(dst1, lmask);   /* dst1 & !mask -> dst1 */\n            dst1 = _mm_add_pi32(dst1, src2);    /* src2 + dst1 -> dst1 */\n            dst1 = _mm_or_si64(dst1, dsta);     /* dsta(full alpha) | dst1 -> dst1 */\n\n            *(__m64 *) dstp = dst1;     /* dst1 -> 2 x dst pixels */\n            dstp += 2;\n            srcp += 2;\n        }\n\n        srcp += srcskip;\n        dstp += dstskip;\n    }\n    _mm_empty();\n}\n\n/* fast RGB888->(A)RGB888 blending with surface alpha */\nstatic void\nBlitRGBtoRGBSurfaceAlphaMMX(SDL_BlitInfo * info)\n{\n    SDL_PixelFormat *df = info->dst_fmt;\n    Uint32 chanmask;\n    unsigned alpha = info->a;\n\n    if (alpha == 128 && (df->Rmask | df->Gmask | df->Bmask) == 0x00FFFFFF) {\n        /* only call a128 version when R,G,B occupy lower bits */\n        BlitRGBtoRGBSurfaceAlpha128MMX(info);\n    } else {\n        int width = info->dst_w;\n        int height = info->dst_h;\n        Uint32 *srcp = (Uint32 *) info->src;\n        int srcskip = info->src_skip >> 2;\n        Uint32 *dstp = (Uint32 *) info->dst;\n        int dstskip = info->dst_skip >> 2;\n        Uint32 dalpha = df->Amask;\n        Uint32 amult;\n\n        __m64 src1, src2, dst1, dst2, mm_alpha, mm_zero, dsta;\n\n        mm_zero = _mm_setzero_si64();   /* 0 -> mm_zero */\n        /* form the alpha mult */\n        amult = alpha | (alpha << 8);\n        amult = amult | (amult << 16);\n        chanmask =\n            (0xff << df->Rshift) | (0xff << df->\n                                    Gshift) | (0xff << df->Bshift);\n        mm_alpha = _mm_set_pi32(0, amult & chanmask);   /* 0000AAAA -> mm_alpha, minus 1 chan */\n        mm_alpha = _mm_unpacklo_pi8(mm_alpha, mm_zero); /* 0A0A0A0A -> mm_alpha, minus 1 chan */\n        /* at this point mm_alpha can be 000A0A0A or 0A0A0A00 or another combo */\n        dsta = _mm_set_pi32(dalpha, dalpha);    /* dst alpha mask -> dsta */\n\n        while (height--) {\n            int n = width;\n            if (n & 1) {\n                /* One Pixel Blend */\n                src2 = _mm_cvtsi32_si64(*srcp); /* src(ARGB) -> src2 (0000ARGB) */\n                src2 = _mm_unpacklo_pi8(src2, mm_zero); /* 0A0R0G0B -> src2 */\n\n                dst1 = _mm_cvtsi32_si64(*dstp); /* dst(ARGB) -> dst1 (0000ARGB) */\n                dst1 = _mm_unpacklo_pi8(dst1, mm_zero); /* 0A0R0G0B -> dst1 */\n\n                src2 = _mm_sub_pi16(src2, dst1);        /* src2 - dst2 -> src2 */\n                src2 = _mm_mullo_pi16(src2, mm_alpha);  /* src2 * alpha -> src2 */\n                src2 = _mm_srli_pi16(src2, 8);  /* src2 >> 8 -> src2 */\n                dst1 = _mm_add_pi8(src2, dst1); /* src2 + dst1 -> dst1 */\n\n                dst1 = _mm_packs_pu16(dst1, mm_zero);   /* 0000ARGB -> dst1 */\n                dst1 = _mm_or_si64(dst1, dsta); /* dsta | dst1 -> dst1 */\n                *dstp = _mm_cvtsi64_si32(dst1); /* dst1 -> pixel */\n\n                ++srcp;\n                ++dstp;\n\n                n--;\n            }\n\n            for (n >>= 1; n > 0; --n) {\n                /* Two Pixels Blend */\n                src1 = *(__m64 *) srcp; /* 2 x src -> src1(ARGBARGB) */\n                src2 = src1;    /* 2 x src -> src2(ARGBARGB) */\n                src1 = _mm_unpacklo_pi8(src1, mm_zero); /* low - 0A0R0G0B -> src1 */\n                src2 = _mm_unpackhi_pi8(src2, mm_zero); /* high - 0A0R0G0B -> src2 */\n\n                dst1 = *(__m64 *) dstp; /* 2 x dst -> dst1(ARGBARGB) */\n                dst2 = dst1;    /* 2 x dst -> dst2(ARGBARGB) */\n                dst1 = _mm_unpacklo_pi8(dst1, mm_zero); /* low - 0A0R0G0B -> dst1 */\n                dst2 = _mm_unpackhi_pi8(dst2, mm_zero); /* high - 0A0R0G0B -> dst2 */\n\n                src1 = _mm_sub_pi16(src1, dst1);        /* src1 - dst1 -> src1 */\n                src1 = _mm_mullo_pi16(src1, mm_alpha);  /* src1 * alpha -> src1 */\n                src1 = _mm_srli_pi16(src1, 8);  /* src1 >> 8 -> src1 */\n                dst1 = _mm_add_pi8(src1, dst1); /* src1 + dst1(dst1) -> dst1 */\n\n                src2 = _mm_sub_pi16(src2, dst2);        /* src2 - dst2 -> src2 */\n                src2 = _mm_mullo_pi16(src2, mm_alpha);  /* src2 * alpha -> src2 */\n                src2 = _mm_srli_pi16(src2, 8);  /* src2 >> 8 -> src2 */\n                dst2 = _mm_add_pi8(src2, dst2); /* src2 + dst2(dst2) -> dst2 */\n\n                dst1 = _mm_packs_pu16(dst1, dst2);      /* 0A0R0G0B(res1), 0A0R0G0B(res2) -> dst1(ARGBARGB) */\n                dst1 = _mm_or_si64(dst1, dsta); /* dsta | dst1 -> dst1 */\n\n                *(__m64 *) dstp = dst1; /* dst1 -> 2 x pixel */\n\n                srcp += 2;\n                dstp += 2;\n            }\n            srcp += srcskip;\n            dstp += dstskip;\n        }\n        _mm_empty();\n    }\n}\n\n/* fast ARGB888->(A)RGB888 blending with pixel alpha */\nstatic void\nBlitRGBtoRGBPixelAlphaMMX(SDL_BlitInfo * info)\n{\n    int width = info->dst_w;\n    int height = info->dst_h;\n    Uint32 *srcp = (Uint32 *) info->src;\n    int srcskip = info->src_skip >> 2;\n    Uint32 *dstp = (Uint32 *) info->dst;\n    int dstskip = info->dst_skip >> 2;\n    SDL_PixelFormat *sf = info->src_fmt;\n    Uint32 amask = sf->Amask;\n    Uint32 ashift = sf->Ashift;\n    Uint64 multmask, multmask2;\n\n    __m64 src1, dst1, mm_alpha, mm_zero, mm_alpha2;\n\n    mm_zero = _mm_setzero_si64();       /* 0 -> mm_zero */\n    multmask = 0x00FF;\n\tmultmask <<= (ashift * 2);\n\tmultmask2 = 0x00FF00FF00FF00FFULL;\n\n    while (height--) {\n\t\t/* *INDENT-OFF* */\n\t\tDUFFS_LOOP4({\n\t\tUint32 alpha = *srcp & amask;\n\t\tif (alpha == 0) {\n\t\t\t/* do nothing */\n\t\t} else if (alpha == amask) {\n\t\t\t*dstp = *srcp;\n\t\t} else {\n\t\t\tsrc1 = _mm_cvtsi32_si64(*srcp); /* src(ARGB) -> src1 (0000ARGB) */\n\t\t\tsrc1 = _mm_unpacklo_pi8(src1, mm_zero); /* 0A0R0G0B -> src1 */\n\n\t\t\tdst1 = _mm_cvtsi32_si64(*dstp); /* dst(ARGB) -> dst1 (0000ARGB) */\n\t\t\tdst1 = _mm_unpacklo_pi8(dst1, mm_zero); /* 0A0R0G0B -> dst1 */\n\n\t\t\tmm_alpha = _mm_cvtsi32_si64(alpha); /* alpha -> mm_alpha (0000000A) */\n\t\t\tmm_alpha = _mm_srli_si64(mm_alpha, ashift); /* mm_alpha >> ashift -> mm_alpha(0000000A) */\n\t\t\tmm_alpha = _mm_unpacklo_pi16(mm_alpha, mm_alpha); /* 00000A0A -> mm_alpha */\n\t\t\tmm_alpha2 = _mm_unpacklo_pi32(mm_alpha, mm_alpha); /* 0A0A0A0A -> mm_alpha2 */\n\t\t\tmm_alpha = _mm_or_si64(mm_alpha2, *(__m64 *) & multmask);\t/* 0F0A0A0A -> mm_alpha */\n\t\t\tmm_alpha2 = _mm_xor_si64(mm_alpha2, *(__m64 *) & multmask2);\t/* 255 - mm_alpha -> mm_alpha */\n\n\t\t\t/* blend */\t\t    \n\t\t\tsrc1 = _mm_mullo_pi16(src1, mm_alpha);\n\t\t\tsrc1 = _mm_srli_pi16(src1, 8);\n\t\t\tdst1 = _mm_mullo_pi16(dst1, mm_alpha2);\n\t\t\tdst1 = _mm_srli_pi16(dst1, 8);\n\t\t\tdst1 = _mm_add_pi16(src1, dst1);\n\t\t\tdst1 = _mm_packs_pu16(dst1, mm_zero);\n\t\t\t\n\t\t\t*dstp = _mm_cvtsi64_si32(dst1); /* dst1 -> pixel */\n\t\t}\n\t\t++srcp;\n\t\t++dstp;\n\t    }, width);\n\t\t/* *INDENT-ON* */\n        srcp += srcskip;\n        dstp += dstskip;\n    }\n    _mm_empty();\n}\n\n#endif /* __MMX__ */\n\n/* fast RGB888->(A)RGB888 blending with surface alpha=128 special case */\nstatic void\nBlitRGBtoRGBSurfaceAlpha128(SDL_BlitInfo * info)\n{\n    int width = info->dst_w;\n    int height = info->dst_h;\n    Uint32 *srcp = (Uint32 *) info->src;\n    int srcskip = info->src_skip >> 2;\n    Uint32 *dstp = (Uint32 *) info->dst;\n    int dstskip = info->dst_skip >> 2;\n\n    while (height--) {\n\t    /* *INDENT-OFF* */\n\t    DUFFS_LOOP4({\n\t\t    Uint32 s = *srcp++;\n\t\t    Uint32 d = *dstp;\n\t\t    *dstp++ = ((((s & 0x00fefefe) + (d & 0x00fefefe)) >> 1)\n\t\t\t       + (s & d & 0x00010101)) | 0xff000000;\n\t    }, width);\n\t    /* *INDENT-ON* */\n        srcp += srcskip;\n        dstp += dstskip;\n    }\n}\n\n/* fast RGB888->(A)RGB888 blending with surface alpha */\nstatic void\nBlitRGBtoRGBSurfaceAlpha(SDL_BlitInfo * info)\n{\n    unsigned alpha = info->a;\n    if (alpha == 128) {\n        BlitRGBtoRGBSurfaceAlpha128(info);\n    } else {\n        int width = info->dst_w;\n        int height = info->dst_h;\n        Uint32 *srcp = (Uint32 *) info->src;\n        int srcskip = info->src_skip >> 2;\n        Uint32 *dstp = (Uint32 *) info->dst;\n        int dstskip = info->dst_skip >> 2;\n        Uint32 s;\n        Uint32 d;\n        Uint32 s1;\n        Uint32 d1;\n\n        while (height--) {\n\t\t\t/* *INDENT-OFF* */\n\t\t\tDUFFS_LOOP4({\n\t\t\t\ts = *srcp;\n\t\t\t\td = *dstp;\n\t\t\t\ts1 = s & 0xff00ff;\n\t\t\t\td1 = d & 0xff00ff;\n\t\t\t\td1 = (d1 + ((s1 - d1) * alpha >> 8))\n\t\t\t\t     & 0xff00ff;\n\t\t\t\ts &= 0xff00;\n\t\t\t\td &= 0xff00;\n\t\t\t\td = (d + ((s - d) * alpha >> 8)) & 0xff00;\n\t\t\t\t*dstp = d1 | d | 0xff000000;\n\t\t\t\t++srcp;\n\t\t\t\t++dstp;\n\t\t\t}, width);\n\t\t\t/* *INDENT-ON* */\n            srcp += srcskip;\n            dstp += dstskip;\n        }\n    }\n}\n\n/* fast ARGB888->(A)RGB888 blending with pixel alpha */\nstatic void\nBlitRGBtoRGBPixelAlpha(SDL_BlitInfo * info)\n{\n    int width = info->dst_w;\n    int height = info->dst_h;\n    Uint32 *srcp = (Uint32 *) info->src;\n    int srcskip = info->src_skip >> 2;\n    Uint32 *dstp = (Uint32 *) info->dst;\n    int dstskip = info->dst_skip >> 2;\n\n    while (height--) {\n\t    /* *INDENT-OFF* */\n\t    DUFFS_LOOP4({\n\t\tUint32 dalpha;\n\t\tUint32 d;\n\t\tUint32 s1;\n\t\tUint32 d1;\n\t\tUint32 s = *srcp;\n\t\tUint32 alpha = s >> 24;\n\t\t/* FIXME: Here we special-case opaque alpha since the\n\t\t   compositioning used (>>8 instead of /255) doesn't handle\n\t\t   it correctly. Also special-case alpha=0 for speed?\n\t\t   Benchmark this! */\n\t\tif (alpha) {\n\t\t  if (alpha == SDL_ALPHA_OPAQUE) {\n\t\t\t  *dstp = *srcp;\n\t\t  } else {\n\t\t    /*\n\t\t     * take out the middle component (green), and process\n\t\t     * the other two in parallel. One multiply less.\n\t\t     */\n\t\t    d = *dstp;\n\t\t\tdalpha = d >> 24;\n\t\t    s1 = s & 0xff00ff;\n\t\t    d1 = d & 0xff00ff;\n\t\t    d1 = (d1 + ((s1 - d1) * alpha >> 8)) & 0xff00ff;\n\t\t    s &= 0xff00;\n\t\t    d &= 0xff00;\n\t\t    d = (d + ((s - d) * alpha >> 8)) & 0xff00;\n\t\t\tdalpha = alpha + (dalpha * (alpha ^ 0xFF) >> 8);\n\t\t    *dstp = d1 | d | (dalpha << 24);\n\t\t  }\n\t\t}\n\t\t++srcp;\n\t\t++dstp;\n\t    }, width);\n\t    /* *INDENT-ON* */\n        srcp += srcskip;\n        dstp += dstskip;\n    }\n}\n\n#ifdef __3dNOW__\n/* fast (as in MMX with prefetch) ARGB888->(A)RGB888 blending with pixel alpha */\nstatic void\nBlitRGBtoRGBPixelAlphaMMX3DNOW(SDL_BlitInfo * info)\n{\n    int width = info->dst_w;\n    int height = info->dst_h;\n    Uint32 *srcp = (Uint32 *) info->src;\n    int srcskip = info->src_skip >> 2;\n    Uint32 *dstp = (Uint32 *) info->dst;\n    int dstskip = info->dst_skip >> 2;\n    SDL_PixelFormat *sf = info->src_fmt;\n    Uint32 amask = sf->Amask;\n    Uint32 ashift = sf->Ashift;\n    Uint64 multmask, multmask2;\n\n    __m64 src1, dst1, mm_alpha, mm_zero, mm_alpha2;\n\n    mm_zero = _mm_setzero_si64();       /* 0 -> mm_zero */\n    multmask = 0x00FF;\n    multmask <<= (ashift * 2);\n    multmask2 = 0x00FF00FF00FF00FFULL;\n\n    while (height--) {\n\t    /* *INDENT-OFF* */\n\t    DUFFS_LOOP4({\n\t\tUint32 alpha;\n\n\t\t_m_prefetch(srcp + 16);\n\t\t_m_prefetch(dstp + 16);\n\n\t\talpha = *srcp & amask;\n\t\tif (alpha == 0) {\n\t\t\t/* do nothing */\n\t\t} else if (alpha == amask) {\n\t\t\t*dstp = *srcp;\n\t\t} else {\n\t\t\tsrc1 = _mm_cvtsi32_si64(*srcp); /* src(ARGB) -> src1 (0000ARGB) */\n\t\t\tsrc1 = _mm_unpacklo_pi8(src1, mm_zero); /* 0A0R0G0B -> src1 */\n\n\t\t\tdst1 = _mm_cvtsi32_si64(*dstp); /* dst(ARGB) -> dst1 (0000ARGB) */\n\t\t\tdst1 = _mm_unpacklo_pi8(dst1, mm_zero); /* 0A0R0G0B -> dst1 */\n\n\t\t\tmm_alpha = _mm_cvtsi32_si64(alpha); /* alpha -> mm_alpha (0000000A) */\n\t\t\tmm_alpha = _mm_srli_si64(mm_alpha, ashift); /* mm_alpha >> ashift -> mm_alpha(0000000A) */\n\t\t\tmm_alpha = _mm_unpacklo_pi16(mm_alpha, mm_alpha); /* 00000A0A -> mm_alpha */\n\t\t\tmm_alpha2 = _mm_unpacklo_pi32(mm_alpha, mm_alpha); /* 0A0A0A0A -> mm_alpha2 */\n\t\t\tmm_alpha = _mm_or_si64(mm_alpha2, *(__m64 *) & multmask);\t/* 0F0A0A0A -> mm_alpha */\n\t\t\tmm_alpha2 = _mm_xor_si64(mm_alpha2, *(__m64 *) & multmask2);\t/* 255 - mm_alpha -> mm_alpha */\n\n\n\t\t\t/* blend */\t\t    \n\t\t\tsrc1 = _mm_mullo_pi16(src1, mm_alpha);\n\t\t\tsrc1 = _mm_srli_pi16(src1, 8);\n\t\t\tdst1 = _mm_mullo_pi16(dst1, mm_alpha2);\n\t\t\tdst1 = _mm_srli_pi16(dst1, 8);\n\t\t\tdst1 = _mm_add_pi16(src1, dst1);\n\t\t\tdst1 = _mm_packs_pu16(dst1, mm_zero);\n\t\t\t\n\t\t\t*dstp = _mm_cvtsi64_si32(dst1); /* dst1 -> pixel */\n\t\t}\n\t\t++srcp;\n\t\t++dstp;\n\t    }, width);\n\t    /* *INDENT-ON* */\n        srcp += srcskip;\n        dstp += dstskip;\n    }\n    _mm_empty();\n}\n\n#endif /* __MMX__ */\n\n/* 16bpp special case for per-surface alpha=50%: blend 2 pixels in parallel */\n\n/* blend a single 16 bit pixel at 50% */\n#define BLEND16_50(d, s, mask)\t\t\t\t\t\t\\\n\t((((s & mask) + (d & mask)) >> 1) + (s & d & (~mask & 0xffff)))\n\n/* blend two 16 bit pixels at 50% */\n#define BLEND2x16_50(d, s, mask)\t\t\t\t\t     \\\n\t(((s & (mask | mask << 16)) >> 1) + ((d & (mask | mask << 16)) >> 1) \\\n\t + (s & d & (~(mask | mask << 16))))\n\nstatic void\nBlit16to16SurfaceAlpha128(SDL_BlitInfo * info, Uint16 mask)\n{\n    int width = info->dst_w;\n    int height = info->dst_h;\n    Uint16 *srcp = (Uint16 *) info->src;\n    int srcskip = info->src_skip >> 1;\n    Uint16 *dstp = (Uint16 *) info->dst;\n    int dstskip = info->dst_skip >> 1;\n\n    while (height--) {\n        if (((uintptr_t) srcp ^ (uintptr_t) dstp) & 2) {\n            /*\n             * Source and destination not aligned, pipeline it.\n             * This is mostly a win for big blits but no loss for\n             * small ones\n             */\n            Uint32 prev_sw;\n            int w = width;\n\n            /* handle odd destination */\n            if ((uintptr_t) dstp & 2) {\n                Uint16 d = *dstp, s = *srcp;\n                *dstp = BLEND16_50(d, s, mask);\n                dstp++;\n                srcp++;\n                w--;\n            }\n            srcp++;             /* srcp is now 32-bit aligned */\n\n            /* bootstrap pipeline with first halfword */\n            prev_sw = ((Uint32 *) srcp)[-1];\n\n            while (w > 1) {\n                Uint32 sw, dw, s;\n                sw = *(Uint32 *) srcp;\n                dw = *(Uint32 *) dstp;\n#if SDL_BYTEORDER == SDL_BIG_ENDIAN\n                s = (prev_sw << 16) + (sw >> 16);\n#else\n                s = (prev_sw >> 16) + (sw << 16);\n#endif\n                prev_sw = sw;\n                *(Uint32 *) dstp = BLEND2x16_50(dw, s, mask);\n                dstp += 2;\n                srcp += 2;\n                w -= 2;\n            }\n\n            /* final pixel if any */\n            if (w) {\n                Uint16 d = *dstp, s;\n#if SDL_BYTEORDER == SDL_BIG_ENDIAN\n                s = (Uint16) prev_sw;\n#else\n                s = (Uint16) (prev_sw >> 16);\n#endif\n                *dstp = BLEND16_50(d, s, mask);\n                srcp++;\n                dstp++;\n            }\n            srcp += srcskip - 1;\n            dstp += dstskip;\n        } else {\n            /* source and destination are aligned */\n            int w = width;\n\n            /* first odd pixel? */\n            if ((uintptr_t) srcp & 2) {\n                Uint16 d = *dstp, s = *srcp;\n                *dstp = BLEND16_50(d, s, mask);\n                srcp++;\n                dstp++;\n                w--;\n            }\n            /* srcp and dstp are now 32-bit aligned */\n\n            while (w > 1) {\n                Uint32 sw = *(Uint32 *) srcp;\n                Uint32 dw = *(Uint32 *) dstp;\n                *(Uint32 *) dstp = BLEND2x16_50(dw, sw, mask);\n                srcp += 2;\n                dstp += 2;\n                w -= 2;\n            }\n\n            /* last odd pixel? */\n            if (w) {\n                Uint16 d = *dstp, s = *srcp;\n                *dstp = BLEND16_50(d, s, mask);\n                srcp++;\n                dstp++;\n            }\n            srcp += srcskip;\n            dstp += dstskip;\n        }\n    }\n}\n\n#ifdef __MMX__\n\n/* fast RGB565->RGB565 blending with surface alpha */\nstatic void\nBlit565to565SurfaceAlphaMMX(SDL_BlitInfo * info)\n{\n    unsigned alpha = info->a;\n    if (alpha == 128) {\n        Blit16to16SurfaceAlpha128(info, 0xf7de);\n    } else {\n        int width = info->dst_w;\n        int height = info->dst_h;\n        Uint16 *srcp = (Uint16 *) info->src;\n        int srcskip = info->src_skip >> 1;\n        Uint16 *dstp = (Uint16 *) info->dst;\n        int dstskip = info->dst_skip >> 1;\n        Uint32 s, d;\n\n        __m64 src1, dst1, src2, dst2, gmask, bmask, mm_res, mm_alpha;\n\n        alpha &= ~(1 + 2 + 4);  /* cut alpha to get the exact same behaviour */\n        mm_alpha = _mm_set_pi32(0, alpha);      /* 0000000A -> mm_alpha */\n        alpha >>= 3;            /* downscale alpha to 5 bits */\n\n        mm_alpha = _mm_unpacklo_pi16(mm_alpha, mm_alpha);       /* 00000A0A -> mm_alpha */\n        mm_alpha = _mm_unpacklo_pi32(mm_alpha, mm_alpha);       /* 0A0A0A0A -> mm_alpha */\n        /* position alpha to allow for mullo and mulhi on diff channels\n           to reduce the number of operations */\n        mm_alpha = _mm_slli_si64(mm_alpha, 3);\n\n        /* Setup the 565 color channel masks */\n        gmask = _mm_set_pi32(0x07E007E0, 0x07E007E0);   /* MASKGREEN -> gmask */\n        bmask = _mm_set_pi32(0x001F001F, 0x001F001F);   /* MASKBLUE -> bmask */\n\n        while (height--) {\n\t\t\t/* *INDENT-OFF* */\n\t\t\tDUFFS_LOOP_124(\n\t\t\t{\n\t\t\t\ts = *srcp++;\n\t\t\t\td = *dstp;\n\t\t\t\t/*\n\t\t\t\t * shift out the middle component (green) to\n\t\t\t\t * the high 16 bits, and process all three RGB\n\t\t\t\t * components at the same time.\n\t\t\t\t */\n\t\t\t\ts = (s | s << 16) & 0x07e0f81f;\n\t\t\t\td = (d | d << 16) & 0x07e0f81f;\n\t\t\t\td += (s - d) * alpha >> 5;\n\t\t\t\td &= 0x07e0f81f;\n\t\t\t\t*dstp++ = (Uint16)(d | d >> 16);\n\t\t\t},{\n\t\t\t\ts = *srcp++;\n\t\t\t\td = *dstp;\n\t\t\t\t/*\n\t\t\t\t * shift out the middle component (green) to\n\t\t\t\t * the high 16 bits, and process all three RGB\n\t\t\t\t * components at the same time.\n\t\t\t\t */\n\t\t\t\ts = (s | s << 16) & 0x07e0f81f;\n\t\t\t\td = (d | d << 16) & 0x07e0f81f;\n\t\t\t\td += (s - d) * alpha >> 5;\n\t\t\t\td &= 0x07e0f81f;\n\t\t\t\t*dstp++ = (Uint16)(d | d >> 16);\n\t\t\t\ts = *srcp++;\n\t\t\t\td = *dstp;\n\t\t\t\t/*\n\t\t\t\t * shift out the middle component (green) to\n\t\t\t\t * the high 16 bits, and process all three RGB\n\t\t\t\t * components at the same time.\n\t\t\t\t */\n\t\t\t\ts = (s | s << 16) & 0x07e0f81f;\n\t\t\t\td = (d | d << 16) & 0x07e0f81f;\n\t\t\t\td += (s - d) * alpha >> 5;\n\t\t\t\td &= 0x07e0f81f;\n\t\t\t\t*dstp++ = (Uint16)(d | d >> 16);\n\t\t\t},{\n\t\t\t\tsrc1 = *(__m64*)srcp; /* 4 src pixels -> src1 */\n\t\t\t\tdst1 = *(__m64*)dstp; /* 4 dst pixels -> dst1 */\n\n\t\t\t\t/* red */\n\t\t\t\tsrc2 = src1;\n\t\t\t\tsrc2 = _mm_srli_pi16(src2, 11); /* src2 >> 11 -> src2 [000r 000r 000r 000r] */\n\n\t\t\t\tdst2 = dst1;\n\t\t\t\tdst2 = _mm_srli_pi16(dst2, 11); /* dst2 >> 11 -> dst2 [000r 000r 000r 000r] */\n\n\t\t\t\t/* blend */\n\t\t\t\tsrc2 = _mm_sub_pi16(src2, dst2);/* src - dst -> src2 */\n\t\t\t\tsrc2 = _mm_mullo_pi16(src2, mm_alpha); /* src2 * alpha -> src2 */\n\t\t\t\tsrc2 = _mm_srli_pi16(src2, 11); /* src2 >> 11 -> src2 */\n\t\t\t\tdst2 = _mm_add_pi16(src2, dst2); /* src2 + dst2 -> dst2 */\n\t\t\t\tdst2 = _mm_slli_pi16(dst2, 11); /* dst2 << 11 -> dst2 */\n\n\t\t\t\tmm_res = dst2; /* RED -> mm_res */\n\n\t\t\t\t/* green -- process the bits in place */\n\t\t\t\tsrc2 = src1;\n\t\t\t\tsrc2 = _mm_and_si64(src2, gmask); /* src & MASKGREEN -> src2 */\n\n\t\t\t\tdst2 = dst1;\n\t\t\t\tdst2 = _mm_and_si64(dst2, gmask); /* dst & MASKGREEN -> dst2 */\n\n\t\t\t\t/* blend */\n\t\t\t\tsrc2 = _mm_sub_pi16(src2, dst2);/* src - dst -> src2 */\n\t\t\t\tsrc2 = _mm_mulhi_pi16(src2, mm_alpha); /* src2 * alpha -> src2 */\n\t\t\t\tsrc2 = _mm_slli_pi16(src2, 5); /* src2 << 5 -> src2 */\n\t\t\t\tdst2 = _mm_add_pi16(src2, dst2); /* src2 + dst2 -> dst2 */\n\n\t\t\t\tmm_res = _mm_or_si64(mm_res, dst2); /* RED | GREEN -> mm_res */\n\n\t\t\t\t/* blue */\n\t\t\t\tsrc2 = src1;\n\t\t\t\tsrc2 = _mm_and_si64(src2, bmask); /* src & MASKBLUE -> src2[000b 000b 000b 000b] */\n\n\t\t\t\tdst2 = dst1;\n\t\t\t\tdst2 = _mm_and_si64(dst2, bmask); /* dst & MASKBLUE -> dst2[000b 000b 000b 000b] */\n\n\t\t\t\t/* blend */\n\t\t\t\tsrc2 = _mm_sub_pi16(src2, dst2);/* src - dst -> src2 */\n\t\t\t\tsrc2 = _mm_mullo_pi16(src2, mm_alpha); /* src2 * alpha -> src2 */\n\t\t\t\tsrc2 = _mm_srli_pi16(src2, 11); /* src2 >> 11 -> src2 */\n\t\t\t\tdst2 = _mm_add_pi16(src2, dst2); /* src2 + dst2 -> dst2 */\n\t\t\t\tdst2 = _mm_and_si64(dst2, bmask); /* dst2 & MASKBLUE -> dst2 */\n\n\t\t\t\tmm_res = _mm_or_si64(mm_res, dst2); /* RED | GREEN | BLUE -> mm_res */\n\n\t\t\t\t*(__m64*)dstp = mm_res; /* mm_res -> 4 dst pixels */\n\n\t\t\t\tsrcp += 4;\n\t\t\t\tdstp += 4;\n\t\t\t}, width);\n\t\t\t/* *INDENT-ON* */\n            srcp += srcskip;\n            dstp += dstskip;\n        }\n        _mm_empty();\n    }\n}\n\n/* fast RGB555->RGB555 blending with surface alpha */\nstatic void\nBlit555to555SurfaceAlphaMMX(SDL_BlitInfo * info)\n{\n    unsigned alpha = info->a;\n    if (alpha == 128) {\n        Blit16to16SurfaceAlpha128(info, 0xfbde);\n    } else {\n        int width = info->dst_w;\n        int height = info->dst_h;\n        Uint16 *srcp = (Uint16 *) info->src;\n        int srcskip = info->src_skip >> 1;\n        Uint16 *dstp = (Uint16 *) info->dst;\n        int dstskip = info->dst_skip >> 1;\n        Uint32 s, d;\n\n        __m64 src1, dst1, src2, dst2, rmask, gmask, bmask, mm_res, mm_alpha;\n\n        alpha &= ~(1 + 2 + 4);  /* cut alpha to get the exact same behaviour */\n        mm_alpha = _mm_set_pi32(0, alpha);      /* 0000000A -> mm_alpha */\n        alpha >>= 3;            /* downscale alpha to 5 bits */\n\n        mm_alpha = _mm_unpacklo_pi16(mm_alpha, mm_alpha);       /* 00000A0A -> mm_alpha */\n        mm_alpha = _mm_unpacklo_pi32(mm_alpha, mm_alpha);       /* 0A0A0A0A -> mm_alpha */\n        /* position alpha to allow for mullo and mulhi on diff channels\n           to reduce the number of operations */\n        mm_alpha = _mm_slli_si64(mm_alpha, 3);\n\n        /* Setup the 555 color channel masks */\n        rmask = _mm_set_pi32(0x7C007C00, 0x7C007C00);   /* MASKRED -> rmask */\n        gmask = _mm_set_pi32(0x03E003E0, 0x03E003E0);   /* MASKGREEN -> gmask */\n        bmask = _mm_set_pi32(0x001F001F, 0x001F001F);   /* MASKBLUE -> bmask */\n\n        while (height--) {\n\t\t\t/* *INDENT-OFF* */\n\t\t\tDUFFS_LOOP_124(\n\t\t\t{\n\t\t\t\ts = *srcp++;\n\t\t\t\td = *dstp;\n\t\t\t\t/*\n\t\t\t\t * shift out the middle component (green) to\n\t\t\t\t * the high 16 bits, and process all three RGB\n\t\t\t\t * components at the same time.\n\t\t\t\t */\n\t\t\t\ts = (s | s << 16) & 0x03e07c1f;\n\t\t\t\td = (d | d << 16) & 0x03e07c1f;\n\t\t\t\td += (s - d) * alpha >> 5;\n\t\t\t\td &= 0x03e07c1f;\n\t\t\t\t*dstp++ = (Uint16)(d | d >> 16);\n\t\t\t},{\n\t\t\t\ts = *srcp++;\n\t\t\t\td = *dstp;\n\t\t\t\t/*\n\t\t\t\t * shift out the middle component (green) to\n\t\t\t\t * the high 16 bits, and process all three RGB\n\t\t\t\t * components at the same time.\n\t\t\t\t */\n\t\t\t\ts = (s | s << 16) & 0x03e07c1f;\n\t\t\t\td = (d | d << 16) & 0x03e07c1f;\n\t\t\t\td += (s - d) * alpha >> 5;\n\t\t\t\td &= 0x03e07c1f;\n\t\t\t\t*dstp++ = (Uint16)(d | d >> 16);\n\t\t\t        s = *srcp++;\n\t\t\t\td = *dstp;\n\t\t\t\t/*\n\t\t\t\t * shift out the middle component (green) to\n\t\t\t\t * the high 16 bits, and process all three RGB\n\t\t\t\t * components at the same time.\n\t\t\t\t */\n\t\t\t\ts = (s | s << 16) & 0x03e07c1f;\n\t\t\t\td = (d | d << 16) & 0x03e07c1f;\n\t\t\t\td += (s - d) * alpha >> 5;\n\t\t\t\td &= 0x03e07c1f;\n\t\t\t\t*dstp++ = (Uint16)(d | d >> 16);\n\t\t\t},{\n\t\t\t\tsrc1 = *(__m64*)srcp; /* 4 src pixels -> src1 */\n\t\t\t\tdst1 = *(__m64*)dstp; /* 4 dst pixels -> dst1 */\n\n\t\t\t\t/* red -- process the bits in place */\n\t\t\t\tsrc2 = src1;\n\t\t\t\tsrc2 = _mm_and_si64(src2, rmask); /* src & MASKRED -> src2 */\n\n\t\t\t\tdst2 = dst1;\n\t\t\t\tdst2 = _mm_and_si64(dst2, rmask); /* dst & MASKRED -> dst2 */\n\n\t\t\t\t/* blend */\n\t\t\t\tsrc2 = _mm_sub_pi16(src2, dst2);/* src - dst -> src2 */\n\t\t\t\tsrc2 = _mm_mulhi_pi16(src2, mm_alpha); /* src2 * alpha -> src2 */\n\t\t\t\tsrc2 = _mm_slli_pi16(src2, 5); /* src2 << 5 -> src2 */\n\t\t\t\tdst2 = _mm_add_pi16(src2, dst2); /* src2 + dst2 -> dst2 */\n\t\t\t\tdst2 = _mm_and_si64(dst2, rmask); /* dst2 & MASKRED -> dst2 */\n\n\t\t\t\tmm_res = dst2; /* RED -> mm_res */\n\t\t\t\t\n\t\t\t\t/* green -- process the bits in place */\n\t\t\t\tsrc2 = src1;\n\t\t\t\tsrc2 = _mm_and_si64(src2, gmask); /* src & MASKGREEN -> src2 */\n\n\t\t\t\tdst2 = dst1;\n\t\t\t\tdst2 = _mm_and_si64(dst2, gmask); /* dst & MASKGREEN -> dst2 */\n\n\t\t\t\t/* blend */\n\t\t\t\tsrc2 = _mm_sub_pi16(src2, dst2);/* src - dst -> src2 */\n\t\t\t\tsrc2 = _mm_mulhi_pi16(src2, mm_alpha); /* src2 * alpha -> src2 */\n\t\t\t\tsrc2 = _mm_slli_pi16(src2, 5); /* src2 << 5 -> src2 */\n\t\t\t\tdst2 = _mm_add_pi16(src2, dst2); /* src2 + dst2 -> dst2 */\n\n\t\t\t\tmm_res = _mm_or_si64(mm_res, dst2); /* RED | GREEN -> mm_res */\n\n\t\t\t\t/* blue */\n\t\t\t\tsrc2 = src1; /* src -> src2 */\n\t\t\t\tsrc2 = _mm_and_si64(src2, bmask); /* src & MASKBLUE -> src2[000b 000b 000b 000b] */\n\n\t\t\t\tdst2 = dst1; /* dst -> dst2 */\n\t\t\t\tdst2 = _mm_and_si64(dst2, bmask); /* dst & MASKBLUE -> dst2[000b 000b 000b 000b] */\n\n\t\t\t\t/* blend */\n\t\t\t\tsrc2 = _mm_sub_pi16(src2, dst2);/* src - dst -> src2 */\n\t\t\t\tsrc2 = _mm_mullo_pi16(src2, mm_alpha); /* src2 * alpha -> src2 */\n\t\t\t\tsrc2 = _mm_srli_pi16(src2, 11); /* src2 >> 11 -> src2 */\n\t\t\t\tdst2 = _mm_add_pi16(src2, dst2); /* src2 + dst2 -> dst2 */\n\t\t\t\tdst2 = _mm_and_si64(dst2, bmask); /* dst2 & MASKBLUE -> dst2 */\n\n\t\t\t\tmm_res = _mm_or_si64(mm_res, dst2); /* RED | GREEN | BLUE -> mm_res */\n\n\t\t\t\t*(__m64*)dstp = mm_res; /* mm_res -> 4 dst pixels */\n\n\t\t\t\tsrcp += 4;\n\t\t\t\tdstp += 4;\n\t\t\t}, width);\n\t\t\t/* *INDENT-ON* */\n            srcp += srcskip;\n            dstp += dstskip;\n        }\n        _mm_empty();\n    }\n}\n\n#endif /* __MMX__ */\n\n/* fast RGB565->RGB565 blending with surface alpha */\nstatic void\nBlit565to565SurfaceAlpha(SDL_BlitInfo * info)\n{\n    unsigned alpha = info->a;\n    if (alpha == 128) {\n        Blit16to16SurfaceAlpha128(info, 0xf7de);\n    } else {\n        int width = info->dst_w;\n        int height = info->dst_h;\n        Uint16 *srcp = (Uint16 *) info->src;\n        int srcskip = info->src_skip >> 1;\n        Uint16 *dstp = (Uint16 *) info->dst;\n        int dstskip = info->dst_skip >> 1;\n        alpha >>= 3;            /* downscale alpha to 5 bits */\n\n        while (height--) {\n\t\t\t/* *INDENT-OFF* */\n\t\t\tDUFFS_LOOP4({\n\t\t\t\tUint32 s = *srcp++;\n\t\t\t\tUint32 d = *dstp;\n\t\t\t\t/*\n\t\t\t\t * shift out the middle component (green) to\n\t\t\t\t * the high 16 bits, and process all three RGB\n\t\t\t\t * components at the same time.\n\t\t\t\t */\n\t\t\t\ts = (s | s << 16) & 0x07e0f81f;\n\t\t\t\td = (d | d << 16) & 0x07e0f81f;\n\t\t\t\td += (s - d) * alpha >> 5;\n\t\t\t\td &= 0x07e0f81f;\n\t\t\t\t*dstp++ = (Uint16)(d | d >> 16);\n\t\t\t}, width);\n\t\t\t/* *INDENT-ON* */\n            srcp += srcskip;\n            dstp += dstskip;\n        }\n    }\n}\n\n/* fast RGB555->RGB555 blending with surface alpha */\nstatic void\nBlit555to555SurfaceAlpha(SDL_BlitInfo * info)\n{\n    unsigned alpha = info->a;   /* downscale alpha to 5 bits */\n    if (alpha == 128) {\n        Blit16to16SurfaceAlpha128(info, 0xfbde);\n    } else {\n        int width = info->dst_w;\n        int height = info->dst_h;\n        Uint16 *srcp = (Uint16 *) info->src;\n        int srcskip = info->src_skip >> 1;\n        Uint16 *dstp = (Uint16 *) info->dst;\n        int dstskip = info->dst_skip >> 1;\n        alpha >>= 3;            /* downscale alpha to 5 bits */\n\n        while (height--) {\n\t\t\t/* *INDENT-OFF* */\n\t\t\tDUFFS_LOOP4({\n\t\t\t\tUint32 s = *srcp++;\n\t\t\t\tUint32 d = *dstp;\n\t\t\t\t/*\n\t\t\t\t * shift out the middle component (green) to\n\t\t\t\t * the high 16 bits, and process all three RGB\n\t\t\t\t * components at the same time.\n\t\t\t\t */\n\t\t\t\ts = (s | s << 16) & 0x03e07c1f;\n\t\t\t\td = (d | d << 16) & 0x03e07c1f;\n\t\t\t\td += (s - d) * alpha >> 5;\n\t\t\t\td &= 0x03e07c1f;\n\t\t\t\t*dstp++ = (Uint16)(d | d >> 16);\n\t\t\t}, width);\n\t\t\t/* *INDENT-ON* */\n            srcp += srcskip;\n            dstp += dstskip;\n        }\n    }\n}\n\n/* fast ARGB8888->RGB565 blending with pixel alpha */\nstatic void\nBlitARGBto565PixelAlpha(SDL_BlitInfo * info)\n{\n    int width = info->dst_w;\n    int height = info->dst_h;\n    Uint32 *srcp = (Uint32 *) info->src;\n    int srcskip = info->src_skip >> 2;\n    Uint16 *dstp = (Uint16 *) info->dst;\n    int dstskip = info->dst_skip >> 1;\n\n    while (height--) {\n\t    /* *INDENT-OFF* */\n\t    DUFFS_LOOP4({\n\t\tUint32 s = *srcp;\n\t\tunsigned alpha = s >> 27; /* downscale alpha to 5 bits */\n\t\t/* FIXME: Here we special-case opaque alpha since the\n\t\t   compositioning used (>>8 instead of /255) doesn't handle\n\t\t   it correctly. Also special-case alpha=0 for speed?\n\t\t   Benchmark this! */\n\t\tif(alpha) {   \n\t\t  if(alpha == (SDL_ALPHA_OPAQUE >> 3)) {\n\t\t    *dstp = (Uint16)((s >> 8 & 0xf800) + (s >> 5 & 0x7e0) + (s >> 3  & 0x1f));\n\t\t  } else {\n\t\t    Uint32 d = *dstp;\n\t\t    /*\n\t\t     * convert source and destination to G0RAB65565\n\t\t     * and blend all components at the same time\n\t\t     */\n\t\t    s = ((s & 0xfc00) << 11) + (s >> 8 & 0xf800)\n\t\t      + (s >> 3 & 0x1f);\n\t\t    d = (d | d << 16) & 0x07e0f81f;\n\t\t    d += (s - d) * alpha >> 5;\n\t\t    d &= 0x07e0f81f;\n\t\t    *dstp = (Uint16)(d | d >> 16);\n\t\t  }\n\t\t}\n\t\tsrcp++;\n\t\tdstp++;\n\t    }, width);\n\t    /* *INDENT-ON* */\n        srcp += srcskip;\n        dstp += dstskip;\n    }\n}\n\n/* fast ARGB8888->RGB555 blending with pixel alpha */\nstatic void\nBlitARGBto555PixelAlpha(SDL_BlitInfo * info)\n{\n    int width = info->dst_w;\n    int height = info->dst_h;\n    Uint32 *srcp = (Uint32 *) info->src;\n    int srcskip = info->src_skip >> 2;\n    Uint16 *dstp = (Uint16 *) info->dst;\n    int dstskip = info->dst_skip >> 1;\n\n    while (height--) {\n\t    /* *INDENT-OFF* */\n\t    DUFFS_LOOP4({\n\t\tunsigned alpha;\n\t\tUint32 s = *srcp;\n\t\talpha = s >> 27; /* downscale alpha to 5 bits */\n\t\t/* FIXME: Here we special-case opaque alpha since the\n\t\t   compositioning used (>>8 instead of /255) doesn't handle\n\t\t   it correctly. Also special-case alpha=0 for speed?\n\t\t   Benchmark this! */\n\t\tif(alpha) {   \n\t\t  if(alpha == (SDL_ALPHA_OPAQUE >> 3)) {\n\t\t    *dstp = (Uint16)((s >> 9 & 0x7c00) + (s >> 6 & 0x3e0) + (s >> 3  & 0x1f));\n\t\t  } else {\n\t\t    Uint32 d = *dstp;\n\t\t    /*\n\t\t     * convert source and destination to G0RAB65565\n\t\t     * and blend all components at the same time\n\t\t     */\n\t\t    s = ((s & 0xf800) << 10) + (s >> 9 & 0x7c00)\n\t\t      + (s >> 3 & 0x1f);\n\t\t    d = (d | d << 16) & 0x03e07c1f;\n\t\t    d += (s - d) * alpha >> 5;\n\t\t    d &= 0x03e07c1f;\n\t\t    *dstp = (Uint16)(d | d >> 16);\n\t\t  }\n\t\t}\n\t\tsrcp++;\n\t\tdstp++;\n\t    }, width);\n\t    /* *INDENT-ON* */\n        srcp += srcskip;\n        dstp += dstskip;\n    }\n}\n\n/* General (slow) N->N blending with per-surface alpha */\nstatic void\nBlitNtoNSurfaceAlpha(SDL_BlitInfo * info)\n{\n    int width = info->dst_w;\n    int height = info->dst_h;\n    Uint8 *src = info->src;\n    int srcskip = info->src_skip;\n    Uint8 *dst = info->dst;\n    int dstskip = info->dst_skip;\n    SDL_PixelFormat *srcfmt = info->src_fmt;\n    SDL_PixelFormat *dstfmt = info->dst_fmt;\n    int srcbpp = srcfmt->BytesPerPixel;\n    int dstbpp = dstfmt->BytesPerPixel;\n    Uint32 Pixel;\n    unsigned sR, sG, sB;\n    unsigned dR, dG, dB, dA;\n    const unsigned sA = info->a;\n\n    if (sA) {\n        while (height--) {\n\t    /* *INDENT-OFF* */\n\t    DUFFS_LOOP4(\n\t    {\n\t\tDISEMBLE_RGB(src, srcbpp, srcfmt, Pixel, sR, sG, sB);\n\t\tDISEMBLE_RGBA(dst, dstbpp, dstfmt, Pixel, dR, dG, dB, dA);\n\t\tALPHA_BLEND_RGBA(sR, sG, sB, sA, dR, dG, dB, dA);\n\t\tASSEMBLE_RGBA(dst, dstbpp, dstfmt, dR, dG, dB, dA);\n\t\tsrc += srcbpp;\n\t\tdst += dstbpp;\n\t    },\n\t    width);\n\t    /* *INDENT-ON* */\n            src += srcskip;\n            dst += dstskip;\n        }\n    }\n}\n\n/* General (slow) colorkeyed N->N blending with per-surface alpha */\nstatic void\nBlitNtoNSurfaceAlphaKey(SDL_BlitInfo * info)\n{\n    int width = info->dst_w;\n    int height = info->dst_h;\n    Uint8 *src = info->src;\n    int srcskip = info->src_skip;\n    Uint8 *dst = info->dst;\n    int dstskip = info->dst_skip;\n    SDL_PixelFormat *srcfmt = info->src_fmt;\n    SDL_PixelFormat *dstfmt = info->dst_fmt;\n    Uint32 ckey = info->colorkey;\n    int srcbpp = srcfmt->BytesPerPixel;\n    int dstbpp = dstfmt->BytesPerPixel;\n    Uint32 Pixel;\n    unsigned sR, sG, sB;\n    unsigned dR, dG, dB, dA;\n    const unsigned sA = info->a;\n\n    while (height--) {\n\t    /* *INDENT-OFF* */\n\t    DUFFS_LOOP4(\n\t    {\n\t\tRETRIEVE_RGB_PIXEL(src, srcbpp, Pixel);\n\t\tif(sA && Pixel != ckey) {\n\t\t    RGB_FROM_PIXEL(Pixel, srcfmt, sR, sG, sB);\n\t\t    DISEMBLE_RGBA(dst, dstbpp, dstfmt, Pixel, dR, dG, dB, dA);\n\t\t    ALPHA_BLEND_RGBA(sR, sG, sB, sA, dR, dG, dB, dA);\n\t\t    ASSEMBLE_RGBA(dst, dstbpp, dstfmt, dR, dG, dB, dA);\n\t\t}\n\t\tsrc += srcbpp;\n\t\tdst += dstbpp;\n\t    },\n\t    width);\n\t    /* *INDENT-ON* */\n        src += srcskip;\n        dst += dstskip;\n    }\n}\n\n/* General (slow) N->N blending with pixel alpha */\nstatic void\nBlitNtoNPixelAlpha(SDL_BlitInfo * info)\n{\n    int width = info->dst_w;\n    int height = info->dst_h;\n    Uint8 *src = info->src;\n    int srcskip = info->src_skip;\n    Uint8 *dst = info->dst;\n    int dstskip = info->dst_skip;\n    SDL_PixelFormat *srcfmt = info->src_fmt;\n    SDL_PixelFormat *dstfmt = info->dst_fmt;\n    int srcbpp;\n    int dstbpp;\n    Uint32 Pixel;\n    unsigned sR, sG, sB, sA;\n    unsigned dR, dG, dB, dA;\n\n    /* Set up some basic variables */\n    srcbpp = srcfmt->BytesPerPixel;\n    dstbpp = dstfmt->BytesPerPixel;\n\n    while (height--) {\n\t    /* *INDENT-OFF* */\n\t    DUFFS_LOOP4(\n\t    {\n\t\tDISEMBLE_RGBA(src, srcbpp, srcfmt, Pixel, sR, sG, sB, sA);\n\t\tif(sA) {\n\t\t    DISEMBLE_RGBA(dst, dstbpp, dstfmt, Pixel, dR, dG, dB, dA);\n\t\t    ALPHA_BLEND_RGBA(sR, sG, sB, sA, dR, dG, dB, dA);\n\t\t    ASSEMBLE_RGBA(dst, dstbpp, dstfmt, dR, dG, dB, dA);\n\t\t}\n\t\tsrc += srcbpp;\n\t\tdst += dstbpp;\n\t    },\n\t    width);\n\t    /* *INDENT-ON* */\n        src += srcskip;\n        dst += dstskip;\n    }\n}\n\n\nSDL_BlitFunc\nSDL_CalculateBlitA(SDL_Surface * surface)\n{\n    SDL_PixelFormat *sf = surface->format;\n    SDL_PixelFormat *df = surface->map->dst->format;\n\n    switch (surface->map->info.flags & ~SDL_COPY_RLE_MASK) {\n    case SDL_COPY_BLEND:\n        /* Per-pixel alpha blits */\n        switch (df->BytesPerPixel) {\n        case 1:\n            return BlitNto1PixelAlpha;\n\n        case 2:\n                if (sf->BytesPerPixel == 4 && sf->Amask == 0xff000000\n                    && sf->Gmask == 0xff00\n                    && ((sf->Rmask == 0xff && df->Rmask == 0x1f)\n                        || (sf->Bmask == 0xff && df->Bmask == 0x1f))) {\n                if (df->Gmask == 0x7e0)\n                    return BlitARGBto565PixelAlpha;\n                else if (df->Gmask == 0x3e0)\n                    return BlitARGBto555PixelAlpha;\n            }\n            return BlitNtoNPixelAlpha;\n\n        case 4:\n            if (sf->Rmask == df->Rmask\n                && sf->Gmask == df->Gmask\n                && sf->Bmask == df->Bmask && sf->BytesPerPixel == 4) {\n#if defined(__MMX__) || defined(__3dNOW__)\n                if (sf->Rshift % 8 == 0\n                    && sf->Gshift % 8 == 0\n                    && sf->Bshift % 8 == 0\n                    && sf->Ashift % 8 == 0 && sf->Aloss == 0) {\n#ifdef __3dNOW__\n                    if (SDL_Has3DNow())\n                        return BlitRGBtoRGBPixelAlphaMMX3DNOW;\n#endif\n#ifdef __MMX__\n                    if (SDL_HasMMX())\n                        return BlitRGBtoRGBPixelAlphaMMX;\n#endif\n                }\n#endif /* __MMX__ || __3dNOW__ */\n                if (sf->Amask == 0xff000000) {\n                    return BlitRGBtoRGBPixelAlpha;\n                }\n            }\n            return BlitNtoNPixelAlpha;\n\n        case 3:\n        default:\n            return BlitNtoNPixelAlpha;\n        }\n        break;\n\n    case SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND:\n        if (sf->Amask == 0) {\n            /* Per-surface alpha blits */\n            switch (df->BytesPerPixel) {\n            case 1:\n                return BlitNto1SurfaceAlpha;\n\n            case 2:\n                if (surface->map->identity) {\n                    if (df->Gmask == 0x7e0) {\n#ifdef __MMX__\n                        if (SDL_HasMMX())\n                            return Blit565to565SurfaceAlphaMMX;\n                        else\n#endif\n                            return Blit565to565SurfaceAlpha;\n                    } else if (df->Gmask == 0x3e0) {\n#ifdef __MMX__\n                        if (SDL_HasMMX())\n                            return Blit555to555SurfaceAlphaMMX;\n                        else\n#endif\n                            return Blit555to555SurfaceAlpha;\n                    }\n                }\n                return BlitNtoNSurfaceAlpha;\n\n            case 4:\n                if (sf->Rmask == df->Rmask\n                    && sf->Gmask == df->Gmask\n                    && sf->Bmask == df->Bmask && sf->BytesPerPixel == 4) {\n#ifdef __MMX__\n                    if (sf->Rshift % 8 == 0\n                        && sf->Gshift % 8 == 0\n                        && sf->Bshift % 8 == 0 && SDL_HasMMX())\n                        return BlitRGBtoRGBSurfaceAlphaMMX;\n#endif\n                    if ((sf->Rmask | sf->Gmask | sf->Bmask) == 0xffffff) {\n                        return BlitRGBtoRGBSurfaceAlpha;\n                    }\n                }\n                return BlitNtoNSurfaceAlpha;\n\n            case 3:\n            default:\n                return BlitNtoNSurfaceAlpha;\n            }\n        }\n        break;\n\n    case SDL_COPY_COLORKEY | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND:\n        if (sf->Amask == 0) {\n            if (df->BytesPerPixel == 1) {\n                return BlitNto1SurfaceAlphaKey;\n            } else {\n                return BlitNtoNSurfaceAlphaKey;\n            }\n        }\n        break;\n    }\n\n    return NULL;\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/* DO NOT EDIT!  This file is generated by sdlgenblit.pl */\n/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../SDL_internal.h\"\n\n/* *INDENT-OFF* */\n\n#include \"SDL_video.h\"\n#include \"SDL_blit.h\"\n#include \"SDL_blit_auto.h\"\n\nstatic void SDL_Blit_RGB888_RGB888_Scale(SDL_BlitInfo *info)\n{\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            *dst = *src;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGB888_RGB888_Blend(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            srcpixel = *src;\n            srcR = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcB = (Uint8)srcpixel; srcA = 0xFF;\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel;\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGB888_RGB888_Blend_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            srcpixel = *src;\n            srcR = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcB = (Uint8)srcpixel; srcA = 0xFF;\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel;\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGB888_RGB888_Modulate(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    Uint32 pixel;\n    Uint32 R, G, B;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            pixel = *src;\n            R = (Uint8)(pixel >> 16); G = (Uint8)(pixel >> 8); B = (Uint8)pixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                R = (R * modulateR) / 255;\n                G = (G * modulateG) / 255;\n                B = (B * modulateB) / 255;\n            }\n            pixel = ((Uint32)R << 16) | ((Uint32)G << 8) | B;\n            *dst = pixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGB888_RGB888_Modulate_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    Uint32 pixel;\n    Uint32 R, G, B;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            pixel = *src;\n            R = (Uint8)(pixel >> 16); G = (Uint8)(pixel >> 8); B = (Uint8)pixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                R = (R * modulateR) / 255;\n                G = (G * modulateG) / 255;\n                B = (B * modulateB) / 255;\n            }\n            pixel = ((Uint32)R << 16) | ((Uint32)G << 8) | B;\n            *dst = pixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGB888_RGB888_Modulate_Blend(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            srcpixel = *src;\n            srcR = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcB = (Uint8)srcpixel; srcA = 0xFF;\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGB888_RGB888_Modulate_Blend_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            srcpixel = *src;\n            srcR = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcB = (Uint8)srcpixel; srcA = 0xFF;\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGB888_BGR888_Scale(SDL_BlitInfo *info)\n{\n    Uint32 pixel;\n    Uint32 R, G, B;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            pixel = *src;\n            R = (Uint8)(pixel >> 16); G = (Uint8)(pixel >> 8); B = (Uint8)pixel;\n            pixel = ((Uint32)B << 16) | ((Uint32)G << 8) | R;\n            *dst = pixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGB888_BGR888_Blend(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            srcpixel = *src;\n            srcR = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcB = (Uint8)srcpixel; srcA = 0xFF;\n            dstpixel = *dst;\n            dstB = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstR = (Uint8)dstpixel;\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstB << 16) | ((Uint32)dstG << 8) | dstR;\n            *dst = dstpixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGB888_BGR888_Blend_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            srcpixel = *src;\n            srcR = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcB = (Uint8)srcpixel; srcA = 0xFF;\n            dstpixel = *dst;\n            dstB = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstR = (Uint8)dstpixel;\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstB << 16) | ((Uint32)dstG << 8) | dstR;\n            *dst = dstpixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGB888_BGR888_Modulate(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    Uint32 pixel;\n    Uint32 R, G, B;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            pixel = *src;\n            R = (Uint8)(pixel >> 16); G = (Uint8)(pixel >> 8); B = (Uint8)pixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                R = (R * modulateR) / 255;\n                G = (G * modulateG) / 255;\n                B = (B * modulateB) / 255;\n            }\n            pixel = ((Uint32)B << 16) | ((Uint32)G << 8) | R;\n            *dst = pixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGB888_BGR888_Modulate_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    Uint32 pixel;\n    Uint32 R, G, B;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            pixel = *src;\n            R = (Uint8)(pixel >> 16); G = (Uint8)(pixel >> 8); B = (Uint8)pixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                R = (R * modulateR) / 255;\n                G = (G * modulateG) / 255;\n                B = (B * modulateB) / 255;\n            }\n            pixel = ((Uint32)B << 16) | ((Uint32)G << 8) | R;\n            *dst = pixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGB888_BGR888_Modulate_Blend(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            srcpixel = *src;\n            srcR = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcB = (Uint8)srcpixel; srcA = 0xFF;\n            dstpixel = *dst;\n            dstB = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstR = (Uint8)dstpixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstB << 16) | ((Uint32)dstG << 8) | dstR;\n            *dst = dstpixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGB888_BGR888_Modulate_Blend_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            srcpixel = *src;\n            srcR = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcB = (Uint8)srcpixel; srcA = 0xFF;\n            dstpixel = *dst;\n            dstB = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstR = (Uint8)dstpixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstB << 16) | ((Uint32)dstG << 8) | dstR;\n            *dst = dstpixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGB888_ARGB8888_Scale(SDL_BlitInfo *info)\n{\n    Uint32 pixel;\n    Uint32 R, G, B, A;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            pixel = *src;\n            R = (Uint8)(pixel >> 16); G = (Uint8)(pixel >> 8); B = (Uint8)pixel; A = 0xFF;\n            pixel = ((Uint32)A << 24) | ((Uint32)R << 16) | ((Uint32)G << 8) | B;\n            *dst = pixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGB888_ARGB8888_Blend(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB, dstA;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            srcpixel = *src;\n            srcR = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcB = (Uint8)srcpixel; srcA = 0xFF;\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel; dstA = (Uint8)(dstpixel >> 24);\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                dstA = srcA + ((255 - srcA) * dstA) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstA << 24) | ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGB888_ARGB8888_Blend_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB, dstA;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            srcpixel = *src;\n            srcR = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcB = (Uint8)srcpixel; srcA = 0xFF;\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel; dstA = (Uint8)(dstpixel >> 24);\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                dstA = srcA + ((255 - srcA) * dstA) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstA << 24) | ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGB888_ARGB8888_Modulate(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 pixel;\n    Uint32 R, G, B, A;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            pixel = *src;\n            R = (Uint8)(pixel >> 16); G = (Uint8)(pixel >> 8); B = (Uint8)pixel; A = 0xFF;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                R = (R * modulateR) / 255;\n                G = (G * modulateG) / 255;\n                B = (B * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                A = (A * modulateA) / 255;\n            }\n            pixel = ((Uint32)A << 24) | ((Uint32)R << 16) | ((Uint32)G << 8) | B;\n            *dst = pixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGB888_ARGB8888_Modulate_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 pixel;\n    Uint32 R, G, B, A;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            pixel = *src;\n            R = (Uint8)(pixel >> 16); G = (Uint8)(pixel >> 8); B = (Uint8)pixel; A = 0xFF;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                R = (R * modulateR) / 255;\n                G = (G * modulateG) / 255;\n                B = (B * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                A = (A * modulateA) / 255;\n            }\n            pixel = ((Uint32)A << 24) | ((Uint32)R << 16) | ((Uint32)G << 8) | B;\n            *dst = pixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGB888_ARGB8888_Modulate_Blend(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB, dstA;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            srcpixel = *src;\n            srcR = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcB = (Uint8)srcpixel; srcA = 0xFF;\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel; dstA = (Uint8)(dstpixel >> 24);\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                dstA = srcA + ((255 - srcA) * dstA) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstA << 24) | ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGB888_ARGB8888_Modulate_Blend_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB, dstA;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            srcpixel = *src;\n            srcR = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcB = (Uint8)srcpixel; srcA = 0xFF;\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel; dstA = (Uint8)(dstpixel >> 24);\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                dstA = srcA + ((255 - srcA) * dstA) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstA << 24) | ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGR888_RGB888_Scale(SDL_BlitInfo *info)\n{\n    Uint32 pixel;\n    Uint32 R, G, B;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            pixel = *src;\n            B = (Uint8)(pixel >> 16); G = (Uint8)(pixel >> 8); R = (Uint8)pixel;\n            pixel = ((Uint32)R << 16) | ((Uint32)G << 8) | B;\n            *dst = pixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGR888_RGB888_Blend(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            srcpixel = *src;\n            srcB = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcR = (Uint8)srcpixel; srcA = 0xFF;\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel;\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGR888_RGB888_Blend_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            srcpixel = *src;\n            srcB = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcR = (Uint8)srcpixel; srcA = 0xFF;\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel;\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGR888_RGB888_Modulate(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    Uint32 pixel;\n    Uint32 R, G, B;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            pixel = *src;\n            B = (Uint8)(pixel >> 16); G = (Uint8)(pixel >> 8); R = (Uint8)pixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                R = (R * modulateR) / 255;\n                G = (G * modulateG) / 255;\n                B = (B * modulateB) / 255;\n            }\n            pixel = ((Uint32)R << 16) | ((Uint32)G << 8) | B;\n            *dst = pixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGR888_RGB888_Modulate_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    Uint32 pixel;\n    Uint32 R, G, B;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            pixel = *src;\n            B = (Uint8)(pixel >> 16); G = (Uint8)(pixel >> 8); R = (Uint8)pixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                R = (R * modulateR) / 255;\n                G = (G * modulateG) / 255;\n                B = (B * modulateB) / 255;\n            }\n            pixel = ((Uint32)R << 16) | ((Uint32)G << 8) | B;\n            *dst = pixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGR888_RGB888_Modulate_Blend(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            srcpixel = *src;\n            srcB = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcR = (Uint8)srcpixel; srcA = 0xFF;\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGR888_RGB888_Modulate_Blend_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            srcpixel = *src;\n            srcB = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcR = (Uint8)srcpixel; srcA = 0xFF;\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGR888_BGR888_Scale(SDL_BlitInfo *info)\n{\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            *dst = *src;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGR888_BGR888_Blend(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            srcpixel = *src;\n            srcB = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcR = (Uint8)srcpixel; srcA = 0xFF;\n            dstpixel = *dst;\n            dstB = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstR = (Uint8)dstpixel;\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstB << 16) | ((Uint32)dstG << 8) | dstR;\n            *dst = dstpixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGR888_BGR888_Blend_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            srcpixel = *src;\n            srcB = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcR = (Uint8)srcpixel; srcA = 0xFF;\n            dstpixel = *dst;\n            dstB = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstR = (Uint8)dstpixel;\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstB << 16) | ((Uint32)dstG << 8) | dstR;\n            *dst = dstpixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGR888_BGR888_Modulate(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    Uint32 pixel;\n    Uint32 R, G, B;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            pixel = *src;\n            B = (Uint8)(pixel >> 16); G = (Uint8)(pixel >> 8); R = (Uint8)pixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                R = (R * modulateR) / 255;\n                G = (G * modulateG) / 255;\n                B = (B * modulateB) / 255;\n            }\n            pixel = ((Uint32)B << 16) | ((Uint32)G << 8) | R;\n            *dst = pixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGR888_BGR888_Modulate_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    Uint32 pixel;\n    Uint32 R, G, B;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            pixel = *src;\n            B = (Uint8)(pixel >> 16); G = (Uint8)(pixel >> 8); R = (Uint8)pixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                R = (R * modulateR) / 255;\n                G = (G * modulateG) / 255;\n                B = (B * modulateB) / 255;\n            }\n            pixel = ((Uint32)B << 16) | ((Uint32)G << 8) | R;\n            *dst = pixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGR888_BGR888_Modulate_Blend(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            srcpixel = *src;\n            srcB = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcR = (Uint8)srcpixel; srcA = 0xFF;\n            dstpixel = *dst;\n            dstB = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstR = (Uint8)dstpixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstB << 16) | ((Uint32)dstG << 8) | dstR;\n            *dst = dstpixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGR888_BGR888_Modulate_Blend_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            srcpixel = *src;\n            srcB = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcR = (Uint8)srcpixel; srcA = 0xFF;\n            dstpixel = *dst;\n            dstB = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstR = (Uint8)dstpixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstB << 16) | ((Uint32)dstG << 8) | dstR;\n            *dst = dstpixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGR888_ARGB8888_Scale(SDL_BlitInfo *info)\n{\n    Uint32 pixel;\n    Uint32 R, G, B, A;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            pixel = *src;\n            B = (Uint8)(pixel >> 16); G = (Uint8)(pixel >> 8); R = (Uint8)pixel; A = 0xFF;\n            pixel = ((Uint32)A << 24) | ((Uint32)R << 16) | ((Uint32)G << 8) | B;\n            *dst = pixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGR888_ARGB8888_Blend(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB, dstA;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            srcpixel = *src;\n            srcB = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcR = (Uint8)srcpixel; srcA = 0xFF;\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel; dstA = (Uint8)(dstpixel >> 24);\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                dstA = srcA + ((255 - srcA) * dstA) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstA << 24) | ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGR888_ARGB8888_Blend_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB, dstA;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            srcpixel = *src;\n            srcB = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcR = (Uint8)srcpixel; srcA = 0xFF;\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel; dstA = (Uint8)(dstpixel >> 24);\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                dstA = srcA + ((255 - srcA) * dstA) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstA << 24) | ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGR888_ARGB8888_Modulate(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 pixel;\n    Uint32 R, G, B, A;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            pixel = *src;\n            B = (Uint8)(pixel >> 16); G = (Uint8)(pixel >> 8); R = (Uint8)pixel; A = 0xFF;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                R = (R * modulateR) / 255;\n                G = (G * modulateG) / 255;\n                B = (B * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                A = (A * modulateA) / 255;\n            }\n            pixel = ((Uint32)A << 24) | ((Uint32)R << 16) | ((Uint32)G << 8) | B;\n            *dst = pixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGR888_ARGB8888_Modulate_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 pixel;\n    Uint32 R, G, B, A;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            pixel = *src;\n            B = (Uint8)(pixel >> 16); G = (Uint8)(pixel >> 8); R = (Uint8)pixel; A = 0xFF;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                R = (R * modulateR) / 255;\n                G = (G * modulateG) / 255;\n                B = (B * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                A = (A * modulateA) / 255;\n            }\n            pixel = ((Uint32)A << 24) | ((Uint32)R << 16) | ((Uint32)G << 8) | B;\n            *dst = pixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGR888_ARGB8888_Modulate_Blend(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB, dstA;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            srcpixel = *src;\n            srcB = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcR = (Uint8)srcpixel; srcA = 0xFF;\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel; dstA = (Uint8)(dstpixel >> 24);\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                dstA = srcA + ((255 - srcA) * dstA) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstA << 24) | ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGR888_ARGB8888_Modulate_Blend_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB, dstA;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            srcpixel = *src;\n            srcB = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcR = (Uint8)srcpixel; srcA = 0xFF;\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel; dstA = (Uint8)(dstpixel >> 24);\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                dstA = srcA + ((255 - srcA) * dstA) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstA << 24) | ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ARGB8888_RGB888_Scale(SDL_BlitInfo *info)\n{\n    Uint32 pixel;\n    Uint32 R, G, B;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            pixel = *src;\n            R = (Uint8)(pixel >> 16); G = (Uint8)(pixel >> 8); B = (Uint8)pixel;\n            pixel = ((Uint32)R << 16) | ((Uint32)G << 8) | B;\n            *dst = pixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ARGB8888_RGB888_Blend(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            srcpixel = *src;\n            srcR = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcB = (Uint8)srcpixel; srcA = (Uint8)(srcpixel >> 24);\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel;\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ARGB8888_RGB888_Blend_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            srcpixel = *src;\n            srcR = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcB = (Uint8)srcpixel; srcA = (Uint8)(srcpixel >> 24);\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel;\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ARGB8888_RGB888_Modulate(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    Uint32 pixel;\n    Uint32 R, G, B;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            pixel = *src;\n            R = (Uint8)(pixel >> 16); G = (Uint8)(pixel >> 8); B = (Uint8)pixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                R = (R * modulateR) / 255;\n                G = (G * modulateG) / 255;\n                B = (B * modulateB) / 255;\n            }\n            pixel = ((Uint32)R << 16) | ((Uint32)G << 8) | B;\n            *dst = pixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ARGB8888_RGB888_Modulate_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    Uint32 pixel;\n    Uint32 R, G, B;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            pixel = *src;\n            R = (Uint8)(pixel >> 16); G = (Uint8)(pixel >> 8); B = (Uint8)pixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                R = (R * modulateR) / 255;\n                G = (G * modulateG) / 255;\n                B = (B * modulateB) / 255;\n            }\n            pixel = ((Uint32)R << 16) | ((Uint32)G << 8) | B;\n            *dst = pixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ARGB8888_RGB888_Modulate_Blend(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            srcpixel = *src;\n            srcR = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcB = (Uint8)srcpixel; srcA = (Uint8)(srcpixel >> 24);\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ARGB8888_RGB888_Modulate_Blend_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            srcpixel = *src;\n            srcR = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcB = (Uint8)srcpixel; srcA = (Uint8)(srcpixel >> 24);\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ARGB8888_BGR888_Scale(SDL_BlitInfo *info)\n{\n    Uint32 pixel;\n    Uint32 R, G, B;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            pixel = *src;\n            R = (Uint8)(pixel >> 16); G = (Uint8)(pixel >> 8); B = (Uint8)pixel;\n            pixel = ((Uint32)B << 16) | ((Uint32)G << 8) | R;\n            *dst = pixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ARGB8888_BGR888_Blend(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            srcpixel = *src;\n            srcR = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcB = (Uint8)srcpixel; srcA = (Uint8)(srcpixel >> 24);\n            dstpixel = *dst;\n            dstB = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstR = (Uint8)dstpixel;\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstB << 16) | ((Uint32)dstG << 8) | dstR;\n            *dst = dstpixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ARGB8888_BGR888_Blend_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            srcpixel = *src;\n            srcR = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcB = (Uint8)srcpixel; srcA = (Uint8)(srcpixel >> 24);\n            dstpixel = *dst;\n            dstB = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstR = (Uint8)dstpixel;\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstB << 16) | ((Uint32)dstG << 8) | dstR;\n            *dst = dstpixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ARGB8888_BGR888_Modulate(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    Uint32 pixel;\n    Uint32 R, G, B;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            pixel = *src;\n            R = (Uint8)(pixel >> 16); G = (Uint8)(pixel >> 8); B = (Uint8)pixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                R = (R * modulateR) / 255;\n                G = (G * modulateG) / 255;\n                B = (B * modulateB) / 255;\n            }\n            pixel = ((Uint32)B << 16) | ((Uint32)G << 8) | R;\n            *dst = pixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ARGB8888_BGR888_Modulate_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    Uint32 pixel;\n    Uint32 R, G, B;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            pixel = *src;\n            R = (Uint8)(pixel >> 16); G = (Uint8)(pixel >> 8); B = (Uint8)pixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                R = (R * modulateR) / 255;\n                G = (G * modulateG) / 255;\n                B = (B * modulateB) / 255;\n            }\n            pixel = ((Uint32)B << 16) | ((Uint32)G << 8) | R;\n            *dst = pixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ARGB8888_BGR888_Modulate_Blend(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            srcpixel = *src;\n            srcR = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcB = (Uint8)srcpixel; srcA = (Uint8)(srcpixel >> 24);\n            dstpixel = *dst;\n            dstB = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstR = (Uint8)dstpixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstB << 16) | ((Uint32)dstG << 8) | dstR;\n            *dst = dstpixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ARGB8888_BGR888_Modulate_Blend_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            srcpixel = *src;\n            srcR = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcB = (Uint8)srcpixel; srcA = (Uint8)(srcpixel >> 24);\n            dstpixel = *dst;\n            dstB = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstR = (Uint8)dstpixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstB << 16) | ((Uint32)dstG << 8) | dstR;\n            *dst = dstpixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ARGB8888_ARGB8888_Scale(SDL_BlitInfo *info)\n{\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            *dst = *src;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ARGB8888_ARGB8888_Blend(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB, dstA;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            srcpixel = *src;\n            srcR = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcB = (Uint8)srcpixel; srcA = (Uint8)(srcpixel >> 24);\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel; dstA = (Uint8)(dstpixel >> 24);\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                dstA = srcA + ((255 - srcA) * dstA) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstA << 24) | ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ARGB8888_ARGB8888_Blend_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB, dstA;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            srcpixel = *src;\n            srcR = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcB = (Uint8)srcpixel; srcA = (Uint8)(srcpixel >> 24);\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel; dstA = (Uint8)(dstpixel >> 24);\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                dstA = srcA + ((255 - srcA) * dstA) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstA << 24) | ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ARGB8888_ARGB8888_Modulate(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 pixel;\n    Uint32 R, G, B, A;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            pixel = *src;\n            R = (Uint8)(pixel >> 16); G = (Uint8)(pixel >> 8); B = (Uint8)pixel; A = (Uint8)(pixel >> 24);\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                R = (R * modulateR) / 255;\n                G = (G * modulateG) / 255;\n                B = (B * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                A = (A * modulateA) / 255;\n            }\n            pixel = ((Uint32)A << 24) | ((Uint32)R << 16) | ((Uint32)G << 8) | B;\n            *dst = pixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ARGB8888_ARGB8888_Modulate_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 pixel;\n    Uint32 R, G, B, A;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            pixel = *src;\n            R = (Uint8)(pixel >> 16); G = (Uint8)(pixel >> 8); B = (Uint8)pixel; A = (Uint8)(pixel >> 24);\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                R = (R * modulateR) / 255;\n                G = (G * modulateG) / 255;\n                B = (B * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                A = (A * modulateA) / 255;\n            }\n            pixel = ((Uint32)A << 24) | ((Uint32)R << 16) | ((Uint32)G << 8) | B;\n            *dst = pixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ARGB8888_ARGB8888_Modulate_Blend(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB, dstA;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            srcpixel = *src;\n            srcR = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcB = (Uint8)srcpixel; srcA = (Uint8)(srcpixel >> 24);\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel; dstA = (Uint8)(dstpixel >> 24);\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                dstA = srcA + ((255 - srcA) * dstA) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstA << 24) | ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ARGB8888_ARGB8888_Modulate_Blend_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB, dstA;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            srcpixel = *src;\n            srcR = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcB = (Uint8)srcpixel; srcA = (Uint8)(srcpixel >> 24);\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel; dstA = (Uint8)(dstpixel >> 24);\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                dstA = srcA + ((255 - srcA) * dstA) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstA << 24) | ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGBA8888_RGB888_Scale(SDL_BlitInfo *info)\n{\n    Uint32 pixel;\n    Uint32 R, G, B;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            pixel = *src;\n            R = (Uint8)(pixel >> 24); G = (Uint8)(pixel >> 16); B = (Uint8)(pixel >> 8);\n            pixel = ((Uint32)R << 16) | ((Uint32)G << 8) | B;\n            *dst = pixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGBA8888_RGB888_Blend(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            srcpixel = *src;\n            srcR = (Uint8)(srcpixel >> 24); srcG = (Uint8)(srcpixel >> 16); srcB = (Uint8)(srcpixel >> 8); srcA = (Uint8)srcpixel;\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel;\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGBA8888_RGB888_Blend_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            srcpixel = *src;\n            srcR = (Uint8)(srcpixel >> 24); srcG = (Uint8)(srcpixel >> 16); srcB = (Uint8)(srcpixel >> 8); srcA = (Uint8)srcpixel;\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel;\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGBA8888_RGB888_Modulate(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    Uint32 pixel;\n    Uint32 R, G, B;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            pixel = *src;\n            R = (Uint8)(pixel >> 24); G = (Uint8)(pixel >> 16); B = (Uint8)(pixel >> 8);\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                R = (R * modulateR) / 255;\n                G = (G * modulateG) / 255;\n                B = (B * modulateB) / 255;\n            }\n            pixel = ((Uint32)R << 16) | ((Uint32)G << 8) | B;\n            *dst = pixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGBA8888_RGB888_Modulate_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    Uint32 pixel;\n    Uint32 R, G, B;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            pixel = *src;\n            R = (Uint8)(pixel >> 24); G = (Uint8)(pixel >> 16); B = (Uint8)(pixel >> 8);\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                R = (R * modulateR) / 255;\n                G = (G * modulateG) / 255;\n                B = (B * modulateB) / 255;\n            }\n            pixel = ((Uint32)R << 16) | ((Uint32)G << 8) | B;\n            *dst = pixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGBA8888_RGB888_Modulate_Blend(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            srcpixel = *src;\n            srcR = (Uint8)(srcpixel >> 24); srcG = (Uint8)(srcpixel >> 16); srcB = (Uint8)(srcpixel >> 8); srcA = (Uint8)srcpixel;\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGBA8888_RGB888_Modulate_Blend_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            srcpixel = *src;\n            srcR = (Uint8)(srcpixel >> 24); srcG = (Uint8)(srcpixel >> 16); srcB = (Uint8)(srcpixel >> 8); srcA = (Uint8)srcpixel;\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGBA8888_BGR888_Scale(SDL_BlitInfo *info)\n{\n    Uint32 pixel;\n    Uint32 R, G, B;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            pixel = *src;\n            R = (Uint8)(pixel >> 24); G = (Uint8)(pixel >> 16); B = (Uint8)(pixel >> 8);\n            pixel = ((Uint32)B << 16) | ((Uint32)G << 8) | R;\n            *dst = pixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGBA8888_BGR888_Blend(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            srcpixel = *src;\n            srcR = (Uint8)(srcpixel >> 24); srcG = (Uint8)(srcpixel >> 16); srcB = (Uint8)(srcpixel >> 8); srcA = (Uint8)srcpixel;\n            dstpixel = *dst;\n            dstB = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstR = (Uint8)dstpixel;\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstB << 16) | ((Uint32)dstG << 8) | dstR;\n            *dst = dstpixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGBA8888_BGR888_Blend_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            srcpixel = *src;\n            srcR = (Uint8)(srcpixel >> 24); srcG = (Uint8)(srcpixel >> 16); srcB = (Uint8)(srcpixel >> 8); srcA = (Uint8)srcpixel;\n            dstpixel = *dst;\n            dstB = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstR = (Uint8)dstpixel;\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstB << 16) | ((Uint32)dstG << 8) | dstR;\n            *dst = dstpixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGBA8888_BGR888_Modulate(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    Uint32 pixel;\n    Uint32 R, G, B;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            pixel = *src;\n            R = (Uint8)(pixel >> 24); G = (Uint8)(pixel >> 16); B = (Uint8)(pixel >> 8);\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                R = (R * modulateR) / 255;\n                G = (G * modulateG) / 255;\n                B = (B * modulateB) / 255;\n            }\n            pixel = ((Uint32)B << 16) | ((Uint32)G << 8) | R;\n            *dst = pixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGBA8888_BGR888_Modulate_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    Uint32 pixel;\n    Uint32 R, G, B;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            pixel = *src;\n            R = (Uint8)(pixel >> 24); G = (Uint8)(pixel >> 16); B = (Uint8)(pixel >> 8);\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                R = (R * modulateR) / 255;\n                G = (G * modulateG) / 255;\n                B = (B * modulateB) / 255;\n            }\n            pixel = ((Uint32)B << 16) | ((Uint32)G << 8) | R;\n            *dst = pixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGBA8888_BGR888_Modulate_Blend(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            srcpixel = *src;\n            srcR = (Uint8)(srcpixel >> 24); srcG = (Uint8)(srcpixel >> 16); srcB = (Uint8)(srcpixel >> 8); srcA = (Uint8)srcpixel;\n            dstpixel = *dst;\n            dstB = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstR = (Uint8)dstpixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstB << 16) | ((Uint32)dstG << 8) | dstR;\n            *dst = dstpixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGBA8888_BGR888_Modulate_Blend_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            srcpixel = *src;\n            srcR = (Uint8)(srcpixel >> 24); srcG = (Uint8)(srcpixel >> 16); srcB = (Uint8)(srcpixel >> 8); srcA = (Uint8)srcpixel;\n            dstpixel = *dst;\n            dstB = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstR = (Uint8)dstpixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstB << 16) | ((Uint32)dstG << 8) | dstR;\n            *dst = dstpixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGBA8888_ARGB8888_Scale(SDL_BlitInfo *info)\n{\n    Uint32 pixel;\n    Uint32 R, G, B, A;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            pixel = *src;\n            R = (Uint8)(pixel >> 24); G = (Uint8)(pixel >> 16); B = (Uint8)(pixel >> 8); A = (Uint8)pixel;\n            pixel = ((Uint32)A << 24) | ((Uint32)R << 16) | ((Uint32)G << 8) | B;\n            *dst = pixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGBA8888_ARGB8888_Blend(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB, dstA;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            srcpixel = *src;\n            srcR = (Uint8)(srcpixel >> 24); srcG = (Uint8)(srcpixel >> 16); srcB = (Uint8)(srcpixel >> 8); srcA = (Uint8)srcpixel;\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel; dstA = (Uint8)(dstpixel >> 24);\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                dstA = srcA + ((255 - srcA) * dstA) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstA << 24) | ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGBA8888_ARGB8888_Blend_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB, dstA;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            srcpixel = *src;\n            srcR = (Uint8)(srcpixel >> 24); srcG = (Uint8)(srcpixel >> 16); srcB = (Uint8)(srcpixel >> 8); srcA = (Uint8)srcpixel;\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel; dstA = (Uint8)(dstpixel >> 24);\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                dstA = srcA + ((255 - srcA) * dstA) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstA << 24) | ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGBA8888_ARGB8888_Modulate(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 pixel;\n    Uint32 R, G, B, A;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            pixel = *src;\n            R = (Uint8)(pixel >> 24); G = (Uint8)(pixel >> 16); B = (Uint8)(pixel >> 8); A = (Uint8)pixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                R = (R * modulateR) / 255;\n                G = (G * modulateG) / 255;\n                B = (B * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                A = (A * modulateA) / 255;\n            }\n            pixel = ((Uint32)A << 24) | ((Uint32)R << 16) | ((Uint32)G << 8) | B;\n            *dst = pixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGBA8888_ARGB8888_Modulate_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 pixel;\n    Uint32 R, G, B, A;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            pixel = *src;\n            R = (Uint8)(pixel >> 24); G = (Uint8)(pixel >> 16); B = (Uint8)(pixel >> 8); A = (Uint8)pixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                R = (R * modulateR) / 255;\n                G = (G * modulateG) / 255;\n                B = (B * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                A = (A * modulateA) / 255;\n            }\n            pixel = ((Uint32)A << 24) | ((Uint32)R << 16) | ((Uint32)G << 8) | B;\n            *dst = pixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGBA8888_ARGB8888_Modulate_Blend(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB, dstA;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            srcpixel = *src;\n            srcR = (Uint8)(srcpixel >> 24); srcG = (Uint8)(srcpixel >> 16); srcB = (Uint8)(srcpixel >> 8); srcA = (Uint8)srcpixel;\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel; dstA = (Uint8)(dstpixel >> 24);\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                dstA = srcA + ((255 - srcA) * dstA) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstA << 24) | ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_RGBA8888_ARGB8888_Modulate_Blend_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB, dstA;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            srcpixel = *src;\n            srcR = (Uint8)(srcpixel >> 24); srcG = (Uint8)(srcpixel >> 16); srcB = (Uint8)(srcpixel >> 8); srcA = (Uint8)srcpixel;\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel; dstA = (Uint8)(dstpixel >> 24);\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                dstA = srcA + ((255 - srcA) * dstA) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstA << 24) | ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ABGR8888_RGB888_Scale(SDL_BlitInfo *info)\n{\n    Uint32 pixel;\n    Uint32 R, G, B;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            pixel = *src;\n            B = (Uint8)(pixel >> 16); G = (Uint8)(pixel >> 8); R = (Uint8)pixel;\n            pixel = ((Uint32)R << 16) | ((Uint32)G << 8) | B;\n            *dst = pixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ABGR8888_RGB888_Blend(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            srcpixel = *src;\n            srcB = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcR = (Uint8)srcpixel; srcA = (Uint8)(srcpixel >> 24);\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel;\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ABGR8888_RGB888_Blend_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            srcpixel = *src;\n            srcB = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcR = (Uint8)srcpixel; srcA = (Uint8)(srcpixel >> 24);\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel;\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ABGR8888_RGB888_Modulate(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    Uint32 pixel;\n    Uint32 R, G, B;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            pixel = *src;\n            B = (Uint8)(pixel >> 16); G = (Uint8)(pixel >> 8); R = (Uint8)pixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                R = (R * modulateR) / 255;\n                G = (G * modulateG) / 255;\n                B = (B * modulateB) / 255;\n            }\n            pixel = ((Uint32)R << 16) | ((Uint32)G << 8) | B;\n            *dst = pixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ABGR8888_RGB888_Modulate_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    Uint32 pixel;\n    Uint32 R, G, B;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            pixel = *src;\n            B = (Uint8)(pixel >> 16); G = (Uint8)(pixel >> 8); R = (Uint8)pixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                R = (R * modulateR) / 255;\n                G = (G * modulateG) / 255;\n                B = (B * modulateB) / 255;\n            }\n            pixel = ((Uint32)R << 16) | ((Uint32)G << 8) | B;\n            *dst = pixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ABGR8888_RGB888_Modulate_Blend(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            srcpixel = *src;\n            srcB = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcR = (Uint8)srcpixel; srcA = (Uint8)(srcpixel >> 24);\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ABGR8888_RGB888_Modulate_Blend_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            srcpixel = *src;\n            srcB = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcR = (Uint8)srcpixel; srcA = (Uint8)(srcpixel >> 24);\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ABGR8888_BGR888_Scale(SDL_BlitInfo *info)\n{\n    Uint32 pixel;\n    Uint32 R, G, B;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            pixel = *src;\n            B = (Uint8)(pixel >> 16); G = (Uint8)(pixel >> 8); R = (Uint8)pixel;\n            pixel = ((Uint32)B << 16) | ((Uint32)G << 8) | R;\n            *dst = pixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ABGR8888_BGR888_Blend(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            srcpixel = *src;\n            srcB = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcR = (Uint8)srcpixel; srcA = (Uint8)(srcpixel >> 24);\n            dstpixel = *dst;\n            dstB = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstR = (Uint8)dstpixel;\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstB << 16) | ((Uint32)dstG << 8) | dstR;\n            *dst = dstpixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ABGR8888_BGR888_Blend_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            srcpixel = *src;\n            srcB = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcR = (Uint8)srcpixel; srcA = (Uint8)(srcpixel >> 24);\n            dstpixel = *dst;\n            dstB = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstR = (Uint8)dstpixel;\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstB << 16) | ((Uint32)dstG << 8) | dstR;\n            *dst = dstpixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ABGR8888_BGR888_Modulate(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    Uint32 pixel;\n    Uint32 R, G, B;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            pixel = *src;\n            B = (Uint8)(pixel >> 16); G = (Uint8)(pixel >> 8); R = (Uint8)pixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                R = (R * modulateR) / 255;\n                G = (G * modulateG) / 255;\n                B = (B * modulateB) / 255;\n            }\n            pixel = ((Uint32)B << 16) | ((Uint32)G << 8) | R;\n            *dst = pixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ABGR8888_BGR888_Modulate_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    Uint32 pixel;\n    Uint32 R, G, B;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            pixel = *src;\n            B = (Uint8)(pixel >> 16); G = (Uint8)(pixel >> 8); R = (Uint8)pixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                R = (R * modulateR) / 255;\n                G = (G * modulateG) / 255;\n                B = (B * modulateB) / 255;\n            }\n            pixel = ((Uint32)B << 16) | ((Uint32)G << 8) | R;\n            *dst = pixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ABGR8888_BGR888_Modulate_Blend(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            srcpixel = *src;\n            srcB = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcR = (Uint8)srcpixel; srcA = (Uint8)(srcpixel >> 24);\n            dstpixel = *dst;\n            dstB = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstR = (Uint8)dstpixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstB << 16) | ((Uint32)dstG << 8) | dstR;\n            *dst = dstpixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ABGR8888_BGR888_Modulate_Blend_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            srcpixel = *src;\n            srcB = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcR = (Uint8)srcpixel; srcA = (Uint8)(srcpixel >> 24);\n            dstpixel = *dst;\n            dstB = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstR = (Uint8)dstpixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstB << 16) | ((Uint32)dstG << 8) | dstR;\n            *dst = dstpixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ABGR8888_ARGB8888_Scale(SDL_BlitInfo *info)\n{\n    Uint32 pixel;\n    Uint32 R, G, B, A;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            pixel = *src;\n            B = (Uint8)(pixel >> 16); G = (Uint8)(pixel >> 8); R = (Uint8)pixel; A = (Uint8)(pixel >> 24);\n            pixel = ((Uint32)A << 24) | ((Uint32)R << 16) | ((Uint32)G << 8) | B;\n            *dst = pixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ABGR8888_ARGB8888_Blend(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB, dstA;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            srcpixel = *src;\n            srcB = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcR = (Uint8)srcpixel; srcA = (Uint8)(srcpixel >> 24);\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel; dstA = (Uint8)(dstpixel >> 24);\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                dstA = srcA + ((255 - srcA) * dstA) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstA << 24) | ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ABGR8888_ARGB8888_Blend_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB, dstA;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            srcpixel = *src;\n            srcB = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcR = (Uint8)srcpixel; srcA = (Uint8)(srcpixel >> 24);\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel; dstA = (Uint8)(dstpixel >> 24);\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                dstA = srcA + ((255 - srcA) * dstA) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstA << 24) | ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ABGR8888_ARGB8888_Modulate(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 pixel;\n    Uint32 R, G, B, A;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            pixel = *src;\n            B = (Uint8)(pixel >> 16); G = (Uint8)(pixel >> 8); R = (Uint8)pixel; A = (Uint8)(pixel >> 24);\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                R = (R * modulateR) / 255;\n                G = (G * modulateG) / 255;\n                B = (B * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                A = (A * modulateA) / 255;\n            }\n            pixel = ((Uint32)A << 24) | ((Uint32)R << 16) | ((Uint32)G << 8) | B;\n            *dst = pixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ABGR8888_ARGB8888_Modulate_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 pixel;\n    Uint32 R, G, B, A;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            pixel = *src;\n            B = (Uint8)(pixel >> 16); G = (Uint8)(pixel >> 8); R = (Uint8)pixel; A = (Uint8)(pixel >> 24);\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                R = (R * modulateR) / 255;\n                G = (G * modulateG) / 255;\n                B = (B * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                A = (A * modulateA) / 255;\n            }\n            pixel = ((Uint32)A << 24) | ((Uint32)R << 16) | ((Uint32)G << 8) | B;\n            *dst = pixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ABGR8888_ARGB8888_Modulate_Blend(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB, dstA;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            srcpixel = *src;\n            srcB = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcR = (Uint8)srcpixel; srcA = (Uint8)(srcpixel >> 24);\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel; dstA = (Uint8)(dstpixel >> 24);\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                dstA = srcA + ((255 - srcA) * dstA) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstA << 24) | ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_ABGR8888_ARGB8888_Modulate_Blend_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB, dstA;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            srcpixel = *src;\n            srcB = (Uint8)(srcpixel >> 16); srcG = (Uint8)(srcpixel >> 8); srcR = (Uint8)srcpixel; srcA = (Uint8)(srcpixel >> 24);\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel; dstA = (Uint8)(dstpixel >> 24);\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                dstA = srcA + ((255 - srcA) * dstA) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstA << 24) | ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGRA8888_RGB888_Scale(SDL_BlitInfo *info)\n{\n    Uint32 pixel;\n    Uint32 R, G, B;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            pixel = *src;\n            B = (Uint8)(pixel >> 24); G = (Uint8)(pixel >> 16); R = (Uint8)(pixel >> 8);\n            pixel = ((Uint32)R << 16) | ((Uint32)G << 8) | B;\n            *dst = pixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGRA8888_RGB888_Blend(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            srcpixel = *src;\n            srcB = (Uint8)(srcpixel >> 24); srcG = (Uint8)(srcpixel >> 16); srcR = (Uint8)(srcpixel >> 8); srcA = (Uint8)srcpixel;\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel;\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGRA8888_RGB888_Blend_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            srcpixel = *src;\n            srcB = (Uint8)(srcpixel >> 24); srcG = (Uint8)(srcpixel >> 16); srcR = (Uint8)(srcpixel >> 8); srcA = (Uint8)srcpixel;\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel;\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGRA8888_RGB888_Modulate(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    Uint32 pixel;\n    Uint32 R, G, B;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            pixel = *src;\n            B = (Uint8)(pixel >> 24); G = (Uint8)(pixel >> 16); R = (Uint8)(pixel >> 8);\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                R = (R * modulateR) / 255;\n                G = (G * modulateG) / 255;\n                B = (B * modulateB) / 255;\n            }\n            pixel = ((Uint32)R << 16) | ((Uint32)G << 8) | B;\n            *dst = pixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGRA8888_RGB888_Modulate_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    Uint32 pixel;\n    Uint32 R, G, B;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            pixel = *src;\n            B = (Uint8)(pixel >> 24); G = (Uint8)(pixel >> 16); R = (Uint8)(pixel >> 8);\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                R = (R * modulateR) / 255;\n                G = (G * modulateG) / 255;\n                B = (B * modulateB) / 255;\n            }\n            pixel = ((Uint32)R << 16) | ((Uint32)G << 8) | B;\n            *dst = pixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGRA8888_RGB888_Modulate_Blend(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            srcpixel = *src;\n            srcB = (Uint8)(srcpixel >> 24); srcG = (Uint8)(srcpixel >> 16); srcR = (Uint8)(srcpixel >> 8); srcA = (Uint8)srcpixel;\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGRA8888_RGB888_Modulate_Blend_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            srcpixel = *src;\n            srcB = (Uint8)(srcpixel >> 24); srcG = (Uint8)(srcpixel >> 16); srcR = (Uint8)(srcpixel >> 8); srcA = (Uint8)srcpixel;\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGRA8888_BGR888_Scale(SDL_BlitInfo *info)\n{\n    Uint32 pixel;\n    Uint32 R, G, B;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            pixel = *src;\n            B = (Uint8)(pixel >> 24); G = (Uint8)(pixel >> 16); R = (Uint8)(pixel >> 8);\n            pixel = ((Uint32)B << 16) | ((Uint32)G << 8) | R;\n            *dst = pixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGRA8888_BGR888_Blend(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            srcpixel = *src;\n            srcB = (Uint8)(srcpixel >> 24); srcG = (Uint8)(srcpixel >> 16); srcR = (Uint8)(srcpixel >> 8); srcA = (Uint8)srcpixel;\n            dstpixel = *dst;\n            dstB = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstR = (Uint8)dstpixel;\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstB << 16) | ((Uint32)dstG << 8) | dstR;\n            *dst = dstpixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGRA8888_BGR888_Blend_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            srcpixel = *src;\n            srcB = (Uint8)(srcpixel >> 24); srcG = (Uint8)(srcpixel >> 16); srcR = (Uint8)(srcpixel >> 8); srcA = (Uint8)srcpixel;\n            dstpixel = *dst;\n            dstB = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstR = (Uint8)dstpixel;\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstB << 16) | ((Uint32)dstG << 8) | dstR;\n            *dst = dstpixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGRA8888_BGR888_Modulate(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    Uint32 pixel;\n    Uint32 R, G, B;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            pixel = *src;\n            B = (Uint8)(pixel >> 24); G = (Uint8)(pixel >> 16); R = (Uint8)(pixel >> 8);\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                R = (R * modulateR) / 255;\n                G = (G * modulateG) / 255;\n                B = (B * modulateB) / 255;\n            }\n            pixel = ((Uint32)B << 16) | ((Uint32)G << 8) | R;\n            *dst = pixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGRA8888_BGR888_Modulate_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    Uint32 pixel;\n    Uint32 R, G, B;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            pixel = *src;\n            B = (Uint8)(pixel >> 24); G = (Uint8)(pixel >> 16); R = (Uint8)(pixel >> 8);\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                R = (R * modulateR) / 255;\n                G = (G * modulateG) / 255;\n                B = (B * modulateB) / 255;\n            }\n            pixel = ((Uint32)B << 16) | ((Uint32)G << 8) | R;\n            *dst = pixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGRA8888_BGR888_Modulate_Blend(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            srcpixel = *src;\n            srcB = (Uint8)(srcpixel >> 24); srcG = (Uint8)(srcpixel >> 16); srcR = (Uint8)(srcpixel >> 8); srcA = (Uint8)srcpixel;\n            dstpixel = *dst;\n            dstB = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstR = (Uint8)dstpixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstB << 16) | ((Uint32)dstG << 8) | dstR;\n            *dst = dstpixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGRA8888_BGR888_Modulate_Blend_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            srcpixel = *src;\n            srcB = (Uint8)(srcpixel >> 24); srcG = (Uint8)(srcpixel >> 16); srcR = (Uint8)(srcpixel >> 8); srcA = (Uint8)srcpixel;\n            dstpixel = *dst;\n            dstB = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstR = (Uint8)dstpixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstB << 16) | ((Uint32)dstG << 8) | dstR;\n            *dst = dstpixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGRA8888_ARGB8888_Scale(SDL_BlitInfo *info)\n{\n    Uint32 pixel;\n    Uint32 R, G, B, A;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            pixel = *src;\n            B = (Uint8)(pixel >> 24); G = (Uint8)(pixel >> 16); R = (Uint8)(pixel >> 8); A = (Uint8)pixel;\n            pixel = ((Uint32)A << 24) | ((Uint32)R << 16) | ((Uint32)G << 8) | B;\n            *dst = pixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGRA8888_ARGB8888_Blend(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB, dstA;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            srcpixel = *src;\n            srcB = (Uint8)(srcpixel >> 24); srcG = (Uint8)(srcpixel >> 16); srcR = (Uint8)(srcpixel >> 8); srcA = (Uint8)srcpixel;\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel; dstA = (Uint8)(dstpixel >> 24);\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                dstA = srcA + ((255 - srcA) * dstA) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstA << 24) | ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGRA8888_ARGB8888_Blend_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB, dstA;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            srcpixel = *src;\n            srcB = (Uint8)(srcpixel >> 24); srcG = (Uint8)(srcpixel >> 16); srcR = (Uint8)(srcpixel >> 8); srcA = (Uint8)srcpixel;\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel; dstA = (Uint8)(dstpixel >> 24);\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                dstA = srcA + ((255 - srcA) * dstA) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstA << 24) | ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGRA8888_ARGB8888_Modulate(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 pixel;\n    Uint32 R, G, B, A;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            pixel = *src;\n            B = (Uint8)(pixel >> 24); G = (Uint8)(pixel >> 16); R = (Uint8)(pixel >> 8); A = (Uint8)pixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                R = (R * modulateR) / 255;\n                G = (G * modulateG) / 255;\n                B = (B * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                A = (A * modulateA) / 255;\n            }\n            pixel = ((Uint32)A << 24) | ((Uint32)R << 16) | ((Uint32)G << 8) | B;\n            *dst = pixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGRA8888_ARGB8888_Modulate_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 pixel;\n    Uint32 R, G, B, A;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            pixel = *src;\n            B = (Uint8)(pixel >> 24); G = (Uint8)(pixel >> 16); R = (Uint8)(pixel >> 8); A = (Uint8)pixel;\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                R = (R * modulateR) / 255;\n                G = (G * modulateG) / 255;\n                B = (B * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                A = (A * modulateA) / 255;\n            }\n            pixel = ((Uint32)A << 24) | ((Uint32)R << 16) | ((Uint32)G << 8) | B;\n            *dst = pixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGRA8888_ARGB8888_Modulate_Blend(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB, dstA;\n\n    while (info->dst_h--) {\n        Uint32 *src = (Uint32 *)info->src;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        while (n--) {\n            srcpixel = *src;\n            srcB = (Uint8)(srcpixel >> 24); srcG = (Uint8)(srcpixel >> 16); srcR = (Uint8)(srcpixel >> 8); srcA = (Uint8)srcpixel;\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel; dstA = (Uint8)(dstpixel >> 24);\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                dstA = srcA + ((255 - srcA) * dstA) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstA << 24) | ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            ++src;\n            ++dst;\n        }\n        info->src += info->src_pitch;\n        info->dst += info->dst_pitch;\n    }\n}\n\nstatic void SDL_Blit_BGRA8888_ARGB8888_Modulate_Blend_Scale(SDL_BlitInfo *info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB, dstA;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint32 *src = 0;\n        Uint32 *dst = (Uint32 *)info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src = (Uint32 *)(info->src + (srcy * info->src_pitch) + (srcx * 4));\n            }\n            srcpixel = *src;\n            srcB = (Uint8)(srcpixel >> 24); srcG = (Uint8)(srcpixel >> 16); srcR = (Uint8)(srcpixel >> 8); srcA = (Uint8)srcpixel;\n            dstpixel = *dst;\n            dstR = (Uint8)(dstpixel >> 16); dstG = (Uint8)(dstpixel >> 8); dstB = (Uint8)dstpixel; dstA = (Uint8)(dstpixel >> 24);\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND|SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND|SDL_COPY_ADD|SDL_COPY_MOD)) {\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                dstA = srcA + ((255 - srcA) * dstA) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR; if (dstR > 255) dstR = 255;\n                dstG = srcG + dstG; if (dstG > 255) dstG = 255;\n                dstB = srcB + dstB; if (dstB > 255) dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            dstpixel = ((Uint32)dstA << 24) | ((Uint32)dstR << 16) | ((Uint32)dstG << 8) | dstB;\n            *dst = dstpixel;\n            posx += incx;\n            ++dst;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\nSDL_BlitFuncEntry SDL_GeneratedBlitFuncTable[] = {\n    { SDL_PIXELFORMAT_RGB888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_RGB888_RGB888_Scale },\n    { SDL_PIXELFORMAT_RGB888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD), SDL_CPU_ANY, SDL_Blit_RGB888_RGB888_Blend },\n    { SDL_PIXELFORMAT_RGB888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_RGB888_RGB888_Blend_Scale },\n    { SDL_PIXELFORMAT_RGB888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA), SDL_CPU_ANY, SDL_Blit_RGB888_RGB888_Modulate },\n    { SDL_PIXELFORMAT_RGB888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_RGB888_RGB888_Modulate_Scale },\n    { SDL_PIXELFORMAT_RGB888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD), SDL_CPU_ANY, SDL_Blit_RGB888_RGB888_Modulate_Blend },\n    { SDL_PIXELFORMAT_RGB888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_RGB888_RGB888_Modulate_Blend_Scale },\n    { SDL_PIXELFORMAT_RGB888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_RGB888_BGR888_Scale },\n    { SDL_PIXELFORMAT_RGB888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD), SDL_CPU_ANY, SDL_Blit_RGB888_BGR888_Blend },\n    { SDL_PIXELFORMAT_RGB888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_RGB888_BGR888_Blend_Scale },\n    { SDL_PIXELFORMAT_RGB888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA), SDL_CPU_ANY, SDL_Blit_RGB888_BGR888_Modulate },\n    { SDL_PIXELFORMAT_RGB888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_RGB888_BGR888_Modulate_Scale },\n    { SDL_PIXELFORMAT_RGB888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD), SDL_CPU_ANY, SDL_Blit_RGB888_BGR888_Modulate_Blend },\n    { SDL_PIXELFORMAT_RGB888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_RGB888_BGR888_Modulate_Blend_Scale },\n    { SDL_PIXELFORMAT_RGB888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_RGB888_ARGB8888_Scale },\n    { SDL_PIXELFORMAT_RGB888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD), SDL_CPU_ANY, SDL_Blit_RGB888_ARGB8888_Blend },\n    { SDL_PIXELFORMAT_RGB888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_RGB888_ARGB8888_Blend_Scale },\n    { SDL_PIXELFORMAT_RGB888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA), SDL_CPU_ANY, SDL_Blit_RGB888_ARGB8888_Modulate },\n    { SDL_PIXELFORMAT_RGB888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_RGB888_ARGB8888_Modulate_Scale },\n    { SDL_PIXELFORMAT_RGB888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD), SDL_CPU_ANY, SDL_Blit_RGB888_ARGB8888_Modulate_Blend },\n    { SDL_PIXELFORMAT_RGB888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_RGB888_ARGB8888_Modulate_Blend_Scale },\n    { SDL_PIXELFORMAT_BGR888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_BGR888_RGB888_Scale },\n    { SDL_PIXELFORMAT_BGR888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD), SDL_CPU_ANY, SDL_Blit_BGR888_RGB888_Blend },\n    { SDL_PIXELFORMAT_BGR888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_BGR888_RGB888_Blend_Scale },\n    { SDL_PIXELFORMAT_BGR888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA), SDL_CPU_ANY, SDL_Blit_BGR888_RGB888_Modulate },\n    { SDL_PIXELFORMAT_BGR888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_BGR888_RGB888_Modulate_Scale },\n    { SDL_PIXELFORMAT_BGR888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD), SDL_CPU_ANY, SDL_Blit_BGR888_RGB888_Modulate_Blend },\n    { SDL_PIXELFORMAT_BGR888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_BGR888_RGB888_Modulate_Blend_Scale },\n    { SDL_PIXELFORMAT_BGR888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_BGR888_BGR888_Scale },\n    { SDL_PIXELFORMAT_BGR888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD), SDL_CPU_ANY, SDL_Blit_BGR888_BGR888_Blend },\n    { SDL_PIXELFORMAT_BGR888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_BGR888_BGR888_Blend_Scale },\n    { SDL_PIXELFORMAT_BGR888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA), SDL_CPU_ANY, SDL_Blit_BGR888_BGR888_Modulate },\n    { SDL_PIXELFORMAT_BGR888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_BGR888_BGR888_Modulate_Scale },\n    { SDL_PIXELFORMAT_BGR888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD), SDL_CPU_ANY, SDL_Blit_BGR888_BGR888_Modulate_Blend },\n    { SDL_PIXELFORMAT_BGR888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_BGR888_BGR888_Modulate_Blend_Scale },\n    { SDL_PIXELFORMAT_BGR888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_BGR888_ARGB8888_Scale },\n    { SDL_PIXELFORMAT_BGR888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD), SDL_CPU_ANY, SDL_Blit_BGR888_ARGB8888_Blend },\n    { SDL_PIXELFORMAT_BGR888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_BGR888_ARGB8888_Blend_Scale },\n    { SDL_PIXELFORMAT_BGR888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA), SDL_CPU_ANY, SDL_Blit_BGR888_ARGB8888_Modulate },\n    { SDL_PIXELFORMAT_BGR888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_BGR888_ARGB8888_Modulate_Scale },\n    { SDL_PIXELFORMAT_BGR888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD), SDL_CPU_ANY, SDL_Blit_BGR888_ARGB8888_Modulate_Blend },\n    { SDL_PIXELFORMAT_BGR888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_BGR888_ARGB8888_Modulate_Blend_Scale },\n    { SDL_PIXELFORMAT_ARGB8888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_ARGB8888_RGB888_Scale },\n    { SDL_PIXELFORMAT_ARGB8888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD), SDL_CPU_ANY, SDL_Blit_ARGB8888_RGB888_Blend },\n    { SDL_PIXELFORMAT_ARGB8888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_ARGB8888_RGB888_Blend_Scale },\n    { SDL_PIXELFORMAT_ARGB8888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA), SDL_CPU_ANY, SDL_Blit_ARGB8888_RGB888_Modulate },\n    { SDL_PIXELFORMAT_ARGB8888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_ARGB8888_RGB888_Modulate_Scale },\n    { SDL_PIXELFORMAT_ARGB8888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD), SDL_CPU_ANY, SDL_Blit_ARGB8888_RGB888_Modulate_Blend },\n    { SDL_PIXELFORMAT_ARGB8888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_ARGB8888_RGB888_Modulate_Blend_Scale },\n    { SDL_PIXELFORMAT_ARGB8888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_ARGB8888_BGR888_Scale },\n    { SDL_PIXELFORMAT_ARGB8888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD), SDL_CPU_ANY, SDL_Blit_ARGB8888_BGR888_Blend },\n    { SDL_PIXELFORMAT_ARGB8888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_ARGB8888_BGR888_Blend_Scale },\n    { SDL_PIXELFORMAT_ARGB8888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA), SDL_CPU_ANY, SDL_Blit_ARGB8888_BGR888_Modulate },\n    { SDL_PIXELFORMAT_ARGB8888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_ARGB8888_BGR888_Modulate_Scale },\n    { SDL_PIXELFORMAT_ARGB8888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD), SDL_CPU_ANY, SDL_Blit_ARGB8888_BGR888_Modulate_Blend },\n    { SDL_PIXELFORMAT_ARGB8888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_ARGB8888_BGR888_Modulate_Blend_Scale },\n    { SDL_PIXELFORMAT_ARGB8888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_ARGB8888_ARGB8888_Scale },\n    { SDL_PIXELFORMAT_ARGB8888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD), SDL_CPU_ANY, SDL_Blit_ARGB8888_ARGB8888_Blend },\n    { SDL_PIXELFORMAT_ARGB8888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_ARGB8888_ARGB8888_Blend_Scale },\n    { SDL_PIXELFORMAT_ARGB8888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA), SDL_CPU_ANY, SDL_Blit_ARGB8888_ARGB8888_Modulate },\n    { SDL_PIXELFORMAT_ARGB8888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_ARGB8888_ARGB8888_Modulate_Scale },\n    { SDL_PIXELFORMAT_ARGB8888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD), SDL_CPU_ANY, SDL_Blit_ARGB8888_ARGB8888_Modulate_Blend },\n    { SDL_PIXELFORMAT_ARGB8888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_ARGB8888_ARGB8888_Modulate_Blend_Scale },\n    { SDL_PIXELFORMAT_RGBA8888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_RGBA8888_RGB888_Scale },\n    { SDL_PIXELFORMAT_RGBA8888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD), SDL_CPU_ANY, SDL_Blit_RGBA8888_RGB888_Blend },\n    { SDL_PIXELFORMAT_RGBA8888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_RGBA8888_RGB888_Blend_Scale },\n    { SDL_PIXELFORMAT_RGBA8888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA), SDL_CPU_ANY, SDL_Blit_RGBA8888_RGB888_Modulate },\n    { SDL_PIXELFORMAT_RGBA8888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_RGBA8888_RGB888_Modulate_Scale },\n    { SDL_PIXELFORMAT_RGBA8888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD), SDL_CPU_ANY, SDL_Blit_RGBA8888_RGB888_Modulate_Blend },\n    { SDL_PIXELFORMAT_RGBA8888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_RGBA8888_RGB888_Modulate_Blend_Scale },\n    { SDL_PIXELFORMAT_RGBA8888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_RGBA8888_BGR888_Scale },\n    { SDL_PIXELFORMAT_RGBA8888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD), SDL_CPU_ANY, SDL_Blit_RGBA8888_BGR888_Blend },\n    { SDL_PIXELFORMAT_RGBA8888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_RGBA8888_BGR888_Blend_Scale },\n    { SDL_PIXELFORMAT_RGBA8888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA), SDL_CPU_ANY, SDL_Blit_RGBA8888_BGR888_Modulate },\n    { SDL_PIXELFORMAT_RGBA8888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_RGBA8888_BGR888_Modulate_Scale },\n    { SDL_PIXELFORMAT_RGBA8888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD), SDL_CPU_ANY, SDL_Blit_RGBA8888_BGR888_Modulate_Blend },\n    { SDL_PIXELFORMAT_RGBA8888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_RGBA8888_BGR888_Modulate_Blend_Scale },\n    { SDL_PIXELFORMAT_RGBA8888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_RGBA8888_ARGB8888_Scale },\n    { SDL_PIXELFORMAT_RGBA8888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD), SDL_CPU_ANY, SDL_Blit_RGBA8888_ARGB8888_Blend },\n    { SDL_PIXELFORMAT_RGBA8888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_RGBA8888_ARGB8888_Blend_Scale },\n    { SDL_PIXELFORMAT_RGBA8888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA), SDL_CPU_ANY, SDL_Blit_RGBA8888_ARGB8888_Modulate },\n    { SDL_PIXELFORMAT_RGBA8888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_RGBA8888_ARGB8888_Modulate_Scale },\n    { SDL_PIXELFORMAT_RGBA8888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD), SDL_CPU_ANY, SDL_Blit_RGBA8888_ARGB8888_Modulate_Blend },\n    { SDL_PIXELFORMAT_RGBA8888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_RGBA8888_ARGB8888_Modulate_Blend_Scale },\n    { SDL_PIXELFORMAT_ABGR8888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_ABGR8888_RGB888_Scale },\n    { SDL_PIXELFORMAT_ABGR8888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD), SDL_CPU_ANY, SDL_Blit_ABGR8888_RGB888_Blend },\n    { SDL_PIXELFORMAT_ABGR8888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_ABGR8888_RGB888_Blend_Scale },\n    { SDL_PIXELFORMAT_ABGR8888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA), SDL_CPU_ANY, SDL_Blit_ABGR8888_RGB888_Modulate },\n    { SDL_PIXELFORMAT_ABGR8888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_ABGR8888_RGB888_Modulate_Scale },\n    { SDL_PIXELFORMAT_ABGR8888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD), SDL_CPU_ANY, SDL_Blit_ABGR8888_RGB888_Modulate_Blend },\n    { SDL_PIXELFORMAT_ABGR8888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_ABGR8888_RGB888_Modulate_Blend_Scale },\n    { SDL_PIXELFORMAT_ABGR8888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_ABGR8888_BGR888_Scale },\n    { SDL_PIXELFORMAT_ABGR8888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD), SDL_CPU_ANY, SDL_Blit_ABGR8888_BGR888_Blend },\n    { SDL_PIXELFORMAT_ABGR8888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_ABGR8888_BGR888_Blend_Scale },\n    { SDL_PIXELFORMAT_ABGR8888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA), SDL_CPU_ANY, SDL_Blit_ABGR8888_BGR888_Modulate },\n    { SDL_PIXELFORMAT_ABGR8888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_ABGR8888_BGR888_Modulate_Scale },\n    { SDL_PIXELFORMAT_ABGR8888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD), SDL_CPU_ANY, SDL_Blit_ABGR8888_BGR888_Modulate_Blend },\n    { SDL_PIXELFORMAT_ABGR8888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_ABGR8888_BGR888_Modulate_Blend_Scale },\n    { SDL_PIXELFORMAT_ABGR8888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_ABGR8888_ARGB8888_Scale },\n    { SDL_PIXELFORMAT_ABGR8888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD), SDL_CPU_ANY, SDL_Blit_ABGR8888_ARGB8888_Blend },\n    { SDL_PIXELFORMAT_ABGR8888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_ABGR8888_ARGB8888_Blend_Scale },\n    { SDL_PIXELFORMAT_ABGR8888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA), SDL_CPU_ANY, SDL_Blit_ABGR8888_ARGB8888_Modulate },\n    { SDL_PIXELFORMAT_ABGR8888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_ABGR8888_ARGB8888_Modulate_Scale },\n    { SDL_PIXELFORMAT_ABGR8888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD), SDL_CPU_ANY, SDL_Blit_ABGR8888_ARGB8888_Modulate_Blend },\n    { SDL_PIXELFORMAT_ABGR8888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_ABGR8888_ARGB8888_Modulate_Blend_Scale },\n    { SDL_PIXELFORMAT_BGRA8888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_BGRA8888_RGB888_Scale },\n    { SDL_PIXELFORMAT_BGRA8888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD), SDL_CPU_ANY, SDL_Blit_BGRA8888_RGB888_Blend },\n    { SDL_PIXELFORMAT_BGRA8888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_BGRA8888_RGB888_Blend_Scale },\n    { SDL_PIXELFORMAT_BGRA8888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA), SDL_CPU_ANY, SDL_Blit_BGRA8888_RGB888_Modulate },\n    { SDL_PIXELFORMAT_BGRA8888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_BGRA8888_RGB888_Modulate_Scale },\n    { SDL_PIXELFORMAT_BGRA8888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD), SDL_CPU_ANY, SDL_Blit_BGRA8888_RGB888_Modulate_Blend },\n    { SDL_PIXELFORMAT_BGRA8888, SDL_PIXELFORMAT_RGB888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_BGRA8888_RGB888_Modulate_Blend_Scale },\n    { SDL_PIXELFORMAT_BGRA8888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_BGRA8888_BGR888_Scale },\n    { SDL_PIXELFORMAT_BGRA8888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD), SDL_CPU_ANY, SDL_Blit_BGRA8888_BGR888_Blend },\n    { SDL_PIXELFORMAT_BGRA8888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_BGRA8888_BGR888_Blend_Scale },\n    { SDL_PIXELFORMAT_BGRA8888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA), SDL_CPU_ANY, SDL_Blit_BGRA8888_BGR888_Modulate },\n    { SDL_PIXELFORMAT_BGRA8888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_BGRA8888_BGR888_Modulate_Scale },\n    { SDL_PIXELFORMAT_BGRA8888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD), SDL_CPU_ANY, SDL_Blit_BGRA8888_BGR888_Modulate_Blend },\n    { SDL_PIXELFORMAT_BGRA8888, SDL_PIXELFORMAT_BGR888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_BGRA8888_BGR888_Modulate_Blend_Scale },\n    { SDL_PIXELFORMAT_BGRA8888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_BGRA8888_ARGB8888_Scale },\n    { SDL_PIXELFORMAT_BGRA8888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD), SDL_CPU_ANY, SDL_Blit_BGRA8888_ARGB8888_Blend },\n    { SDL_PIXELFORMAT_BGRA8888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_BGRA8888_ARGB8888_Blend_Scale },\n    { SDL_PIXELFORMAT_BGRA8888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA), SDL_CPU_ANY, SDL_Blit_BGRA8888_ARGB8888_Modulate },\n    { SDL_PIXELFORMAT_BGRA8888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_BGRA8888_ARGB8888_Modulate_Scale },\n    { SDL_PIXELFORMAT_BGRA8888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD), SDL_CPU_ANY, SDL_Blit_BGRA8888_ARGB8888_Modulate_Blend },\n    { SDL_PIXELFORMAT_BGRA8888, SDL_PIXELFORMAT_ARGB8888, (SDL_COPY_MODULATE_COLOR | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD | SDL_COPY_NEAREST), SDL_CPU_ANY, SDL_Blit_BGRA8888_ARGB8888_Modulate_Blend_Scale },\n    { 0, 0, 0, 0, NULL }\n};\n\n/* *INDENT-ON* */\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../SDL_internal.h\"\n\n#include \"SDL_video.h\"\n#include \"SDL_blit.h\"\n#include \"SDL_blit_copy.h\"\n\n\n#ifdef __SSE__\n/* This assumes 16-byte aligned src and dst */\nstatic SDL_INLINE void\nSDL_memcpySSE(Uint8 * dst, const Uint8 * src, int len)\n{\n    int i;\n\n    __m128 values[4];\n    for (i = len / 64; i--;) {\n        _mm_prefetch(src, _MM_HINT_NTA);\n        values[0] = *(__m128 *) (src + 0);\n        values[1] = *(__m128 *) (src + 16);\n        values[2] = *(__m128 *) (src + 32);\n        values[3] = *(__m128 *) (src + 48);\n        _mm_stream_ps((float *) (dst + 0), values[0]);\n        _mm_stream_ps((float *) (dst + 16), values[1]);\n        _mm_stream_ps((float *) (dst + 32), values[2]);\n        _mm_stream_ps((float *) (dst + 48), values[3]);\n        src += 64;\n        dst += 64;\n    }\n\n    if (len & 63)\n        SDL_memcpy(dst, src, len & 63);\n}\n#endif /* __SSE__ */\n\n#ifdef __MMX__\n#ifdef _MSC_VER\n#pragma warning(disable:4799)\n#endif\nstatic SDL_INLINE void\nSDL_memcpyMMX(Uint8 * dst, const Uint8 * src, int len)\n{\n    const int remain = (len & 63);\n    int i;\n\n    __m64* d64 = (__m64*)dst;\n    __m64* s64 = (__m64*)src;\n\n    for(i= len / 64; i--;) {\n        d64[0] = s64[0];\n        d64[1] = s64[1];\n        d64[2] = s64[2];\n        d64[3] = s64[3];\n        d64[4] = s64[4];\n        d64[5] = s64[5];\n        d64[6] = s64[6];\n        d64[7] = s64[7];\n\n        d64 += 8;\n        s64 += 8;\n    }\n\n    if (remain)\n    {\n        const int skip = len - remain;\n        SDL_memcpy(dst + skip, src + skip, remain);\n    }\n}\n#endif /* __MMX__ */\n\nvoid\nSDL_BlitCopy(SDL_BlitInfo * info)\n{\n    SDL_bool overlap;\n    Uint8 *src, *dst;\n    int w, h;\n    int srcskip, dstskip;\n\n    w = info->dst_w * info->dst_fmt->BytesPerPixel;\n    h = info->dst_h;\n    src = info->src;\n    dst = info->dst;\n    srcskip = info->src_pitch;\n    dstskip = info->dst_pitch;\n\n    /* Properly handle overlapping blits */\n    if (src < dst) {\n        overlap = (dst < (src + h*srcskip));\n    } else {\n        overlap = (src < (dst + h*dstskip));\n    }\n    if (overlap) {\n        while (h--) {\n            SDL_memmove(dst, src, w);\n            src += srcskip;\n            dst += dstskip;\n        }\n        return;\n    }\n\n#ifdef __SSE__\n    if (SDL_HasSSE() &&\n        !((uintptr_t) src & 15) && !(srcskip & 15) &&\n        !((uintptr_t) dst & 15) && !(dstskip & 15)) {\n        while (h--) {\n            SDL_memcpySSE(dst, src, w);\n            src += srcskip;\n            dst += dstskip;\n        }\n        return;\n    }\n#endif\n\n#ifdef __MMX__\n    if (SDL_HasMMX() && !(srcskip & 7) && !(dstskip & 7)) {\n        while (h--) {\n            SDL_memcpyMMX(dst, src, w);\n            src += srcskip;\n            dst += dstskip;\n        }\n        _mm_empty();\n        return;\n    }\n#endif\n\n    while (h--) {\n        SDL_memcpy(dst, src, w);\n        src += srcskip;\n        dst += dstskip;\n    }\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../SDL_internal.h\"\n\n#include \"SDL_video.h\"\n#include \"SDL_endian.h\"\n#include \"SDL_cpuinfo.h\"\n#include \"SDL_blit.h\"\n\n#include \"SDL_assert.h\"\n\n/* Functions to blit from N-bit surfaces to other surfaces */\n\n#if SDL_ALTIVEC_BLITTERS\n#ifdef HAVE_ALTIVEC_H\n#include <altivec.h>\n#endif\n#ifdef __MACOSX__\n#include <sys/sysctl.h>\nstatic size_t\nGetL3CacheSize(void)\n{\n    const char key[] = \"hw.l3cachesize\";\n    u_int64_t result = 0;\n    size_t typeSize = sizeof(result);\n\n\n    int err = sysctlbyname(key, &result, &typeSize, NULL, 0);\n    if (0 != err)\n        return 0;\n\n    return result;\n}\n#else\nstatic size_t\nGetL3CacheSize(void)\n{\n    /* XXX: Just guess G4 */\n    return 2097152;\n}\n#endif /* __MACOSX__ */\n\n#if (defined(__MACOSX__) && (__GNUC__ < 4))\n#define VECUINT8_LITERAL(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) \\\n        (vector unsigned char) ( a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p )\n#define VECUINT16_LITERAL(a,b,c,d,e,f,g,h) \\\n        (vector unsigned short) ( a,b,c,d,e,f,g,h )\n#else\n#define VECUINT8_LITERAL(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) \\\n        (vector unsigned char) { a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p }\n#define VECUINT16_LITERAL(a,b,c,d,e,f,g,h) \\\n        (vector unsigned short) { a,b,c,d,e,f,g,h }\n#endif\n\n#define UNALIGNED_PTR(x) (((size_t) x) & 0x0000000F)\n#define VSWIZZLE32(a,b,c,d) (vector unsigned char) \\\n                               ( 0x00+a, 0x00+b, 0x00+c, 0x00+d, \\\n                                 0x04+a, 0x04+b, 0x04+c, 0x04+d, \\\n                                 0x08+a, 0x08+b, 0x08+c, 0x08+d, \\\n                                 0x0C+a, 0x0C+b, 0x0C+c, 0x0C+d )\n\n#define MAKE8888(dstfmt, r, g, b, a)  \\\n    ( ((r<<dstfmt->Rshift)&dstfmt->Rmask) | \\\n      ((g<<dstfmt->Gshift)&dstfmt->Gmask) | \\\n      ((b<<dstfmt->Bshift)&dstfmt->Bmask) | \\\n      ((a<<dstfmt->Ashift)&dstfmt->Amask) )\n\n/*\n * Data Stream Touch...Altivec cache prefetching.\n *\n *  Don't use this on a G5...however, the speed boost is very significant\n *   on a G4.\n */\n#define DST_CHAN_SRC 1\n#define DST_CHAN_DEST 2\n\n/* macro to set DST control word value... */\n#define DST_CTRL(size, count, stride) \\\n    (((size) << 24) | ((count) << 16) | (stride))\n\n#define VEC_ALIGNER(src) ((UNALIGNED_PTR(src)) \\\n    ? vec_lvsl(0, src) \\\n    : vec_add(vec_lvsl(8, src), vec_splat_u8(8)))\n\n/* Calculate the permute vector used for 32->32 swizzling */\nstatic vector unsigned char\ncalc_swizzle32(const SDL_PixelFormat * srcfmt, const SDL_PixelFormat * dstfmt)\n{\n    /*\n     * We have to assume that the bits that aren't used by other\n     *  colors is alpha, and it's one complete byte, since some formats\n     *  leave alpha with a zero mask, but we should still swizzle the bits.\n     */\n    /* ARGB */\n    const static const struct SDL_PixelFormat default_pixel_format = {\n        0, NULL, 0, 0,\n        {0, 0},\n        0x00FF0000, 0x0000FF00, 0x000000FF, 0xFF000000,\n        0, 0, 0, 0,\n        16, 8, 0, 24,\n        0, NULL\n    };\n    if (!srcfmt) {\n        srcfmt = &default_pixel_format;\n    }\n    if (!dstfmt) {\n        dstfmt = &default_pixel_format;\n    }\n    const vector unsigned char plus = VECUINT8_LITERAL(0x00, 0x00, 0x00, 0x00,\n                                                       0x04, 0x04, 0x04, 0x04,\n                                                       0x08, 0x08, 0x08, 0x08,\n                                                       0x0C, 0x0C, 0x0C,\n                                                       0x0C);\n    vector unsigned char vswiz;\n    vector unsigned int srcvec;\n#define RESHIFT(X) (3 - ((X) >> 3))\n    Uint32 rmask = RESHIFT(srcfmt->Rshift) << (dstfmt->Rshift);\n    Uint32 gmask = RESHIFT(srcfmt->Gshift) << (dstfmt->Gshift);\n    Uint32 bmask = RESHIFT(srcfmt->Bshift) << (dstfmt->Bshift);\n    Uint32 amask;\n    /* Use zero for alpha if either surface doesn't have alpha */\n    if (dstfmt->Amask) {\n        amask =\n            ((srcfmt->Amask) ? RESHIFT(srcfmt->\n                                       Ashift) : 0x10) << (dstfmt->Ashift);\n    } else {\n        amask =\n            0x10101010 & ((dstfmt->Rmask | dstfmt->Gmask | dstfmt->Bmask) ^\n                          0xFFFFFFFF);\n    }\n#undef RESHIFT\n    ((unsigned int *) (char *) &srcvec)[0] = (rmask | gmask | bmask | amask);\n    vswiz = vec_add(plus, (vector unsigned char) vec_splat(srcvec, 0));\n    return (vswiz);\n}\n\nstatic void Blit_RGB888_RGB565(SDL_BlitInfo * info);\nstatic void\nBlit_RGB888_RGB565Altivec(SDL_BlitInfo * info)\n{\n    int height = info->dst_h;\n    Uint8 *src = (Uint8 *) info->src;\n    int srcskip = info->src_skip;\n    Uint8 *dst = (Uint8 *) info->dst;\n    int dstskip = info->dst_skip;\n    SDL_PixelFormat *srcfmt = info->src_fmt;\n    vector unsigned char valpha = vec_splat_u8(0);\n    vector unsigned char vpermute = calc_swizzle32(srcfmt, NULL);\n    vector unsigned char vgmerge = VECUINT8_LITERAL(0x00, 0x02, 0x00, 0x06,\n                                                    0x00, 0x0a, 0x00, 0x0e,\n                                                    0x00, 0x12, 0x00, 0x16,\n                                                    0x00, 0x1a, 0x00, 0x1e);\n    vector unsigned short v1 = vec_splat_u16(1);\n    vector unsigned short v3 = vec_splat_u16(3);\n    vector unsigned short v3f =\n        VECUINT16_LITERAL(0x003f, 0x003f, 0x003f, 0x003f,\n                          0x003f, 0x003f, 0x003f, 0x003f);\n    vector unsigned short vfc =\n        VECUINT16_LITERAL(0x00fc, 0x00fc, 0x00fc, 0x00fc,\n                          0x00fc, 0x00fc, 0x00fc, 0x00fc);\n    vector unsigned short vf800 = (vector unsigned short) vec_splat_u8(-7);\n    vf800 = vec_sl(vf800, vec_splat_u16(8));\n\n    while (height--) {\n        vector unsigned char valigner;\n        vector unsigned char voverflow;\n        vector unsigned char vsrc;\n\n        int width = info->dst_w;\n        int extrawidth;\n\n        /* do scalar until we can align... */\n#define ONE_PIXEL_BLEND(condition, widthvar) \\\n        while (condition) { \\\n            Uint32 Pixel; \\\n            unsigned sR, sG, sB, sA; \\\n            DISEMBLE_RGBA((Uint8 *)src, 4, srcfmt, Pixel, \\\n                          sR, sG, sB, sA); \\\n            *(Uint16 *)(dst) = (((sR << 8) & 0x0000F800) | \\\n                                ((sG << 3) & 0x000007E0) | \\\n                                ((sB >> 3) & 0x0000001F)); \\\n            dst += 2; \\\n            src += 4; \\\n            widthvar--; \\\n        }\n\n        ONE_PIXEL_BLEND(((UNALIGNED_PTR(dst)) && (width)), width);\n\n        /* After all that work, here's the vector part! */\n        extrawidth = (width % 8);       /* trailing unaligned stores */\n        width -= extrawidth;\n        vsrc = vec_ld(0, src);\n        valigner = VEC_ALIGNER(src);\n\n        while (width) {\n            vector unsigned short vpixel, vrpixel, vgpixel, vbpixel;\n            vector unsigned int vsrc1, vsrc2;\n            vector unsigned char vdst;\n\n            voverflow = vec_ld(15, src);\n            vsrc = vec_perm(vsrc, voverflow, valigner);\n            vsrc1 = (vector unsigned int) vec_perm(vsrc, valpha, vpermute);\n            src += 16;\n            vsrc = voverflow;\n            voverflow = vec_ld(15, src);\n            vsrc = vec_perm(vsrc, voverflow, valigner);\n            vsrc2 = (vector unsigned int) vec_perm(vsrc, valpha, vpermute);\n            /* 1555 */\n            vpixel = (vector unsigned short) vec_packpx(vsrc1, vsrc2);\n            vgpixel = (vector unsigned short) vec_perm(vsrc1, vsrc2, vgmerge);\n            vgpixel = vec_and(vgpixel, vfc);\n            vgpixel = vec_sl(vgpixel, v3);\n            vrpixel = vec_sl(vpixel, v1);\n            vrpixel = vec_and(vrpixel, vf800);\n            vbpixel = vec_and(vpixel, v3f);\n            vdst =\n                vec_or((vector unsigned char) vrpixel,\n                       (vector unsigned char) vgpixel);\n            /* 565 */\n            vdst = vec_or(vdst, (vector unsigned char) vbpixel);\n            vec_st(vdst, 0, dst);\n\n            width -= 8;\n            src += 16;\n            dst += 16;\n            vsrc = voverflow;\n        }\n\n        SDL_assert(width == 0);\n\n        /* do scalar until we can align... */\n        ONE_PIXEL_BLEND((extrawidth), extrawidth);\n#undef ONE_PIXEL_BLEND\n\n        src += srcskip;         /* move to next row, accounting for pitch. */\n        dst += dstskip;\n    }\n\n\n}\n\nstatic void\nBlit_RGB565_32Altivec(SDL_BlitInfo * info)\n{\n    int height = info->dst_h;\n    Uint8 *src = (Uint8 *) info->src;\n    int srcskip = info->src_skip;\n    Uint8 *dst = (Uint8 *) info->dst;\n    int dstskip = info->dst_skip;\n    SDL_PixelFormat *srcfmt = info->src_fmt;\n    SDL_PixelFormat *dstfmt = info->dst_fmt;\n    unsigned alpha;\n    vector unsigned char valpha;\n    vector unsigned char vpermute;\n    vector unsigned short vf800;\n    vector unsigned int v8 = vec_splat_u32(8);\n    vector unsigned int v16 = vec_add(v8, v8);\n    vector unsigned short v2 = vec_splat_u16(2);\n    vector unsigned short v3 = vec_splat_u16(3);\n    /*\n       0x10 - 0x1f is the alpha\n       0x00 - 0x0e evens are the red\n       0x01 - 0x0f odds are zero\n     */\n    vector unsigned char vredalpha1 = VECUINT8_LITERAL(0x10, 0x00, 0x01, 0x01,\n                                                       0x10, 0x02, 0x01, 0x01,\n                                                       0x10, 0x04, 0x01, 0x01,\n                                                       0x10, 0x06, 0x01,\n                                                       0x01);\n    vector unsigned char vredalpha2 =\n        (vector unsigned\n         char) (vec_add((vector unsigned int) vredalpha1, vec_sl(v8, v16))\n        );\n    /*\n       0x00 - 0x0f is ARxx ARxx ARxx ARxx\n       0x11 - 0x0f odds are blue\n     */\n    vector unsigned char vblue1 = VECUINT8_LITERAL(0x00, 0x01, 0x02, 0x11,\n                                                   0x04, 0x05, 0x06, 0x13,\n                                                   0x08, 0x09, 0x0a, 0x15,\n                                                   0x0c, 0x0d, 0x0e, 0x17);\n    vector unsigned char vblue2 =\n        (vector unsigned char) (vec_add((vector unsigned int) vblue1, v8)\n        );\n    /*\n       0x00 - 0x0f is ARxB ARxB ARxB ARxB\n       0x10 - 0x0e evens are green\n     */\n    vector unsigned char vgreen1 = VECUINT8_LITERAL(0x00, 0x01, 0x10, 0x03,\n                                                    0x04, 0x05, 0x12, 0x07,\n                                                    0x08, 0x09, 0x14, 0x0b,\n                                                    0x0c, 0x0d, 0x16, 0x0f);\n    vector unsigned char vgreen2 =\n        (vector unsigned\n         char) (vec_add((vector unsigned int) vgreen1, vec_sl(v8, v8))\n        );\n\n    SDL_assert(srcfmt->BytesPerPixel == 2);\n    SDL_assert(dstfmt->BytesPerPixel == 4);\n\n    vf800 = (vector unsigned short) vec_splat_u8(-7);\n    vf800 = vec_sl(vf800, vec_splat_u16(8));\n\n    if (dstfmt->Amask && info->a) {\n        ((unsigned char *) &valpha)[0] = alpha = info->a;\n        valpha = vec_splat(valpha, 0);\n    } else {\n        alpha = 0;\n        valpha = vec_splat_u8(0);\n    }\n\n    vpermute = calc_swizzle32(NULL, dstfmt);\n    while (height--) {\n        vector unsigned char valigner;\n        vector unsigned char voverflow;\n        vector unsigned char vsrc;\n\n        int width = info->dst_w;\n        int extrawidth;\n\n        /* do scalar until we can align... */\n#define ONE_PIXEL_BLEND(condition, widthvar) \\\n        while (condition) { \\\n            unsigned sR, sG, sB; \\\n            unsigned short Pixel = *((unsigned short *)src); \\\n            sR = (Pixel >> 8) & 0xf8; \\\n            sG = (Pixel >> 3) & 0xfc; \\\n            sB = (Pixel << 3) & 0xf8; \\\n            ASSEMBLE_RGBA(dst, 4, dstfmt, sR, sG, sB, alpha); \\\n            src += 2; \\\n            dst += 4; \\\n            widthvar--; \\\n        }\n        ONE_PIXEL_BLEND(((UNALIGNED_PTR(dst)) && (width)), width);\n\n        /* After all that work, here's the vector part! */\n        extrawidth = (width % 8);       /* trailing unaligned stores */\n        width -= extrawidth;\n        vsrc = vec_ld(0, src);\n        valigner = VEC_ALIGNER(src);\n\n        while (width) {\n            vector unsigned short vR, vG, vB;\n            vector unsigned char vdst1, vdst2;\n\n            voverflow = vec_ld(15, src);\n            vsrc = vec_perm(vsrc, voverflow, valigner);\n\n            vR = vec_and((vector unsigned short) vsrc, vf800);\n            vB = vec_sl((vector unsigned short) vsrc, v3);\n            vG = vec_sl(vB, v2);\n\n            vdst1 =\n                (vector unsigned char) vec_perm((vector unsigned char) vR,\n                                                valpha, vredalpha1);\n            vdst1 = vec_perm(vdst1, (vector unsigned char) vB, vblue1);\n            vdst1 = vec_perm(vdst1, (vector unsigned char) vG, vgreen1);\n            vdst1 = vec_perm(vdst1, valpha, vpermute);\n            vec_st(vdst1, 0, dst);\n\n            vdst2 =\n                (vector unsigned char) vec_perm((vector unsigned char) vR,\n                                                valpha, vredalpha2);\n            vdst2 = vec_perm(vdst2, (vector unsigned char) vB, vblue2);\n            vdst2 = vec_perm(vdst2, (vector unsigned char) vG, vgreen2);\n            vdst2 = vec_perm(vdst2, valpha, vpermute);\n            vec_st(vdst2, 16, dst);\n\n            width -= 8;\n            dst += 32;\n            src += 16;\n            vsrc = voverflow;\n        }\n\n        SDL_assert(width == 0);\n\n\n        /* do scalar until we can align... */\n        ONE_PIXEL_BLEND((extrawidth), extrawidth);\n#undef ONE_PIXEL_BLEND\n\n        src += srcskip;         /* move to next row, accounting for pitch. */\n        dst += dstskip;\n    }\n\n}\n\n\nstatic void\nBlit_RGB555_32Altivec(SDL_BlitInfo * info)\n{\n    int height = info->dst_h;\n    Uint8 *src = (Uint8 *) info->src;\n    int srcskip = info->src_skip;\n    Uint8 *dst = (Uint8 *) info->dst;\n    int dstskip = info->dst_skip;\n    SDL_PixelFormat *srcfmt = info->src_fmt;\n    SDL_PixelFormat *dstfmt = info->dst_fmt;\n    unsigned alpha;\n    vector unsigned char valpha;\n    vector unsigned char vpermute;\n    vector unsigned short vf800;\n    vector unsigned int v8 = vec_splat_u32(8);\n    vector unsigned int v16 = vec_add(v8, v8);\n    vector unsigned short v1 = vec_splat_u16(1);\n    vector unsigned short v3 = vec_splat_u16(3);\n    /*\n       0x10 - 0x1f is the alpha\n       0x00 - 0x0e evens are the red\n       0x01 - 0x0f odds are zero\n     */\n    vector unsigned char vredalpha1 = VECUINT8_LITERAL(0x10, 0x00, 0x01, 0x01,\n                                                       0x10, 0x02, 0x01, 0x01,\n                                                       0x10, 0x04, 0x01, 0x01,\n                                                       0x10, 0x06, 0x01,\n                                                       0x01);\n    vector unsigned char vredalpha2 =\n        (vector unsigned\n         char) (vec_add((vector unsigned int) vredalpha1, vec_sl(v8, v16))\n        );\n    /*\n       0x00 - 0x0f is ARxx ARxx ARxx ARxx\n       0x11 - 0x0f odds are blue\n     */\n    vector unsigned char vblue1 = VECUINT8_LITERAL(0x00, 0x01, 0x02, 0x11,\n                                                   0x04, 0x05, 0x06, 0x13,\n                                                   0x08, 0x09, 0x0a, 0x15,\n                                                   0x0c, 0x0d, 0x0e, 0x17);\n    vector unsigned char vblue2 =\n        (vector unsigned char) (vec_add((vector unsigned int) vblue1, v8)\n        );\n    /*\n       0x00 - 0x0f is ARxB ARxB ARxB ARxB\n       0x10 - 0x0e evens are green\n     */\n    vector unsigned char vgreen1 = VECUINT8_LITERAL(0x00, 0x01, 0x10, 0x03,\n                                                    0x04, 0x05, 0x12, 0x07,\n                                                    0x08, 0x09, 0x14, 0x0b,\n                                                    0x0c, 0x0d, 0x16, 0x0f);\n    vector unsigned char vgreen2 =\n        (vector unsigned\n         char) (vec_add((vector unsigned int) vgreen1, vec_sl(v8, v8))\n        );\n\n    SDL_assert(srcfmt->BytesPerPixel == 2);\n    SDL_assert(dstfmt->BytesPerPixel == 4);\n\n    vf800 = (vector unsigned short) vec_splat_u8(-7);\n    vf800 = vec_sl(vf800, vec_splat_u16(8));\n\n    if (dstfmt->Amask && info->a) {\n        ((unsigned char *) &valpha)[0] = alpha = info->a;\n        valpha = vec_splat(valpha, 0);\n    } else {\n        alpha = 0;\n        valpha = vec_splat_u8(0);\n    }\n\n    vpermute = calc_swizzle32(NULL, dstfmt);\n    while (height--) {\n        vector unsigned char valigner;\n        vector unsigned char voverflow;\n        vector unsigned char vsrc;\n\n        int width = info->dst_w;\n        int extrawidth;\n\n        /* do scalar until we can align... */\n#define ONE_PIXEL_BLEND(condition, widthvar) \\\n        while (condition) { \\\n            unsigned sR, sG, sB; \\\n            unsigned short Pixel = *((unsigned short *)src); \\\n            sR = (Pixel >> 7) & 0xf8; \\\n            sG = (Pixel >> 2) & 0xf8; \\\n            sB = (Pixel << 3) & 0xf8; \\\n            ASSEMBLE_RGBA(dst, 4, dstfmt, sR, sG, sB, alpha); \\\n            src += 2; \\\n            dst += 4; \\\n            widthvar--; \\\n        }\n        ONE_PIXEL_BLEND(((UNALIGNED_PTR(dst)) && (width)), width);\n\n        /* After all that work, here's the vector part! */\n        extrawidth = (width % 8);       /* trailing unaligned stores */\n        width -= extrawidth;\n        vsrc = vec_ld(0, src);\n        valigner = VEC_ALIGNER(src);\n\n        while (width) {\n            vector unsigned short vR, vG, vB;\n            vector unsigned char vdst1, vdst2;\n\n            voverflow = vec_ld(15, src);\n            vsrc = vec_perm(vsrc, voverflow, valigner);\n\n            vR = vec_and(vec_sl((vector unsigned short) vsrc, v1), vf800);\n            vB = vec_sl((vector unsigned short) vsrc, v3);\n            vG = vec_sl(vB, v3);\n\n            vdst1 =\n                (vector unsigned char) vec_perm((vector unsigned char) vR,\n                                                valpha, vredalpha1);\n            vdst1 = vec_perm(vdst1, (vector unsigned char) vB, vblue1);\n            vdst1 = vec_perm(vdst1, (vector unsigned char) vG, vgreen1);\n            vdst1 = vec_perm(vdst1, valpha, vpermute);\n            vec_st(vdst1, 0, dst);\n\n            vdst2 =\n                (vector unsigned char) vec_perm((vector unsigned char) vR,\n                                                valpha, vredalpha2);\n            vdst2 = vec_perm(vdst2, (vector unsigned char) vB, vblue2);\n            vdst2 = vec_perm(vdst2, (vector unsigned char) vG, vgreen2);\n            vdst2 = vec_perm(vdst2, valpha, vpermute);\n            vec_st(vdst2, 16, dst);\n\n            width -= 8;\n            dst += 32;\n            src += 16;\n            vsrc = voverflow;\n        }\n\n        SDL_assert(width == 0);\n\n\n        /* do scalar until we can align... */\n        ONE_PIXEL_BLEND((extrawidth), extrawidth);\n#undef ONE_PIXEL_BLEND\n\n        src += srcskip;         /* move to next row, accounting for pitch. */\n        dst += dstskip;\n    }\n\n}\n\nstatic void BlitNtoNKey(SDL_BlitInfo * info);\nstatic void BlitNtoNKeyCopyAlpha(SDL_BlitInfo * info);\nstatic void\nBlit32to32KeyAltivec(SDL_BlitInfo * info)\n{\n    int height = info->dst_h;\n    Uint32 *srcp = (Uint32 *) info->src;\n    int srcskip = info->src_skip / 4;\n    Uint32 *dstp = (Uint32 *) info->dst;\n    int dstskip = info->dst_skip / 4;\n    SDL_PixelFormat *srcfmt = info->src_fmt;\n    int srcbpp = srcfmt->BytesPerPixel;\n    SDL_PixelFormat *dstfmt = info->dst_fmt;\n    int dstbpp = dstfmt->BytesPerPixel;\n    int copy_alpha = (srcfmt->Amask && dstfmt->Amask);\n    unsigned alpha = dstfmt->Amask ? info->a : 0;\n    Uint32 rgbmask = srcfmt->Rmask | srcfmt->Gmask | srcfmt->Bmask;\n    Uint32 ckey = info->colorkey;\n    vector unsigned int valpha;\n    vector unsigned char vpermute;\n    vector unsigned char vzero;\n    vector unsigned int vckey;\n    vector unsigned int vrgbmask;\n    vpermute = calc_swizzle32(srcfmt, dstfmt);\n    if (info->dst_w < 16) {\n        if (copy_alpha) {\n            BlitNtoNKeyCopyAlpha(info);\n        } else {\n            BlitNtoNKey(info);\n        }\n        return;\n    }\n    vzero = vec_splat_u8(0);\n    if (alpha) {\n        ((unsigned char *) &valpha)[0] = (unsigned char) alpha;\n        valpha =\n            (vector unsigned int) vec_splat((vector unsigned char) valpha, 0);\n    } else {\n        valpha = (vector unsigned int) vzero;\n    }\n    ckey &= rgbmask;\n    ((unsigned int *) (char *) &vckey)[0] = ckey;\n    vckey = vec_splat(vckey, 0);\n    ((unsigned int *) (char *) &vrgbmask)[0] = rgbmask;\n    vrgbmask = vec_splat(vrgbmask, 0);\n\n    while (height--) {\n#define ONE_PIXEL_BLEND(condition, widthvar) \\\n        if (copy_alpha) { \\\n            while (condition) { \\\n                Uint32 Pixel; \\\n                unsigned sR, sG, sB, sA; \\\n                DISEMBLE_RGBA((Uint8 *)srcp, srcbpp, srcfmt, Pixel, \\\n                          sR, sG, sB, sA); \\\n                if ( (Pixel & rgbmask) != ckey ) { \\\n                      ASSEMBLE_RGBA((Uint8 *)dstp, dstbpp, dstfmt, \\\n                            sR, sG, sB, sA); \\\n                } \\\n                dstp = (Uint32 *) (((Uint8 *) dstp) + dstbpp); \\\n                srcp = (Uint32 *) (((Uint8 *) srcp) + srcbpp); \\\n                widthvar--; \\\n            } \\\n        } else { \\\n            while (condition) { \\\n                Uint32 Pixel; \\\n                unsigned sR, sG, sB; \\\n                RETRIEVE_RGB_PIXEL((Uint8 *)srcp, srcbpp, Pixel); \\\n                if ( Pixel != ckey ) { \\\n                    RGB_FROM_PIXEL(Pixel, srcfmt, sR, sG, sB); \\\n                    ASSEMBLE_RGBA((Uint8 *)dstp, dstbpp, dstfmt, \\\n                              sR, sG, sB, alpha); \\\n                } \\\n                dstp = (Uint32 *) (((Uint8 *)dstp) + dstbpp); \\\n                srcp = (Uint32 *) (((Uint8 *)srcp) + srcbpp); \\\n                widthvar--; \\\n            } \\\n        }\n        int width = info->dst_w;\n        ONE_PIXEL_BLEND((UNALIGNED_PTR(dstp)) && (width), width);\n        SDL_assert(width > 0);\n        if (width > 0) {\n            int extrawidth = (width % 4);\n            vector unsigned char valigner = VEC_ALIGNER(srcp);\n            vector unsigned int vs = vec_ld(0, srcp);\n            width -= extrawidth;\n            SDL_assert(width >= 4);\n            while (width) {\n                vector unsigned char vsel;\n                vector unsigned int vd;\n                vector unsigned int voverflow = vec_ld(15, srcp);\n                /* load the source vec */\n                vs = vec_perm(vs, voverflow, valigner);\n                /* vsel is set for items that match the key */\n                vsel = (vector unsigned char) vec_and(vs, vrgbmask);\n                vsel = (vector unsigned char) vec_cmpeq(vs, vckey);\n                /* permute the src vec to the dest format */\n                vs = vec_perm(vs, valpha, vpermute);\n                /* load the destination vec */\n                vd = vec_ld(0, dstp);\n                /* select the source and dest into vs */\n                vd = (vector unsigned int) vec_sel((vector unsigned char) vs,\n                                                   (vector unsigned char) vd,\n                                                   vsel);\n\n                vec_st(vd, 0, dstp);\n                srcp += 4;\n                width -= 4;\n                dstp += 4;\n                vs = voverflow;\n            }\n            ONE_PIXEL_BLEND((extrawidth), extrawidth);\n#undef ONE_PIXEL_BLEND\n            srcp += srcskip;\n            dstp += dstskip;\n        }\n    }\n}\n\n/* Altivec code to swizzle one 32-bit surface to a different 32-bit format. */\n/* Use this on a G5 */\nstatic void\nConvertAltivec32to32_noprefetch(SDL_BlitInfo * info)\n{\n    int height = info->dst_h;\n    Uint32 *src = (Uint32 *) info->src;\n    int srcskip = info->src_skip / 4;\n    Uint32 *dst = (Uint32 *) info->dst;\n    int dstskip = info->dst_skip / 4;\n    SDL_PixelFormat *srcfmt = info->src_fmt;\n    SDL_PixelFormat *dstfmt = info->dst_fmt;\n    vector unsigned int vzero = vec_splat_u32(0);\n    vector unsigned char vpermute = calc_swizzle32(srcfmt, dstfmt);\n    if (dstfmt->Amask && !srcfmt->Amask) {\n        if (info->a) {\n            vector unsigned char valpha;\n            ((unsigned char *) &valpha)[0] = info->a;\n            vzero = (vector unsigned int) vec_splat(valpha, 0);\n        }\n    }\n\n    SDL_assert(srcfmt->BytesPerPixel == 4);\n    SDL_assert(dstfmt->BytesPerPixel == 4);\n\n    while (height--) {\n        vector unsigned char valigner;\n        vector unsigned int vbits;\n        vector unsigned int voverflow;\n        Uint32 bits;\n        Uint8 r, g, b, a;\n\n        int width = info->dst_w;\n        int extrawidth;\n\n        /* do scalar until we can align... */\n        while ((UNALIGNED_PTR(dst)) && (width)) {\n            bits = *(src++);\n            RGBA_FROM_8888(bits, srcfmt, r, g, b, a);\n            if(!srcfmt->Amask)\n              a = info->a;\n            *(dst++) = MAKE8888(dstfmt, r, g, b, a);\n            width--;\n        }\n\n        /* After all that work, here's the vector part! */\n        extrawidth = (width % 4);\n        width -= extrawidth;\n        valigner = VEC_ALIGNER(src);\n        vbits = vec_ld(0, src);\n\n        while (width) {\n            voverflow = vec_ld(15, src);\n            src += 4;\n            width -= 4;\n            vbits = vec_perm(vbits, voverflow, valigner);       /* src is ready. */\n            vbits = vec_perm(vbits, vzero, vpermute);   /* swizzle it. */\n            vec_st(vbits, 0, dst);      /* store it back out. */\n            dst += 4;\n            vbits = voverflow;\n        }\n\n        SDL_assert(width == 0);\n\n        /* cover pixels at the end of the row that didn't fit in 16 bytes. */\n        while (extrawidth) {\n            bits = *(src++);    /* max 7 pixels, don't bother with prefetch. */\n            RGBA_FROM_8888(bits, srcfmt, r, g, b, a);\n            if(!srcfmt->Amask)\n              a = info->a;\n            *(dst++) = MAKE8888(dstfmt, r, g, b, a);\n            extrawidth--;\n        }\n\n        src += srcskip;\n        dst += dstskip;\n    }\n\n}\n\n/* Altivec code to swizzle one 32-bit surface to a different 32-bit format. */\n/* Use this on a G4 */\nstatic void\nConvertAltivec32to32_prefetch(SDL_BlitInfo * info)\n{\n    const int scalar_dst_lead = sizeof(Uint32) * 4;\n    const int vector_dst_lead = sizeof(Uint32) * 16;\n\n    int height = info->dst_h;\n    Uint32 *src = (Uint32 *) info->src;\n    int srcskip = info->src_skip / 4;\n    Uint32 *dst = (Uint32 *) info->dst;\n    int dstskip = info->dst_skip / 4;\n    SDL_PixelFormat *srcfmt = info->src_fmt;\n    SDL_PixelFormat *dstfmt = info->dst_fmt;\n    vector unsigned int vzero = vec_splat_u32(0);\n    vector unsigned char vpermute = calc_swizzle32(srcfmt, dstfmt);\n    if (dstfmt->Amask && !srcfmt->Amask) {\n        if (info->a) {\n            vector unsigned char valpha;\n            ((unsigned char *) &valpha)[0] = info->a;\n            vzero = (vector unsigned int) vec_splat(valpha, 0);\n        }\n    }\n\n    SDL_assert(srcfmt->BytesPerPixel == 4);\n    SDL_assert(dstfmt->BytesPerPixel == 4);\n\n    while (height--) {\n        vector unsigned char valigner;\n        vector unsigned int vbits;\n        vector unsigned int voverflow;\n        Uint32 bits;\n        Uint8 r, g, b, a;\n\n        int width = info->dst_w;\n        int extrawidth;\n\n        /* do scalar until we can align... */\n        while ((UNALIGNED_PTR(dst)) && (width)) {\n            vec_dstt(src + scalar_dst_lead, DST_CTRL(2, 32, 1024),\n                     DST_CHAN_SRC);\n            vec_dstst(dst + scalar_dst_lead, DST_CTRL(2, 32, 1024),\n                      DST_CHAN_DEST);\n            bits = *(src++);\n            RGBA_FROM_8888(bits, srcfmt, r, g, b, a);\n            if(!srcfmt->Amask)\n              a = info->a;\n            *(dst++) = MAKE8888(dstfmt, r, g, b, a);\n            width--;\n        }\n\n        /* After all that work, here's the vector part! */\n        extrawidth = (width % 4);\n        width -= extrawidth;\n        valigner = VEC_ALIGNER(src);\n        vbits = vec_ld(0, src);\n\n        while (width) {\n            vec_dstt(src + vector_dst_lead, DST_CTRL(2, 32, 1024),\n                     DST_CHAN_SRC);\n            vec_dstst(dst + vector_dst_lead, DST_CTRL(2, 32, 1024),\n                      DST_CHAN_DEST);\n            voverflow = vec_ld(15, src);\n            src += 4;\n            width -= 4;\n            vbits = vec_perm(vbits, voverflow, valigner);       /* src is ready. */\n            vbits = vec_perm(vbits, vzero, vpermute);   /* swizzle it. */\n            vec_st(vbits, 0, dst);      /* store it back out. */\n            dst += 4;\n            vbits = voverflow;\n        }\n\n        SDL_assert(width == 0);\n\n        /* cover pixels at the end of the row that didn't fit in 16 bytes. */\n        while (extrawidth) {\n            bits = *(src++);    /* max 7 pixels, don't bother with prefetch. */\n            RGBA_FROM_8888(bits, srcfmt, r, g, b, a);\n            if(!srcfmt->Amask)\n              a = info->a;\n            *(dst++) = MAKE8888(dstfmt, r, g, b, a);\n            extrawidth--;\n        }\n\n        src += srcskip;\n        dst += dstskip;\n    }\n\n    vec_dss(DST_CHAN_SRC);\n    vec_dss(DST_CHAN_DEST);\n}\n\nstatic Uint32\nGetBlitFeatures(void)\n{\n    static Uint32 features = 0xffffffff;\n    if (features == 0xffffffff) {\n        /* Provide an override for testing .. */\n        char *override = SDL_getenv(\"SDL_ALTIVEC_BLIT_FEATURES\");\n        if (override) {\n            features = 0;\n            SDL_sscanf(override, \"%u\", &features);\n        } else {\n            features = (0\n                        /* Feature 1 is has-MMX */\n                        | ((SDL_HasMMX())? 1 : 0)\n                        /* Feature 2 is has-AltiVec */\n                        | ((SDL_HasAltiVec())? 2 : 0)\n                        /* Feature 4 is dont-use-prefetch */\n                        /* !!!! FIXME: Check for G5 or later, not the cache size! Always prefetch on a G4. */\n                        | ((GetL3CacheSize() == 0) ? 4 : 0)\n                );\n        }\n    }\n    return features;\n}\n\n#if __MWERKS__\n#pragma altivec_model off\n#endif\n#else\n/* Feature 1 is has-MMX */\n#define GetBlitFeatures() ((Uint32)(SDL_HasMMX() ? 1 : 0))\n#endif\n\n/* This is now endian dependent */\n#if SDL_BYTEORDER == SDL_LIL_ENDIAN\n#define HI  1\n#define LO  0\n#else /* SDL_BYTEORDER == SDL_BIG_ENDIAN */\n#define HI  0\n#define LO  1\n#endif\n\n/* Special optimized blit for RGB 8-8-8 --> RGB 3-3-2 */\n#define RGB888_RGB332(dst, src) { \\\n    dst = (Uint8)((((src)&0x00E00000)>>16)| \\\n                  (((src)&0x0000E000)>>11)| \\\n                  (((src)&0x000000C0)>>6)); \\\n}\nstatic void\nBlit_RGB888_index8(SDL_BlitInfo * info)\n{\n#ifndef USE_DUFFS_LOOP\n    int c;\n#endif\n    int width, height;\n    Uint32 *src;\n    const Uint8 *map;\n    Uint8 *dst;\n    int srcskip, dstskip;\n\n    /* Set up some basic variables */\n    width = info->dst_w;\n    height = info->dst_h;\n    src = (Uint32 *) info->src;\n    srcskip = info->src_skip / 4;\n    dst = info->dst;\n    dstskip = info->dst_skip;\n    map = info->table;\n\n    if (map == NULL) {\n        while (height--) {\n#ifdef USE_DUFFS_LOOP\n            /* *INDENT-OFF* */\n            DUFFS_LOOP(\n                RGB888_RGB332(*dst++, *src);\n            , width);\n            /* *INDENT-ON* */\n#else\n            for (c = width / 4; c; --c) {\n                /* Pack RGB into 8bit pixel */\n                ++src;\n                RGB888_RGB332(*dst++, *src);\n                ++src;\n                RGB888_RGB332(*dst++, *src);\n                ++src;\n                RGB888_RGB332(*dst++, *src);\n                ++src;\n            }\n            switch (width & 3) {\n            case 3:\n                RGB888_RGB332(*dst++, *src);\n                ++src;\n            case 2:\n                RGB888_RGB332(*dst++, *src);\n                ++src;\n            case 1:\n                RGB888_RGB332(*dst++, *src);\n                ++src;\n            }\n#endif /* USE_DUFFS_LOOP */\n            src += srcskip;\n            dst += dstskip;\n        }\n    } else {\n        int Pixel;\n\n        while (height--) {\n#ifdef USE_DUFFS_LOOP\n            /* *INDENT-OFF* */\n            DUFFS_LOOP(\n                RGB888_RGB332(Pixel, *src);\n                *dst++ = map[Pixel];\n                ++src;\n            , width);\n            /* *INDENT-ON* */\n#else\n            for (c = width / 4; c; --c) {\n                /* Pack RGB into 8bit pixel */\n                RGB888_RGB332(Pixel, *src);\n                *dst++ = map[Pixel];\n                ++src;\n                RGB888_RGB332(Pixel, *src);\n                *dst++ = map[Pixel];\n                ++src;\n                RGB888_RGB332(Pixel, *src);\n                *dst++ = map[Pixel];\n                ++src;\n                RGB888_RGB332(Pixel, *src);\n                *dst++ = map[Pixel];\n                ++src;\n            }\n            switch (width & 3) {\n            case 3:\n                RGB888_RGB332(Pixel, *src);\n                *dst++ = map[Pixel];\n                ++src;\n            case 2:\n                RGB888_RGB332(Pixel, *src);\n                *dst++ = map[Pixel];\n                ++src;\n            case 1:\n                RGB888_RGB332(Pixel, *src);\n                *dst++ = map[Pixel];\n                ++src;\n            }\n#endif /* USE_DUFFS_LOOP */\n            src += srcskip;\n            dst += dstskip;\n        }\n    }\n}\n\n/* Special optimized blit for RGB 10-10-10 --> RGB 3-3-2 */\n#define RGB101010_RGB332(dst, src) { \\\n    dst = (Uint8)((((src)&0x38000000)>>22)| \\\n                  (((src)&0x000E0000)>>15)| \\\n                  (((src)&0x00000300)>>8)); \\\n}\nstatic void\nBlit_RGB101010_index8(SDL_BlitInfo * info)\n{\n#ifndef USE_DUFFS_LOOP\n    int c;\n#endif\n    int width, height;\n    Uint32 *src;\n    const Uint8 *map;\n    Uint8 *dst;\n    int srcskip, dstskip;\n\n    /* Set up some basic variables */\n    width = info->dst_w;\n    height = info->dst_h;\n    src = (Uint32 *) info->src;\n    srcskip = info->src_skip / 4;\n    dst = info->dst;\n    dstskip = info->dst_skip;\n    map = info->table;\n\n    if (map == NULL) {\n        while (height--) {\n#ifdef USE_DUFFS_LOOP\n            /* *INDENT-OFF* */\n            DUFFS_LOOP(\n                RGB101010_RGB332(*dst++, *src);\n            , width);\n            /* *INDENT-ON* */\n#else\n            for (c = width / 4; c; --c) {\n                /* Pack RGB into 8bit pixel */\n                ++src;\n                RGB101010_RGB332(*dst++, *src);\n                ++src;\n                RGB101010_RGB332(*dst++, *src);\n                ++src;\n                RGB101010_RGB332(*dst++, *src);\n                ++src;\n            }\n            switch (width & 3) {\n            case 3:\n                RGB101010_RGB332(*dst++, *src);\n                ++src;\n            case 2:\n                RGB101010_RGB332(*dst++, *src);\n                ++src;\n            case 1:\n                RGB101010_RGB332(*dst++, *src);\n                ++src;\n            }\n#endif /* USE_DUFFS_LOOP */\n            src += srcskip;\n            dst += dstskip;\n        }\n    } else {\n        int Pixel;\n\n        while (height--) {\n#ifdef USE_DUFFS_LOOP\n            /* *INDENT-OFF* */\n            DUFFS_LOOP(\n                RGB101010_RGB332(Pixel, *src);\n                *dst++ = map[Pixel];\n                ++src;\n            , width);\n            /* *INDENT-ON* */\n#else\n            for (c = width / 4; c; --c) {\n                /* Pack RGB into 8bit pixel */\n                RGB101010_RGB332(Pixel, *src);\n                *dst++ = map[Pixel];\n                ++src;\n                RGB101010_RGB332(Pixel, *src);\n                *dst++ = map[Pixel];\n                ++src;\n                RGB101010_RGB332(Pixel, *src);\n                *dst++ = map[Pixel];\n                ++src;\n                RGB101010_RGB332(Pixel, *src);\n                *dst++ = map[Pixel];\n                ++src;\n            }\n            switch (width & 3) {\n            case 3:\n                RGB101010_RGB332(Pixel, *src);\n                *dst++ = map[Pixel];\n                ++src;\n            case 2:\n                RGB101010_RGB332(Pixel, *src);\n                *dst++ = map[Pixel];\n                ++src;\n            case 1:\n                RGB101010_RGB332(Pixel, *src);\n                *dst++ = map[Pixel];\n                ++src;\n            }\n#endif /* USE_DUFFS_LOOP */\n            src += srcskip;\n            dst += dstskip;\n        }\n    }\n}\n\n/* Special optimized blit for RGB 8-8-8 --> RGB 5-5-5 */\n#define RGB888_RGB555(dst, src) { \\\n    *(Uint16 *)(dst) = (Uint16)((((*src)&0x00F80000)>>9)| \\\n                                (((*src)&0x0000F800)>>6)| \\\n                                (((*src)&0x000000F8)>>3)); \\\n}\n#define RGB888_RGB555_TWO(dst, src) { \\\n    *(Uint32 *)(dst) = (((((src[HI])&0x00F80000)>>9)| \\\n                         (((src[HI])&0x0000F800)>>6)| \\\n                         (((src[HI])&0x000000F8)>>3))<<16)| \\\n                         (((src[LO])&0x00F80000)>>9)| \\\n                         (((src[LO])&0x0000F800)>>6)| \\\n                         (((src[LO])&0x000000F8)>>3); \\\n}\nstatic void\nBlit_RGB888_RGB555(SDL_BlitInfo * info)\n{\n#ifndef USE_DUFFS_LOOP\n    int c;\n#endif\n    int width, height;\n    Uint32 *src;\n    Uint16 *dst;\n    int srcskip, dstskip;\n\n    /* Set up some basic variables */\n    width = info->dst_w;\n    height = info->dst_h;\n    src = (Uint32 *) info->src;\n    srcskip = info->src_skip / 4;\n    dst = (Uint16 *) info->dst;\n    dstskip = info->dst_skip / 2;\n\n#ifdef USE_DUFFS_LOOP\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP(\n            RGB888_RGB555(dst, src);\n            ++src;\n            ++dst;\n        , width);\n        /* *INDENT-ON* */\n        src += srcskip;\n        dst += dstskip;\n    }\n#else\n    /* Memory align at 4-byte boundary, if necessary */\n    if ((long) dst & 0x03) {\n        /* Don't do anything if width is 0 */\n        if (width == 0) {\n            return;\n        }\n        --width;\n\n        while (height--) {\n            /* Perform copy alignment */\n            RGB888_RGB555(dst, src);\n            ++src;\n            ++dst;\n\n            /* Copy in 4 pixel chunks */\n            for (c = width / 4; c; --c) {\n                RGB888_RGB555_TWO(dst, src);\n                src += 2;\n                dst += 2;\n                RGB888_RGB555_TWO(dst, src);\n                src += 2;\n                dst += 2;\n            }\n            /* Get any leftovers */\n            switch (width & 3) {\n            case 3:\n                RGB888_RGB555(dst, src);\n                ++src;\n                ++dst;\n            case 2:\n                RGB888_RGB555_TWO(dst, src);\n                src += 2;\n                dst += 2;\n                break;\n            case 1:\n                RGB888_RGB555(dst, src);\n                ++src;\n                ++dst;\n                break;\n            }\n            src += srcskip;\n            dst += dstskip;\n        }\n    } else {\n        while (height--) {\n            /* Copy in 4 pixel chunks */\n            for (c = width / 4; c; --c) {\n                RGB888_RGB555_TWO(dst, src);\n                src += 2;\n                dst += 2;\n                RGB888_RGB555_TWO(dst, src);\n                src += 2;\n                dst += 2;\n            }\n            /* Get any leftovers */\n            switch (width & 3) {\n            case 3:\n                RGB888_RGB555(dst, src);\n                ++src;\n                ++dst;\n            case 2:\n                RGB888_RGB555_TWO(dst, src);\n                src += 2;\n                dst += 2;\n                break;\n            case 1:\n                RGB888_RGB555(dst, src);\n                ++src;\n                ++dst;\n                break;\n            }\n            src += srcskip;\n            dst += dstskip;\n        }\n    }\n#endif /* USE_DUFFS_LOOP */\n}\n\n/* Special optimized blit for RGB 8-8-8 --> RGB 5-6-5 */\n#define RGB888_RGB565(dst, src) { \\\n    *(Uint16 *)(dst) = (Uint16)((((*src)&0x00F80000)>>8)| \\\n                                (((*src)&0x0000FC00)>>5)| \\\n                                (((*src)&0x000000F8)>>3)); \\\n}\n#define RGB888_RGB565_TWO(dst, src) { \\\n    *(Uint32 *)(dst) = (((((src[HI])&0x00F80000)>>8)| \\\n                         (((src[HI])&0x0000FC00)>>5)| \\\n                         (((src[HI])&0x000000F8)>>3))<<16)| \\\n                         (((src[LO])&0x00F80000)>>8)| \\\n                         (((src[LO])&0x0000FC00)>>5)| \\\n                         (((src[LO])&0x000000F8)>>3); \\\n}\nstatic void\nBlit_RGB888_RGB565(SDL_BlitInfo * info)\n{\n#ifndef USE_DUFFS_LOOP\n    int c;\n#endif\n    int width, height;\n    Uint32 *src;\n    Uint16 *dst;\n    int srcskip, dstskip;\n\n    /* Set up some basic variables */\n    width = info->dst_w;\n    height = info->dst_h;\n    src = (Uint32 *) info->src;\n    srcskip = info->src_skip / 4;\n    dst = (Uint16 *) info->dst;\n    dstskip = info->dst_skip / 2;\n\n#ifdef USE_DUFFS_LOOP\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP(\n            RGB888_RGB565(dst, src);\n            ++src;\n            ++dst;\n        , width);\n        /* *INDENT-ON* */\n        src += srcskip;\n        dst += dstskip;\n    }\n#else\n    /* Memory align at 4-byte boundary, if necessary */\n    if ((long) dst & 0x03) {\n        /* Don't do anything if width is 0 */\n        if (width == 0) {\n            return;\n        }\n        --width;\n\n        while (height--) {\n            /* Perform copy alignment */\n            RGB888_RGB565(dst, src);\n            ++src;\n            ++dst;\n\n            /* Copy in 4 pixel chunks */\n            for (c = width / 4; c; --c) {\n                RGB888_RGB565_TWO(dst, src);\n                src += 2;\n                dst += 2;\n                RGB888_RGB565_TWO(dst, src);\n                src += 2;\n                dst += 2;\n            }\n            /* Get any leftovers */\n            switch (width & 3) {\n            case 3:\n                RGB888_RGB565(dst, src);\n                ++src;\n                ++dst;\n            case 2:\n                RGB888_RGB565_TWO(dst, src);\n                src += 2;\n                dst += 2;\n                break;\n            case 1:\n                RGB888_RGB565(dst, src);\n                ++src;\n                ++dst;\n                break;\n            }\n            src += srcskip;\n            dst += dstskip;\n        }\n    } else {\n        while (height--) {\n            /* Copy in 4 pixel chunks */\n            for (c = width / 4; c; --c) {\n                RGB888_RGB565_TWO(dst, src);\n                src += 2;\n                dst += 2;\n                RGB888_RGB565_TWO(dst, src);\n                src += 2;\n                dst += 2;\n            }\n            /* Get any leftovers */\n            switch (width & 3) {\n            case 3:\n                RGB888_RGB565(dst, src);\n                ++src;\n                ++dst;\n            case 2:\n                RGB888_RGB565_TWO(dst, src);\n                src += 2;\n                dst += 2;\n                break;\n            case 1:\n                RGB888_RGB565(dst, src);\n                ++src;\n                ++dst;\n                break;\n            }\n            src += srcskip;\n            dst += dstskip;\n        }\n    }\n#endif /* USE_DUFFS_LOOP */\n}\n\n\n/* Special optimized blit for RGB 5-6-5 --> 32-bit RGB surfaces */\n#define RGB565_32(dst, src, map) (map[src[LO]*2] + map[src[HI]*2+1])\nstatic void\nBlit_RGB565_32(SDL_BlitInfo * info, const Uint32 * map)\n{\n#ifndef USE_DUFFS_LOOP\n    int c;\n#endif\n    int width, height;\n    Uint8 *src;\n    Uint32 *dst;\n    int srcskip, dstskip;\n\n    /* Set up some basic variables */\n    width = info->dst_w;\n    height = info->dst_h;\n    src = (Uint8 *) info->src;\n    srcskip = info->src_skip;\n    dst = (Uint32 *) info->dst;\n    dstskip = info->dst_skip / 4;\n\n#ifdef USE_DUFFS_LOOP\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP(\n        {\n            *dst++ = RGB565_32(dst, src, map);\n            src += 2;\n        },\n        width);\n        /* *INDENT-ON* */\n        src += srcskip;\n        dst += dstskip;\n    }\n#else\n    while (height--) {\n        /* Copy in 4 pixel chunks */\n        for (c = width / 4; c; --c) {\n            *dst++ = RGB565_32(dst, src, map);\n            src += 2;\n            *dst++ = RGB565_32(dst, src, map);\n            src += 2;\n            *dst++ = RGB565_32(dst, src, map);\n            src += 2;\n            *dst++ = RGB565_32(dst, src, map);\n            src += 2;\n        }\n        /* Get any leftovers */\n        switch (width & 3) {\n        case 3:\n            *dst++ = RGB565_32(dst, src, map);\n            src += 2;\n        case 2:\n            *dst++ = RGB565_32(dst, src, map);\n            src += 2;\n        case 1:\n            *dst++ = RGB565_32(dst, src, map);\n            src += 2;\n            break;\n        }\n        src += srcskip;\n        dst += dstskip;\n    }\n#endif /* USE_DUFFS_LOOP */\n}\n\n/* Special optimized blit for RGB 5-6-5 --> ARGB 8-8-8-8 */\nstatic const Uint32 RGB565_ARGB8888_LUT[512] = {\n    0x00000000, 0xff000000, 0x00000008, 0xff002000,\n    0x00000010, 0xff004000, 0x00000018, 0xff006100,\n    0x00000020, 0xff008100, 0x00000029, 0xff00a100,\n    0x00000031, 0xff00c200, 0x00000039, 0xff00e200,\n    0x00000041, 0xff080000, 0x0000004a, 0xff082000,\n    0x00000052, 0xff084000, 0x0000005a, 0xff086100,\n    0x00000062, 0xff088100, 0x0000006a, 0xff08a100,\n    0x00000073, 0xff08c200, 0x0000007b, 0xff08e200,\n    0x00000083, 0xff100000, 0x0000008b, 0xff102000,\n    0x00000094, 0xff104000, 0x0000009c, 0xff106100,\n    0x000000a4, 0xff108100, 0x000000ac, 0xff10a100,\n    0x000000b4, 0xff10c200, 0x000000bd, 0xff10e200,\n    0x000000c5, 0xff180000, 0x000000cd, 0xff182000,\n    0x000000d5, 0xff184000, 0x000000de, 0xff186100,\n    0x000000e6, 0xff188100, 0x000000ee, 0xff18a100,\n    0x000000f6, 0xff18c200, 0x000000ff, 0xff18e200,\n    0x00000400, 0xff200000, 0x00000408, 0xff202000,\n    0x00000410, 0xff204000, 0x00000418, 0xff206100,\n    0x00000420, 0xff208100, 0x00000429, 0xff20a100,\n    0x00000431, 0xff20c200, 0x00000439, 0xff20e200,\n    0x00000441, 0xff290000, 0x0000044a, 0xff292000,\n    0x00000452, 0xff294000, 0x0000045a, 0xff296100,\n    0x00000462, 0xff298100, 0x0000046a, 0xff29a100,\n    0x00000473, 0xff29c200, 0x0000047b, 0xff29e200,\n    0x00000483, 0xff310000, 0x0000048b, 0xff312000,\n    0x00000494, 0xff314000, 0x0000049c, 0xff316100,\n    0x000004a4, 0xff318100, 0x000004ac, 0xff31a100,\n    0x000004b4, 0xff31c200, 0x000004bd, 0xff31e200,\n    0x000004c5, 0xff390000, 0x000004cd, 0xff392000,\n    0x000004d5, 0xff394000, 0x000004de, 0xff396100,\n    0x000004e6, 0xff398100, 0x000004ee, 0xff39a100,\n    0x000004f6, 0xff39c200, 0x000004ff, 0xff39e200,\n    0x00000800, 0xff410000, 0x00000808, 0xff412000,\n    0x00000810, 0xff414000, 0x00000818, 0xff416100,\n    0x00000820, 0xff418100, 0x00000829, 0xff41a100,\n    0x00000831, 0xff41c200, 0x00000839, 0xff41e200,\n    0x00000841, 0xff4a0000, 0x0000084a, 0xff4a2000,\n    0x00000852, 0xff4a4000, 0x0000085a, 0xff4a6100,\n    0x00000862, 0xff4a8100, 0x0000086a, 0xff4aa100,\n    0x00000873, 0xff4ac200, 0x0000087b, 0xff4ae200,\n    0x00000883, 0xff520000, 0x0000088b, 0xff522000,\n    0x00000894, 0xff524000, 0x0000089c, 0xff526100,\n    0x000008a4, 0xff528100, 0x000008ac, 0xff52a100,\n    0x000008b4, 0xff52c200, 0x000008bd, 0xff52e200,\n    0x000008c5, 0xff5a0000, 0x000008cd, 0xff5a2000,\n    0x000008d5, 0xff5a4000, 0x000008de, 0xff5a6100,\n    0x000008e6, 0xff5a8100, 0x000008ee, 0xff5aa100,\n    0x000008f6, 0xff5ac200, 0x000008ff, 0xff5ae200,\n    0x00000c00, 0xff620000, 0x00000c08, 0xff622000,\n    0x00000c10, 0xff624000, 0x00000c18, 0xff626100,\n    0x00000c20, 0xff628100, 0x00000c29, 0xff62a100,\n    0x00000c31, 0xff62c200, 0x00000c39, 0xff62e200,\n    0x00000c41, 0xff6a0000, 0x00000c4a, 0xff6a2000,\n    0x00000c52, 0xff6a4000, 0x00000c5a, 0xff6a6100,\n    0x00000c62, 0xff6a8100, 0x00000c6a, 0xff6aa100,\n    0x00000c73, 0xff6ac200, 0x00000c7b, 0xff6ae200,\n    0x00000c83, 0xff730000, 0x00000c8b, 0xff732000,\n    0x00000c94, 0xff734000, 0x00000c9c, 0xff736100,\n    0x00000ca4, 0xff738100, 0x00000cac, 0xff73a100,\n    0x00000cb4, 0xff73c200, 0x00000cbd, 0xff73e200,\n    0x00000cc5, 0xff7b0000, 0x00000ccd, 0xff7b2000,\n    0x00000cd5, 0xff7b4000, 0x00000cde, 0xff7b6100,\n    0x00000ce6, 0xff7b8100, 0x00000cee, 0xff7ba100,\n    0x00000cf6, 0xff7bc200, 0x00000cff, 0xff7be200,\n    0x00001000, 0xff830000, 0x00001008, 0xff832000,\n    0x00001010, 0xff834000, 0x00001018, 0xff836100,\n    0x00001020, 0xff838100, 0x00001029, 0xff83a100,\n    0x00001031, 0xff83c200, 0x00001039, 0xff83e200,\n    0x00001041, 0xff8b0000, 0x0000104a, 0xff8b2000,\n    0x00001052, 0xff8b4000, 0x0000105a, 0xff8b6100,\n    0x00001062, 0xff8b8100, 0x0000106a, 0xff8ba100,\n    0x00001073, 0xff8bc200, 0x0000107b, 0xff8be200,\n    0x00001083, 0xff940000, 0x0000108b, 0xff942000,\n    0x00001094, 0xff944000, 0x0000109c, 0xff946100,\n    0x000010a4, 0xff948100, 0x000010ac, 0xff94a100,\n    0x000010b4, 0xff94c200, 0x000010bd, 0xff94e200,\n    0x000010c5, 0xff9c0000, 0x000010cd, 0xff9c2000,\n    0x000010d5, 0xff9c4000, 0x000010de, 0xff9c6100,\n    0x000010e6, 0xff9c8100, 0x000010ee, 0xff9ca100,\n    0x000010f6, 0xff9cc200, 0x000010ff, 0xff9ce200,\n    0x00001400, 0xffa40000, 0x00001408, 0xffa42000,\n    0x00001410, 0xffa44000, 0x00001418, 0xffa46100,\n    0x00001420, 0xffa48100, 0x00001429, 0xffa4a100,\n    0x00001431, 0xffa4c200, 0x00001439, 0xffa4e200,\n    0x00001441, 0xffac0000, 0x0000144a, 0xffac2000,\n    0x00001452, 0xffac4000, 0x0000145a, 0xffac6100,\n    0x00001462, 0xffac8100, 0x0000146a, 0xffaca100,\n    0x00001473, 0xffacc200, 0x0000147b, 0xfface200,\n    0x00001483, 0xffb40000, 0x0000148b, 0xffb42000,\n    0x00001494, 0xffb44000, 0x0000149c, 0xffb46100,\n    0x000014a4, 0xffb48100, 0x000014ac, 0xffb4a100,\n    0x000014b4, 0xffb4c200, 0x000014bd, 0xffb4e200,\n    0x000014c5, 0xffbd0000, 0x000014cd, 0xffbd2000,\n    0x000014d5, 0xffbd4000, 0x000014de, 0xffbd6100,\n    0x000014e6, 0xffbd8100, 0x000014ee, 0xffbda100,\n    0x000014f6, 0xffbdc200, 0x000014ff, 0xffbde200,\n    0x00001800, 0xffc50000, 0x00001808, 0xffc52000,\n    0x00001810, 0xffc54000, 0x00001818, 0xffc56100,\n    0x00001820, 0xffc58100, 0x00001829, 0xffc5a100,\n    0x00001831, 0xffc5c200, 0x00001839, 0xffc5e200,\n    0x00001841, 0xffcd0000, 0x0000184a, 0xffcd2000,\n    0x00001852, 0xffcd4000, 0x0000185a, 0xffcd6100,\n    0x00001862, 0xffcd8100, 0x0000186a, 0xffcda100,\n    0x00001873, 0xffcdc200, 0x0000187b, 0xffcde200,\n    0x00001883, 0xffd50000, 0x0000188b, 0xffd52000,\n    0x00001894, 0xffd54000, 0x0000189c, 0xffd56100,\n    0x000018a4, 0xffd58100, 0x000018ac, 0xffd5a100,\n    0x000018b4, 0xffd5c200, 0x000018bd, 0xffd5e200,\n    0x000018c5, 0xffde0000, 0x000018cd, 0xffde2000,\n    0x000018d5, 0xffde4000, 0x000018de, 0xffde6100,\n    0x000018e6, 0xffde8100, 0x000018ee, 0xffdea100,\n    0x000018f6, 0xffdec200, 0x000018ff, 0xffdee200,\n    0x00001c00, 0xffe60000, 0x00001c08, 0xffe62000,\n    0x00001c10, 0xffe64000, 0x00001c18, 0xffe66100,\n    0x00001c20, 0xffe68100, 0x00001c29, 0xffe6a100,\n    0x00001c31, 0xffe6c200, 0x00001c39, 0xffe6e200,\n    0x00001c41, 0xffee0000, 0x00001c4a, 0xffee2000,\n    0x00001c52, 0xffee4000, 0x00001c5a, 0xffee6100,\n    0x00001c62, 0xffee8100, 0x00001c6a, 0xffeea100,\n    0x00001c73, 0xffeec200, 0x00001c7b, 0xffeee200,\n    0x00001c83, 0xfff60000, 0x00001c8b, 0xfff62000,\n    0x00001c94, 0xfff64000, 0x00001c9c, 0xfff66100,\n    0x00001ca4, 0xfff68100, 0x00001cac, 0xfff6a100,\n    0x00001cb4, 0xfff6c200, 0x00001cbd, 0xfff6e200,\n    0x00001cc5, 0xffff0000, 0x00001ccd, 0xffff2000,\n    0x00001cd5, 0xffff4000, 0x00001cde, 0xffff6100,\n    0x00001ce6, 0xffff8100, 0x00001cee, 0xffffa100,\n    0x00001cf6, 0xffffc200, 0x00001cff, 0xffffe200\n};\n\nstatic void\nBlit_RGB565_ARGB8888(SDL_BlitInfo * info)\n{\n    Blit_RGB565_32(info, RGB565_ARGB8888_LUT);\n}\n\n/* Special optimized blit for RGB 5-6-5 --> ABGR 8-8-8-8 */\nstatic const Uint32 RGB565_ABGR8888_LUT[512] = {\n    0xff000000, 0x00000000, 0xff080000, 0x00002000,\n    0xff100000, 0x00004000, 0xff180000, 0x00006100,\n    0xff200000, 0x00008100, 0xff290000, 0x0000a100,\n    0xff310000, 0x0000c200, 0xff390000, 0x0000e200,\n    0xff410000, 0x00000008, 0xff4a0000, 0x00002008,\n    0xff520000, 0x00004008, 0xff5a0000, 0x00006108,\n    0xff620000, 0x00008108, 0xff6a0000, 0x0000a108,\n    0xff730000, 0x0000c208, 0xff7b0000, 0x0000e208,\n    0xff830000, 0x00000010, 0xff8b0000, 0x00002010,\n    0xff940000, 0x00004010, 0xff9c0000, 0x00006110,\n    0xffa40000, 0x00008110, 0xffac0000, 0x0000a110,\n    0xffb40000, 0x0000c210, 0xffbd0000, 0x0000e210,\n    0xffc50000, 0x00000018, 0xffcd0000, 0x00002018,\n    0xffd50000, 0x00004018, 0xffde0000, 0x00006118,\n    0xffe60000, 0x00008118, 0xffee0000, 0x0000a118,\n    0xfff60000, 0x0000c218, 0xffff0000, 0x0000e218,\n    0xff000400, 0x00000020, 0xff080400, 0x00002020,\n    0xff100400, 0x00004020, 0xff180400, 0x00006120,\n    0xff200400, 0x00008120, 0xff290400, 0x0000a120,\n    0xff310400, 0x0000c220, 0xff390400, 0x0000e220,\n    0xff410400, 0x00000029, 0xff4a0400, 0x00002029,\n    0xff520400, 0x00004029, 0xff5a0400, 0x00006129,\n    0xff620400, 0x00008129, 0xff6a0400, 0x0000a129,\n    0xff730400, 0x0000c229, 0xff7b0400, 0x0000e229,\n    0xff830400, 0x00000031, 0xff8b0400, 0x00002031,\n    0xff940400, 0x00004031, 0xff9c0400, 0x00006131,\n    0xffa40400, 0x00008131, 0xffac0400, 0x0000a131,\n    0xffb40400, 0x0000c231, 0xffbd0400, 0x0000e231,\n    0xffc50400, 0x00000039, 0xffcd0400, 0x00002039,\n    0xffd50400, 0x00004039, 0xffde0400, 0x00006139,\n    0xffe60400, 0x00008139, 0xffee0400, 0x0000a139,\n    0xfff60400, 0x0000c239, 0xffff0400, 0x0000e239,\n    0xff000800, 0x00000041, 0xff080800, 0x00002041,\n    0xff100800, 0x00004041, 0xff180800, 0x00006141,\n    0xff200800, 0x00008141, 0xff290800, 0x0000a141,\n    0xff310800, 0x0000c241, 0xff390800, 0x0000e241,\n    0xff410800, 0x0000004a, 0xff4a0800, 0x0000204a,\n    0xff520800, 0x0000404a, 0xff5a0800, 0x0000614a,\n    0xff620800, 0x0000814a, 0xff6a0800, 0x0000a14a,\n    0xff730800, 0x0000c24a, 0xff7b0800, 0x0000e24a,\n    0xff830800, 0x00000052, 0xff8b0800, 0x00002052,\n    0xff940800, 0x00004052, 0xff9c0800, 0x00006152,\n    0xffa40800, 0x00008152, 0xffac0800, 0x0000a152,\n    0xffb40800, 0x0000c252, 0xffbd0800, 0x0000e252,\n    0xffc50800, 0x0000005a, 0xffcd0800, 0x0000205a,\n    0xffd50800, 0x0000405a, 0xffde0800, 0x0000615a,\n    0xffe60800, 0x0000815a, 0xffee0800, 0x0000a15a,\n    0xfff60800, 0x0000c25a, 0xffff0800, 0x0000e25a,\n    0xff000c00, 0x00000062, 0xff080c00, 0x00002062,\n    0xff100c00, 0x00004062, 0xff180c00, 0x00006162,\n    0xff200c00, 0x00008162, 0xff290c00, 0x0000a162,\n    0xff310c00, 0x0000c262, 0xff390c00, 0x0000e262,\n    0xff410c00, 0x0000006a, 0xff4a0c00, 0x0000206a,\n    0xff520c00, 0x0000406a, 0xff5a0c00, 0x0000616a,\n    0xff620c00, 0x0000816a, 0xff6a0c00, 0x0000a16a,\n    0xff730c00, 0x0000c26a, 0xff7b0c00, 0x0000e26a,\n    0xff830c00, 0x00000073, 0xff8b0c00, 0x00002073,\n    0xff940c00, 0x00004073, 0xff9c0c00, 0x00006173,\n    0xffa40c00, 0x00008173, 0xffac0c00, 0x0000a173,\n    0xffb40c00, 0x0000c273, 0xffbd0c00, 0x0000e273,\n    0xffc50c00, 0x0000007b, 0xffcd0c00, 0x0000207b,\n    0xffd50c00, 0x0000407b, 0xffde0c00, 0x0000617b,\n    0xffe60c00, 0x0000817b, 0xffee0c00, 0x0000a17b,\n    0xfff60c00, 0x0000c27b, 0xffff0c00, 0x0000e27b,\n    0xff001000, 0x00000083, 0xff081000, 0x00002083,\n    0xff101000, 0x00004083, 0xff181000, 0x00006183,\n    0xff201000, 0x00008183, 0xff291000, 0x0000a183,\n    0xff311000, 0x0000c283, 0xff391000, 0x0000e283,\n    0xff411000, 0x0000008b, 0xff4a1000, 0x0000208b,\n    0xff521000, 0x0000408b, 0xff5a1000, 0x0000618b,\n    0xff621000, 0x0000818b, 0xff6a1000, 0x0000a18b,\n    0xff731000, 0x0000c28b, 0xff7b1000, 0x0000e28b,\n    0xff831000, 0x00000094, 0xff8b1000, 0x00002094,\n    0xff941000, 0x00004094, 0xff9c1000, 0x00006194,\n    0xffa41000, 0x00008194, 0xffac1000, 0x0000a194,\n    0xffb41000, 0x0000c294, 0xffbd1000, 0x0000e294,\n    0xffc51000, 0x0000009c, 0xffcd1000, 0x0000209c,\n    0xffd51000, 0x0000409c, 0xffde1000, 0x0000619c,\n    0xffe61000, 0x0000819c, 0xffee1000, 0x0000a19c,\n    0xfff61000, 0x0000c29c, 0xffff1000, 0x0000e29c,\n    0xff001400, 0x000000a4, 0xff081400, 0x000020a4,\n    0xff101400, 0x000040a4, 0xff181400, 0x000061a4,\n    0xff201400, 0x000081a4, 0xff291400, 0x0000a1a4,\n    0xff311400, 0x0000c2a4, 0xff391400, 0x0000e2a4,\n    0xff411400, 0x000000ac, 0xff4a1400, 0x000020ac,\n    0xff521400, 0x000040ac, 0xff5a1400, 0x000061ac,\n    0xff621400, 0x000081ac, 0xff6a1400, 0x0000a1ac,\n    0xff731400, 0x0000c2ac, 0xff7b1400, 0x0000e2ac,\n    0xff831400, 0x000000b4, 0xff8b1400, 0x000020b4,\n    0xff941400, 0x000040b4, 0xff9c1400, 0x000061b4,\n    0xffa41400, 0x000081b4, 0xffac1400, 0x0000a1b4,\n    0xffb41400, 0x0000c2b4, 0xffbd1400, 0x0000e2b4,\n    0xffc51400, 0x000000bd, 0xffcd1400, 0x000020bd,\n    0xffd51400, 0x000040bd, 0xffde1400, 0x000061bd,\n    0xffe61400, 0x000081bd, 0xffee1400, 0x0000a1bd,\n    0xfff61400, 0x0000c2bd, 0xffff1400, 0x0000e2bd,\n    0xff001800, 0x000000c5, 0xff081800, 0x000020c5,\n    0xff101800, 0x000040c5, 0xff181800, 0x000061c5,\n    0xff201800, 0x000081c5, 0xff291800, 0x0000a1c5,\n    0xff311800, 0x0000c2c5, 0xff391800, 0x0000e2c5,\n    0xff411800, 0x000000cd, 0xff4a1800, 0x000020cd,\n    0xff521800, 0x000040cd, 0xff5a1800, 0x000061cd,\n    0xff621800, 0x000081cd, 0xff6a1800, 0x0000a1cd,\n    0xff731800, 0x0000c2cd, 0xff7b1800, 0x0000e2cd,\n    0xff831800, 0x000000d5, 0xff8b1800, 0x000020d5,\n    0xff941800, 0x000040d5, 0xff9c1800, 0x000061d5,\n    0xffa41800, 0x000081d5, 0xffac1800, 0x0000a1d5,\n    0xffb41800, 0x0000c2d5, 0xffbd1800, 0x0000e2d5,\n    0xffc51800, 0x000000de, 0xffcd1800, 0x000020de,\n    0xffd51800, 0x000040de, 0xffde1800, 0x000061de,\n    0xffe61800, 0x000081de, 0xffee1800, 0x0000a1de,\n    0xfff61800, 0x0000c2de, 0xffff1800, 0x0000e2de,\n    0xff001c00, 0x000000e6, 0xff081c00, 0x000020e6,\n    0xff101c00, 0x000040e6, 0xff181c00, 0x000061e6,\n    0xff201c00, 0x000081e6, 0xff291c00, 0x0000a1e6,\n    0xff311c00, 0x0000c2e6, 0xff391c00, 0x0000e2e6,\n    0xff411c00, 0x000000ee, 0xff4a1c00, 0x000020ee,\n    0xff521c00, 0x000040ee, 0xff5a1c00, 0x000061ee,\n    0xff621c00, 0x000081ee, 0xff6a1c00, 0x0000a1ee,\n    0xff731c00, 0x0000c2ee, 0xff7b1c00, 0x0000e2ee,\n    0xff831c00, 0x000000f6, 0xff8b1c00, 0x000020f6,\n    0xff941c00, 0x000040f6, 0xff9c1c00, 0x000061f6,\n    0xffa41c00, 0x000081f6, 0xffac1c00, 0x0000a1f6,\n    0xffb41c00, 0x0000c2f6, 0xffbd1c00, 0x0000e2f6,\n    0xffc51c00, 0x000000ff, 0xffcd1c00, 0x000020ff,\n    0xffd51c00, 0x000040ff, 0xffde1c00, 0x000061ff,\n    0xffe61c00, 0x000081ff, 0xffee1c00, 0x0000a1ff,\n    0xfff61c00, 0x0000c2ff, 0xffff1c00, 0x0000e2ff\n};\n\nstatic void\nBlit_RGB565_ABGR8888(SDL_BlitInfo * info)\n{\n    Blit_RGB565_32(info, RGB565_ABGR8888_LUT);\n}\n\n/* Special optimized blit for RGB 5-6-5 --> RGBA 8-8-8-8 */\nstatic const Uint32 RGB565_RGBA8888_LUT[512] = {\n    0x000000ff, 0x00000000, 0x000008ff, 0x00200000,\n    0x000010ff, 0x00400000, 0x000018ff, 0x00610000,\n    0x000020ff, 0x00810000, 0x000029ff, 0x00a10000,\n    0x000031ff, 0x00c20000, 0x000039ff, 0x00e20000,\n    0x000041ff, 0x08000000, 0x00004aff, 0x08200000,\n    0x000052ff, 0x08400000, 0x00005aff, 0x08610000,\n    0x000062ff, 0x08810000, 0x00006aff, 0x08a10000,\n    0x000073ff, 0x08c20000, 0x00007bff, 0x08e20000,\n    0x000083ff, 0x10000000, 0x00008bff, 0x10200000,\n    0x000094ff, 0x10400000, 0x00009cff, 0x10610000,\n    0x0000a4ff, 0x10810000, 0x0000acff, 0x10a10000,\n    0x0000b4ff, 0x10c20000, 0x0000bdff, 0x10e20000,\n    0x0000c5ff, 0x18000000, 0x0000cdff, 0x18200000,\n    0x0000d5ff, 0x18400000, 0x0000deff, 0x18610000,\n    0x0000e6ff, 0x18810000, 0x0000eeff, 0x18a10000,\n    0x0000f6ff, 0x18c20000, 0x0000ffff, 0x18e20000,\n    0x000400ff, 0x20000000, 0x000408ff, 0x20200000,\n    0x000410ff, 0x20400000, 0x000418ff, 0x20610000,\n    0x000420ff, 0x20810000, 0x000429ff, 0x20a10000,\n    0x000431ff, 0x20c20000, 0x000439ff, 0x20e20000,\n    0x000441ff, 0x29000000, 0x00044aff, 0x29200000,\n    0x000452ff, 0x29400000, 0x00045aff, 0x29610000,\n    0x000462ff, 0x29810000, 0x00046aff, 0x29a10000,\n    0x000473ff, 0x29c20000, 0x00047bff, 0x29e20000,\n    0x000483ff, 0x31000000, 0x00048bff, 0x31200000,\n    0x000494ff, 0x31400000, 0x00049cff, 0x31610000,\n    0x0004a4ff, 0x31810000, 0x0004acff, 0x31a10000,\n    0x0004b4ff, 0x31c20000, 0x0004bdff, 0x31e20000,\n    0x0004c5ff, 0x39000000, 0x0004cdff, 0x39200000,\n    0x0004d5ff, 0x39400000, 0x0004deff, 0x39610000,\n    0x0004e6ff, 0x39810000, 0x0004eeff, 0x39a10000,\n    0x0004f6ff, 0x39c20000, 0x0004ffff, 0x39e20000,\n    0x000800ff, 0x41000000, 0x000808ff, 0x41200000,\n    0x000810ff, 0x41400000, 0x000818ff, 0x41610000,\n    0x000820ff, 0x41810000, 0x000829ff, 0x41a10000,\n    0x000831ff, 0x41c20000, 0x000839ff, 0x41e20000,\n    0x000841ff, 0x4a000000, 0x00084aff, 0x4a200000,\n    0x000852ff, 0x4a400000, 0x00085aff, 0x4a610000,\n    0x000862ff, 0x4a810000, 0x00086aff, 0x4aa10000,\n    0x000873ff, 0x4ac20000, 0x00087bff, 0x4ae20000,\n    0x000883ff, 0x52000000, 0x00088bff, 0x52200000,\n    0x000894ff, 0x52400000, 0x00089cff, 0x52610000,\n    0x0008a4ff, 0x52810000, 0x0008acff, 0x52a10000,\n    0x0008b4ff, 0x52c20000, 0x0008bdff, 0x52e20000,\n    0x0008c5ff, 0x5a000000, 0x0008cdff, 0x5a200000,\n    0x0008d5ff, 0x5a400000, 0x0008deff, 0x5a610000,\n    0x0008e6ff, 0x5a810000, 0x0008eeff, 0x5aa10000,\n    0x0008f6ff, 0x5ac20000, 0x0008ffff, 0x5ae20000,\n    0x000c00ff, 0x62000000, 0x000c08ff, 0x62200000,\n    0x000c10ff, 0x62400000, 0x000c18ff, 0x62610000,\n    0x000c20ff, 0x62810000, 0x000c29ff, 0x62a10000,\n    0x000c31ff, 0x62c20000, 0x000c39ff, 0x62e20000,\n    0x000c41ff, 0x6a000000, 0x000c4aff, 0x6a200000,\n    0x000c52ff, 0x6a400000, 0x000c5aff, 0x6a610000,\n    0x000c62ff, 0x6a810000, 0x000c6aff, 0x6aa10000,\n    0x000c73ff, 0x6ac20000, 0x000c7bff, 0x6ae20000,\n    0x000c83ff, 0x73000000, 0x000c8bff, 0x73200000,\n    0x000c94ff, 0x73400000, 0x000c9cff, 0x73610000,\n    0x000ca4ff, 0x73810000, 0x000cacff, 0x73a10000,\n    0x000cb4ff, 0x73c20000, 0x000cbdff, 0x73e20000,\n    0x000cc5ff, 0x7b000000, 0x000ccdff, 0x7b200000,\n    0x000cd5ff, 0x7b400000, 0x000cdeff, 0x7b610000,\n    0x000ce6ff, 0x7b810000, 0x000ceeff, 0x7ba10000,\n    0x000cf6ff, 0x7bc20000, 0x000cffff, 0x7be20000,\n    0x001000ff, 0x83000000, 0x001008ff, 0x83200000,\n    0x001010ff, 0x83400000, 0x001018ff, 0x83610000,\n    0x001020ff, 0x83810000, 0x001029ff, 0x83a10000,\n    0x001031ff, 0x83c20000, 0x001039ff, 0x83e20000,\n    0x001041ff, 0x8b000000, 0x00104aff, 0x8b200000,\n    0x001052ff, 0x8b400000, 0x00105aff, 0x8b610000,\n    0x001062ff, 0x8b810000, 0x00106aff, 0x8ba10000,\n    0x001073ff, 0x8bc20000, 0x00107bff, 0x8be20000,\n    0x001083ff, 0x94000000, 0x00108bff, 0x94200000,\n    0x001094ff, 0x94400000, 0x00109cff, 0x94610000,\n    0x0010a4ff, 0x94810000, 0x0010acff, 0x94a10000,\n    0x0010b4ff, 0x94c20000, 0x0010bdff, 0x94e20000,\n    0x0010c5ff, 0x9c000000, 0x0010cdff, 0x9c200000,\n    0x0010d5ff, 0x9c400000, 0x0010deff, 0x9c610000,\n    0x0010e6ff, 0x9c810000, 0x0010eeff, 0x9ca10000,\n    0x0010f6ff, 0x9cc20000, 0x0010ffff, 0x9ce20000,\n    0x001400ff, 0xa4000000, 0x001408ff, 0xa4200000,\n    0x001410ff, 0xa4400000, 0x001418ff, 0xa4610000,\n    0x001420ff, 0xa4810000, 0x001429ff, 0xa4a10000,\n    0x001431ff, 0xa4c20000, 0x001439ff, 0xa4e20000,\n    0x001441ff, 0xac000000, 0x00144aff, 0xac200000,\n    0x001452ff, 0xac400000, 0x00145aff, 0xac610000,\n    0x001462ff, 0xac810000, 0x00146aff, 0xaca10000,\n    0x001473ff, 0xacc20000, 0x00147bff, 0xace20000,\n    0x001483ff, 0xb4000000, 0x00148bff, 0xb4200000,\n    0x001494ff, 0xb4400000, 0x00149cff, 0xb4610000,\n    0x0014a4ff, 0xb4810000, 0x0014acff, 0xb4a10000,\n    0x0014b4ff, 0xb4c20000, 0x0014bdff, 0xb4e20000,\n    0x0014c5ff, 0xbd000000, 0x0014cdff, 0xbd200000,\n    0x0014d5ff, 0xbd400000, 0x0014deff, 0xbd610000,\n    0x0014e6ff, 0xbd810000, 0x0014eeff, 0xbda10000,\n    0x0014f6ff, 0xbdc20000, 0x0014ffff, 0xbde20000,\n    0x001800ff, 0xc5000000, 0x001808ff, 0xc5200000,\n    0x001810ff, 0xc5400000, 0x001818ff, 0xc5610000,\n    0x001820ff, 0xc5810000, 0x001829ff, 0xc5a10000,\n    0x001831ff, 0xc5c20000, 0x001839ff, 0xc5e20000,\n    0x001841ff, 0xcd000000, 0x00184aff, 0xcd200000,\n    0x001852ff, 0xcd400000, 0x00185aff, 0xcd610000,\n    0x001862ff, 0xcd810000, 0x00186aff, 0xcda10000,\n    0x001873ff, 0xcdc20000, 0x00187bff, 0xcde20000,\n    0x001883ff, 0xd5000000, 0x00188bff, 0xd5200000,\n    0x001894ff, 0xd5400000, 0x00189cff, 0xd5610000,\n    0x0018a4ff, 0xd5810000, 0x0018acff, 0xd5a10000,\n    0x0018b4ff, 0xd5c20000, 0x0018bdff, 0xd5e20000,\n    0x0018c5ff, 0xde000000, 0x0018cdff, 0xde200000,\n    0x0018d5ff, 0xde400000, 0x0018deff, 0xde610000,\n    0x0018e6ff, 0xde810000, 0x0018eeff, 0xdea10000,\n    0x0018f6ff, 0xdec20000, 0x0018ffff, 0xdee20000,\n    0x001c00ff, 0xe6000000, 0x001c08ff, 0xe6200000,\n    0x001c10ff, 0xe6400000, 0x001c18ff, 0xe6610000,\n    0x001c20ff, 0xe6810000, 0x001c29ff, 0xe6a10000,\n    0x001c31ff, 0xe6c20000, 0x001c39ff, 0xe6e20000,\n    0x001c41ff, 0xee000000, 0x001c4aff, 0xee200000,\n    0x001c52ff, 0xee400000, 0x001c5aff, 0xee610000,\n    0x001c62ff, 0xee810000, 0x001c6aff, 0xeea10000,\n    0x001c73ff, 0xeec20000, 0x001c7bff, 0xeee20000,\n    0x001c83ff, 0xf6000000, 0x001c8bff, 0xf6200000,\n    0x001c94ff, 0xf6400000, 0x001c9cff, 0xf6610000,\n    0x001ca4ff, 0xf6810000, 0x001cacff, 0xf6a10000,\n    0x001cb4ff, 0xf6c20000, 0x001cbdff, 0xf6e20000,\n    0x001cc5ff, 0xff000000, 0x001ccdff, 0xff200000,\n    0x001cd5ff, 0xff400000, 0x001cdeff, 0xff610000,\n    0x001ce6ff, 0xff810000, 0x001ceeff, 0xffa10000,\n    0x001cf6ff, 0xffc20000, 0x001cffff, 0xffe20000,\n};\n\nstatic void\nBlit_RGB565_RGBA8888(SDL_BlitInfo * info)\n{\n    Blit_RGB565_32(info, RGB565_RGBA8888_LUT);\n}\n\n/* Special optimized blit for RGB 5-6-5 --> BGRA 8-8-8-8 */\nstatic const Uint32 RGB565_BGRA8888_LUT[512] = {\n    0x00000000, 0x000000ff, 0x08000000, 0x002000ff,\n    0x10000000, 0x004000ff, 0x18000000, 0x006100ff,\n    0x20000000, 0x008100ff, 0x29000000, 0x00a100ff,\n    0x31000000, 0x00c200ff, 0x39000000, 0x00e200ff,\n    0x41000000, 0x000008ff, 0x4a000000, 0x002008ff,\n    0x52000000, 0x004008ff, 0x5a000000, 0x006108ff,\n    0x62000000, 0x008108ff, 0x6a000000, 0x00a108ff,\n    0x73000000, 0x00c208ff, 0x7b000000, 0x00e208ff,\n    0x83000000, 0x000010ff, 0x8b000000, 0x002010ff,\n    0x94000000, 0x004010ff, 0x9c000000, 0x006110ff,\n    0xa4000000, 0x008110ff, 0xac000000, 0x00a110ff,\n    0xb4000000, 0x00c210ff, 0xbd000000, 0x00e210ff,\n    0xc5000000, 0x000018ff, 0xcd000000, 0x002018ff,\n    0xd5000000, 0x004018ff, 0xde000000, 0x006118ff,\n    0xe6000000, 0x008118ff, 0xee000000, 0x00a118ff,\n    0xf6000000, 0x00c218ff, 0xff000000, 0x00e218ff,\n    0x00040000, 0x000020ff, 0x08040000, 0x002020ff,\n    0x10040000, 0x004020ff, 0x18040000, 0x006120ff,\n    0x20040000, 0x008120ff, 0x29040000, 0x00a120ff,\n    0x31040000, 0x00c220ff, 0x39040000, 0x00e220ff,\n    0x41040000, 0x000029ff, 0x4a040000, 0x002029ff,\n    0x52040000, 0x004029ff, 0x5a040000, 0x006129ff,\n    0x62040000, 0x008129ff, 0x6a040000, 0x00a129ff,\n    0x73040000, 0x00c229ff, 0x7b040000, 0x00e229ff,\n    0x83040000, 0x000031ff, 0x8b040000, 0x002031ff,\n    0x94040000, 0x004031ff, 0x9c040000, 0x006131ff,\n    0xa4040000, 0x008131ff, 0xac040000, 0x00a131ff,\n    0xb4040000, 0x00c231ff, 0xbd040000, 0x00e231ff,\n    0xc5040000, 0x000039ff, 0xcd040000, 0x002039ff,\n    0xd5040000, 0x004039ff, 0xde040000, 0x006139ff,\n    0xe6040000, 0x008139ff, 0xee040000, 0x00a139ff,\n    0xf6040000, 0x00c239ff, 0xff040000, 0x00e239ff,\n    0x00080000, 0x000041ff, 0x08080000, 0x002041ff,\n    0x10080000, 0x004041ff, 0x18080000, 0x006141ff,\n    0x20080000, 0x008141ff, 0x29080000, 0x00a141ff,\n    0x31080000, 0x00c241ff, 0x39080000, 0x00e241ff,\n    0x41080000, 0x00004aff, 0x4a080000, 0x00204aff,\n    0x52080000, 0x00404aff, 0x5a080000, 0x00614aff,\n    0x62080000, 0x00814aff, 0x6a080000, 0x00a14aff,\n    0x73080000, 0x00c24aff, 0x7b080000, 0x00e24aff,\n    0x83080000, 0x000052ff, 0x8b080000, 0x002052ff,\n    0x94080000, 0x004052ff, 0x9c080000, 0x006152ff,\n    0xa4080000, 0x008152ff, 0xac080000, 0x00a152ff,\n    0xb4080000, 0x00c252ff, 0xbd080000, 0x00e252ff,\n    0xc5080000, 0x00005aff, 0xcd080000, 0x00205aff,\n    0xd5080000, 0x00405aff, 0xde080000, 0x00615aff,\n    0xe6080000, 0x00815aff, 0xee080000, 0x00a15aff,\n    0xf6080000, 0x00c25aff, 0xff080000, 0x00e25aff,\n    0x000c0000, 0x000062ff, 0x080c0000, 0x002062ff,\n    0x100c0000, 0x004062ff, 0x180c0000, 0x006162ff,\n    0x200c0000, 0x008162ff, 0x290c0000, 0x00a162ff,\n    0x310c0000, 0x00c262ff, 0x390c0000, 0x00e262ff,\n    0x410c0000, 0x00006aff, 0x4a0c0000, 0x00206aff,\n    0x520c0000, 0x00406aff, 0x5a0c0000, 0x00616aff,\n    0x620c0000, 0x00816aff, 0x6a0c0000, 0x00a16aff,\n    0x730c0000, 0x00c26aff, 0x7b0c0000, 0x00e26aff,\n    0x830c0000, 0x000073ff, 0x8b0c0000, 0x002073ff,\n    0x940c0000, 0x004073ff, 0x9c0c0000, 0x006173ff,\n    0xa40c0000, 0x008173ff, 0xac0c0000, 0x00a173ff,\n    0xb40c0000, 0x00c273ff, 0xbd0c0000, 0x00e273ff,\n    0xc50c0000, 0x00007bff, 0xcd0c0000, 0x00207bff,\n    0xd50c0000, 0x00407bff, 0xde0c0000, 0x00617bff,\n    0xe60c0000, 0x00817bff, 0xee0c0000, 0x00a17bff,\n    0xf60c0000, 0x00c27bff, 0xff0c0000, 0x00e27bff,\n    0x00100000, 0x000083ff, 0x08100000, 0x002083ff,\n    0x10100000, 0x004083ff, 0x18100000, 0x006183ff,\n    0x20100000, 0x008183ff, 0x29100000, 0x00a183ff,\n    0x31100000, 0x00c283ff, 0x39100000, 0x00e283ff,\n    0x41100000, 0x00008bff, 0x4a100000, 0x00208bff,\n    0x52100000, 0x00408bff, 0x5a100000, 0x00618bff,\n    0x62100000, 0x00818bff, 0x6a100000, 0x00a18bff,\n    0x73100000, 0x00c28bff, 0x7b100000, 0x00e28bff,\n    0x83100000, 0x000094ff, 0x8b100000, 0x002094ff,\n    0x94100000, 0x004094ff, 0x9c100000, 0x006194ff,\n    0xa4100000, 0x008194ff, 0xac100000, 0x00a194ff,\n    0xb4100000, 0x00c294ff, 0xbd100000, 0x00e294ff,\n    0xc5100000, 0x00009cff, 0xcd100000, 0x00209cff,\n    0xd5100000, 0x00409cff, 0xde100000, 0x00619cff,\n    0xe6100000, 0x00819cff, 0xee100000, 0x00a19cff,\n    0xf6100000, 0x00c29cff, 0xff100000, 0x00e29cff,\n    0x00140000, 0x0000a4ff, 0x08140000, 0x0020a4ff,\n    0x10140000, 0x0040a4ff, 0x18140000, 0x0061a4ff,\n    0x20140000, 0x0081a4ff, 0x29140000, 0x00a1a4ff,\n    0x31140000, 0x00c2a4ff, 0x39140000, 0x00e2a4ff,\n    0x41140000, 0x0000acff, 0x4a140000, 0x0020acff,\n    0x52140000, 0x0040acff, 0x5a140000, 0x0061acff,\n    0x62140000, 0x0081acff, 0x6a140000, 0x00a1acff,\n    0x73140000, 0x00c2acff, 0x7b140000, 0x00e2acff,\n    0x83140000, 0x0000b4ff, 0x8b140000, 0x0020b4ff,\n    0x94140000, 0x0040b4ff, 0x9c140000, 0x0061b4ff,\n    0xa4140000, 0x0081b4ff, 0xac140000, 0x00a1b4ff,\n    0xb4140000, 0x00c2b4ff, 0xbd140000, 0x00e2b4ff,\n    0xc5140000, 0x0000bdff, 0xcd140000, 0x0020bdff,\n    0xd5140000, 0x0040bdff, 0xde140000, 0x0061bdff,\n    0xe6140000, 0x0081bdff, 0xee140000, 0x00a1bdff,\n    0xf6140000, 0x00c2bdff, 0xff140000, 0x00e2bdff,\n    0x00180000, 0x0000c5ff, 0x08180000, 0x0020c5ff,\n    0x10180000, 0x0040c5ff, 0x18180000, 0x0061c5ff,\n    0x20180000, 0x0081c5ff, 0x29180000, 0x00a1c5ff,\n    0x31180000, 0x00c2c5ff, 0x39180000, 0x00e2c5ff,\n    0x41180000, 0x0000cdff, 0x4a180000, 0x0020cdff,\n    0x52180000, 0x0040cdff, 0x5a180000, 0x0061cdff,\n    0x62180000, 0x0081cdff, 0x6a180000, 0x00a1cdff,\n    0x73180000, 0x00c2cdff, 0x7b180000, 0x00e2cdff,\n    0x83180000, 0x0000d5ff, 0x8b180000, 0x0020d5ff,\n    0x94180000, 0x0040d5ff, 0x9c180000, 0x0061d5ff,\n    0xa4180000, 0x0081d5ff, 0xac180000, 0x00a1d5ff,\n    0xb4180000, 0x00c2d5ff, 0xbd180000, 0x00e2d5ff,\n    0xc5180000, 0x0000deff, 0xcd180000, 0x0020deff,\n    0xd5180000, 0x0040deff, 0xde180000, 0x0061deff,\n    0xe6180000, 0x0081deff, 0xee180000, 0x00a1deff,\n    0xf6180000, 0x00c2deff, 0xff180000, 0x00e2deff,\n    0x001c0000, 0x0000e6ff, 0x081c0000, 0x0020e6ff,\n    0x101c0000, 0x0040e6ff, 0x181c0000, 0x0061e6ff,\n    0x201c0000, 0x0081e6ff, 0x291c0000, 0x00a1e6ff,\n    0x311c0000, 0x00c2e6ff, 0x391c0000, 0x00e2e6ff,\n    0x411c0000, 0x0000eeff, 0x4a1c0000, 0x0020eeff,\n    0x521c0000, 0x0040eeff, 0x5a1c0000, 0x0061eeff,\n    0x621c0000, 0x0081eeff, 0x6a1c0000, 0x00a1eeff,\n    0x731c0000, 0x00c2eeff, 0x7b1c0000, 0x00e2eeff,\n    0x831c0000, 0x0000f6ff, 0x8b1c0000, 0x0020f6ff,\n    0x941c0000, 0x0040f6ff, 0x9c1c0000, 0x0061f6ff,\n    0xa41c0000, 0x0081f6ff, 0xac1c0000, 0x00a1f6ff,\n    0xb41c0000, 0x00c2f6ff, 0xbd1c0000, 0x00e2f6ff,\n    0xc51c0000, 0x0000ffff, 0xcd1c0000, 0x0020ffff,\n    0xd51c0000, 0x0040ffff, 0xde1c0000, 0x0061ffff,\n    0xe61c0000, 0x0081ffff, 0xee1c0000, 0x00a1ffff,\n    0xf61c0000, 0x00c2ffff, 0xff1c0000, 0x00e2ffff\n};\n\nstatic void\nBlit_RGB565_BGRA8888(SDL_BlitInfo * info)\n{\n    Blit_RGB565_32(info, RGB565_BGRA8888_LUT);\n}\n\nstatic void\nBlitNto1(SDL_BlitInfo * info)\n{\n#ifndef USE_DUFFS_LOOP\n    int c;\n#endif\n    int width, height;\n    Uint8 *src;\n    const Uint8 *map;\n    Uint8 *dst;\n    int srcskip, dstskip;\n    int srcbpp;\n    Uint32 Pixel;\n    int sR, sG, sB;\n    SDL_PixelFormat *srcfmt;\n\n    /* Set up some basic variables */\n    width = info->dst_w;\n    height = info->dst_h;\n    src = info->src;\n    srcskip = info->src_skip;\n    dst = info->dst;\n    dstskip = info->dst_skip;\n    map = info->table;\n    srcfmt = info->src_fmt;\n    srcbpp = srcfmt->BytesPerPixel;\n\n    if (map == NULL) {\n        while (height--) {\n#ifdef USE_DUFFS_LOOP\n            /* *INDENT-OFF* */\n            DUFFS_LOOP(\n                DISEMBLE_RGB(src, srcbpp, srcfmt, Pixel,\n                                sR, sG, sB);\n                if ( 1 ) {\n                    /* Pack RGB into 8bit pixel */\n                    *dst = ((sR>>5)<<(3+2))|\n                            ((sG>>5)<<(2)) |\n                            ((sB>>6)<<(0)) ;\n                }\n                dst++;\n                src += srcbpp;\n            , width);\n            /* *INDENT-ON* */\n#else\n            for (c = width; c; --c) {\n                DISEMBLE_RGB(src, srcbpp, srcfmt, Pixel, sR, sG, sB);\n                if (1) {\n                    /* Pack RGB into 8bit pixel */\n                    *dst = ((sR >> 5) << (3 + 2)) |\n                        ((sG >> 5) << (2)) | ((sB >> 6) << (0));\n                }\n                dst++;\n                src += srcbpp;\n            }\n#endif\n            src += srcskip;\n            dst += dstskip;\n        }\n    } else {\n        while (height--) {\n#ifdef USE_DUFFS_LOOP\n            /* *INDENT-OFF* */\n            DUFFS_LOOP(\n                DISEMBLE_RGB(src, srcbpp, srcfmt, Pixel,\n                                sR, sG, sB);\n                if ( 1 ) {\n                    /* Pack RGB into 8bit pixel */\n                    *dst = map[((sR>>5)<<(3+2))|\n                           ((sG>>5)<<(2))  |\n                           ((sB>>6)<<(0))  ];\n                }\n                dst++;\n                src += srcbpp;\n            , width);\n            /* *INDENT-ON* */\n#else\n            for (c = width; c; --c) {\n                DISEMBLE_RGB(src, srcbpp, srcfmt, Pixel, sR, sG, sB);\n                if (1) {\n                    /* Pack RGB into 8bit pixel */\n                    *dst = map[((sR >> 5) << (3 + 2)) |\n                               ((sG >> 5) << (2)) | ((sB >> 6) << (0))];\n                }\n                dst++;\n                src += srcbpp;\n            }\n#endif /* USE_DUFFS_LOOP */\n            src += srcskip;\n            dst += dstskip;\n        }\n    }\n}\n\n/* blits 32 bit RGB<->RGBA with both surfaces having the same R,G,B fields */\nstatic void\nBlit4to4MaskAlpha(SDL_BlitInfo * info)\n{\n    int width = info->dst_w;\n    int height = info->dst_h;\n    Uint32 *src = (Uint32 *) info->src;\n    int srcskip = info->src_skip;\n    Uint32 *dst = (Uint32 *) info->dst;\n    int dstskip = info->dst_skip;\n    SDL_PixelFormat *srcfmt = info->src_fmt;\n    SDL_PixelFormat *dstfmt = info->dst_fmt;\n\n    if (dstfmt->Amask) {\n        /* RGB->RGBA, SET_ALPHA */\n        Uint32 mask = (info->a >> dstfmt->Aloss) << dstfmt->Ashift;\n\n        while (height--) {\n            /* *INDENT-OFF* */\n            DUFFS_LOOP(\n            {\n                *dst = *src | mask;\n                ++dst;\n                ++src;\n            },\n            width);\n            /* *INDENT-ON* */\n            src = (Uint32 *) ((Uint8 *) src + srcskip);\n            dst = (Uint32 *) ((Uint8 *) dst + dstskip);\n        }\n    } else {\n        /* RGBA->RGB, NO_ALPHA */\n        Uint32 mask = srcfmt->Rmask | srcfmt->Gmask | srcfmt->Bmask;\n\n        while (height--) {\n            /* *INDENT-OFF* */\n            DUFFS_LOOP(\n            {\n                *dst = *src & mask;\n                ++dst;\n                ++src;\n            },\n            width);\n            /* *INDENT-ON* */\n            src = (Uint32 *) ((Uint8 *) src + srcskip);\n            dst = (Uint32 *) ((Uint8 *) dst + dstskip);\n        }\n    }\n}\n\nstatic void\nBlitNtoN(SDL_BlitInfo * info)\n{\n    int width = info->dst_w;\n    int height = info->dst_h;\n    Uint8 *src = info->src;\n    int srcskip = info->src_skip;\n    Uint8 *dst = info->dst;\n    int dstskip = info->dst_skip;\n    SDL_PixelFormat *srcfmt = info->src_fmt;\n    int srcbpp = srcfmt->BytesPerPixel;\n    SDL_PixelFormat *dstfmt = info->dst_fmt;\n    int dstbpp = dstfmt->BytesPerPixel;\n    unsigned alpha = dstfmt->Amask ? info->a : 0;\n\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP(\n        {\n            Uint32 Pixel;\n            unsigned sR;\n            unsigned sG;\n            unsigned sB;\n            DISEMBLE_RGB(src, srcbpp, srcfmt, Pixel, sR, sG, sB);\n            ASSEMBLE_RGBA(dst, dstbpp, dstfmt, sR, sG, sB, alpha);\n            dst += dstbpp;\n            src += srcbpp;\n        },\n        width);\n        /* *INDENT-ON* */\n        src += srcskip;\n        dst += dstskip;\n    }\n}\n\nstatic void\nBlitNtoNCopyAlpha(SDL_BlitInfo * info)\n{\n    int width = info->dst_w;\n    int height = info->dst_h;\n    Uint8 *src = info->src;\n    int srcskip = info->src_skip;\n    Uint8 *dst = info->dst;\n    int dstskip = info->dst_skip;\n    SDL_PixelFormat *srcfmt = info->src_fmt;\n    int srcbpp = srcfmt->BytesPerPixel;\n    SDL_PixelFormat *dstfmt = info->dst_fmt;\n    int dstbpp = dstfmt->BytesPerPixel;\n    int c;\n\n    while (height--) {\n        for (c = width; c; --c) {\n            Uint32 Pixel;\n            unsigned sR, sG, sB, sA;\n            DISEMBLE_RGBA(src, srcbpp, srcfmt, Pixel, sR, sG, sB, sA);\n            ASSEMBLE_RGBA(dst, dstbpp, dstfmt, sR, sG, sB, sA);\n            dst += dstbpp;\n            src += srcbpp;\n        }\n        src += srcskip;\n        dst += dstskip;\n    }\n}\n\nstatic void\nBlitNto1Key(SDL_BlitInfo * info)\n{\n    int width = info->dst_w;\n    int height = info->dst_h;\n    Uint8 *src = info->src;\n    int srcskip = info->src_skip;\n    Uint8 *dst = info->dst;\n    int dstskip = info->dst_skip;\n    SDL_PixelFormat *srcfmt = info->src_fmt;\n    const Uint8 *palmap = info->table;\n    Uint32 ckey = info->colorkey;\n    Uint32 rgbmask = ~srcfmt->Amask;\n    int srcbpp;\n    Uint32 Pixel;\n    unsigned sR, sG, sB;\n\n    /* Set up some basic variables */\n    srcbpp = srcfmt->BytesPerPixel;\n    ckey &= rgbmask;\n\n    if (palmap == NULL) {\n        while (height--) {\n            /* *INDENT-OFF* */\n            DUFFS_LOOP(\n            {\n                DISEMBLE_RGB(src, srcbpp, srcfmt, Pixel,\n                                sR, sG, sB);\n                if ( (Pixel & rgbmask) != ckey ) {\n                    /* Pack RGB into 8bit pixel */\n                    *dst = (Uint8)(((sR>>5)<<(3+2))|\n                                   ((sG>>5)<<(2)) |\n                                   ((sB>>6)<<(0)));\n                }\n                dst++;\n                src += srcbpp;\n            },\n            width);\n            /* *INDENT-ON* */\n            src += srcskip;\n            dst += dstskip;\n        }\n    } else {\n        while (height--) {\n            /* *INDENT-OFF* */\n            DUFFS_LOOP(\n            {\n                DISEMBLE_RGB(src, srcbpp, srcfmt, Pixel,\n                                sR, sG, sB);\n                if ( (Pixel & rgbmask) != ckey ) {\n                    /* Pack RGB into 8bit pixel */\n                    *dst = (Uint8)palmap[((sR>>5)<<(3+2))|\n                                         ((sG>>5)<<(2))  |\n                                         ((sB>>6)<<(0))  ];\n                }\n                dst++;\n                src += srcbpp;\n            },\n            width);\n            /* *INDENT-ON* */\n            src += srcskip;\n            dst += dstskip;\n        }\n    }\n}\n\nstatic void\nBlit2to2Key(SDL_BlitInfo * info)\n{\n    int width = info->dst_w;\n    int height = info->dst_h;\n    Uint16 *srcp = (Uint16 *) info->src;\n    int srcskip = info->src_skip;\n    Uint16 *dstp = (Uint16 *) info->dst;\n    int dstskip = info->dst_skip;\n    Uint32 ckey = info->colorkey;\n    Uint32 rgbmask = ~info->src_fmt->Amask;\n\n    /* Set up some basic variables */\n    srcskip /= 2;\n    dstskip /= 2;\n    ckey &= rgbmask;\n\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP(\n        {\n            if ( (*srcp & rgbmask) != ckey ) {\n                *dstp = *srcp;\n            }\n            dstp++;\n            srcp++;\n        },\n        width);\n        /* *INDENT-ON* */\n        srcp += srcskip;\n        dstp += dstskip;\n    }\n}\n\nstatic void\nBlitNtoNKey(SDL_BlitInfo * info)\n{\n    int width = info->dst_w;\n    int height = info->dst_h;\n    Uint8 *src = info->src;\n    int srcskip = info->src_skip;\n    Uint8 *dst = info->dst;\n    int dstskip = info->dst_skip;\n    Uint32 ckey = info->colorkey;\n    SDL_PixelFormat *srcfmt = info->src_fmt;\n    SDL_PixelFormat *dstfmt = info->dst_fmt;\n    int srcbpp = srcfmt->BytesPerPixel;\n    int dstbpp = dstfmt->BytesPerPixel;\n    unsigned alpha = dstfmt->Amask ? info->a : 0;\n    Uint32 rgbmask = ~srcfmt->Amask;\n\n    /* Set up some basic variables */\n    ckey &= rgbmask;\n\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP(\n        {\n            Uint32 Pixel;\n            unsigned sR;\n            unsigned sG;\n            unsigned sB;\n            RETRIEVE_RGB_PIXEL(src, srcbpp, Pixel);\n            if ( (Pixel & rgbmask) != ckey ) {\n                RGB_FROM_PIXEL(Pixel, srcfmt, sR, sG, sB);\n                ASSEMBLE_RGBA(dst, dstbpp, dstfmt, sR, sG, sB, alpha);\n            }\n            dst += dstbpp;\n            src += srcbpp;\n        },\n        width);\n        /* *INDENT-ON* */\n        src += srcskip;\n        dst += dstskip;\n    }\n}\n\nstatic void\nBlitNtoNKeyCopyAlpha(SDL_BlitInfo * info)\n{\n    int width = info->dst_w;\n    int height = info->dst_h;\n    Uint8 *src = info->src;\n    int srcskip = info->src_skip;\n    Uint8 *dst = info->dst;\n    int dstskip = info->dst_skip;\n    Uint32 ckey = info->colorkey;\n    SDL_PixelFormat *srcfmt = info->src_fmt;\n    SDL_PixelFormat *dstfmt = info->dst_fmt;\n    Uint32 rgbmask = ~srcfmt->Amask;\n\n    Uint8 srcbpp;\n    Uint8 dstbpp;\n    Uint32 Pixel;\n    unsigned sR, sG, sB, sA;\n\n    /* Set up some basic variables */\n    srcbpp = srcfmt->BytesPerPixel;\n    dstbpp = dstfmt->BytesPerPixel;\n    ckey &= rgbmask;\n\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP(\n        {\n            DISEMBLE_RGBA(src, srcbpp, srcfmt, Pixel, sR, sG, sB, sA);\n            if ( (Pixel & rgbmask) != ckey ) {\n                  ASSEMBLE_RGBA(dst, dstbpp, dstfmt, sR, sG, sB, sA);\n            }\n            dst += dstbpp;\n            src += srcbpp;\n        },\n        width);\n        /* *INDENT-ON* */\n        src += srcskip;\n        dst += dstskip;\n    }\n}\n\n/* Special optimized blit for ARGB 2-10-10-10 --> RGBA */\nstatic void\nBlit2101010toN(SDL_BlitInfo * info)\n{\n    int width = info->dst_w;\n    int height = info->dst_h;\n    Uint8 *src = info->src;\n    int srcskip = info->src_skip;\n    Uint8 *dst = info->dst;\n    int dstskip = info->dst_skip;\n    SDL_PixelFormat *dstfmt = info->dst_fmt;\n    int dstbpp = dstfmt->BytesPerPixel;\n    Uint32 Pixel;\n    unsigned sR, sG, sB, sA;\n\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP(\n        {\n            Pixel = *(Uint32 *)src;\n            RGBA_FROM_ARGB2101010(Pixel, sR, sG, sB, sA);\n            ASSEMBLE_RGBA(dst, dstbpp, dstfmt, sR, sG, sB, sA);\n            dst += dstbpp;\n            src += 4;\n        },\n        width);\n        /* *INDENT-ON* */\n        src += srcskip;\n        dst += dstskip;\n    }\n}\n\n/* Special optimized blit for RGBA --> ARGB 2-10-10-10 */\nstatic void\nBlitNto2101010(SDL_BlitInfo * info)\n{\n    int width = info->dst_w;\n    int height = info->dst_h;\n    Uint8 *src = info->src;\n    int srcskip = info->src_skip;\n    Uint8 *dst = info->dst;\n    int dstskip = info->dst_skip;\n    SDL_PixelFormat *srcfmt = info->src_fmt;\n    int srcbpp = srcfmt->BytesPerPixel;\n    Uint32 Pixel;\n    unsigned sR, sG, sB, sA;\n\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP(\n        {\n            DISEMBLE_RGBA(src, srcbpp, srcfmt, Pixel, sR, sG, sB, sA);\n            ARGB2101010_FROM_RGBA(Pixel, sR, sG, sB, sA);\n            *(Uint32 *)dst = Pixel;\n            dst += 4;\n            src += srcbpp;\n        },\n        width);\n        /* *INDENT-ON* */\n        src += srcskip;\n        dst += dstskip;\n    }\n}\n\n/* Normal N to N optimized blitters */\nstruct blit_table\n{\n    Uint32 srcR, srcG, srcB;\n    int dstbpp;\n    Uint32 dstR, dstG, dstB;\n    Uint32 blit_features;\n    SDL_BlitFunc blitfunc;\n    enum\n    { NO_ALPHA = 1, SET_ALPHA = 2, COPY_ALPHA = 4 } alpha;\n};\nstatic const struct blit_table normal_blit_1[] = {\n    /* Default for 8-bit RGB source, never optimized */\n    {0, 0, 0, 0, 0, 0, 0, 0, BlitNtoN, 0}\n};\n\nstatic const struct blit_table normal_blit_2[] = {\n#if SDL_ALTIVEC_BLITTERS\n    /* has-altivec */\n    {0x0000F800, 0x000007E0, 0x0000001F, 4, 0x00000000, 0x00000000, 0x00000000,\n     2, Blit_RGB565_32Altivec, NO_ALPHA | COPY_ALPHA | SET_ALPHA},\n    {0x00007C00, 0x000003E0, 0x0000001F, 4, 0x00000000, 0x00000000, 0x00000000,\n     2, Blit_RGB555_32Altivec, NO_ALPHA | COPY_ALPHA | SET_ALPHA},\n#endif\n    {0x0000F800, 0x000007E0, 0x0000001F, 4, 0x00FF0000, 0x0000FF00, 0x000000FF,\n     0, Blit_RGB565_ARGB8888, NO_ALPHA | COPY_ALPHA | SET_ALPHA},\n    {0x0000F800, 0x000007E0, 0x0000001F, 4, 0x000000FF, 0x0000FF00, 0x00FF0000,\n     0, Blit_RGB565_ABGR8888, NO_ALPHA | COPY_ALPHA | SET_ALPHA},\n    {0x0000F800, 0x000007E0, 0x0000001F, 4, 0xFF000000, 0x00FF0000, 0x0000FF00,\n     0, Blit_RGB565_RGBA8888, NO_ALPHA | COPY_ALPHA | SET_ALPHA},\n    {0x0000F800, 0x000007E0, 0x0000001F, 4, 0x0000FF00, 0x00FF0000, 0xFF000000,\n     0, Blit_RGB565_BGRA8888, NO_ALPHA | COPY_ALPHA | SET_ALPHA},\n\n    /* Default for 16-bit RGB source, used if no other blitter matches */\n    {0, 0, 0, 0, 0, 0, 0, 0, BlitNtoN, 0}\n};\n\nstatic const struct blit_table normal_blit_3[] = {\n    /* Default for 24-bit RGB source, never optimized */\n    {0, 0, 0, 0, 0, 0, 0, 0, BlitNtoN, 0}\n};\n\nstatic const struct blit_table normal_blit_4[] = {\n#if SDL_ALTIVEC_BLITTERS\n    /* has-altivec | dont-use-prefetch */\n    {0x00000000, 0x00000000, 0x00000000, 4, 0x00000000, 0x00000000, 0x00000000,\n     6, ConvertAltivec32to32_noprefetch, NO_ALPHA | COPY_ALPHA | SET_ALPHA},\n    /* has-altivec */\n    {0x00000000, 0x00000000, 0x00000000, 4, 0x00000000, 0x00000000, 0x00000000,\n     2, ConvertAltivec32to32_prefetch, NO_ALPHA | COPY_ALPHA | SET_ALPHA},\n    /* has-altivec */\n    {0x00000000, 0x00000000, 0x00000000, 2, 0x0000F800, 0x000007E0, 0x0000001F,\n     2, Blit_RGB888_RGB565Altivec, NO_ALPHA},\n#endif\n    {0x00FF0000, 0x0000FF00, 0x000000FF, 2, 0x0000F800, 0x000007E0, 0x0000001F,\n     0, Blit_RGB888_RGB565, NO_ALPHA},\n    {0x00FF0000, 0x0000FF00, 0x000000FF, 2, 0x00007C00, 0x000003E0, 0x0000001F,\n     0, Blit_RGB888_RGB555, NO_ALPHA},\n    /* Default for 32-bit RGB source, used if no other blitter matches */\n    {0, 0, 0, 0, 0, 0, 0, 0, BlitNtoN, 0}\n};\n\nstatic const struct blit_table *const normal_blit[] = {\n    normal_blit_1, normal_blit_2, normal_blit_3, normal_blit_4\n};\n\n/* Mask matches table, or table entry is zero */\n#define MASKOK(x, y) (((x) == (y)) || ((y) == 0x00000000))\n\nSDL_BlitFunc\nSDL_CalculateBlitN(SDL_Surface * surface)\n{\n    SDL_PixelFormat *srcfmt;\n    SDL_PixelFormat *dstfmt;\n    const struct blit_table *table;\n    int which;\n    SDL_BlitFunc blitfun;\n\n    /* Set up data for choosing the blit */\n    srcfmt = surface->format;\n    dstfmt = surface->map->dst->format;\n\n    /* We don't support destinations less than 8-bits */\n    if (dstfmt->BitsPerPixel < 8) {\n        return (NULL);\n    }\n\n    switch (surface->map->info.flags & ~SDL_COPY_RLE_MASK) {\n    case 0:\n        blitfun = NULL;\n        if (dstfmt->BitsPerPixel == 8) {\n            if ((srcfmt->BytesPerPixel == 4) &&\n                (srcfmt->Rmask == 0x00FF0000) &&\n                (srcfmt->Gmask == 0x0000FF00) &&\n                (srcfmt->Bmask == 0x000000FF)) {\n                blitfun = Blit_RGB888_index8;\n            } else if ((srcfmt->BytesPerPixel == 4) &&\n                (srcfmt->Rmask == 0x3FF00000) &&\n                (srcfmt->Gmask == 0x000FFC00) &&\n                (srcfmt->Bmask == 0x000003FF)) {\n                blitfun = Blit_RGB101010_index8;\n            } else {\n                blitfun = BlitNto1;\n            }\n        } else {\n            /* Now the meat, choose the blitter we want */\n            int a_need = NO_ALPHA;\n            if (dstfmt->Amask)\n                a_need = srcfmt->Amask ? COPY_ALPHA : SET_ALPHA;\n            table = normal_blit[srcfmt->BytesPerPixel - 1];\n            for (which = 0; table[which].dstbpp; ++which) {\n                if (MASKOK(srcfmt->Rmask, table[which].srcR) &&\n                    MASKOK(srcfmt->Gmask, table[which].srcG) &&\n                    MASKOK(srcfmt->Bmask, table[which].srcB) &&\n                    MASKOK(dstfmt->Rmask, table[which].dstR) &&\n                    MASKOK(dstfmt->Gmask, table[which].dstG) &&\n                    MASKOK(dstfmt->Bmask, table[which].dstB) &&\n                    dstfmt->BytesPerPixel == table[which].dstbpp &&\n                    (a_need & table[which].alpha) == a_need &&\n                    ((table[which].blit_features & GetBlitFeatures()) ==\n                     table[which].blit_features))\n                    break;\n            }\n            blitfun = table[which].blitfunc;\n\n            if (blitfun == BlitNtoN) {  /* default C fallback catch-all. Slow! */\n                if (srcfmt->format == SDL_PIXELFORMAT_ARGB2101010) {\n                    blitfun = Blit2101010toN;\n                } else if (dstfmt->format == SDL_PIXELFORMAT_ARGB2101010) {\n                    blitfun = BlitNto2101010;\n                } else if (srcfmt->BytesPerPixel == 4 &&\n                            dstfmt->BytesPerPixel == 4 &&\n                            srcfmt->Rmask == dstfmt->Rmask &&\n                            srcfmt->Gmask == dstfmt->Gmask &&\n                            srcfmt->Bmask == dstfmt->Bmask) {\n                    /* Fastpath C fallback: 32bit RGB<->RGBA blit with matching RGB */\n                    blitfun = Blit4to4MaskAlpha;\n                } else if (a_need == COPY_ALPHA) {\n                    blitfun = BlitNtoNCopyAlpha;\n                }\n            }\n        }\n        return (blitfun);\n\n    case SDL_COPY_COLORKEY:\n        /* colorkey blit: Here we don't have too many options, mostly\n           because RLE is the preferred fast way to deal with this.\n           If a particular case turns out to be useful we'll add it. */\n\n        if (srcfmt->BytesPerPixel == 2 && surface->map->identity)\n            return Blit2to2Key;\n        else if (dstfmt->BytesPerPixel == 1)\n            return BlitNto1Key;\n        else {\n#if SDL_ALTIVEC_BLITTERS\n            if ((srcfmt->BytesPerPixel == 4) && (dstfmt->BytesPerPixel == 4)\n                && SDL_HasAltiVec()) {\n                return Blit32to32KeyAltivec;\n            } else\n#endif\n            if (srcfmt->Amask && dstfmt->Amask) {\n                return BlitNtoNKeyCopyAlpha;\n            } else {\n                return BlitNtoNKey;\n            }\n        }\n    }\n\n    return NULL;\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../SDL_internal.h\"\n\n#include \"SDL_video.h\"\n#include \"SDL_blit.h\"\n#include \"SDL_blit_slow.h\"\n\n/* The ONE TRUE BLITTER\n * This puppy has to handle all the unoptimized cases - yes, it's slow.\n */\nvoid\nSDL_Blit_Slow(SDL_BlitInfo * info)\n{\n    const int flags = info->flags;\n    const Uint32 modulateR = info->r;\n    const Uint32 modulateG = info->g;\n    const Uint32 modulateB = info->b;\n    const Uint32 modulateA = info->a;\n    Uint32 srcpixel;\n    Uint32 srcR, srcG, srcB, srcA;\n    Uint32 dstpixel;\n    Uint32 dstR, dstG, dstB, dstA;\n    int srcy, srcx;\n    int posy, posx;\n    int incy, incx;\n    SDL_PixelFormat *src_fmt = info->src_fmt;\n    SDL_PixelFormat *dst_fmt = info->dst_fmt;\n    int srcbpp = src_fmt->BytesPerPixel;\n    int dstbpp = dst_fmt->BytesPerPixel;\n\n    srcy = 0;\n    posy = 0;\n    incy = (info->src_h << 16) / info->dst_h;\n    incx = (info->src_w << 16) / info->dst_w;\n\n    while (info->dst_h--) {\n        Uint8 *src = 0;\n        Uint8 *dst = (Uint8 *) info->dst;\n        int n = info->dst_w;\n        srcx = -1;\n        posx = 0x10000L;\n        while (posy >= 0x10000L) {\n            ++srcy;\n            posy -= 0x10000L;\n        }\n        while (n--) {\n            if (posx >= 0x10000L) {\n                while (posx >= 0x10000L) {\n                    ++srcx;\n                    posx -= 0x10000L;\n                }\n                src =\n                    (info->src + (srcy * info->src_pitch) + (srcx * srcbpp));\n            }\n            if (src_fmt->Amask) {\n                DISEMBLE_RGBA(src, srcbpp, src_fmt, srcpixel, srcR, srcG,\n                              srcB, srcA);\n            } else {\n                DISEMBLE_RGB(src, srcbpp, src_fmt, srcpixel, srcR, srcG,\n                             srcB);\n                srcA = 0xFF;\n            }\n            if (flags & SDL_COPY_COLORKEY) {\n                /* srcpixel isn't set for 24 bpp */\n                if (srcbpp == 3) {\n                    srcpixel = (srcR << src_fmt->Rshift) |\n                        (srcG << src_fmt->Gshift) | (srcB << src_fmt->Bshift);\n                }\n                if (srcpixel == info->colorkey) {\n                    posx += incx;\n                    dst += dstbpp;\n                    continue;\n                }\n            }\n            if (dst_fmt->Amask) {\n                DISEMBLE_RGBA(dst, dstbpp, dst_fmt, dstpixel, dstR, dstG,\n                              dstB, dstA);\n            } else {\n                DISEMBLE_RGB(dst, dstbpp, dst_fmt, dstpixel, dstR, dstG,\n                             dstB);\n                dstA = 0xFF;\n            }\n\n            if (flags & SDL_COPY_MODULATE_COLOR) {\n                srcR = (srcR * modulateR) / 255;\n                srcG = (srcG * modulateG) / 255;\n                srcB = (srcB * modulateB) / 255;\n            }\n            if (flags & SDL_COPY_MODULATE_ALPHA) {\n                srcA = (srcA * modulateA) / 255;\n            }\n            if (flags & (SDL_COPY_BLEND | SDL_COPY_ADD)) {\n                /* This goes away if we ever use premultiplied alpha */\n                if (srcA < 255) {\n                    srcR = (srcR * srcA) / 255;\n                    srcG = (srcG * srcA) / 255;\n                    srcB = (srcB * srcA) / 255;\n                }\n            }\n            switch (flags & (SDL_COPY_BLEND | SDL_COPY_ADD | SDL_COPY_MOD)) {\n            case 0:\n                dstR = srcR;\n                dstG = srcG;\n                dstB = srcB;\n                dstA = srcA;\n                break;\n            case SDL_COPY_BLEND:\n                dstR = srcR + ((255 - srcA) * dstR) / 255;\n                dstG = srcG + ((255 - srcA) * dstG) / 255;\n                dstB = srcB + ((255 - srcA) * dstB) / 255;\n                break;\n            case SDL_COPY_ADD:\n                dstR = srcR + dstR;\n                if (dstR > 255)\n                    dstR = 255;\n                dstG = srcG + dstG;\n                if (dstG > 255)\n                    dstG = 255;\n                dstB = srcB + dstB;\n                if (dstB > 255)\n                    dstB = 255;\n                break;\n            case SDL_COPY_MOD:\n                dstR = (srcR * dstR) / 255;\n                dstG = (srcG * dstG) / 255;\n                dstB = (srcB * dstB) / 255;\n                break;\n            }\n            if (dst_fmt->Amask) {\n                ASSEMBLE_RGBA(dst, dstbpp, dst_fmt, dstR, dstG, dstB, dstA);\n            } else {\n                ASSEMBLE_RGB(dst, dstbpp, dst_fmt, dstR, dstG, dstB);\n            }\n            posx += incx;\n            dst += dstbpp;\n        }\n        posy += incy;\n        info->dst += info->dst_pitch;\n    }\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n *  Simple DirectMedia Layer\n *  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n * \n *  This software is provided 'as-is', without any express or implied\n *  warranty.  In no event will the authors be held liable for any damages\n *  arising from the use of this software.\n * \n *  Permission is granted to anyone to use this software for any purpose,\n *  including commercial applications, and to alter it and redistribute it\n *  freely, subject to the following restrictions:\n * \n *  1. The origin of this software must not be misrepresented; you must not\n *     claim that you wrote the original software. If you use this software\n *     in a product, an acknowledgment in the product documentation would be\n *     appreciated but is not required.\n *  2. Altered source versions must be plainly marked as such, and must not be\n *     misrepresented as being the original software.\n *  3. This notice may not be removed or altered from any source distribution.\n */\n#include \"../SDL_internal.h\"\n\n#if SDL_VIDEO_OPENGL_EGL\n\n#if SDL_VIDEO_DRIVER_WINDOWS || SDL_VIDEO_DRIVER_WINRT\n#include \"../core/windows/SDL_windows.h\"\n#endif\n\n#include \"SDL_sysvideo.h\"\n#include \"SDL_egl_c.h\"\n#include \"SDL_loadso.h\"\n#include \"SDL_hints.h\"\n\n#if SDL_VIDEO_DRIVER_RPI\n/* Raspbian places the OpenGL ES/EGL binaries in a non standard path */\n#define DEFAULT_EGL \"/opt/vc/lib/libEGL.so\"\n#define DEFAULT_OGL_ES2 \"/opt/vc/lib/libGLESv2.so\"\n#define DEFAULT_OGL_ES_PVR \"/opt/vc/lib/libGLES_CM.so\"\n#define DEFAULT_OGL_ES \"/opt/vc/lib/libGLESv1_CM.so\"\n\n#elif SDL_VIDEO_DRIVER_ANDROID || SDL_VIDEO_DRIVER_VIVANTE\n/* Android */\n#define DEFAULT_EGL \"libEGL.so\"\n#define DEFAULT_OGL_ES2 \"libGLESv2.so\"\n#define DEFAULT_OGL_ES_PVR \"libGLES_CM.so\"\n#define DEFAULT_OGL_ES \"libGLESv1_CM.so\"\n\n#elif SDL_VIDEO_DRIVER_WINDOWS || SDL_VIDEO_DRIVER_WINRT\n/* EGL AND OpenGL ES support via ANGLE */\n#define DEFAULT_EGL \"libEGL.dll\"\n#define DEFAULT_OGL_ES2 \"libGLESv2.dll\"\n#define DEFAULT_OGL_ES_PVR \"libGLES_CM.dll\"\n#define DEFAULT_OGL_ES \"libGLESv1_CM.dll\"\n\n#else\n/* Desktop Linux */\n#define DEFAULT_OGL \"libGL.so.1\"\n#define DEFAULT_EGL \"libEGL.so.1\"\n#define DEFAULT_OGL_ES2 \"libGLESv2.so.2\"\n#define DEFAULT_OGL_ES_PVR \"libGLES_CM.so.1\"\n#define DEFAULT_OGL_ES \"libGLESv1_CM.so.1\"\n#endif /* SDL_VIDEO_DRIVER_RPI */\n\n#define LOAD_FUNC(NAME) \\\n_this->egl_data->NAME = SDL_LoadFunction(_this->egl_data->dll_handle, #NAME); \\\nif (!_this->egl_data->NAME) \\\n{ \\\n    return SDL_SetError(\"Could not retrieve EGL function \" #NAME); \\\n}\n    \n/* EGL implementation of SDL OpenGL ES support */\n#ifdef EGL_KHR_create_context        \nstatic int SDL_EGL_HasExtension(_THIS, const char *ext)\n{\n    int i;\n    int len = 0;\n    int ext_len;\n    const char *exts;\n    const char *ext_word;\n\n    ext_len = SDL_strlen(ext);\n    exts = _this->egl_data->eglQueryString(_this->egl_data->egl_display, EGL_EXTENSIONS);\n\n    if(exts) {\n        ext_word = exts;\n\n        for(i = 0; exts[i] != 0; i++) {\n            if(exts[i] == ' ') {\n                if(ext_len == len && !SDL_strncmp(ext_word, ext, len)) {\n                    return 1;\n                }\n\n                len = 0;\n                ext_word = &exts[i + 1];\n            }\n            else {\n                len++;\n            }\n        }\n    }\n\n    return 0;\n}\n#endif /* EGL_KHR_create_context */\n\nvoid *\nSDL_EGL_GetProcAddress(_THIS, const char *proc)\n{\n    static char procname[1024];\n    void *retval;\n    \n    /* eglGetProcAddress is busted on Android http://code.google.com/p/android/issues/detail?id=7681 */\n#if !defined(SDL_VIDEO_DRIVER_ANDROID) && !defined(SDL_VIDEO_DRIVER_MIR) \n    if (_this->egl_data->eglGetProcAddress) {\n        retval = _this->egl_data->eglGetProcAddress(proc);\n        if (retval) {\n            return retval;\n        }\n    }\n#endif\n    \n    retval = SDL_LoadFunction(_this->egl_data->egl_dll_handle, proc);\n    if (!retval && SDL_strlen(proc) <= 1022) {\n        procname[0] = '_';\n        SDL_strlcpy(procname + 1, proc, 1022);\n        retval = SDL_LoadFunction(_this->egl_data->egl_dll_handle, procname);\n    }\n    return retval;\n}\n\nvoid\nSDL_EGL_UnloadLibrary(_THIS)\n{\n    if (_this->egl_data) {\n        if (_this->egl_data->egl_display) {\n            _this->egl_data->eglTerminate(_this->egl_data->egl_display);\n            _this->egl_data->egl_display = NULL;\n        }\n\n        if (_this->egl_data->dll_handle) {\n            SDL_UnloadObject(_this->egl_data->dll_handle);\n            _this->egl_data->dll_handle = NULL;\n        }\n        if (_this->egl_data->egl_dll_handle) {\n            SDL_UnloadObject(_this->egl_data->egl_dll_handle);\n            _this->egl_data->egl_dll_handle = NULL;\n        }\n        \n        SDL_free(_this->egl_data);\n        _this->egl_data = NULL;\n    }\n}\n\nint\nSDL_EGL_LoadLibrary(_THIS, const char *egl_path, NativeDisplayType native_display)\n{\n    void *dll_handle = NULL, *egl_dll_handle = NULL; /* The naming is counter intuitive, but hey, I just work here -- Gabriel */\n    char *path = NULL;\n#if SDL_VIDEO_DRIVER_WINDOWS || SDL_VIDEO_DRIVER_WINRT\n    const char *d3dcompiler;\n#endif\n\n    if (_this->egl_data) {\n        return SDL_SetError(\"OpenGL ES context already created\");\n    }\n\n    _this->egl_data = (struct SDL_EGL_VideoData *) SDL_calloc(1, sizeof(SDL_EGL_VideoData));\n    if (!_this->egl_data) {\n        return SDL_OutOfMemory();\n    }\n\n#if SDL_VIDEO_DRIVER_WINDOWS || SDL_VIDEO_DRIVER_WINRT\n    d3dcompiler = SDL_GetHint(SDL_HINT_VIDEO_WIN_D3DCOMPILER);\n    if (!d3dcompiler) {\n        if (WIN_IsWindowsVistaOrGreater()) {\n            d3dcompiler = \"d3dcompiler_46.dll\";\n        } else {\n            d3dcompiler = \"d3dcompiler_43.dll\";\n        }\n    }\n    if (SDL_strcasecmp(d3dcompiler, \"none\") != 0) {\n        SDL_LoadObject(d3dcompiler);\n    }\n#endif\n\n    /* A funny thing, loading EGL.so first does not work on the Raspberry, so we load libGL* first */\n    path = SDL_getenv(\"SDL_VIDEO_GL_DRIVER\");\n    if (path != NULL) {\n        egl_dll_handle = SDL_LoadObject(path);\n    }\n\n    if (egl_dll_handle == NULL) {\n        if(_this->gl_config.profile_mask == SDL_GL_CONTEXT_PROFILE_ES) {\n            if (_this->gl_config.major_version > 1) {\n                path = DEFAULT_OGL_ES2;\n                egl_dll_handle = SDL_LoadObject(path);\n            }\n            else {\n                path = DEFAULT_OGL_ES;\n                egl_dll_handle = SDL_LoadObject(path);\n                if (egl_dll_handle == NULL) {\n                    path = DEFAULT_OGL_ES_PVR;\n                    egl_dll_handle = SDL_LoadObject(path);\n                }\n            }\n        }\n#ifdef DEFAULT_OGL         \n        else {\n            path = DEFAULT_OGL;\n            egl_dll_handle = SDL_LoadObject(path);\n        }\n#endif        \n    }\n    _this->egl_data->egl_dll_handle = egl_dll_handle;\n\n    if (egl_dll_handle == NULL) {\n        return SDL_SetError(\"Could not initialize OpenGL / GLES library\");\n    }\n\n    /* Loading libGL* in the previous step took care of loading libEGL.so, but we future proof by double checking */\n    if (egl_path != NULL) {\n        dll_handle = SDL_LoadObject(egl_path);\n    }   \n    /* Try loading a EGL symbol, if it does not work try the default library paths */\n    if (dll_handle == NULL || SDL_LoadFunction(dll_handle, \"eglChooseConfig\") == NULL) {\n        if (dll_handle != NULL) {\n            SDL_UnloadObject(dll_handle);\n        }\n        path = SDL_getenv(\"SDL_VIDEO_EGL_DRIVER\");\n        if (path == NULL) {\n            path = DEFAULT_EGL;\n        }\n        dll_handle = SDL_LoadObject(path);\n        if (dll_handle == NULL || SDL_LoadFunction(dll_handle, \"eglChooseConfig\") == NULL) {\n            if (dll_handle != NULL) {\n                SDL_UnloadObject(dll_handle);\n            }\n            return SDL_SetError(\"Could not load EGL library\");\n        }\n        SDL_ClearError();\n    }\n\n    _this->egl_data->dll_handle = dll_handle;\n\n    /* Load new function pointers */\n    LOAD_FUNC(eglGetDisplay);\n    LOAD_FUNC(eglInitialize);\n    LOAD_FUNC(eglTerminate);\n    LOAD_FUNC(eglGetProcAddress);\n    LOAD_FUNC(eglChooseConfig);\n    LOAD_FUNC(eglGetConfigAttrib);\n    LOAD_FUNC(eglCreateContext);\n    LOAD_FUNC(eglDestroyContext);\n    LOAD_FUNC(eglCreateWindowSurface);\n    LOAD_FUNC(eglDestroySurface);\n    LOAD_FUNC(eglMakeCurrent);\n    LOAD_FUNC(eglSwapBuffers);\n    LOAD_FUNC(eglSwapInterval);\n    LOAD_FUNC(eglWaitNative);\n    LOAD_FUNC(eglWaitGL);\n    LOAD_FUNC(eglBindAPI);\n    LOAD_FUNC(eglQueryString);\n    \n#if !defined(__WINRT__)\n    _this->egl_data->egl_display = _this->egl_data->eglGetDisplay(native_display);\n    if (!_this->egl_data->egl_display) {\n        return SDL_SetError(\"Could not get EGL display\");\n    }\n    \n    if (_this->egl_data->eglInitialize(_this->egl_data->egl_display, NULL, NULL) != EGL_TRUE) {\n        return SDL_SetError(\"Could not initialize EGL\");\n    }\n#endif\n\n    _this->gl_config.driver_loaded = 1;\n\n    if (path) {\n        SDL_strlcpy(_this->gl_config.driver_path, path, sizeof(_this->gl_config.driver_path) - 1);\n    } else {\n        *_this->gl_config.driver_path = '\\0';\n    }\n    \n    return 0;\n}\n\nint\nSDL_EGL_ChooseConfig(_THIS) \n{\n    /* 64 seems nice. */\n    EGLint attribs[64];\n    EGLint found_configs = 0, value;\n    /* 128 seems even nicer here */\n    EGLConfig configs[128];\n    int i, j, best_bitdiff = -1, bitdiff;\n    \n    if (!_this->egl_data) {\n        /* The EGL library wasn't loaded, SDL_GetError() should have info */\n        return -1;\n    }\n  \n    /* Get a valid EGL configuration */\n    i = 0;\n    attribs[i++] = EGL_RED_SIZE;\n    attribs[i++] = _this->gl_config.red_size;\n    attribs[i++] = EGL_GREEN_SIZE;\n    attribs[i++] = _this->gl_config.green_size;\n    attribs[i++] = EGL_BLUE_SIZE;\n    attribs[i++] = _this->gl_config.blue_size;\n    \n    if (_this->gl_config.alpha_size) {\n        attribs[i++] = EGL_ALPHA_SIZE;\n        attribs[i++] = _this->gl_config.alpha_size;\n    }\n    \n    if (_this->gl_config.buffer_size) {\n        attribs[i++] = EGL_BUFFER_SIZE;\n        attribs[i++] = _this->gl_config.buffer_size;\n    }\n    \n    attribs[i++] = EGL_DEPTH_SIZE;\n    attribs[i++] = _this->gl_config.depth_size;\n    \n    if (_this->gl_config.stencil_size) {\n        attribs[i++] = EGL_STENCIL_SIZE;\n        attribs[i++] = _this->gl_config.stencil_size;\n    }\n    \n    if (_this->gl_config.multisamplebuffers) {\n        attribs[i++] = EGL_SAMPLE_BUFFERS;\n        attribs[i++] = _this->gl_config.multisamplebuffers;\n    }\n    \n    if (_this->gl_config.multisamplesamples) {\n        attribs[i++] = EGL_SAMPLES;\n        attribs[i++] = _this->gl_config.multisamplesamples;\n    }\n    \n    attribs[i++] = EGL_RENDERABLE_TYPE;\n    if(_this->gl_config.profile_mask == SDL_GL_CONTEXT_PROFILE_ES) {\n        if (_this->gl_config.major_version == 2) {\n            attribs[i++] = EGL_OPENGL_ES2_BIT;\n        } else {\n            attribs[i++] = EGL_OPENGL_ES_BIT;\n        }\n        _this->egl_data->eglBindAPI(EGL_OPENGL_ES_API);\n    }\n    else {\n        attribs[i++] = EGL_OPENGL_BIT;\n        _this->egl_data->eglBindAPI(EGL_OPENGL_API);\n    }\n    \n    attribs[i++] = EGL_NONE;\n   \n    if (_this->egl_data->eglChooseConfig(_this->egl_data->egl_display,\n        attribs,\n        configs, SDL_arraysize(configs),\n        &found_configs) == EGL_FALSE ||\n        found_configs == 0) {\n        return SDL_SetError(\"Couldn't find matching EGL config\");\n    }\n    \n    /* eglChooseConfig returns a number of configurations that match or exceed the requested attribs. */\n    /* From those, we select the one that matches our requirements more closely via a makeshift algorithm */\n\n    for ( i=0; i<found_configs; i++ ) {\n        bitdiff = 0;\n        for (j = 0; j < SDL_arraysize(attribs) - 1; j += 2) {\n            if (attribs[j] == EGL_NONE) {\n               break;\n            }\n            \n            if ( attribs[j+1] != EGL_DONT_CARE && (\n                attribs[j] == EGL_RED_SIZE ||\n                attribs[j] == EGL_GREEN_SIZE ||\n                attribs[j] == EGL_BLUE_SIZE ||\n                attribs[j] == EGL_ALPHA_SIZE ||\n                attribs[j] == EGL_DEPTH_SIZE ||\n                attribs[j] == EGL_STENCIL_SIZE)) {\n                _this->egl_data->eglGetConfigAttrib(_this->egl_data->egl_display, configs[i], attribs[j], &value);\n                bitdiff += value - attribs[j + 1]; /* value is always >= attrib */\n            }\n        }\n\n        if (bitdiff < best_bitdiff || best_bitdiff == -1) {\n            _this->egl_data->egl_config = configs[i];\n            \n            best_bitdiff = bitdiff;\n        }\n           \n        if (bitdiff == 0) break; /* we found an exact match! */\n    }\n    \n    return 0;\n}\n\nSDL_GLContext\nSDL_EGL_CreateContext(_THIS, EGLSurface egl_surface)\n{\n    EGLint context_attrib_list[] = {\n        EGL_CONTEXT_CLIENT_VERSION,\n        1,\n        EGL_NONE,\n        EGL_NONE,\n        EGL_NONE,\n        EGL_NONE,\n        EGL_NONE\n    };\n    \n    EGLContext egl_context, share_context = EGL_NO_CONTEXT;\n    \n    if (!_this->egl_data) {\n        /* The EGL library wasn't loaded, SDL_GetError() should have info */\n        return NULL;\n    }\n    \n    if (_this->gl_config.share_with_current_context) {\n        share_context = (EGLContext)SDL_GL_GetCurrentContext();\n    }\n    \n    /* Bind the API */\n    if(_this->gl_config.profile_mask == SDL_GL_CONTEXT_PROFILE_ES) {\n        _this->egl_data->eglBindAPI(EGL_OPENGL_ES_API);\n        if (_this->gl_config.major_version) {\n            context_attrib_list[1] = _this->gl_config.major_version;\n        }\n\n        egl_context = _this->egl_data->eglCreateContext(_this->egl_data->egl_display,\n                                          _this->egl_data->egl_config,\n                                          share_context, context_attrib_list);\n    }\n    else {\n        _this->egl_data->eglBindAPI(EGL_OPENGL_API);\n#ifdef EGL_KHR_create_context        \n        if(SDL_EGL_HasExtension(_this, \"EGL_KHR_create_context\")) {\n            context_attrib_list[0] = EGL_CONTEXT_MAJOR_VERSION_KHR;\n            context_attrib_list[1] = _this->gl_config.major_version;\n            context_attrib_list[2] = EGL_CONTEXT_MINOR_VERSION_KHR;\n            context_attrib_list[3] = _this->gl_config.minor_version;\n            context_attrib_list[4] = EGL_CONTEXT_OPENGL_PROFILE_MASK_KHR;\n            switch(_this->gl_config.profile_mask) {\n            case SDL_GL_CONTEXT_PROFILE_COMPATIBILITY:\n                context_attrib_list[5] = EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT_KHR;\n                break;\n\n            case SDL_GL_CONTEXT_PROFILE_CORE:\n            default:\n                context_attrib_list[5] = EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT_KHR;\n                break;\n            }\n        }\n        else {\n            context_attrib_list[0] = EGL_NONE;\n        }\n#else /* EGL_KHR_create_context */\n        context_attrib_list[0] = EGL_NONE;\n#endif /* EGL_KHR_create_context */\n        egl_context = _this->egl_data->eglCreateContext(_this->egl_data->egl_display,\n                                          _this->egl_data->egl_config,\n                                          share_context, context_attrib_list);\n    }\n    \n    if (egl_context == EGL_NO_CONTEXT) {\n        SDL_SetError(\"Could not create EGL context\");\n        return NULL;\n    }\n    \n    _this->egl_data->egl_swapinterval = 0;\n    \n    if (SDL_EGL_MakeCurrent(_this, egl_surface, egl_context) < 0) {\n        SDL_EGL_DeleteContext(_this, egl_context);\n        SDL_SetError(\"Could not make EGL context current\");\n        return NULL;\n    }\n  \n    return (SDL_GLContext) egl_context;\n}\n\nint\nSDL_EGL_MakeCurrent(_THIS, EGLSurface egl_surface, SDL_GLContext context)\n{\n    EGLContext egl_context = (EGLContext) context;\n\n    if (!_this->egl_data) {\n        return SDL_SetError(\"OpenGL not initialized\");\n    }\n    \n    /* The android emulator crashes badly if you try to eglMakeCurrent \n     * with a valid context and invalid surface, so we have to check for both here.\n     */\n    if (!egl_context || !egl_surface) {\n         _this->egl_data->eglMakeCurrent(_this->egl_data->egl_display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);\n    }\n    else {\n        if (!_this->egl_data->eglMakeCurrent(_this->egl_data->egl_display,\n            egl_surface, egl_surface, egl_context)) {\n            return SDL_SetError(\"Unable to make EGL context current\");\n        }\n    }\n      \n    return 0;\n}\n\nint\nSDL_EGL_SetSwapInterval(_THIS, int interval)\n{\n    EGLBoolean status;\n    \n    if (!_this->egl_data) {\n        return SDL_SetError(\"EGL not initialized\");\n    }\n    \n    status = _this->egl_data->eglSwapInterval(_this->egl_data->egl_display, interval);\n    if (status == EGL_TRUE) {\n        _this->egl_data->egl_swapinterval = interval;\n        return 0;\n    }\n    \n    return SDL_SetError(\"Unable to set the EGL swap interval\");\n}\n\nint\nSDL_EGL_GetSwapInterval(_THIS)\n{\n    if (!_this->egl_data) {\n        return SDL_SetError(\"EGL not initialized\");\n    }\n    \n    return _this->egl_data->egl_swapinterval;\n}\n\nvoid\nSDL_EGL_SwapBuffers(_THIS, EGLSurface egl_surface)\n{\n    _this->egl_data->eglSwapBuffers(_this->egl_data->egl_display, egl_surface);\n}\n\nvoid\nSDL_EGL_DeleteContext(_THIS, SDL_GLContext context)\n{\n    EGLContext egl_context = (EGLContext) context;\n\n    /* Clean up GLES and EGL */\n    if (!_this->egl_data) {\n        return;\n    }\n    \n    if (egl_context != NULL && egl_context != EGL_NO_CONTEXT) {\n        SDL_EGL_MakeCurrent(_this, NULL, NULL);\n        _this->egl_data->eglDestroyContext(_this->egl_data->egl_display, egl_context);\n    }\n        \n}\n\nEGLSurface *\nSDL_EGL_CreateSurface(_THIS, NativeWindowType nw) \n{\n    if (SDL_EGL_ChooseConfig(_this) != 0) {\n        return EGL_NO_SURFACE;\n    }\n    \n#if __ANDROID__\n    {\n        /* Android docs recommend doing this!\n         * Ref: http://developer.android.com/reference/android/app/NativeActivity.html \n         */\n        EGLint format;\n        _this->egl_data->eglGetConfigAttrib(_this->egl_data->egl_display,\n                                            _this->egl_data->egl_config, \n                                            EGL_NATIVE_VISUAL_ID, &format);\n\n        ANativeWindow_setBuffersGeometry(nw, 0, 0, format);\n    }\n#endif    \n    \n    return _this->egl_data->eglCreateWindowSurface(\n            _this->egl_data->egl_display,\n            _this->egl_data->egl_config,\n            nw, NULL);\n}\n\nvoid\nSDL_EGL_DestroySurface(_THIS, EGLSurface egl_surface) \n{\n    if (!_this->egl_data) {\n        return;\n    }\n    \n    if (egl_surface != EGL_NO_SURFACE) {\n        _this->egl_data->eglDestroySurface(_this->egl_data->egl_display, egl_surface);\n    }\n}\n\n#endif /* SDL_VIDEO_OPENGL_EGL */\n\n/* vi: set ts=4 sw=4 expandtab: */\n    \n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../SDL_internal.h\"\n\n/* This is the game controller API for Simple DirectMedia Layer */\n\n#include \"SDL_events.h\"\n#include \"SDL_assert.h\"\n#include \"SDL_sysjoystick.h\"\n#include \"SDL_hints.h\"\n#include \"SDL_gamecontrollerdb.h\"\n\n#if !SDL_EVENTS_DISABLED\n#include \"../events/SDL_events_c.h\"\n#endif\n#define ABS(_x) ((_x) < 0 ? -(_x) : (_x))\n\n#define SDL_CONTROLLER_PLATFORM_FIELD \"platform:\"\n\n/* a list of currently opened game controllers */\nstatic SDL_GameController *SDL_gamecontrollers = NULL;\n\n/* keep track of the hat and mask value that transforms this hat movement into a button/axis press */\nstruct _SDL_HatMapping\n{\n    int hat;\n    Uint8 mask;\n};\n\n#define k_nMaxReverseEntries 20\n\n/**\n * We are encoding the \"HAT\" as 0xhm. where h == hat ID and m == mask\n * MAX 4 hats supported\n */\n#define k_nMaxHatEntries 0x3f + 1\n\n/* our in memory mapping db between joystick objects and controller mappings */\nstruct _SDL_ControllerMapping\n{\n    SDL_JoystickGUID guid;\n    const char *name;\n\n    /* mapping of axis/button id to controller version */\n    int axes[SDL_CONTROLLER_AXIS_MAX];\n    int buttonasaxis[SDL_CONTROLLER_AXIS_MAX];\n\n    int buttons[SDL_CONTROLLER_BUTTON_MAX];\n    int axesasbutton[SDL_CONTROLLER_BUTTON_MAX];\n    struct _SDL_HatMapping hatasbutton[SDL_CONTROLLER_BUTTON_MAX];\n\n    /* reverse mapping, joystick indices to buttons */\n    SDL_GameControllerAxis raxes[k_nMaxReverseEntries];\n    SDL_GameControllerAxis rbuttonasaxis[k_nMaxReverseEntries];\n\n    SDL_GameControllerButton rbuttons[k_nMaxReverseEntries];\n    SDL_GameControllerButton raxesasbutton[k_nMaxReverseEntries];\n    SDL_GameControllerButton rhatasbutton[k_nMaxHatEntries];\n\n};\n\n\n/* our hard coded list of mapping support */\ntypedef struct _ControllerMapping_t\n{\n    SDL_JoystickGUID guid;\n    char *name;\n    char *mapping;\n    struct _ControllerMapping_t *next;\n} ControllerMapping_t;\n\nstatic ControllerMapping_t *s_pSupportedControllers = NULL;\nstatic ControllerMapping_t *s_pXInputMapping = NULL;\nstatic ControllerMapping_t *s_pEmscriptenMapping = NULL;\n\n/* The SDL game controller structure */\nstruct _SDL_GameController\n{\n    SDL_Joystick *joystick; /* underlying joystick device */\n    int ref_count;\n    Uint8 hatState[4]; /* the current hat state for this controller */\n    struct _SDL_ControllerMapping mapping; /* the mapping object for this controller */\n    struct _SDL_GameController *next; /* pointer to next game controller we have allocated */\n};\n\n\nint SDL_PrivateGameControllerAxis(SDL_GameController * gamecontroller, SDL_GameControllerAxis axis, Sint16 value);\nint SDL_PrivateGameControllerButton(SDL_GameController * gamecontroller, SDL_GameControllerButton button, Uint8 state);\n\n/*\n * Event filter to fire controller events from joystick ones\n */\nint SDL_GameControllerEventWatcher(void *userdata, SDL_Event * event)\n{\n    switch(event->type) {\n    case SDL_JOYAXISMOTION:\n        {\n            SDL_GameController *controllerlist;\n\n            if (event->jaxis.axis >= k_nMaxReverseEntries) break;\n\n            controllerlist = SDL_gamecontrollers;\n            while (controllerlist) {\n                if (controllerlist->joystick->instance_id == event->jaxis.which) {\n                    if (controllerlist->mapping.raxes[event->jaxis.axis] >= 0) /* simple axis to axis, send it through */ {\n                        SDL_GameControllerAxis axis = controllerlist->mapping.raxes[event->jaxis.axis];\n                        Sint16 value = event->jaxis.value;\n                        switch (axis) {\n                            case SDL_CONTROLLER_AXIS_TRIGGERLEFT:\n                            case SDL_CONTROLLER_AXIS_TRIGGERRIGHT:\n                                /* Shift it to be 0 - 32767. */\n                                value = value / 2 + 16384;\n                            default:\n                                break;\n                        }\n                        SDL_PrivateGameControllerAxis(controllerlist, axis, value);\n                    } else if (controllerlist->mapping.raxesasbutton[event->jaxis.axis] >= 0) { /* simulate an axis as a button */\n                        SDL_PrivateGameControllerButton(controllerlist, controllerlist->mapping.raxesasbutton[event->jaxis.axis], ABS(event->jaxis.value) > 32768/2 ? SDL_PRESSED : SDL_RELEASED);\n                    }\n                    break;\n                }\n                controllerlist = controllerlist->next;\n            }\n        }\n        break;\n    case SDL_JOYBUTTONDOWN:\n    case SDL_JOYBUTTONUP:\n        {\n            SDL_GameController *controllerlist;\n\n            if (event->jbutton.button >= k_nMaxReverseEntries) break;\n\n            controllerlist = SDL_gamecontrollers;\n            while (controllerlist) {\n                if (controllerlist->joystick->instance_id == event->jbutton.which) {\n                    if (controllerlist->mapping.rbuttons[event->jbutton.button] >= 0) { /* simple button as button */\n                        SDL_PrivateGameControllerButton(controllerlist, controllerlist->mapping.rbuttons[event->jbutton.button], event->jbutton.state);\n                    } else if (controllerlist->mapping.rbuttonasaxis[event->jbutton.button] >= 0) { /* an button pretending to be an axis */\n                        SDL_PrivateGameControllerAxis(controllerlist, controllerlist->mapping.rbuttonasaxis[event->jbutton.button], event->jbutton.state > 0 ? 32767 : 0);\n                    }\n                    break;\n                }\n                controllerlist = controllerlist->next;\n            }\n        }\n        break;\n    case SDL_JOYHATMOTION:\n        {\n            SDL_GameController *controllerlist;\n\n            if (event->jhat.hat >= 4) break;\n\n            controllerlist = SDL_gamecontrollers;\n            while (controllerlist) {\n                if (controllerlist->joystick->instance_id == event->jhat.which) {\n                    Uint8 bSame = controllerlist->hatState[event->jhat.hat] & event->jhat.value;\n                    /* Get list of removed bits (button release) */\n                    Uint8 bChanged = controllerlist->hatState[event->jhat.hat] ^ bSame;\n                    /* the hat idx in the high nibble */\n                    int bHighHat = event->jhat.hat << 4;\n\n                    if (bChanged & SDL_HAT_DOWN)\n                        SDL_PrivateGameControllerButton(controllerlist, controllerlist->mapping.rhatasbutton[bHighHat | SDL_HAT_DOWN], SDL_RELEASED);\n                    if (bChanged & SDL_HAT_UP)\n                        SDL_PrivateGameControllerButton(controllerlist, controllerlist->mapping.rhatasbutton[bHighHat | SDL_HAT_UP], SDL_RELEASED);\n                    if (bChanged & SDL_HAT_LEFT)\n                        SDL_PrivateGameControllerButton(controllerlist, controllerlist->mapping.rhatasbutton[bHighHat | SDL_HAT_LEFT], SDL_RELEASED);\n                    if (bChanged & SDL_HAT_RIGHT)\n                        SDL_PrivateGameControllerButton(controllerlist, controllerlist->mapping.rhatasbutton[bHighHat | SDL_HAT_RIGHT], SDL_RELEASED);\n\n                    /* Get list of added bits (button press) */\n                    bChanged = event->jhat.value ^ bSame;\n\n                    if (bChanged & SDL_HAT_DOWN)\n                        SDL_PrivateGameControllerButton(controllerlist, controllerlist->mapping.rhatasbutton[bHighHat | SDL_HAT_DOWN], SDL_PRESSED);\n                    if (bChanged & SDL_HAT_UP)\n                        SDL_PrivateGameControllerButton(controllerlist, controllerlist->mapping.rhatasbutton[bHighHat | SDL_HAT_UP], SDL_PRESSED);\n                    if (bChanged & SDL_HAT_LEFT)\n                        SDL_PrivateGameControllerButton(controllerlist, controllerlist->mapping.rhatasbutton[bHighHat | SDL_HAT_LEFT], SDL_PRESSED);\n                    if (bChanged & SDL_HAT_RIGHT)\n                        SDL_PrivateGameControllerButton(controllerlist, controllerlist->mapping.rhatasbutton[bHighHat | SDL_HAT_RIGHT], SDL_PRESSED);\n\n                    /* update our state cache */\n                    controllerlist->hatState[event->jhat.hat] = event->jhat.value;\n\n                    break;\n                }\n                controllerlist = controllerlist->next;\n            }\n        }\n        break;\n    case SDL_JOYDEVICEADDED:\n        {\n            if (SDL_IsGameController(event->jdevice.which)) {\n                SDL_Event deviceevent;\n                deviceevent.type = SDL_CONTROLLERDEVICEADDED;\n                deviceevent.cdevice.which = event->jdevice.which;\n                SDL_PushEvent(&deviceevent);\n            }\n        }\n        break;\n    case SDL_JOYDEVICEREMOVED:\n        {\n            SDL_GameController *controllerlist = SDL_gamecontrollers;\n            while (controllerlist) {\n                if (controllerlist->joystick->instance_id == event->jdevice.which) {\n                    SDL_Event deviceevent;\n                    deviceevent.type = SDL_CONTROLLERDEVICEREMOVED;\n                    deviceevent.cdevice.which = event->jdevice.which;\n                    SDL_PushEvent(&deviceevent);\n                    break;\n                }\n                controllerlist = controllerlist->next;\n            }\n        }\n        break;\n    default:\n        break;\n    }\n\n    return 1;\n}\n\n/*\n * Helper function to scan the mappings database for a controller with the specified GUID\n */\nControllerMapping_t *SDL_PrivateGetControllerMappingForGUID(SDL_JoystickGUID *guid)\n{\n    ControllerMapping_t *pSupportedController = s_pSupportedControllers;\n    while (pSupportedController) {\n        if (SDL_memcmp(guid, &pSupportedController->guid, sizeof(*guid)) == 0) {\n            return pSupportedController;\n        }\n        pSupportedController = pSupportedController->next;\n    }\n    return NULL;\n}\n\n/*\n * Helper function to determine pre-calculated offset to certain joystick mappings\n */\nControllerMapping_t *SDL_PrivateGetControllerMapping(int device_index)\n{\n#if SDL_JOYSTICK_XINPUT\n    if (SDL_SYS_IsXInputGamepad_DeviceIndex(device_index) && s_pXInputMapping) {\n        return s_pXInputMapping;\n    }\n    else\n#endif\n#if defined(SDL_JOYSTICK_EMSCRIPTEN)\n    if (s_pEmscriptenMapping) {\n        return s_pEmscriptenMapping;\n    }\n    else\n#endif\n    {\n        SDL_JoystickGUID jGUID = SDL_JoystickGetDeviceGUID(device_index);\n        return SDL_PrivateGetControllerMappingForGUID(&jGUID);\n    }\n}\n\nstatic const char* map_StringForControllerAxis[] = {\n    \"leftx\",\n    \"lefty\",\n    \"rightx\",\n    \"righty\",\n    \"lefttrigger\",\n    \"righttrigger\",\n    NULL\n};\n\n/*\n * convert a string to its enum equivalent\n */\nSDL_GameControllerAxis SDL_GameControllerGetAxisFromString(const char *pchString)\n{\n    int entry;\n    if (!pchString || !pchString[0])\n        return SDL_CONTROLLER_AXIS_INVALID;\n\n    for (entry = 0; map_StringForControllerAxis[entry]; ++entry) {\n        if (!SDL_strcasecmp(pchString, map_StringForControllerAxis[entry]))\n            return entry;\n    }\n    return SDL_CONTROLLER_AXIS_INVALID;\n}\n\n/*\n * convert an enum to its string equivalent\n */\nconst char* SDL_GameControllerGetStringForAxis(SDL_GameControllerAxis axis)\n{\n    if (axis > SDL_CONTROLLER_AXIS_INVALID && axis < SDL_CONTROLLER_AXIS_MAX) {\n        return map_StringForControllerAxis[axis];\n    }\n    return NULL;\n}\n\nstatic const char* map_StringForControllerButton[] = {\n    \"a\",\n    \"b\",\n    \"x\",\n    \"y\",\n    \"back\",\n    \"guide\",\n    \"start\",\n    \"leftstick\",\n    \"rightstick\",\n    \"leftshoulder\",\n    \"rightshoulder\",\n    \"dpup\",\n    \"dpdown\",\n    \"dpleft\",\n    \"dpright\",\n    NULL\n};\n\n/*\n * convert a string to its enum equivalent\n */\nSDL_GameControllerButton SDL_GameControllerGetButtonFromString(const char *pchString)\n{\n    int entry;\n    if (!pchString || !pchString[0])\n        return SDL_CONTROLLER_BUTTON_INVALID;\n\n    for (entry = 0; map_StringForControllerButton[entry]; ++entry) {\n        if (SDL_strcasecmp(pchString, map_StringForControllerButton[entry]) == 0)\n            return entry;\n    }\n    return SDL_CONTROLLER_BUTTON_INVALID;\n}\n\n/*\n * convert an enum to its string equivalent\n */\nconst char* SDL_GameControllerGetStringForButton(SDL_GameControllerButton axis)\n{\n    if (axis > SDL_CONTROLLER_BUTTON_INVALID && axis < SDL_CONTROLLER_BUTTON_MAX) {\n        return map_StringForControllerButton[axis];\n    }\n    return NULL;\n}\n\n/*\n * given a controller button name and a joystick name update our mapping structure with it\n */\nvoid SDL_PrivateGameControllerParseButton(const char *szGameButton, const char *szJoystickButton, struct _SDL_ControllerMapping *pMapping)\n{\n    int iSDLButton = 0;\n    SDL_GameControllerButton button;\n    SDL_GameControllerAxis axis;\n    button = SDL_GameControllerGetButtonFromString(szGameButton);\n    axis = SDL_GameControllerGetAxisFromString(szGameButton);\n    iSDLButton = SDL_atoi(&szJoystickButton[1]);\n\n    if (szJoystickButton[0] == 'a') {\n        if (iSDLButton >= k_nMaxReverseEntries) {\n            SDL_SetError(\"Axis index too large: %d\", iSDLButton);\n            return;\n        }\n        if (axis != SDL_CONTROLLER_AXIS_INVALID) {\n            pMapping->axes[ axis ] = iSDLButton;\n            pMapping->raxes[ iSDLButton ] = axis;\n        } else if (button != SDL_CONTROLLER_BUTTON_INVALID) {\n            pMapping->axesasbutton[ button ] = iSDLButton;\n            pMapping->raxesasbutton[ iSDLButton ] = button;\n        } else {\n            SDL_assert(!\"How did we get here?\");\n        }\n\n    } else if (szJoystickButton[0] == 'b') {\n        if (iSDLButton >= k_nMaxReverseEntries) {\n            SDL_SetError(\"Button index too large: %d\", iSDLButton);\n            return;\n        }\n        if (button != SDL_CONTROLLER_BUTTON_INVALID) {\n            pMapping->buttons[ button ] = iSDLButton;\n            pMapping->rbuttons[ iSDLButton ] = button;\n        } else if (axis != SDL_CONTROLLER_AXIS_INVALID) {\n            pMapping->buttonasaxis[ axis ] = iSDLButton;\n            pMapping->rbuttonasaxis[ iSDLButton ] = axis;\n        } else {\n            SDL_assert(!\"How did we get here?\");\n        }\n    } else if (szJoystickButton[0] == 'h') {\n        int hat = SDL_atoi(&szJoystickButton[1]);\n        int mask = SDL_atoi(&szJoystickButton[3]);\n        if (hat >= 4) {\n            SDL_SetError(\"Hat index too large: %d\", iSDLButton);\n        }\n\n        if (button != SDL_CONTROLLER_BUTTON_INVALID) {\n            int ridx;\n            pMapping->hatasbutton[ button ].hat = hat;\n            pMapping->hatasbutton[ button ].mask = mask;\n            ridx = (hat << 4) | mask;\n            pMapping->rhatasbutton[ ridx ] = button;\n        } else if (axis != SDL_CONTROLLER_AXIS_INVALID) {\n            SDL_assert(!\"Support hat as axis\");\n        } else {\n            SDL_assert(!\"How did we get here?\");\n        }\n    }\n}\n\n\n/*\n * given a controller mapping string update our mapping object\n */\nstatic void\nSDL_PrivateGameControllerParseControllerConfigString(struct _SDL_ControllerMapping *pMapping, const char *pchString)\n{\n    char szGameButton[20];\n    char szJoystickButton[20];\n    SDL_bool bGameButton = SDL_TRUE;\n    int i = 0;\n    const char *pchPos = pchString;\n\n    SDL_memset(szGameButton, 0x0, sizeof(szGameButton));\n    SDL_memset(szJoystickButton, 0x0, sizeof(szJoystickButton));\n\n    while (pchPos && *pchPos) {\n        if (*pchPos == ':') {\n            i = 0;\n            bGameButton = SDL_FALSE;\n        } else if (*pchPos == ' ') {\n\n        } else if (*pchPos == ',') {\n            i = 0;\n            bGameButton = SDL_TRUE;\n            SDL_PrivateGameControllerParseButton(szGameButton, szJoystickButton, pMapping);\n            SDL_memset(szGameButton, 0x0, sizeof(szGameButton));\n            SDL_memset(szJoystickButton, 0x0, sizeof(szJoystickButton));\n\n        } else if (bGameButton) {\n            if (i >= sizeof(szGameButton)) {\n                SDL_SetError(\"Button name too large: %s\", szGameButton);\n                return;\n            }\n            szGameButton[i] = *pchPos;\n            i++;\n        } else {\n            if (i >= sizeof(szJoystickButton)) {\n                SDL_SetError(\"Joystick button name too large: %s\", szJoystickButton);\n                return;\n            }\n            szJoystickButton[i] = *pchPos;\n            i++;\n        }\n        pchPos++;\n    }\n\n    SDL_PrivateGameControllerParseButton(szGameButton, szJoystickButton, pMapping);\n\n}\n\n/*\n * Make a new button mapping struct\n */\nvoid SDL_PrivateLoadButtonMapping(struct _SDL_ControllerMapping *pMapping, SDL_JoystickGUID guid, const char *pchName, const char *pchMapping)\n{\n    int j;\n\n    pMapping->guid = guid;\n    pMapping->name = pchName;\n\n    /* set all the button mappings to non defaults */\n    for (j = 0; j < SDL_CONTROLLER_AXIS_MAX; j++) {\n        pMapping->axes[j] = -1;\n        pMapping->buttonasaxis[j] = -1;\n    }\n    for (j = 0; j < SDL_CONTROLLER_BUTTON_MAX; j++) {\n        pMapping->buttons[j] = -1;\n        pMapping->axesasbutton[j] = -1;\n        pMapping->hatasbutton[j].hat = -1;\n    }\n\n    for (j = 0; j < k_nMaxReverseEntries; j++) {\n        pMapping->raxes[j] = SDL_CONTROLLER_AXIS_INVALID;\n        pMapping->rbuttonasaxis[j] = SDL_CONTROLLER_AXIS_INVALID;\n        pMapping->rbuttons[j] = SDL_CONTROLLER_BUTTON_INVALID;\n        pMapping->raxesasbutton[j] = SDL_CONTROLLER_BUTTON_INVALID;\n    }\n\n    for (j = 0; j < k_nMaxHatEntries; j++) {\n        pMapping->rhatasbutton[j] = SDL_CONTROLLER_BUTTON_INVALID;\n    }\n\n    SDL_PrivateGameControllerParseControllerConfigString(pMapping, pchMapping);\n}\n\n\n/*\n * grab the guid string from a mapping string\n */\nchar *SDL_PrivateGetControllerGUIDFromMappingString(const char *pMapping)\n{\n    const char *pFirstComma = SDL_strchr(pMapping, ',');\n    if (pFirstComma) {\n        char *pchGUID = SDL_malloc(pFirstComma - pMapping + 1);\n        if (!pchGUID) {\n            SDL_OutOfMemory();\n            return NULL;\n        }\n        SDL_memcpy(pchGUID, pMapping, pFirstComma - pMapping);\n        pchGUID[ pFirstComma - pMapping ] = 0;\n        return pchGUID;\n    }\n    return NULL;\n}\n\n\n/*\n * grab the name string from a mapping string\n */\nchar *SDL_PrivateGetControllerNameFromMappingString(const char *pMapping)\n{\n    const char *pFirstComma, *pSecondComma;\n    char *pchName;\n\n    pFirstComma = SDL_strchr(pMapping, ',');\n    if (!pFirstComma)\n        return NULL;\n\n    pSecondComma = SDL_strchr(pFirstComma + 1, ',');\n    if (!pSecondComma)\n        return NULL;\n\n    pchName = SDL_malloc(pSecondComma - pFirstComma);\n    if (!pchName) {\n        SDL_OutOfMemory();\n        return NULL;\n    }\n    SDL_memcpy(pchName, pFirstComma + 1, pSecondComma - pFirstComma);\n    pchName[ pSecondComma - pFirstComma - 1 ] = 0;\n    return pchName;\n}\n\n\n/*\n * grab the button mapping string from a mapping string\n */\nchar *SDL_PrivateGetControllerMappingFromMappingString(const char *pMapping)\n{\n    const char *pFirstComma, *pSecondComma;\n\n    pFirstComma = SDL_strchr(pMapping, ',');\n    if (!pFirstComma)\n        return NULL;\n\n    pSecondComma = SDL_strchr(pFirstComma + 1, ',');\n    if (!pSecondComma)\n        return NULL;\n\n    return SDL_strdup(pSecondComma + 1); /* mapping is everything after the 3rd comma */\n}\n\nvoid SDL_PrivateGameControllerRefreshMapping(ControllerMapping_t *pControllerMapping)\n{\n    SDL_GameController *gamecontrollerlist = SDL_gamecontrollers;\n    while (gamecontrollerlist) {\n        if (!SDL_memcmp(&gamecontrollerlist->mapping.guid, &pControllerMapping->guid, sizeof(pControllerMapping->guid))) {\n            SDL_Event event;\n            event.type = SDL_CONTROLLERDEVICEREMAPPED;\n            event.cdevice.which = gamecontrollerlist->joystick->instance_id;\n            SDL_PushEvent(&event);\n\n            /* Not really threadsafe.  Should this lock access within SDL_GameControllerEventWatcher? */\n            SDL_PrivateLoadButtonMapping(&gamecontrollerlist->mapping, pControllerMapping->guid, pControllerMapping->name, pControllerMapping->mapping);\n        }\n\n        gamecontrollerlist = gamecontrollerlist->next;\n    }\n}\n\n/*\n * Add or update an entry into the Mappings Database\n */\nint\nSDL_GameControllerAddMappingsFromRW(SDL_RWops * rw, int freerw)\n{\n    const char *platform = SDL_GetPlatform();\n    int controllers = 0;\n    char *buf, *line, *line_end, *tmp, *comma, line_platform[64];\n    size_t db_size, platform_len;\n    \n    if (rw == NULL) {\n        return SDL_SetError(\"Invalid RWops\");\n    }\n    db_size = (size_t)SDL_RWsize(rw);\n    \n    buf = (char *)SDL_malloc(db_size + 1);\n    if (buf == NULL) {\n        if (freerw) {\n            SDL_RWclose(rw);\n        }\n        return SDL_SetError(\"Could not allocate space to read DB into memory\");\n    }\n    \n    if (SDL_RWread(rw, buf, db_size, 1) != 1) {\n        if (freerw) {\n            SDL_RWclose(rw);\n        }\n        SDL_free(buf);\n        return SDL_SetError(\"Could not read DB\");\n    }\n    \n    if (freerw) {\n        SDL_RWclose(rw);\n    }\n    \n    buf[db_size] = '\\0';\n    line = buf;\n    \n    while (line < buf + db_size) {\n        line_end = SDL_strchr(line, '\\n');\n        if (line_end != NULL) {\n            *line_end = '\\0';\n        } else {\n            line_end = buf + db_size;\n        }\n        \n        /* Extract and verify the platform */\n        tmp = SDL_strstr(line, SDL_CONTROLLER_PLATFORM_FIELD);\n        if (tmp != NULL) {\n            tmp += SDL_strlen(SDL_CONTROLLER_PLATFORM_FIELD);\n            comma = SDL_strchr(tmp, ',');\n            if (comma != NULL) {\n                platform_len = comma - tmp + 1;\n                if (platform_len + 1 < SDL_arraysize(line_platform)) {\n                    SDL_strlcpy(line_platform, tmp, platform_len);\n                    if (SDL_strncasecmp(line_platform, platform, platform_len) == 0 &&\n                        SDL_GameControllerAddMapping(line) > 0) {\n                        controllers++;\n                    }\n                }\n            }\n        }\n        \n        line = line_end + 1;\n    }\n\n    SDL_free(buf);\n    return controllers;\n}\n\n/*\n * Add or update an entry into the Mappings Database\n */\nint\nSDL_GameControllerAddMapping(const char *mappingString)\n{\n    char *pchGUID;\n    char *pchName;\n    char *pchMapping;\n    SDL_JoystickGUID jGUID;\n    ControllerMapping_t *pControllerMapping;\n    SDL_bool is_xinput_mapping = SDL_FALSE;\n    SDL_bool is_emscripten_mapping = SDL_FALSE;\n\n    if (!mappingString) {\n        return SDL_InvalidParamError(\"mappingString\");\n    }\n\n    pchGUID = SDL_PrivateGetControllerGUIDFromMappingString(mappingString);\n    if (!pchGUID) {\n        return SDL_SetError(\"Couldn't parse GUID from %s\", mappingString);\n    }\n    if (!SDL_strcasecmp(pchGUID, \"xinput\")) {\n        is_xinput_mapping = SDL_TRUE;\n    }\n    if (!SDL_strcasecmp(pchGUID, \"emscripten\")) {\n        is_emscripten_mapping = SDL_TRUE;\n    }\n    jGUID = SDL_JoystickGetGUIDFromString(pchGUID);\n    SDL_free(pchGUID);\n\n    pchName = SDL_PrivateGetControllerNameFromMappingString(mappingString);\n    if (!pchName) {\n        return SDL_SetError(\"Couldn't parse name from %s\", mappingString);\n    }\n\n    pchMapping = SDL_PrivateGetControllerMappingFromMappingString(mappingString);\n    if (!pchMapping) {\n        SDL_free(pchName);\n        return SDL_SetError(\"Couldn't parse %s\", mappingString);\n    }\n\n    pControllerMapping = SDL_PrivateGetControllerMappingForGUID(&jGUID);\n\n    if (pControllerMapping) {\n        /* Update existing mapping */\n        SDL_free(pControllerMapping->name);\n        pControllerMapping->name = pchName;\n        SDL_free(pControllerMapping->mapping);\n        pControllerMapping->mapping = pchMapping;\n        /* refresh open controllers */\n        SDL_PrivateGameControllerRefreshMapping(pControllerMapping);\n        return 0;\n    } else {\n        pControllerMapping = SDL_malloc(sizeof(*pControllerMapping));\n        if (!pControllerMapping) {\n            SDL_free(pchName);\n            SDL_free(pchMapping);\n            return SDL_OutOfMemory();\n        }\n        if (is_xinput_mapping) {\n            s_pXInputMapping = pControllerMapping;\n        }\n        if (is_emscripten_mapping) {\n            s_pEmscriptenMapping = pControllerMapping;\n        }\n        pControllerMapping->guid = jGUID;\n        pControllerMapping->name = pchName;\n        pControllerMapping->mapping = pchMapping;\n        pControllerMapping->next = s_pSupportedControllers;\n        s_pSupportedControllers = pControllerMapping;\n        return 1;\n    }\n}\n\n/*\n * Get the mapping string for this GUID\n */\nchar *\nSDL_GameControllerMappingForGUID(SDL_JoystickGUID guid)\n{\n    char *pMappingString = NULL;\n    ControllerMapping_t *mapping = SDL_PrivateGetControllerMappingForGUID(&guid);\n    if (mapping) {\n        char pchGUID[33];\n        size_t needed;\n        SDL_JoystickGetGUIDString(guid, pchGUID, sizeof(pchGUID));\n        /* allocate enough memory for GUID + ',' + name + ',' + mapping + \\0 */\n        needed = SDL_strlen(pchGUID) + 1 + SDL_strlen(mapping->name) + 1 + SDL_strlen(mapping->mapping) + 1;\n        pMappingString = SDL_malloc(needed);\n        if (!pMappingString) {\n            SDL_OutOfMemory();\n            return NULL;\n        }\n        SDL_snprintf(pMappingString, needed, \"%s,%s,%s\", pchGUID, mapping->name, mapping->mapping);\n    }\n    return pMappingString;\n}\n\n/*\n * Get the mapping string for this device\n */\nchar *\nSDL_GameControllerMapping(SDL_GameController * gamecontroller)\n{\n    if (!gamecontroller) {\n        return NULL;\n    }\n\n    return SDL_GameControllerMappingForGUID(gamecontroller->mapping.guid);\n}\n\nstatic void\nSDL_GameControllerLoadHints()\n{\n    const char *hint = SDL_GetHint(SDL_HINT_GAMECONTROLLERCONFIG);\n    if (hint && hint[0]) {\n        size_t nchHints = SDL_strlen(hint);\n        char *pUserMappings = SDL_malloc(nchHints + 1);\n        char *pTempMappings = pUserMappings;\n        SDL_memcpy(pUserMappings, hint, nchHints);\n        pUserMappings[nchHints] = '\\0';\n        while (pUserMappings) {\n            char *pchNewLine = NULL;\n\n            pchNewLine = SDL_strchr(pUserMappings, '\\n');\n            if (pchNewLine)\n                *pchNewLine = '\\0';\n\n            SDL_GameControllerAddMapping(pUserMappings);\n\n            if (pchNewLine) {\n                pUserMappings = pchNewLine + 1;\n            } else {\n                pUserMappings = NULL;\n            }\n        }\n        SDL_free(pTempMappings);\n    }\n}\n\n/*\n * Initialize the game controller system, mostly load our DB of controller config mappings\n */\nint\nSDL_GameControllerInit(void)\n{\n    int i = 0;\n    const char *pMappingString = NULL;\n    s_pSupportedControllers = NULL;\n    pMappingString = s_ControllerMappings[i];\n    while (pMappingString) {\n        SDL_GameControllerAddMapping(pMappingString);\n\n        i++;\n        pMappingString = s_ControllerMappings[i];\n    }\n\n    /* load in any user supplied config */\n    SDL_GameControllerLoadHints();\n\n    /* watch for joy events and fire controller ones if needed */\n    SDL_AddEventWatch(SDL_GameControllerEventWatcher, NULL);\n\n    /* Send added events for controllers currently attached */\n    for (i = 0; i < SDL_NumJoysticks(); ++i) {\n        if (SDL_IsGameController(i)) {\n            SDL_Event deviceevent;\n            deviceevent.type = SDL_CONTROLLERDEVICEADDED;\n            deviceevent.cdevice.which = i;\n            SDL_PushEvent(&deviceevent);\n        }\n    }\n\n    return (0);\n}\n\n\n/*\n * Get the implementation dependent name of a controller\n */\nconst char *\nSDL_GameControllerNameForIndex(int device_index)\n{\n    ControllerMapping_t *pSupportedController =  SDL_PrivateGetControllerMapping(device_index);\n    if (pSupportedController) {\n        return pSupportedController->name;\n    }\n    return NULL;\n}\n\n\n/*\n * Return 1 if the joystick at this device index is a supported controller\n */\nSDL_bool\nSDL_IsGameController(int device_index)\n{\n    ControllerMapping_t *pSupportedController =  SDL_PrivateGetControllerMapping(device_index);\n    if (pSupportedController) {\n        return SDL_TRUE;\n    }\n\n    return SDL_FALSE;\n}\n\n/*\n * Open a controller for use - the index passed as an argument refers to\n * the N'th controller on the system.  This index is the value which will\n * identify this controller in future controller events.\n *\n * This function returns a controller identifier, or NULL if an error occurred.\n */\nSDL_GameController *\nSDL_GameControllerOpen(int device_index)\n{\n    SDL_GameController *gamecontroller;\n    SDL_GameController *gamecontrollerlist;\n    ControllerMapping_t *pSupportedController = NULL;\n\n    if ((device_index < 0) || (device_index >= SDL_NumJoysticks())) {\n        SDL_SetError(\"There are %d joysticks available\", SDL_NumJoysticks());\n        return (NULL);\n    }\n\n    gamecontrollerlist = SDL_gamecontrollers;\n    /* If the controller is already open, return it */\n    while (gamecontrollerlist) {\n        if (SDL_SYS_GetInstanceIdOfDeviceIndex(device_index) == gamecontrollerlist->joystick->instance_id) {\n                gamecontroller = gamecontrollerlist;\n                ++gamecontroller->ref_count;\n                return (gamecontroller);\n        }\n        gamecontrollerlist = gamecontrollerlist->next;\n    }\n\n    /* Find a controller mapping */\n    pSupportedController =  SDL_PrivateGetControllerMapping(device_index);\n    if (!pSupportedController) {\n        SDL_SetError(\"Couldn't find mapping for device (%d)\", device_index);\n        return (NULL);\n    }\n\n    /* Create and initialize the joystick */\n    gamecontroller = (SDL_GameController *) SDL_malloc((sizeof *gamecontroller));\n    if (gamecontroller == NULL) {\n        SDL_OutOfMemory();\n        return NULL;\n    }\n\n    SDL_memset(gamecontroller, 0, (sizeof *gamecontroller));\n    gamecontroller->joystick = SDL_JoystickOpen(device_index);\n    if (!gamecontroller->joystick) {\n        SDL_free(gamecontroller);\n        return NULL;\n    }\n\n    SDL_PrivateLoadButtonMapping(&gamecontroller->mapping, pSupportedController->guid, pSupportedController->name, pSupportedController->mapping);\n\n    /* Add joystick to list */\n    ++gamecontroller->ref_count;\n    /* Link the joystick in the list */\n    gamecontroller->next = SDL_gamecontrollers;\n    SDL_gamecontrollers = gamecontroller;\n\n    SDL_SYS_JoystickUpdate(gamecontroller->joystick);\n\n    return (gamecontroller);\n}\n\n/*\n * Manually pump for controller updates.\n */\nvoid\nSDL_GameControllerUpdate(void)\n{\n    /* Just for API completeness; the joystick API does all the work. */\n    SDL_JoystickUpdate();\n}\n\n\n/*\n * Get the current state of an axis control on a controller\n */\nSint16\nSDL_GameControllerGetAxis(SDL_GameController * gamecontroller, SDL_GameControllerAxis axis)\n{\n    if (!gamecontroller)\n        return 0;\n\n    if (gamecontroller->mapping.axes[axis] >= 0) {\n        Sint16 value = (SDL_JoystickGetAxis(gamecontroller->joystick, gamecontroller->mapping.axes[axis]));\n        switch (axis) {\n            case SDL_CONTROLLER_AXIS_TRIGGERLEFT:\n            case SDL_CONTROLLER_AXIS_TRIGGERRIGHT:\n                /* Shift it to be 0 - 32767. */\n                value = value / 2 + 16384;\n            default:\n                break;\n        }\n        return value;\n    } else if (gamecontroller->mapping.buttonasaxis[axis] >= 0) {\n        Uint8 value;\n        value = SDL_JoystickGetButton(gamecontroller->joystick, gamecontroller->mapping.buttonasaxis[axis]);\n        if (value > 0)\n            return 32767;\n        return 0;\n    }\n    return 0;\n}\n\n\n/*\n * Get the current state of a button on a controller\n */\nUint8\nSDL_GameControllerGetButton(SDL_GameController * gamecontroller, SDL_GameControllerButton button)\n{\n    if (!gamecontroller)\n        return 0;\n\n    if (gamecontroller->mapping.buttons[button] >= 0) {\n        return (SDL_JoystickGetButton(gamecontroller->joystick, gamecontroller->mapping.buttons[button]));\n    } else if (gamecontroller->mapping.axesasbutton[button] >= 0) {\n        Sint16 value;\n        value = SDL_JoystickGetAxis(gamecontroller->joystick, gamecontroller->mapping.axesasbutton[button]);\n        if (ABS(value) > 32768/2)\n            return 1;\n        return 0;\n    } else if (gamecontroller->mapping.hatasbutton[button].hat >= 0) {\n        Uint8 value;\n        value = SDL_JoystickGetHat(gamecontroller->joystick, gamecontroller->mapping.hatasbutton[button].hat);\n\n        if (value & gamecontroller->mapping.hatasbutton[button].mask)\n            return 1;\n        return 0;\n    }\n\n    return 0;\n}\n\n/*\n * Return if the joystick in question is currently attached to the system,\n *  \\return 0 if not plugged in, 1 if still present.\n */\nSDL_bool\nSDL_GameControllerGetAttached(SDL_GameController * gamecontroller)\n{\n    if (!gamecontroller)\n        return SDL_FALSE;\n\n    return SDL_JoystickGetAttached(gamecontroller->joystick);\n}\n\n\nconst char *\nSDL_GameControllerName(SDL_GameController * gamecontroller)\n{\n    if (!gamecontroller)\n        return NULL;\n\n    return (gamecontroller->mapping.name);\n}\n\n\n/*\n * Get the joystick for this controller\n */\nSDL_Joystick *SDL_GameControllerGetJoystick(SDL_GameController * gamecontroller)\n{\n    if (!gamecontroller)\n        return NULL;\n\n    return gamecontroller->joystick;\n}\n\n/**\n * Get the SDL joystick layer binding for this controller axis mapping\n */\nSDL_GameControllerButtonBind SDL_GameControllerGetBindForAxis(SDL_GameController * gamecontroller, SDL_GameControllerAxis axis)\n{\n    SDL_GameControllerButtonBind bind;\n    SDL_memset(&bind, 0x0, sizeof(bind));\n\n    if (!gamecontroller || axis == SDL_CONTROLLER_AXIS_INVALID)\n        return bind;\n\n    if (gamecontroller->mapping.axes[axis] >= 0) {\n        bind.bindType = SDL_CONTROLLER_BINDTYPE_AXIS;\n        bind.value.button = gamecontroller->mapping.axes[axis];\n    } else if (gamecontroller->mapping.buttonasaxis[axis] >= 0) {\n        bind.bindType = SDL_CONTROLLER_BINDTYPE_BUTTON;\n        bind.value.button = gamecontroller->mapping.buttonasaxis[axis];\n    }\n\n    return bind;\n}\n\n\n/**\n * Get the SDL joystick layer binding for this controller button mapping\n */\nSDL_GameControllerButtonBind SDL_GameControllerGetBindForButton(SDL_GameController * gamecontroller, SDL_GameControllerButton button)\n{\n    SDL_GameControllerButtonBind bind;\n    SDL_memset(&bind, 0x0, sizeof(bind));\n\n    if (!gamecontroller || button == SDL_CONTROLLER_BUTTON_INVALID)\n        return bind;\n\n    if (gamecontroller->mapping.buttons[button] >= 0) {\n        bind.bindType = SDL_CONTROLLER_BINDTYPE_BUTTON;\n        bind.value.button = gamecontroller->mapping.buttons[button];\n    } else if (gamecontroller->mapping.axesasbutton[button] >= 0) {\n        bind.bindType = SDL_CONTROLLER_BINDTYPE_AXIS;\n        bind.value.axis = gamecontroller->mapping.axesasbutton[button];\n    } else if (gamecontroller->mapping.hatasbutton[button].hat >= 0) {\n        bind.bindType = SDL_CONTROLLER_BINDTYPE_HAT;\n        bind.value.hat.hat = gamecontroller->mapping.hatasbutton[button].hat;\n        bind.value.hat.hat_mask = gamecontroller->mapping.hatasbutton[button].mask;\n    }\n\n    return bind;\n}\n\n\nvoid\nSDL_GameControllerClose(SDL_GameController * gamecontroller)\n{\n    SDL_GameController *gamecontrollerlist, *gamecontrollerlistprev;\n\n    if (!gamecontroller)\n        return;\n\n    /* First decrement ref count */\n    if (--gamecontroller->ref_count > 0) {\n        return;\n    }\n\n    SDL_JoystickClose(gamecontroller->joystick);\n\n    gamecontrollerlist = SDL_gamecontrollers;\n    gamecontrollerlistprev = NULL;\n    while (gamecontrollerlist) {\n        if (gamecontroller == gamecontrollerlist) {\n            if (gamecontrollerlistprev) {\n                /* unlink this entry */\n                gamecontrollerlistprev->next = gamecontrollerlist->next;\n            } else {\n                SDL_gamecontrollers = gamecontroller->next;\n            }\n\n            break;\n        }\n        gamecontrollerlistprev = gamecontrollerlist;\n        gamecontrollerlist = gamecontrollerlist->next;\n    }\n\n    SDL_free(gamecontroller);\n}\n\n\n/*\n * Quit the controller subsystem\n */\nvoid\nSDL_GameControllerQuit(void)\n{\n    ControllerMapping_t *pControllerMap;\n    while (SDL_gamecontrollers) {\n        SDL_gamecontrollers->ref_count = 1;\n        SDL_GameControllerClose(SDL_gamecontrollers);\n    }\n\n    while (s_pSupportedControllers) {\n        pControllerMap = s_pSupportedControllers;\n        s_pSupportedControllers = s_pSupportedControllers->next;\n        SDL_free(pControllerMap->name);\n        SDL_free(pControllerMap->mapping);\n        SDL_free(pControllerMap);\n    }\n\n    SDL_DelEventWatch(SDL_GameControllerEventWatcher, NULL);\n\n}\n\n/*\n * Event filter to transform joystick events into appropriate game controller ones\n */\nint\nSDL_PrivateGameControllerAxis(SDL_GameController * gamecontroller, SDL_GameControllerAxis axis, Sint16 value)\n{\n    int posted;\n\n    /* translate the event, if desired */\n    posted = 0;\n#if !SDL_EVENTS_DISABLED\n    if (SDL_GetEventState(SDL_CONTROLLERAXISMOTION) == SDL_ENABLE) {\n        SDL_Event event;\n        event.type = SDL_CONTROLLERAXISMOTION;\n        event.caxis.which = gamecontroller->joystick->instance_id;\n        event.caxis.axis = axis;\n        event.caxis.value = value;\n        posted = SDL_PushEvent(&event) == 1;\n    }\n#endif /* !SDL_EVENTS_DISABLED */\n    return (posted);\n}\n\n\n/*\n * Event filter to transform joystick events into appropriate game controller ones\n */\nint\nSDL_PrivateGameControllerButton(SDL_GameController * gamecontroller, SDL_GameControllerButton button, Uint8 state)\n{\n    int posted;\n#if !SDL_EVENTS_DISABLED\n    SDL_Event event;\n\n    if (button == SDL_CONTROLLER_BUTTON_INVALID)\n        return (0);\n\n    switch (state) {\n    case SDL_PRESSED:\n        event.type = SDL_CONTROLLERBUTTONDOWN;\n        break;\n    case SDL_RELEASED:\n        event.type = SDL_CONTROLLERBUTTONUP;\n        break;\n    default:\n        /* Invalid state -- bail */\n        return (0);\n    }\n#endif /* !SDL_EVENTS_DISABLED */\n\n    /* translate the event, if desired */\n    posted = 0;\n#if !SDL_EVENTS_DISABLED\n    if (SDL_GetEventState(event.type) == SDL_ENABLE) {\n        event.cbutton.which = gamecontroller->joystick->instance_id;\n        event.cbutton.button = button;\n        event.cbutton.state = state;\n        posted = SDL_PushEvent(&event) == 1;\n    }\n#endif /* !SDL_EVENTS_DISABLED */\n    return (posted);\n}\n\n/*\n * Turn off controller events\n */\nint\nSDL_GameControllerEventState(int state)\n{\n#if SDL_EVENTS_DISABLED\n    return SDL_IGNORE;\n#else\n    const Uint32 event_list[] = {\n        SDL_CONTROLLERAXISMOTION, SDL_CONTROLLERBUTTONDOWN, SDL_CONTROLLERBUTTONUP,\n        SDL_CONTROLLERDEVICEADDED, SDL_CONTROLLERDEVICEREMOVED, SDL_CONTROLLERDEVICEREMAPPED,\n    };\n    unsigned int i;\n\n    switch (state) {\n    case SDL_QUERY:\n        state = SDL_IGNORE;\n        for (i = 0; i < SDL_arraysize(event_list); ++i) {\n            state = SDL_EventState(event_list[i], SDL_QUERY);\n            if (state == SDL_ENABLE) {\n                break;\n            }\n        }\n        break;\n    default:\n        for (i = 0; i < SDL_arraysize(event_list); ++i) {\n            SDL_EventState(event_list[i], state);\n        }\n        break;\n    }\n    return (state);\n#endif /* SDL_EVENTS_DISABLED */\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../../SDL_internal.h\"\n\n/* Output audio to nowhere... */\n\n#include \"SDL_audio.h\"\n#include \"../SDL_audio_c.h\"\n#include \"SDL_dummyaudio.h\"\n\nstatic int\nDUMMYAUD_OpenDevice(_THIS, void *handle, const char *devname, int iscapture)\n{\n    return 0;                   /* always succeeds. */\n}\n\nstatic int\nDUMMYAUD_Init(SDL_AudioDriverImpl * impl)\n{\n    /* Set the function pointers */\n    impl->OpenDevice = DUMMYAUD_OpenDevice;\n    impl->OnlyHasDefaultOutputDevice = 1;\n    return 1;   /* this audio target is available. */\n}\n\nAudioBootStrap DUMMYAUD_bootstrap = {\n    \"dummy\", \"SDL dummy audio driver\", DUMMYAUD_Init, 1\n};\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../../SDL_internal.h\"\n\n#if SDL_AUDIO_DRIVER_DISK\n\n/* Output raw audio data to a file. */\n\n#if HAVE_STDIO_H\n#include <stdio.h>\n#endif\n\n#include \"SDL_rwops.h\"\n#include \"SDL_timer.h\"\n#include \"SDL_audio.h\"\n#include \"../SDL_audiomem.h\"\n#include \"../SDL_audio_c.h\"\n#include \"SDL_diskaudio.h\"\n\n/* environment variables and defaults. */\n#define DISKENVR_OUTFILE         \"SDL_DISKAUDIOFILE\"\n#define DISKDEFAULT_OUTFILE      \"sdlaudio.raw\"\n#define DISKENVR_WRITEDELAY      \"SDL_DISKAUDIODELAY\"\n#define DISKDEFAULT_WRITEDELAY   150\n\nstatic const char *\nDISKAUD_GetOutputFilename(const char *devname)\n{\n    if (devname == NULL) {\n        devname = SDL_getenv(DISKENVR_OUTFILE);\n        if (devname == NULL) {\n            devname = DISKDEFAULT_OUTFILE;\n        }\n    }\n    return devname;\n}\n\n/* This function waits until it is possible to write a full sound buffer */\nstatic void\nDISKAUD_WaitDevice(_THIS)\n{\n    SDL_Delay(this->hidden->write_delay);\n}\n\nstatic void\nDISKAUD_PlayDevice(_THIS)\n{\n    size_t written;\n\n    /* Write the audio data */\n    written = SDL_RWwrite(this->hidden->output,\n                          this->hidden->mixbuf, 1, this->hidden->mixlen);\n\n    /* If we couldn't write, assume fatal error for now */\n    if (written != this->hidden->mixlen) {\n        SDL_OpenedAudioDeviceDisconnected(this);\n    }\n#ifdef DEBUG_AUDIO\n    fprintf(stderr, \"Wrote %d bytes of audio data\\n\", written);\n#endif\n}\n\nstatic Uint8 *\nDISKAUD_GetDeviceBuf(_THIS)\n{\n    return (this->hidden->mixbuf);\n}\n\nstatic void\nDISKAUD_CloseDevice(_THIS)\n{\n    if (this->hidden != NULL) {\n        SDL_FreeAudioMem(this->hidden->mixbuf);\n        this->hidden->mixbuf = NULL;\n        if (this->hidden->output != NULL) {\n            SDL_RWclose(this->hidden->output);\n            this->hidden->output = NULL;\n        }\n        SDL_free(this->hidden);\n        this->hidden = NULL;\n    }\n}\n\nstatic int\nDISKAUD_OpenDevice(_THIS, void *handle, const char *devname, int iscapture)\n{\n    const char *envr = SDL_getenv(DISKENVR_WRITEDELAY);\n    const char *fname = DISKAUD_GetOutputFilename(devname);\n\n    this->hidden = (struct SDL_PrivateAudioData *)\n        SDL_malloc(sizeof(*this->hidden));\n    if (this->hidden == NULL) {\n        return SDL_OutOfMemory();\n    }\n    SDL_memset(this->hidden, 0, sizeof(*this->hidden));\n\n    this->hidden->mixlen = this->spec.size;\n    this->hidden->write_delay =\n        (envr) ? SDL_atoi(envr) : DISKDEFAULT_WRITEDELAY;\n\n    /* Open the audio device */\n    this->hidden->output = SDL_RWFromFile(fname, \"wb\");\n    if (this->hidden->output == NULL) {\n        DISKAUD_CloseDevice(this);\n        return -1;\n    }\n\n    /* Allocate mixing buffer */\n    this->hidden->mixbuf = (Uint8 *) SDL_AllocAudioMem(this->hidden->mixlen);\n    if (this->hidden->mixbuf == NULL) {\n        DISKAUD_CloseDevice(this);\n        return -1;\n    }\n    SDL_memset(this->hidden->mixbuf, this->spec.silence, this->spec.size);\n\n#if HAVE_STDIO_H\n    fprintf(stderr,\n            \"WARNING: You are using the SDL disk writer audio driver!\\n\"\n            \" Writing to file [%s].\\n\", fname);\n#endif\n\n    /* We're ready to rock and roll. :-) */\n    return 0;\n}\n\nstatic int\nDISKAUD_Init(SDL_AudioDriverImpl * impl)\n{\n    /* Set the function pointers */\n    impl->OpenDevice = DISKAUD_OpenDevice;\n    impl->WaitDevice = DISKAUD_WaitDevice;\n    impl->PlayDevice = DISKAUD_PlayDevice;\n    impl->GetDeviceBuf = DISKAUD_GetDeviceBuf;\n    impl->CloseDevice = DISKAUD_CloseDevice;\n\n    impl->AllowsArbitraryDeviceNames = 1;\n\n    return 1;   /* this audio target is available. */\n}\n\nAudioBootStrap DISKAUD_bootstrap = {\n    \"disk\", \"direct-to-disk audio\", DISKAUD_Init, 1\n};\n\n#endif /* SDL_AUDIO_DRIVER_DISK */\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../../SDL_internal.h\"\n\n#if SDL_VIDEO_DRIVER_DUMMY\n\n/* Being a null driver, there's no event stream. We just define stubs for\n   most of the API. */\n\n#include \"../../events/SDL_events_c.h\"\n\n#include \"SDL_nullvideo.h\"\n#include \"SDL_nullevents_c.h\"\n\nvoid\nDUMMY_PumpEvents(_THIS)\n{\n    /* do nothing. */\n}\n\n#endif /* SDL_VIDEO_DRIVER_DUMMY */\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../../SDL_internal.h\"\n\n#if SDL_VIDEO_DRIVER_DUMMY\n\n#include \"../SDL_sysvideo.h\"\n#include \"SDL_nullframebuffer_c.h\"\n\n\n#define DUMMY_SURFACE   \"_SDL_DummySurface\"\n\nint SDL_DUMMY_CreateWindowFramebuffer(_THIS, SDL_Window * window, Uint32 * format, void ** pixels, int *pitch)\n{\n    SDL_Surface *surface;\n    const Uint32 surface_format = SDL_PIXELFORMAT_RGB888;\n    int w, h;\n    int bpp;\n    Uint32 Rmask, Gmask, Bmask, Amask;\n\n    /* Free the old framebuffer surface */\n    surface = (SDL_Surface *) SDL_GetWindowData(window, DUMMY_SURFACE);\n    SDL_FreeSurface(surface);\n\n    /* Create a new one */\n    SDL_PixelFormatEnumToMasks(surface_format, &bpp, &Rmask, &Gmask, &Bmask, &Amask);\n    SDL_GetWindowSize(window, &w, &h);\n    surface = SDL_CreateRGBSurface(0, w, h, bpp, Rmask, Gmask, Bmask, Amask);\n    if (!surface) {\n        return -1;\n    }\n\n    /* Save the info and return! */\n    SDL_SetWindowData(window, DUMMY_SURFACE, surface);\n    *format = surface_format;\n    *pixels = surface->pixels;\n    *pitch = surface->pitch;\n    return 0;\n}\n\nint SDL_DUMMY_UpdateWindowFramebuffer(_THIS, SDL_Window * window, const SDL_Rect * rects, int numrects)\n{\n    static int frame_number;\n    SDL_Surface *surface;\n\n    surface = (SDL_Surface *) SDL_GetWindowData(window, DUMMY_SURFACE);\n    if (!surface) {\n        return SDL_SetError(\"Couldn't find dummy surface for window\");\n    }\n\n    /* Send the data to the display */\n    if (SDL_getenv(\"SDL_VIDEO_DUMMY_SAVE_FRAMES\")) {\n        char file[128];\n        SDL_snprintf(file, sizeof(file), \"SDL_window%d-%8.8d.bmp\",\n                     SDL_GetWindowID(window), ++frame_number);\n        SDL_SaveBMP(surface, file);\n    }\n    return 0;\n}\n\nvoid SDL_DUMMY_DestroyWindowFramebuffer(_THIS, SDL_Window * window)\n{\n    SDL_Surface *surface;\n\n    surface = (SDL_Surface *) SDL_SetWindowData(window, DUMMY_SURFACE, NULL);\n    SDL_FreeSurface(surface);\n}\n\n#endif /* SDL_VIDEO_DRIVER_DUMMY */\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../../SDL_internal.h\"\n\n#if SDL_AUDIO_DRIVER_EMSCRIPTEN\n\n#include \"SDL_audio.h\"\n#include \"SDL_log.h\"\n#include \"../SDL_audio_c.h\"\n#include \"SDL_emscriptenaudio.h\"\n\n#include <emscripten/emscripten.h>\n\nstatic int\ncopyData(_THIS)\n{\n    int byte_len;\n\n    if (this->hidden->write_off + this->convert.len_cvt > this->hidden->mixlen) {\n        if (this->hidden->write_off > this->hidden->read_off) {\n            SDL_memmove(this->hidden->mixbuf,\n                        this->hidden->mixbuf + this->hidden->read_off,\n                        this->hidden->mixlen - this->hidden->read_off);\n            this->hidden->write_off = this->hidden->write_off - this->hidden->read_off;\n        } else {\n            this->hidden->write_off = 0;\n        }\n        this->hidden->read_off = 0;\n    }\n\n    SDL_memcpy(this->hidden->mixbuf + this->hidden->write_off,\n               this->convert.buf,\n               this->convert.len_cvt);\n    this->hidden->write_off += this->convert.len_cvt;\n    byte_len = this->hidden->write_off - this->hidden->read_off;\n\n    return byte_len;\n}\n\nstatic void\nHandleAudioProcess(_THIS)\n{\n    Uint8 *buf = NULL;\n    int byte_len = 0;\n    int bytes = SDL_AUDIO_BITSIZE(this->spec.format) / 8;\n    int bytes_in = SDL_AUDIO_BITSIZE(this->convert.src_format) / 8;\n\n    /* Only do soemthing if audio is enabled */\n    if (!this->enabled)\n        return;\n\n    if (this->paused)\n        return;\n\n    if (this->convert.needed) {\n        if (this->hidden->conv_in_len != 0) {\n            this->convert.len = this->hidden->conv_in_len * bytes_in * this->spec.channels;\n        }\n\n        (*this->spec.callback) (this->spec.userdata,\n                                 this->convert.buf,\n                                 this->convert.len);\n        SDL_ConvertAudio(&this->convert);\n        buf = this->convert.buf;\n        byte_len = this->convert.len_cvt;\n\n        /* size mismatch*/\n        if (byte_len != this->spec.size) {\n            if (!this->hidden->mixbuf) {\n                this->hidden->mixlen = this->spec.size > byte_len ? this->spec.size * 2 : byte_len * 2;\n                this->hidden->mixbuf = SDL_malloc(this->hidden->mixlen);\n            }\n\n            /* copy existing data */\n            byte_len = copyData(this);\n\n            /* read more data*/\n            while (byte_len < this->spec.size) {\n                (*this->spec.callback) (this->spec.userdata,\n                                         this->convert.buf,\n                                         this->convert.len);\n                SDL_ConvertAudio(&this->convert);\n                byte_len = copyData(this);\n            }\n\n            byte_len = this->spec.size;\n            buf = this->hidden->mixbuf + this->hidden->read_off;\n            this->hidden->read_off += byte_len;\n        }\n\n    } else {\n        if (!this->hidden->mixbuf) {\n            this->hidden->mixlen = this->spec.size;\n            this->hidden->mixbuf = SDL_malloc(this->hidden->mixlen);\n        }\n        (*this->spec.callback) (this->spec.userdata,\n                                 this->hidden->mixbuf,\n                                 this->hidden->mixlen);\n        buf = this->hidden->mixbuf;\n        byte_len = this->hidden->mixlen;\n    }\n\n    if (buf) {\n        EM_ASM_ARGS({\n            var numChannels = SDL2.audio.currentOutputBuffer['numberOfChannels'];\n            for (var c = 0; c < numChannels; ++c) {\n                var channelData = SDL2.audio.currentOutputBuffer['getChannelData'](c);\n                if (channelData.length != $1) {\n                    throw 'Web Audio output buffer length mismatch! Destination size: ' + channelData.length + ' samples vs expected ' + $1 + ' samples!';\n                }\n\n                for (var j = 0; j < $1; ++j) {\n                    channelData[j] = HEAPF32[$0 + ((j*numChannels + c) << 2) >> 2];\n                }\n            }\n        }, buf, byte_len / bytes / this->spec.channels);\n    }\n}\n\nstatic void\nEmscripten_CloseDevice(_THIS)\n{\n    if (this->hidden != NULL) {\n        if (this->hidden->mixbuf != NULL) {\n            /* Clean up the audio buffer */\n            SDL_free(this->hidden->mixbuf);\n            this->hidden->mixbuf = NULL;\n        }\n\n        SDL_free(this->hidden);\n        this->hidden = NULL;\n    }\n}\n\nstatic int\nEmscripten_OpenDevice(_THIS, void *handle, const char *devname, int iscapture)\n{\n    SDL_bool valid_format = SDL_FALSE;\n    SDL_AudioFormat test_format = SDL_FirstAudioFormat(this->spec.format);\n    int i;\n    float f;\n    int result;\n\n    while ((!valid_format) && (test_format)) {\n        switch (test_format) {\n        case AUDIO_F32: /* web audio only supports floats */\n            this->spec.format = test_format;\n\n            valid_format = SDL_TRUE;\n            break;\n        }\n        test_format = SDL_NextAudioFormat();\n    }\n\n    if (!valid_format) {\n        /* Didn't find a compatible format :( */\n        return SDL_SetError(\"No compatible audio format!\");\n    }\n\n    /* Initialize all variables that we clean on shutdown */\n    this->hidden = (struct SDL_PrivateAudioData *)\n        SDL_malloc((sizeof *this->hidden));\n    if (this->hidden == NULL) {\n        return SDL_OutOfMemory();\n    }\n    SDL_memset(this->hidden, 0, (sizeof *this->hidden));\n\n    /* based on parts of library_sdl.js */\n\n    /* create context (TODO: this puts stuff in the global namespace...)*/\n    result = EM_ASM_INT_V({\n        if(typeof(SDL2) === 'undefined')\n            SDL2 = {};\n\n        if(typeof(SDL2.audio) === 'undefined')\n            SDL2.audio = {};\n\n        if (!SDL2.audioContext) {\n            if (typeof(AudioContext) !== 'undefined') {\n                SDL2.audioContext = new AudioContext();\n            } else if (typeof(webkitAudioContext) !== 'undefined') {\n                SDL2.audioContext = new webkitAudioContext();\n            } else {\n                return -1;\n            }\n        }\n        return 0;\n    });\n    if (result < 0) {\n        return SDL_SetError(\"Web Audio API is not available!\");\n    }\n\n    /* limit to native freq */\n    int sampleRate = EM_ASM_INT_V({\n        return SDL2.audioContext['sampleRate'];\n    });\n\n    if(this->spec.freq != sampleRate) {\n        for (i = this->spec.samples; i > 0; i--) {\n            f = (float)i / (float)sampleRate * (float)this->spec.freq;\n            if (SDL_floor(f) == f) {\n                this->hidden->conv_in_len = SDL_floor(f);\n                break;\n            }\n        }\n\n        this->spec.freq = sampleRate;\n    }\n\n    SDL_CalculateAudioSpec(&this->spec);\n\n    /* setup a ScriptProcessorNode */\n    EM_ASM_ARGS({\n        SDL2.audio.scriptProcessorNode = SDL2.audioContext['createScriptProcessor']($1, 0, $0);\n        SDL2.audio.scriptProcessorNode['onaudioprocess'] = function (e) {\n            SDL2.audio.currentOutputBuffer = e['outputBuffer'];\n            Runtime.dynCall('vi', $2, [$3]);\n        };\n        SDL2.audio.scriptProcessorNode['connect'](SDL2.audioContext['destination']);\n    }, this->spec.channels, this->spec.samples, HandleAudioProcess, this);\n    return 0;\n}\n\nstatic int\nEmscripten_Init(SDL_AudioDriverImpl * impl)\n{\n    /* Set the function pointers */\n    impl->OpenDevice = Emscripten_OpenDevice;\n    impl->CloseDevice = Emscripten_CloseDevice;\n\n    /* only one output */\n    impl->OnlyHasDefaultOutputDevice = 1;\n\n    /* no threads here */\n    impl->SkipMixerLock = 1;\n    impl->ProvidesOwnCallbackThread = 1;\n\n    /* check availability */\n    int available = EM_ASM_INT_V({\n        if (typeof(AudioContext) !== 'undefined') {\n            return 1;\n        } else if (typeof(webkitAudioContext) !== 'undefined') {\n            return 1;\n        }\n        return 0;\n    });\n\n    return available;\n}\n\nAudioBootStrap EmscriptenAudio_bootstrap = {\n    \"emscripten\", \"SDL emscripten audio driver\", Emscripten_Init, 0\n};\n\n#endif /* SDL_AUDIO_DRIVER_EMSCRIPTEN */\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n\n\n#include \"../../SDL_internal.h\"\n\n#if SDL_VIDEO_DRIVER_EMSCRIPTEN\n\n#include <emscripten/html5.h>\n\n#include \"../../events/SDL_events_c.h\"\n#include \"../../events/SDL_keyboard_c.h\"\n#include \"../../events/SDL_touch_c.h\"\n\n#include \"SDL_emscriptenevents.h\"\n#include \"SDL_emscriptenvideo.h\"\n\n#include \"SDL_hints.h\"\n\n#define FULLSCREEN_MASK ( SDL_WINDOW_FULLSCREEN_DESKTOP | SDL_WINDOW_FULLSCREEN )\n\n/*\n.which to scancode\nhttps://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Constants\n*/\nstatic const SDL_Scancode emscripten_scancode_table[] = {\n    /*  0 */    SDL_SCANCODE_UNKNOWN,\n    /*  1 */    SDL_SCANCODE_UNKNOWN,\n    /*  2 */    SDL_SCANCODE_UNKNOWN,\n    /*  3 */    SDL_SCANCODE_CANCEL,\n    /*  4 */    SDL_SCANCODE_UNKNOWN,\n    /*  5 */    SDL_SCANCODE_UNKNOWN,\n    /*  6 */    SDL_SCANCODE_HELP,\n    /*  7 */    SDL_SCANCODE_UNKNOWN,\n    /*  8 */    SDL_SCANCODE_BACKSPACE,\n    /*  9 */    SDL_SCANCODE_TAB,\n    /*  10 */   SDL_SCANCODE_UNKNOWN,\n    /*  11 */   SDL_SCANCODE_UNKNOWN,\n    /*  12 */   SDL_SCANCODE_UNKNOWN,\n    /*  13 */   SDL_SCANCODE_RETURN,\n    /*  14 */   SDL_SCANCODE_UNKNOWN,\n    /*  15 */   SDL_SCANCODE_UNKNOWN,\n    /*  16 */   SDL_SCANCODE_LSHIFT,\n    /*  17 */   SDL_SCANCODE_LCTRL,\n    /*  18 */   SDL_SCANCODE_LALT,\n    /*  19 */   SDL_SCANCODE_PAUSE,\n    /*  20 */   SDL_SCANCODE_CAPSLOCK,\n    /*  21 */   SDL_SCANCODE_UNKNOWN,\n    /*  22 */   SDL_SCANCODE_UNKNOWN,\n    /*  23 */   SDL_SCANCODE_UNKNOWN,\n    /*  24 */   SDL_SCANCODE_UNKNOWN,\n    /*  25 */   SDL_SCANCODE_UNKNOWN,\n    /*  26 */   SDL_SCANCODE_UNKNOWN,\n    /*  27 */   SDL_SCANCODE_ESCAPE,\n    /*  28 */   SDL_SCANCODE_UNKNOWN,\n    /*  29 */   SDL_SCANCODE_UNKNOWN,\n    /*  30 */   SDL_SCANCODE_UNKNOWN,\n    /*  31 */   SDL_SCANCODE_UNKNOWN,\n    /*  32 */   SDL_SCANCODE_SPACE,\n    /*  33 */   SDL_SCANCODE_PAGEUP,\n    /*  34 */   SDL_SCANCODE_PAGEDOWN,\n    /*  35 */   SDL_SCANCODE_END,\n    /*  36 */   SDL_SCANCODE_HOME,\n    /*  37 */   SDL_SCANCODE_LEFT,\n    /*  38 */   SDL_SCANCODE_UP,\n    /*  39 */   SDL_SCANCODE_RIGHT,\n    /*  40 */   SDL_SCANCODE_DOWN,\n    /*  41 */   SDL_SCANCODE_UNKNOWN,\n    /*  42 */   SDL_SCANCODE_UNKNOWN,\n    /*  43 */   SDL_SCANCODE_UNKNOWN,\n    /*  44 */   SDL_SCANCODE_UNKNOWN,\n    /*  45 */   SDL_SCANCODE_INSERT,\n    /*  46 */   SDL_SCANCODE_DELETE,\n    /*  47 */   SDL_SCANCODE_UNKNOWN,\n    /*  48 */   SDL_SCANCODE_0,\n    /*  49 */   SDL_SCANCODE_1,\n    /*  50 */   SDL_SCANCODE_2,\n    /*  51 */   SDL_SCANCODE_3,\n    /*  52 */   SDL_SCANCODE_4,\n    /*  53 */   SDL_SCANCODE_5,\n    /*  54 */   SDL_SCANCODE_6,\n    /*  55 */   SDL_SCANCODE_7,\n    /*  56 */   SDL_SCANCODE_8,\n    /*  57 */   SDL_SCANCODE_9,\n    /*  58 */   SDL_SCANCODE_UNKNOWN,\n    /*  59 */   SDL_SCANCODE_SEMICOLON,\n    /*  60 */   SDL_SCANCODE_UNKNOWN,\n    /*  61 */   SDL_SCANCODE_EQUALS,\n    /*  62 */   SDL_SCANCODE_UNKNOWN,\n    /*  63 */   SDL_SCANCODE_UNKNOWN,\n    /*  64 */   SDL_SCANCODE_UNKNOWN,\n    /*  65 */   SDL_SCANCODE_A,\n    /*  66 */   SDL_SCANCODE_B,\n    /*  67 */   SDL_SCANCODE_C,\n    /*  68 */   SDL_SCANCODE_D,\n    /*  69 */   SDL_SCANCODE_E,\n    /*  70 */   SDL_SCANCODE_F,\n    /*  71 */   SDL_SCANCODE_G,\n    /*  72 */   SDL_SCANCODE_H,\n    /*  73 */   SDL_SCANCODE_I,\n    /*  74 */   SDL_SCANCODE_J,\n    /*  75 */   SDL_SCANCODE_K,\n    /*  76 */   SDL_SCANCODE_L,\n    /*  77 */   SDL_SCANCODE_M,\n    /*  78 */   SDL_SCANCODE_N,\n    /*  79 */   SDL_SCANCODE_O,\n    /*  80 */   SDL_SCANCODE_P,\n    /*  81 */   SDL_SCANCODE_Q,\n    /*  82 */   SDL_SCANCODE_R,\n    /*  83 */   SDL_SCANCODE_S,\n    /*  84 */   SDL_SCANCODE_T,\n    /*  85 */   SDL_SCANCODE_U,\n    /*  86 */   SDL_SCANCODE_V,\n    /*  87 */   SDL_SCANCODE_W,\n    /*  88 */   SDL_SCANCODE_X,\n    /*  89 */   SDL_SCANCODE_Y,\n    /*  90 */   SDL_SCANCODE_Z,\n    /*  91 */   SDL_SCANCODE_LGUI,\n    /*  92 */   SDL_SCANCODE_UNKNOWN,\n    /*  93 */   SDL_SCANCODE_APPLICATION,\n    /*  94 */   SDL_SCANCODE_UNKNOWN,\n    /*  95 */   SDL_SCANCODE_UNKNOWN,\n    /*  96 */   SDL_SCANCODE_KP_0,\n    /*  97 */   SDL_SCANCODE_KP_1,\n    /*  98 */   SDL_SCANCODE_KP_2,\n    /*  99 */   SDL_SCANCODE_KP_3,\n    /* 100 */   SDL_SCANCODE_KP_4,\n    /* 101 */   SDL_SCANCODE_KP_5,\n    /* 102 */   SDL_SCANCODE_KP_6,\n    /* 103 */   SDL_SCANCODE_KP_7,\n    /* 104 */   SDL_SCANCODE_KP_8,\n    /* 105 */   SDL_SCANCODE_KP_9,\n    /* 106 */   SDL_SCANCODE_KP_MULTIPLY,\n    /* 107 */   SDL_SCANCODE_KP_PLUS,\n    /* 108 */   SDL_SCANCODE_UNKNOWN,\n    /* 109 */   SDL_SCANCODE_KP_MINUS,\n    /* 110 */   SDL_SCANCODE_KP_PERIOD,\n    /* 111 */   SDL_SCANCODE_KP_DIVIDE,\n    /* 112 */   SDL_SCANCODE_F1,\n    /* 113 */   SDL_SCANCODE_F2,\n    /* 114 */   SDL_SCANCODE_F3,\n    /* 115 */   SDL_SCANCODE_F4,\n    /* 116 */   SDL_SCANCODE_F5,\n    /* 117 */   SDL_SCANCODE_F6,\n    /* 118 */   SDL_SCANCODE_F7,\n    /* 119 */   SDL_SCANCODE_F8,\n    /* 120 */   SDL_SCANCODE_F9,\n    /* 121 */   SDL_SCANCODE_F10,\n    /* 122 */   SDL_SCANCODE_F11,\n    /* 123 */   SDL_SCANCODE_F12,\n    /* 124 */   SDL_SCANCODE_F13,\n    /* 125 */   SDL_SCANCODE_F14,\n    /* 126 */   SDL_SCANCODE_F15,\n    /* 127 */   SDL_SCANCODE_F16,\n    /* 128 */   SDL_SCANCODE_F17,\n    /* 129 */   SDL_SCANCODE_F18,\n    /* 130 */   SDL_SCANCODE_F19,\n    /* 131 */   SDL_SCANCODE_F20,\n    /* 132 */   SDL_SCANCODE_F21,\n    /* 133 */   SDL_SCANCODE_F22,\n    /* 134 */   SDL_SCANCODE_F23,\n    /* 135 */   SDL_SCANCODE_F24,\n    /* 136 */   SDL_SCANCODE_UNKNOWN,\n    /* 137 */   SDL_SCANCODE_UNKNOWN,\n    /* 138 */   SDL_SCANCODE_UNKNOWN,\n    /* 139 */   SDL_SCANCODE_UNKNOWN,\n    /* 140 */   SDL_SCANCODE_UNKNOWN,\n    /* 141 */   SDL_SCANCODE_UNKNOWN,\n    /* 142 */   SDL_SCANCODE_UNKNOWN,\n    /* 143 */   SDL_SCANCODE_UNKNOWN,\n    /* 144 */   SDL_SCANCODE_NUMLOCKCLEAR,\n    /* 145 */   SDL_SCANCODE_SCROLLLOCK,\n    /* 146 */   SDL_SCANCODE_UNKNOWN,\n    /* 147 */   SDL_SCANCODE_UNKNOWN,\n    /* 148 */   SDL_SCANCODE_UNKNOWN,\n    /* 149 */   SDL_SCANCODE_UNKNOWN,\n    /* 150 */   SDL_SCANCODE_UNKNOWN,\n    /* 151 */   SDL_SCANCODE_UNKNOWN,\n    /* 152 */   SDL_SCANCODE_UNKNOWN,\n    /* 153 */   SDL_SCANCODE_UNKNOWN,\n    /* 154 */   SDL_SCANCODE_UNKNOWN,\n    /* 155 */   SDL_SCANCODE_UNKNOWN,\n    /* 156 */   SDL_SCANCODE_UNKNOWN,\n    /* 157 */   SDL_SCANCODE_UNKNOWN,\n    /* 158 */   SDL_SCANCODE_UNKNOWN,\n    /* 159 */   SDL_SCANCODE_UNKNOWN,\n    /* 160 */   SDL_SCANCODE_UNKNOWN,\n    /* 161 */   SDL_SCANCODE_UNKNOWN,\n    /* 162 */   SDL_SCANCODE_UNKNOWN,\n    /* 163 */   SDL_SCANCODE_UNKNOWN,\n    /* 164 */   SDL_SCANCODE_UNKNOWN,\n    /* 165 */   SDL_SCANCODE_UNKNOWN,\n    /* 166 */   SDL_SCANCODE_UNKNOWN,\n    /* 167 */   SDL_SCANCODE_UNKNOWN,\n    /* 168 */   SDL_SCANCODE_UNKNOWN,\n    /* 169 */   SDL_SCANCODE_UNKNOWN,\n    /* 170 */   SDL_SCANCODE_UNKNOWN,\n    /* 171 */   SDL_SCANCODE_UNKNOWN,\n    /* 172 */   SDL_SCANCODE_UNKNOWN,\n    /* 173 */   SDL_SCANCODE_MINUS, /*FX*/\n    /* 174 */   SDL_SCANCODE_UNKNOWN,\n    /* 175 */   SDL_SCANCODE_UNKNOWN,\n    /* 176 */   SDL_SCANCODE_UNKNOWN,\n    /* 177 */   SDL_SCANCODE_UNKNOWN,\n    /* 178 */   SDL_SCANCODE_UNKNOWN,\n    /* 179 */   SDL_SCANCODE_UNKNOWN,\n    /* 180 */   SDL_SCANCODE_UNKNOWN,\n    /* 181 */   SDL_SCANCODE_UNKNOWN,\n    /* 182 */   SDL_SCANCODE_UNKNOWN,\n    /* 183 */   SDL_SCANCODE_UNKNOWN,\n    /* 184 */   SDL_SCANCODE_UNKNOWN,\n    /* 185 */   SDL_SCANCODE_UNKNOWN,\n    /* 186 */   SDL_SCANCODE_SEMICOLON, /*IE, Chrome, D3E legacy*/\n    /* 187 */   SDL_SCANCODE_EQUALS, /*IE, Chrome, D3E legacy*/\n    /* 188 */   SDL_SCANCODE_COMMA,\n    /* 189 */   SDL_SCANCODE_MINUS, /*IE, Chrome, D3E legacy*/\n    /* 190 */   SDL_SCANCODE_PERIOD,\n    /* 191 */   SDL_SCANCODE_SLASH,\n    /* 192 */   SDL_SCANCODE_GRAVE, /*FX, D3E legacy (SDL_SCANCODE_APOSTROPHE in IE/Chrome)*/\n    /* 193 */   SDL_SCANCODE_UNKNOWN,\n    /* 194 */   SDL_SCANCODE_UNKNOWN,\n    /* 195 */   SDL_SCANCODE_UNKNOWN,\n    /* 196 */   SDL_SCANCODE_UNKNOWN,\n    /* 197 */   SDL_SCANCODE_UNKNOWN,\n    /* 198 */   SDL_SCANCODE_UNKNOWN,\n    /* 199 */   SDL_SCANCODE_UNKNOWN,\n    /* 200 */   SDL_SCANCODE_UNKNOWN,\n    /* 201 */   SDL_SCANCODE_UNKNOWN,\n    /* 202 */   SDL_SCANCODE_UNKNOWN,\n    /* 203 */   SDL_SCANCODE_UNKNOWN,\n    /* 204 */   SDL_SCANCODE_UNKNOWN,\n    /* 205 */   SDL_SCANCODE_UNKNOWN,\n    /* 206 */   SDL_SCANCODE_UNKNOWN,\n    /* 207 */   SDL_SCANCODE_UNKNOWN,\n    /* 208 */   SDL_SCANCODE_UNKNOWN,\n    /* 209 */   SDL_SCANCODE_UNKNOWN,\n    /* 210 */   SDL_SCANCODE_UNKNOWN,\n    /* 211 */   SDL_SCANCODE_UNKNOWN,\n    /* 212 */   SDL_SCANCODE_UNKNOWN,\n    /* 213 */   SDL_SCANCODE_UNKNOWN,\n    /* 214 */   SDL_SCANCODE_UNKNOWN,\n    /* 215 */   SDL_SCANCODE_UNKNOWN,\n    /* 216 */   SDL_SCANCODE_UNKNOWN,\n    /* 217 */   SDL_SCANCODE_UNKNOWN,\n    /* 218 */   SDL_SCANCODE_UNKNOWN,\n    /* 219 */   SDL_SCANCODE_LEFTBRACKET,\n    /* 220 */   SDL_SCANCODE_BACKSLASH,\n    /* 221 */   SDL_SCANCODE_RIGHTBRACKET,\n    /* 222 */   SDL_SCANCODE_APOSTROPHE, /*FX, D3E legacy*/\n};\n\n\n/* \"borrowed\" from SDL_windowsevents.c */\nint\nEmscripten_ConvertUTF32toUTF8(Uint32 codepoint, char * text)\n{\n    if (codepoint <= 0x7F) {\n        text[0] = (char) codepoint;\n        text[1] = '\\0';\n    } else if (codepoint <= 0x7FF) {\n        text[0] = 0xC0 | (char) ((codepoint >> 6) & 0x1F);\n        text[1] = 0x80 | (char) (codepoint & 0x3F);\n        text[2] = '\\0';\n    } else if (codepoint <= 0xFFFF) {\n        text[0] = 0xE0 | (char) ((codepoint >> 12) & 0x0F);\n        text[1] = 0x80 | (char) ((codepoint >> 6) & 0x3F);\n        text[2] = 0x80 | (char) (codepoint & 0x3F);\n        text[3] = '\\0';\n    } else if (codepoint <= 0x10FFFF) {\n        text[0] = 0xF0 | (char) ((codepoint >> 18) & 0x0F);\n        text[1] = 0x80 | (char) ((codepoint >> 12) & 0x3F);\n        text[2] = 0x80 | (char) ((codepoint >> 6) & 0x3F);\n        text[3] = 0x80 | (char) (codepoint & 0x3F);\n        text[4] = '\\0';\n    } else {\n        return SDL_FALSE;\n    }\n    return SDL_TRUE;\n}\n\nEM_BOOL\nEmscripten_HandleMouseMove(int eventType, const EmscriptenMouseEvent *mouseEvent, void *userData)\n{\n    SDL_WindowData *window_data = userData;\n    int mx, my;\n    static double residualx = 0, residualy = 0;\n    EmscriptenPointerlockChangeEvent pointerlock_status;\n\n    /* rescale (in case canvas is being scaled)*/\n    double client_w, client_h, xscale, yscale;\n    emscripten_get_element_css_size(NULL, &client_w, &client_h);\n    xscale = window_data->window->w / client_w;\n    yscale = window_data->window->h / client_h;\n\n    /* check for pointer lock */\n    int isPointerLockSupported = emscripten_get_pointerlock_status(&pointerlock_status);\n    int isPointerLocked = isPointerLockSupported == EMSCRIPTEN_RESULT_SUCCESS  ? pointerlock_status.isActive : SDL_FALSE;\n\n    if (isPointerLocked) {\n        residualx += mouseEvent->movementX * xscale;\n        residualy += mouseEvent->movementY * yscale;\n        /* Let slow sub-pixel motion accumulate. Don't lose it. */\n        mx = residualx;\n        residualx -= mx;\n        my = residualy;\n        residualy -= my;\n    } else {\n        mx = mouseEvent->canvasX * xscale;\n        my = mouseEvent->canvasY * yscale;\n    }\n\n    SDL_SendMouseMotion(window_data->window, 0, isPointerLocked, mx, my);\n    return 0;\n}\n\nEM_BOOL\nEmscripten_HandleMouseButton(int eventType, const EmscriptenMouseEvent *mouseEvent, void *userData)\n{\n    SDL_WindowData *window_data = userData;\n    uint32_t sdl_button;\n    switch (mouseEvent->button) {\n        case 0:\n            sdl_button = SDL_BUTTON_LEFT;\n            break;\n        case 1:\n            sdl_button = SDL_BUTTON_MIDDLE;\n            break;\n        case 2:\n            sdl_button = SDL_BUTTON_RIGHT;\n            break;\n        default:\n            return 0;\n    }\n    SDL_SendMouseButton(window_data->window, 0, eventType == EMSCRIPTEN_EVENT_MOUSEDOWN ? SDL_PRESSED : SDL_RELEASED, sdl_button);\n    return 1;\n}\n\nEM_BOOL\nEmscripten_HandleMouseFocus(int eventType, const EmscriptenMouseEvent *mouseEvent, void *userData)\n{\n    SDL_WindowData *window_data = userData;\n\n    int mx = mouseEvent->canvasX, my = mouseEvent->canvasY;\n    EmscriptenPointerlockChangeEvent pointerlock_status;\n\n    /* check for pointer lock */\n    int isPointerLockSupported = emscripten_get_pointerlock_status(&pointerlock_status);\n    int isPointerLocked = isPointerLockSupported == EMSCRIPTEN_RESULT_SUCCESS  ? pointerlock_status.isActive : SDL_FALSE;\n\n    if (!isPointerLocked) {\n        /* rescale (in case canvas is being scaled)*/\n        double client_w, client_h;\n        emscripten_get_element_css_size(NULL, &client_w, &client_h);\n\n        mx = mx * (window_data->window->w / client_w);\n        my = my * (window_data->window->h / client_h);\n        SDL_SendMouseMotion(window_data->window, 0, isPointerLocked, mx, my);\n    }\n\n    SDL_SetMouseFocus(eventType == EMSCRIPTEN_EVENT_MOUSEENTER ? window_data->window : NULL);\n    return 1;\n}\n\nEM_BOOL\nEmscripten_HandleWheel(int eventType, const EmscriptenWheelEvent *wheelEvent, void *userData)\n{\n    SDL_WindowData *window_data = userData;\n    SDL_SendMouseWheel(window_data->window, 0, wheelEvent->deltaX, -wheelEvent->deltaY, SDL_MOUSEWHEEL_NORMAL);\n    return 1;\n}\n\nEM_BOOL\nEmscripten_HandleFocus(int eventType, const EmscriptenFocusEvent *wheelEvent, void *userData)\n{\n    SDL_WindowData *window_data = userData;\n    /* If the user switches away while keys are pressed (such as\n     * via Alt+Tab), key release events won't be received. */\n    if (eventType == EMSCRIPTEN_EVENT_BLUR) {\n        SDL_ResetKeyboard();\n    }\n    SDL_SendWindowEvent(window_data->window, eventType == EMSCRIPTEN_EVENT_FOCUS ? SDL_WINDOWEVENT_FOCUS_GAINED : SDL_WINDOWEVENT_FOCUS_LOST, 0, 0);\n    return 1;\n}\n\nEM_BOOL\nEmscripten_HandleTouch(int eventType, const EmscriptenTouchEvent *touchEvent, void *userData)\n{\n    /*SDL_WindowData *window_data = userData;*/\n    int i;\n\n    SDL_TouchID deviceId = 0;\n    if (!SDL_GetTouch(deviceId)) {\n        if (SDL_AddTouch(deviceId, \"\") < 0) {\n             return 0;\n        }\n    }\n\n    /* rescale (in case canvas is being scaled)*/\n    double client_w, client_h, xscale, yscale;\n    emscripten_get_element_css_size(NULL, &client_w, &client_h);\n    SDL_WindowData *window_data = userData;\n    xscale = window_data->window->w / client_w;\n    yscale = window_data->window->h / client_h;\n\n    for (i = 0; i < touchEvent->numTouches; i++) {\n        long x, y, id;\n\n        if (!touchEvent->touches[i].isChanged)\n            continue;\n\n        id = touchEvent->touches[i].identifier;\n        x = touchEvent->touches[i].canvasX * xscale;\n        y = touchEvent->touches[i].canvasY * yscale;\n\n        if (eventType == EMSCRIPTEN_EVENT_TOUCHMOVE) {\n            SDL_SendTouchMotion(deviceId, id, x, y, 1.0f);\n        } else if (eventType == EMSCRIPTEN_EVENT_TOUCHSTART) {\n            SDL_SendTouch(deviceId, id, SDL_TRUE, x, y, 1.0f);\n        } else {\n            SDL_SendTouch(deviceId, id, SDL_FALSE, x, y, 1.0f);\n        }\n    }\n\n\n    return 1;\n}\n\nEM_BOOL\nEmscripten_HandleKey(int eventType, const EmscriptenKeyboardEvent *keyEvent, void *userData)\n{\n    Uint32 scancode;\n\n    /* .keyCode is deprecated, but still the most reliable way to get keys */\n    if (keyEvent->keyCode < SDL_arraysize(emscripten_scancode_table)) {\n        scancode = emscripten_scancode_table[keyEvent->keyCode];\n\n        if (scancode != SDL_SCANCODE_UNKNOWN) {\n\n            if (keyEvent->location == DOM_KEY_LOCATION_RIGHT) {\n                switch (scancode) {\n                    case SDL_SCANCODE_LSHIFT:\n                        scancode = SDL_SCANCODE_RSHIFT;\n                        break;\n                    case SDL_SCANCODE_LCTRL:\n                        scancode = SDL_SCANCODE_RCTRL;\n                        break;\n                    case SDL_SCANCODE_LALT:\n                        scancode = SDL_SCANCODE_RALT;\n                        break;\n                    case SDL_SCANCODE_LGUI:\n                        scancode = SDL_SCANCODE_RGUI;\n                        break;\n                }\n            }\n            SDL_SendKeyboardKey(eventType == EMSCRIPTEN_EVENT_KEYDOWN ?\n                                SDL_PRESSED : SDL_RELEASED, scancode);\n        }\n    }\n\n    /* if we prevent keydown, we won't get keypress\n     * also we need to ALWAYS prevent backspace and tab otherwise chrome takes action and does bad navigation UX\n     */\n    return SDL_GetEventState(SDL_TEXTINPUT) != SDL_ENABLE || eventType != EMSCRIPTEN_EVENT_KEYDOWN\n            || keyEvent->keyCode == 8 /* backspace */ || keyEvent->keyCode == 9 /* tab */;\n}\n\nEM_BOOL\nEmscripten_HandleKeyPress(int eventType, const EmscriptenKeyboardEvent *keyEvent, void *userData)\n{\n    char text[5];\n    if (Emscripten_ConvertUTF32toUTF8(keyEvent->charCode, text)) {\n        SDL_SendKeyboardText(text);\n    }\n    return 1;\n}\n\nEM_BOOL\nEmscripten_HandleFullscreenChange(int eventType, const EmscriptenFullscreenChangeEvent *fullscreenChangeEvent, void *userData)\n{\n    SDL_WindowData *window_data = userData;\n    if(fullscreenChangeEvent->isFullscreen)\n    {\n        window_data->window->flags |= window_data->requested_fullscreen_mode;\n\n        window_data->requested_fullscreen_mode = 0;\n\n        if(!window_data->requested_fullscreen_mode)\n            window_data->window->flags |= SDL_WINDOW_FULLSCREEN; /*we didn't reqest fullscreen*/\n    }\n    else\n    {\n        window_data->window->flags &= ~FULLSCREEN_MASK;\n    }\n\n    return 0;\n}\n\nEM_BOOL\nEmscripten_HandleResize(int eventType, const EmscriptenUiEvent *uiEvent, void *userData)\n{\n    SDL_WindowData *window_data = userData;\n    if(!(window_data->window->flags & FULLSCREEN_MASK))\n    {\n        /* this will only work if the canvas size is set through css */\n        if(window_data->window->flags & SDL_WINDOW_RESIZABLE)\n        {\n            double w = window_data->window->w;\n            double h = window_data->window->h;\n\n            if(window_data->external_size) {\n                emscripten_get_element_css_size(NULL, &w, &h);\n            }\n\n            emscripten_set_canvas_size(w * window_data->pixel_ratio, h * window_data->pixel_ratio);\n\n            /* set_canvas_size unsets this */\n            if (!window_data->external_size && window_data->pixel_ratio != 1.0f) {\n                emscripten_set_element_css_size(NULL, w, h);\n            }\n\n            SDL_SendWindowEvent(window_data->window, SDL_WINDOWEVENT_RESIZED, w, h);\n        }\n    }\n\n    return 0;\n}\n\nEM_BOOL\nEmscripten_HandleCanvasResize(int eventType, const void *reserved, void *userData)\n{\n    /*this is used during fullscreen changes*/\n    SDL_WindowData *window_data = userData;\n\n    if(window_data->fullscreen_resize)\n    {\n        double css_w, css_h;\n        emscripten_get_element_css_size(NULL, &css_w, &css_h);\n        SDL_SendWindowEvent(window_data->window, SDL_WINDOWEVENT_RESIZED, css_w, css_h);\n    }\n\n    return 0;\n}\n\nEM_BOOL\nEmscripten_HandleVisibilityChange(int eventType, const EmscriptenVisibilityChangeEvent *visEvent, void *userData)\n{\n    SDL_WindowData *window_data = userData;\n    SDL_SendWindowEvent(window_data->window, visEvent->hidden ? SDL_WINDOWEVENT_HIDDEN : SDL_WINDOWEVENT_SHOWN, 0, 0);\n    return 0;\n}\n\nvoid\nEmscripten_RegisterEventHandlers(SDL_WindowData *data)\n{\n    /* There is only one window and that window is the canvas */\n    emscripten_set_mousemove_callback(\"#canvas\", data, 0, Emscripten_HandleMouseMove);\n\n    emscripten_set_mousedown_callback(\"#canvas\", data, 0, Emscripten_HandleMouseButton);\n    emscripten_set_mouseup_callback(\"#document\", data, 0, Emscripten_HandleMouseButton);\n\n    emscripten_set_mouseenter_callback(\"#canvas\", data, 0, Emscripten_HandleMouseFocus);\n    emscripten_set_mouseleave_callback(\"#canvas\", data, 0, Emscripten_HandleMouseFocus);\n\n    emscripten_set_wheel_callback(\"#canvas\", data, 0, Emscripten_HandleWheel);\n\n    emscripten_set_focus_callback(\"#window\", data, 0, Emscripten_HandleFocus);\n    emscripten_set_blur_callback(\"#window\", data, 0, Emscripten_HandleFocus);\n\n    emscripten_set_touchstart_callback(\"#canvas\", data, 0, Emscripten_HandleTouch);\n    emscripten_set_touchend_callback(\"#canvas\", data, 0, Emscripten_HandleTouch);\n    emscripten_set_touchmove_callback(\"#canvas\", data, 0, Emscripten_HandleTouch);\n    emscripten_set_touchcancel_callback(\"#canvas\", data, 0, Emscripten_HandleTouch);\n\n    /* Keyboard events are awkward */\n    const char *keyElement = SDL_GetHint(SDL_HINT_EMSCRIPTEN_KEYBOARD_ELEMENT);\n    if (!keyElement) keyElement = \"#window\";\n\n    emscripten_set_keydown_callback(keyElement, data, 0, Emscripten_HandleKey);\n    emscripten_set_keyup_callback(keyElement, data, 0, Emscripten_HandleKey);\n    emscripten_set_keypress_callback(keyElement, data, 0, Emscripten_HandleKeyPress);\n\n    emscripten_set_fullscreenchange_callback(\"#document\", data, 0, Emscripten_HandleFullscreenChange);\n\n    emscripten_set_resize_callback(\"#window\", data, 0, Emscripten_HandleResize);\n\n    emscripten_set_visibilitychange_callback(data, 0, Emscripten_HandleVisibilityChange);\n}\n\nvoid\nEmscripten_UnregisterEventHandlers(SDL_WindowData *data)\n{\n    /* only works due to having one window */\n    emscripten_set_mousemove_callback(\"#canvas\", NULL, 0, NULL);\n\n    emscripten_set_mousedown_callback(\"#canvas\", NULL, 0, NULL);\n    emscripten_set_mouseup_callback(\"#document\", NULL, 0, NULL);\n\n    emscripten_set_mouseenter_callback(\"#canvas\", NULL, 0, NULL);\n    emscripten_set_mouseleave_callback(\"#canvas\", NULL, 0, NULL);\n\n    emscripten_set_wheel_callback(\"#canvas\", NULL, 0, NULL);\n\n    emscripten_set_focus_callback(\"#window\", NULL, 0, NULL);\n    emscripten_set_blur_callback(\"#window\", NULL, 0, NULL);\n\n    emscripten_set_touchstart_callback(\"#canvas\", NULL, 0, NULL);\n    emscripten_set_touchend_callback(\"#canvas\", NULL, 0, NULL);\n    emscripten_set_touchmove_callback(\"#canvas\", NULL, 0, NULL);\n    emscripten_set_touchcancel_callback(\"#canvas\", NULL, 0, NULL);\n\n    const char *target = SDL_GetHint(SDL_HINT_EMSCRIPTEN_KEYBOARD_ELEMENT);\n    if (!target) {\n        target = \"#window\";\n    }\n\n    emscripten_set_keydown_callback(target, NULL, 0, NULL);\n    emscripten_set_keyup_callback(target, NULL, 0, NULL);\n\n    emscripten_set_keypress_callback(target, NULL, 0, NULL);\n\n    emscripten_set_fullscreenchange_callback(\"#document\", NULL, 0, NULL);\n\n    emscripten_set_resize_callback(\"#window\", NULL, 0, NULL);\n\n    emscripten_set_visibilitychange_callback(NULL, 0, NULL);\n}\n\n#endif /* SDL_VIDEO_DRIVER_EMSCRIPTEN */\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../../SDL_internal.h\"\n\n#if SDL_VIDEO_DRIVER_EMSCRIPTEN\n\n#include \"SDL_emscriptenvideo.h\"\n#include \"SDL_emscriptenframebuffer.h\"\n\n\nint Emscripten_CreateWindowFramebuffer(_THIS, SDL_Window * window, Uint32 * format, void ** pixels, int *pitch)\n{\n    SDL_Surface *surface;\n    const Uint32 surface_format = SDL_PIXELFORMAT_BGR888;\n    int w, h;\n    int bpp;\n    Uint32 Rmask, Gmask, Bmask, Amask;\n\n    /* Free the old framebuffer surface */\n    SDL_WindowData *data = (SDL_WindowData *) window->driverdata;\n    surface = data->surface;\n    SDL_FreeSurface(surface);\n\n    /* Create a new one */\n    SDL_PixelFormatEnumToMasks(surface_format, &bpp, &Rmask, &Gmask, &Bmask, &Amask);\n    SDL_GetWindowSize(window, &w, &h);\n\n    surface = SDL_CreateRGBSurface(0, w, h, bpp, Rmask, Gmask, Bmask, Amask);\n    if (!surface) {\n        return -1;\n    }\n\n    /* Save the info and return! */\n    data->surface = surface;\n    *format = surface_format;\n    *pixels = surface->pixels;\n    *pitch = surface->pitch;\n    return 0;\n}\n\nint Emscripten_UpdateWindowFramebuffer(_THIS, SDL_Window * window, const SDL_Rect * rects, int numrects)\n{\n    SDL_Surface *surface;\n\n    SDL_WindowData *data = (SDL_WindowData *) window->driverdata;\n    surface = data->surface;\n    if (!surface) {\n        return SDL_SetError(\"Couldn't find framebuffer surface for window\");\n    }\n\n    /* Send the data to the display */\n\n    EM_ASM_INT({\n        var w = $0;\n        var h = $1;\n        var pixels = $2;\n\n        if (!Module['SDL2']) Module['SDL2'] = {};\n        var SDL2 = Module['SDL2'];\n        if (SDL2.ctxCanvas !== Module['canvas']) {\n            SDL2.ctx = Module['createContext'](Module['canvas'], false, true);\n            SDL2.ctxCanvas = Module['canvas'];\n        }\n        if (SDL2.w !== w || SDL2.h !== h || SDL2.imageCtx !== SDL2.ctx) {\n            SDL2.image = SDL2.ctx.createImageData(w, h);\n            SDL2.w = w;\n            SDL2.h = h;\n            SDL2.imageCtx = SDL2.ctx;\n        }\n        var data = SDL2.image.data;\n        var src = pixels >> 2;\n        var dst = 0;\n        var num;\n        if (typeof CanvasPixelArray !== 'undefined' && data instanceof CanvasPixelArray) {\n            // IE10/IE11: ImageData objects are backed by the deprecated CanvasPixelArray,\n            // not UInt8ClampedArray. These don't have buffers, so we need to revert\n            // to copying a byte at a time. We do the undefined check because modern\n            // browsers do not define CanvasPixelArray anymore.\n            num = data.length;\n            while (dst < num) {\n                var val = HEAP32[src]; // This is optimized. Instead, we could do {{{ makeGetValue('buffer', 'dst', 'i32') }}};\n                data[dst  ] = val & 0xff;\n                data[dst+1] = (val >> 8) & 0xff;\n                data[dst+2] = (val >> 16) & 0xff;\n                data[dst+3] = isScreen ? 0xff : ((val >> 24) & 0xff);\n                src++;\n                dst += 4;\n            }\n        } else {\n            if (SDL2.data32Data !== data) {\n                SDL2.data32 = new Int32Array(data.buffer);\n                SDL2.data8 = new Uint8Array(data.buffer);\n            }\n            var data32 = SDL2.data32;\n            num = data32.length;\n            // logically we need to do\n            //      while (dst < num) {\n            //          data32[dst++] = HEAP32[src++] | 0xff000000\n            //      }\n            // the following code is faster though, because\n            // .set() is almost free - easily 10x faster due to\n            // native memcpy efficiencies, and the remaining loop\n            // just stores, not load + store, so it is faster\n            data32.set(HEAP32.subarray(src, src + num));\n            var data8 = SDL2.data8;\n            var i = 3;\n            var j = i + 4*num;\n            if (num % 8 == 0) {\n                // unrolling gives big speedups\n                while (i < j) {\n                  data8[i] = 0xff;\n                  i = i + 4 | 0;\n                  data8[i] = 0xff;\n                  i = i + 4 | 0;\n                  data8[i] = 0xff;\n                  i = i + 4 | 0;\n                  data8[i] = 0xff;\n                  i = i + 4 | 0;\n                  data8[i] = 0xff;\n                  i = i + 4 | 0;\n                  data8[i] = 0xff;\n                  i = i + 4 | 0;\n                  data8[i] = 0xff;\n                  i = i + 4 | 0;\n                  data8[i] = 0xff;\n                  i = i + 4 | 0;\n                }\n             } else {\n                while (i < j) {\n                  data8[i] = 0xff;\n                  i = i + 4 | 0;\n                }\n            }\n        }\n\n        SDL2.ctx.putImageData(SDL2.image, 0, 0);\n        return 0;\n    }, surface->w, surface->h, surface->pixels);\n\n    /*if (SDL_getenv(\"SDL_VIDEO_Emscripten_SAVE_FRAMES\")) {\n        static int frame_number = 0;\n        char file[128];\n        SDL_snprintf(file, sizeof(file), \"SDL_window%d-%8.8d.bmp\",\n                     SDL_GetWindowID(window), ++frame_number);\n        SDL_SaveBMP(surface, file);\n    }*/\n    return 0;\n}\n\nvoid Emscripten_DestroyWindowFramebuffer(_THIS, SDL_Window * window)\n{\n    SDL_WindowData *data = (SDL_WindowData *) window->driverdata;\n\n    SDL_FreeSurface(data->surface);\n    data->surface = NULL;\n}\n\n#endif /* SDL_VIDEO_DRIVER_EMSCRIPTEN */\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n\n\n#include \"../../SDL_internal.h\"\n\n#if SDL_VIDEO_DRIVER_EMSCRIPTEN\n\n#include <emscripten/emscripten.h>\n#include <emscripten/html5.h>\n\n#include \"SDL_emscriptenmouse.h\"\n\n#include \"../../events/SDL_mouse_c.h\"\n#include \"SDL_assert.h\"\n\n\nstatic SDL_Cursor*\nEmscripten_CreateDefaultCursor()\n{\n    SDL_Cursor* cursor;\n    Emscripten_CursorData *curdata;\n\n    cursor = SDL_calloc(1, sizeof(SDL_Cursor));\n    if (cursor) {\n        curdata = (Emscripten_CursorData *) SDL_calloc(1, sizeof(*curdata));\n        if (!curdata) {\n            SDL_OutOfMemory();\n            SDL_free(cursor);\n            return NULL;\n        }\n\n        curdata->system_cursor = \"default\";\n        cursor->driverdata = curdata;\n    }\n    else {\n        SDL_OutOfMemory();\n    }\n\n    return cursor;\n}\n\nstatic SDL_Cursor*\nEmscripten_CreateCursor(SDL_Surface* sruface, int hot_x, int hot_y)\n{\n    return Emscripten_CreateDefaultCursor();\n}\n\nstatic SDL_Cursor*\nEmscripten_CreateSystemCursor(SDL_SystemCursor id)\n{\n    SDL_Cursor *cursor;\n    Emscripten_CursorData *curdata;\n    const char *cursor_name = NULL;\n\n    switch(id) {\n        case SDL_SYSTEM_CURSOR_ARROW:\n            cursor_name = \"default\";\n            break;\n        case SDL_SYSTEM_CURSOR_IBEAM:\n            cursor_name = \"text\";\n            break;\n        case SDL_SYSTEM_CURSOR_WAIT:\n            cursor_name = \"wait\";\n            break;\n        case SDL_SYSTEM_CURSOR_CROSSHAIR:\n            cursor_name = \"crosshair\";\n            break;\n        case SDL_SYSTEM_CURSOR_WAITARROW:\n            cursor_name = \"progress\";\n            break;\n        case SDL_SYSTEM_CURSOR_SIZENWSE:\n            cursor_name = \"nwse-resize\";\n            break;\n        case SDL_SYSTEM_CURSOR_SIZENESW:\n            cursor_name = \"nesw-resize\";\n            break;\n        case SDL_SYSTEM_CURSOR_SIZEWE:\n            cursor_name = \"ew-resize\";\n            break;\n        case SDL_SYSTEM_CURSOR_SIZENS:\n            cursor_name = \"ns-resize\";\n            break;\n        case SDL_SYSTEM_CURSOR_SIZEALL:\n            break;\n        case SDL_SYSTEM_CURSOR_NO:\n            cursor_name = \"not-allowed\";\n            break;\n        case SDL_SYSTEM_CURSOR_HAND:\n            cursor_name = \"pointer\";\n            break;\n        default:\n            SDL_assert(0);\n            return NULL;\n    }\n\n    cursor = (SDL_Cursor *) SDL_calloc(1, sizeof(*cursor));\n    if (!cursor) {\n        SDL_OutOfMemory();\n        return NULL;\n    }\n    curdata = (Emscripten_CursorData *) SDL_calloc(1, sizeof(*curdata));\n    if (!curdata) {\n        SDL_OutOfMemory();\n        SDL_free(cursor);\n        return NULL;\n    }\n\n    curdata->system_cursor = cursor_name;\n    cursor->driverdata = curdata;\n\n    return cursor;\n}\n\nstatic void\nEmscripten_FreeCursor(SDL_Cursor* cursor)\n{\n    Emscripten_CursorData *curdata;\n    if (cursor) {\n        curdata = (Emscripten_CursorData *) cursor->driverdata;\n\n        if (curdata != NULL) {\n            SDL_free(cursor->driverdata);\n        }\n\n        SDL_free(cursor);\n    }\n}\n\nstatic int\nEmscripten_ShowCursor(SDL_Cursor* cursor)\n{\n    Emscripten_CursorData *curdata;\n    if (SDL_GetMouseFocus() != NULL) {\n        if(cursor && cursor->driverdata) {\n            curdata = (Emscripten_CursorData *) cursor->driverdata;\n\n            if(curdata->system_cursor) {\n                EM_ASM_INT({\n                    if (Module['canvas']) {\n                        Module['canvas'].style['cursor'] = Module['Pointer_stringify']($0);\n                    }\n                    return 0;\n                }, curdata->system_cursor);\n            }\n        }\n        else {\n            EM_ASM(\n                if (Module['canvas']) {\n                    Module['canvas'].style['cursor'] = 'none';\n                }\n            );\n        }\n    }\n    return 0;\n}\n\nstatic void\nEmscripten_WarpMouse(SDL_Window* window, int x, int y)\n{\n    SDL_Unsupported();\n}\n\nstatic int\nEmscripten_SetRelativeMouseMode(SDL_bool enabled)\n{\n    /* TODO: pointer lock isn't actually enabled yet */\n    if(enabled) {\n        if(emscripten_request_pointerlock(NULL, 1) >= EMSCRIPTEN_RESULT_SUCCESS) {\n            return 0;\n        }\n    } else {\n        if(emscripten_exit_pointerlock() >= EMSCRIPTEN_RESULT_SUCCESS) {\n            return 0;\n        }\n    }\n    return -1;\n}\n\nvoid\nEmscripten_InitMouse()\n{\n    SDL_Mouse* mouse = SDL_GetMouse();\n\n    mouse->CreateCursor         = Emscripten_CreateCursor;\n    mouse->ShowCursor           = Emscripten_ShowCursor;\n    mouse->FreeCursor           = Emscripten_FreeCursor;\n    mouse->WarpMouse            = Emscripten_WarpMouse;\n    mouse->CreateSystemCursor   = Emscripten_CreateSystemCursor;\n    mouse->SetRelativeMouseMode = Emscripten_SetRelativeMouseMode;\n\n    SDL_SetDefaultCursor(Emscripten_CreateDefaultCursor());\n}\n\nvoid\nEmscripten_FiniMouse()\n{\n    SDL_Mouse* mouse = SDL_GetMouse();\n\n    Emscripten_FreeCursor(mouse->def_cursor);\n    mouse->def_cursor = NULL;\n\n    mouse->CreateCursor         = NULL;\n    mouse->ShowCursor           = NULL;\n    mouse->FreeCursor           = NULL;\n    mouse->WarpMouse            = NULL;\n    mouse->CreateSystemCursor   = NULL;\n    mouse->SetRelativeMouseMode = NULL;\n}\n\n#endif /* SDL_VIDEO_DRIVER_EMSCRIPTEN */\n\n/* vi: set ts=4 sw=4 expandtab: */\n\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../../SDL_internal.h\"\n\n#if SDL_VIDEO_DRIVER_EMSCRIPTEN && SDL_VIDEO_OPENGL_EGL\n\n#include <emscripten/emscripten.h>\n#include <GLES2/gl2.h>\n\n#include \"SDL_emscriptenvideo.h\"\n#include \"SDL_emscriptenopengles.h\"\n\n#define LOAD_FUNC(NAME) _this->egl_data->NAME = NAME;\n\n/* EGL implementation of SDL OpenGL support */\n\nint\nEmscripten_GLES_LoadLibrary(_THIS, const char *path) {\n    /*we can't load EGL dynamically*/\n    _this->egl_data = (struct SDL_EGL_VideoData *) SDL_calloc(1, sizeof(SDL_EGL_VideoData));\n    if (!_this->egl_data) {\n        return SDL_OutOfMemory();\n    }\n    \n    LOAD_FUNC(eglGetDisplay);\n    LOAD_FUNC(eglInitialize);\n    LOAD_FUNC(eglTerminate);\n    LOAD_FUNC(eglGetProcAddress);\n    LOAD_FUNC(eglChooseConfig);\n    LOAD_FUNC(eglGetConfigAttrib);\n    LOAD_FUNC(eglCreateContext);\n    LOAD_FUNC(eglDestroyContext);\n    LOAD_FUNC(eglCreateWindowSurface);\n    LOAD_FUNC(eglDestroySurface);\n    LOAD_FUNC(eglMakeCurrent);\n    LOAD_FUNC(eglSwapBuffers);\n    LOAD_FUNC(eglSwapInterval);\n    LOAD_FUNC(eglWaitNative);\n    LOAD_FUNC(eglWaitGL);\n    LOAD_FUNC(eglBindAPI);\n    \n    _this->egl_data->egl_display = _this->egl_data->eglGetDisplay(EGL_DEFAULT_DISPLAY);\n    if (!_this->egl_data->egl_display) {\n        return SDL_SetError(\"Could not get EGL display\");\n    }\n    \n    if (_this->egl_data->eglInitialize(_this->egl_data->egl_display, NULL, NULL) != EGL_TRUE) {\n        return SDL_SetError(\"Could not initialize EGL\");\n    }\n\n    _this->gl_config.driver_loaded = 1;\n\n    if (path) {\n        SDL_strlcpy(_this->gl_config.driver_path, path, sizeof(_this->gl_config.driver_path) - 1);\n    } else {\n        *_this->gl_config.driver_path = '\\0';\n    }\n    \n    return 0;\n}\n\nvoid\nEmscripten_GLES_DeleteContext(_THIS, SDL_GLContext context)\n{\n    /*\n    WebGL contexts can't actually be deleted, so we need to reset it.\n    ES2 renderer resets state on init anyway, clearing the canvas should be enough\n    */\n\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);\n\n    SDL_EGL_DeleteContext(_this, context);\n}\n\nSDL_EGL_CreateContext_impl(Emscripten)\nSDL_EGL_SwapWindow_impl(Emscripten)\nSDL_EGL_MakeCurrent_impl(Emscripten)\n\nvoid\nEmscripten_GLES_GetDrawableSize(_THIS, SDL_Window * window, int * w, int * h)\n{\n    SDL_WindowData *data;\n    if (window->driverdata) {\n        data = (SDL_WindowData *) window->driverdata;\n\n        if (w) {\n            *w = window->w * data->pixel_ratio;\n        }\n\n        if (h) {\n            *h = window->h * data->pixel_ratio;\n        }\n    }\n}\n\n#endif /* SDL_VIDEO_DRIVER_EMSCRIPTEN && SDL_VIDEO_OPENGL_EGL */\n\n/* vi: set ts=4 sw=4 expandtab: */\n\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../../SDL_internal.h\"\n\n#if defined(SDL_LOADSO_DUMMY) || defined(SDL_LOADSO_DISABLED)\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/* System dependent library loading routines                           */\n\n#include \"SDL_loadso.h\"\n\nvoid *\nSDL_LoadObject(const char *sofile)\n{\n    const char *loaderror = \"SDL_LoadObject() not implemented\";\n    SDL_SetError(\"Failed loading %s: %s\", sofile, loaderror);\n    return (NULL);\n}\n\nvoid *\nSDL_LoadFunction(void *handle, const char *name)\n{\n    const char *loaderror = \"SDL_LoadFunction() not implemented\";\n    SDL_SetError(\"Failed loading %s: %s\", name, loaderror);\n    return (NULL);\n}\n\nvoid\nSDL_UnloadObject(void *handle)\n{\n    /* no-op. */\n}\n\n#endif /* SDL_LOADSO_DUMMY || SDL_LOADSO_DISABLED */\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../../SDL_internal.h\"\n\n/* Thread management routines for SDL */\n\n#include \"SDL_thread.h\"\n#include \"../SDL_systhread.h\"\n\n#ifdef SDL_PASSED_BEGINTHREAD_ENDTHREAD\nint\nSDL_SYS_CreateThread(SDL_Thread * thread, void *args,\n                     pfnSDL_CurrentBeginThread pfnBeginThread,\n                     pfnSDL_CurrentEndThread pfnEndThread)\n#else\nint\nSDL_SYS_CreateThread(SDL_Thread * thread, void *args)\n#endif /* SDL_PASSED_BEGINTHREAD_ENDTHREAD */\n{\n    return SDL_SetError(\"Threads are not supported on this platform\");\n}\n\nvoid\nSDL_SYS_SetupThread(const char *name)\n{\n    return;\n}\n\nSDL_threadID\nSDL_ThreadID(void)\n{\n    return (0);\n}\n\nint\nSDL_SYS_SetThreadPriority(SDL_ThreadPriority priority)\n{\n    return (0);\n}\n\nvoid\nSDL_SYS_WaitThread(SDL_Thread * thread)\n{\n    return;\n}\n\nvoid\nSDL_SYS_DetachThread(SDL_Thread * thread)\n{\n    return;\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n\n#include \"../../SDL_internal.h\"\n#include \"../SDL_thread_c.h\"\n\n\nSDL_TLSData *\nSDL_SYS_GetTLSData()\n{\n    return SDL_Generic_GetTLSData();\n}\n\nint\nSDL_SYS_SetTLSData(SDL_TLSData *data)\n{\n    return SDL_Generic_SetTLSData(data);\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../SDL_internal.h\"\n\n#include \"SDL_atomic.h\"\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1500)\n#include <intrin.h>\n#define HAVE_MSC_ATOMICS 1\n#endif\n\n#if defined(__MACOSX__)  /* !!! FIXME: should we favor gcc atomics? */\n#include <libkern/OSAtomic.h>\n#endif\n\n#if !defined(HAVE_GCC_ATOMICS) && defined(__SOLARIS__)\n#include <atomic.h>\n#endif\n\n/*\n  If any of the operations are not provided then we must emulate some\n  of them. That means we need a nice implementation of spin locks\n  that avoids the \"one big lock\" problem. We use a vector of spin\n  locks and pick which one to use based on the address of the operand\n  of the function.\n\n  To generate the index of the lock we first shift by 3 bits to get\n  rid on the zero bits that result from 32 and 64 bit allignment of\n  data. We then mask off all but 5 bits and use those 5 bits as an\n  index into the table.\n\n  Picking the lock this way insures that accesses to the same data at\n  the same time will go to the same lock. OTOH, accesses to different\n  data have only a 1/32 chance of hitting the same lock. That should\n  pretty much eliminate the chances of several atomic operations on\n  different data from waiting on the same \"big lock\". If it isn't\n  then the table of locks can be expanded to a new size so long as\n  the new size is a power of two.\n\n  Contributed by Bob Pendleton, bob@pendleton.com\n*/\n\n#if !defined(HAVE_MSC_ATOMICS) && !defined(HAVE_GCC_ATOMICS) && !defined(__MACOSX__) && !defined(__SOLARIS__)\n#define EMULATE_CAS 1\n#endif\n\n#if EMULATE_CAS\nstatic SDL_SpinLock locks[32];\n\nstatic SDL_INLINE void\nenterLock(void *a)\n{\n    uintptr_t index = ((((uintptr_t)a) >> 3) & 0x1f);\n\n    SDL_AtomicLock(&locks[index]);\n}\n\nstatic SDL_INLINE void\nleaveLock(void *a)\n{\n    uintptr_t index = ((((uintptr_t)a) >> 3) & 0x1f);\n\n    SDL_AtomicUnlock(&locks[index]);\n}\n#endif\n\n\nSDL_bool\nSDL_AtomicCAS(SDL_atomic_t *a, int oldval, int newval)\n{\n#ifdef HAVE_MSC_ATOMICS\n    return (_InterlockedCompareExchange((long*)&a->value, (long)newval, (long)oldval) == (long)oldval);\n#elif defined(__MACOSX__)  /* !!! FIXME: should we favor gcc atomics? */\n    return (SDL_bool) OSAtomicCompareAndSwap32Barrier(oldval, newval, &a->value);\n#elif defined(HAVE_GCC_ATOMICS)\n    return (SDL_bool) __sync_bool_compare_and_swap(&a->value, oldval, newval);\n#elif defined(__SOLARIS__) && defined(_LP64)\n    return (SDL_bool) ((int) atomic_cas_64((volatile uint64_t*)&a->value, (uint64_t)oldval, (uint64_t)newval) == oldval);\n#elif defined(__SOLARIS__) && !defined(_LP64)\n    return (SDL_bool) ((int) atomic_cas_32((volatile uint32_t*)&a->value, (uint32_t)oldval, (uint32_t)newval) == oldval);\n#elif EMULATE_CAS\n    SDL_bool retval = SDL_FALSE;\n\n    enterLock(a);\n    if (a->value == oldval) {\n        a->value = newval;\n        retval = SDL_TRUE;\n    }\n    leaveLock(a);\n\n    return retval;\n#else\n    #error Please define your platform.\n#endif\n}\n\nSDL_bool\nSDL_AtomicCASPtr(void **a, void *oldval, void *newval)\n{\n#if defined(HAVE_MSC_ATOMICS) && (_M_IX86)\n    return (_InterlockedCompareExchange((long*)a, (long)newval, (long)oldval) == (long)oldval);\n#elif defined(HAVE_MSC_ATOMICS) && (!_M_IX86)\n    return (_InterlockedCompareExchangePointer(a, newval, oldval) == oldval);\n#elif defined(__MACOSX__) && defined(__LP64__)   /* !!! FIXME: should we favor gcc atomics? */\n    return (SDL_bool) OSAtomicCompareAndSwap64Barrier((int64_t)oldval, (int64_t)newval, (int64_t*) a);\n#elif defined(__MACOSX__) && !defined(__LP64__)  /* !!! FIXME: should we favor gcc atomics? */\n    return (SDL_bool) OSAtomicCompareAndSwap32Barrier((int32_t)oldval, (int32_t)newval, (int32_t*) a);\n#elif defined(HAVE_GCC_ATOMICS)\n    return __sync_bool_compare_and_swap(a, oldval, newval);\n#elif defined(__SOLARIS__)\n    return (SDL_bool) (atomic_cas_ptr(a, oldval, newval) == oldval);\n#elif EMULATE_CAS\n    SDL_bool retval = SDL_FALSE;\n\n    enterLock(a);\n    if (*a == oldval) {\n        *a = newval;\n        retval = SDL_TRUE;\n    }\n    leaveLock(a);\n\n    return retval;\n#else\n    #error Please define your platform.\n#endif\n}\n\nint\nSDL_AtomicSet(SDL_atomic_t *a, int v)\n{\n#ifdef HAVE_MSC_ATOMICS\n    return _InterlockedExchange((long*)&a->value, v);\n#elif defined(HAVE_GCC_ATOMICS)\n    return __sync_lock_test_and_set(&a->value, v);\n#elif defined(__SOLARIS__) && defined(_LP64)\n    return (int) atomic_swap_64((volatile uint64_t*)&a->value, (uint64_t)v);\n#elif defined(__SOLARIS__) && !defined(_LP64)\n    return (int) atomic_swap_32((volatile uint32_t*)&a->value, (uint32_t)v);\n#else\n    int value;\n    do {\n        value = a->value;\n    } while (!SDL_AtomicCAS(a, value, v));\n    return value;\n#endif\n}\n\nvoid*\nSDL_AtomicSetPtr(void **a, void *v)\n{\n#if defined(HAVE_MSC_ATOMICS) && (_M_IX86)\n    return (void *) _InterlockedExchange((long *)a, (long) v);\n#elif defined(HAVE_MSC_ATOMICS) && (!_M_IX86)\n    return _InterlockedExchangePointer(a, v);\n#elif defined(HAVE_GCC_ATOMICS)\n    return __sync_lock_test_and_set(a, v);\n#elif defined(__SOLARIS__)\n    return atomic_swap_ptr(a, v);\n#else\n    void *value;\n    do {\n        value = *a;\n    } while (!SDL_AtomicCASPtr(a, value, v));\n    return value;\n#endif\n}\n\nint\nSDL_AtomicAdd(SDL_atomic_t *a, int v)\n{\n#ifdef HAVE_MSC_ATOMICS\n    return _InterlockedExchangeAdd((long*)&a->value, v);\n#elif defined(HAVE_GCC_ATOMICS)\n    return __sync_fetch_and_add(&a->value, v);\n#elif defined(__SOLARIS__)\n    int pv = a->value;\n    membar_consumer();\n#if defined(_LP64)\n    atomic_add_64((volatile uint64_t*)&a->value, v);\n#elif !defined(_LP64)\n    atomic_add_32((volatile uint32_t*)&a->value, v);\n#endif\n    return pv;\n#else\n    int value;\n    do {\n        value = a->value;\n    } while (!SDL_AtomicCAS(a, value, (value + v)));\n    return value;\n#endif\n}\n\nint\nSDL_AtomicGet(SDL_atomic_t *a)\n{\n    int value;\n    do {\n        value = a->value;\n    } while (!SDL_AtomicCAS(a, value, value));\n    return value;\n}\n\nvoid *\nSDL_AtomicGetPtr(void **a)\n{\n    void *value;\n    do {\n        value = *a;\n    } while (!SDL_AtomicCASPtr(a, value, value));\n    return value;\n}\n\n#ifdef __thumb__\n#if defined(__ARM_ARCH_6__) || defined(__ARM_ARCH_6J__) || defined(__ARM_ARCH_6K__) || defined(__ARM_ARCH_6T2__) || defined(__ARM_ARCH_6Z__) || defined(__ARM_ARCH_6ZK__)\n__asm__(\n\"   .align 2\\n\"\n\"   .globl _SDL_MemoryBarrierRelease\\n\"\n\"   .globl _SDL_MemoryBarrierAcquire\\n\"\n\"_SDL_MemoryBarrierRelease:\\n\"\n\"_SDL_MemoryBarrierAcquire:\\n\"\n\"   mov r0, #0\\n\"\n\"   mcr p15, 0, r0, c7, c10, 5\\n\"\n\"   bx lr\\n\"\n);\n#endif\n#endif\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#ifdef TEST_MAIN\n#include \"SDL_config.h\"\n#else\n#include \"../SDL_internal.h\"\n#endif\n\n#if defined(__WIN32__)\n#include \"../core/windows/SDL_windows.h\"\n#endif\n\n/* CPU feature detection for SDL */\n\n#include \"SDL_cpuinfo.h\"\n\n#ifdef HAVE_SYSCONF\n#include <unistd.h>\n#endif\n#ifdef HAVE_SYSCTLBYNAME\n#include <sys/types.h>\n#include <sys/sysctl.h>\n#endif\n#if defined(__MACOSX__) && (defined(__ppc__) || defined(__ppc64__))\n#include <sys/sysctl.h>         /* For AltiVec check */\n#elif defined(__OpenBSD__) && defined(__powerpc__)\n#include <sys/param.h>\n#include <sys/sysctl.h> /* For AltiVec check */\n#include <machine/cpu.h>\n#elif SDL_ALTIVEC_BLITTERS && HAVE_SETJMP\n#include <signal.h>\n#include <setjmp.h>\n#endif\n\n#define CPU_HAS_RDTSC   0x00000001\n#define CPU_HAS_ALTIVEC 0x00000002\n#define CPU_HAS_MMX     0x00000004\n#define CPU_HAS_3DNOW   0x00000008\n#define CPU_HAS_SSE     0x00000010\n#define CPU_HAS_SSE2    0x00000020\n#define CPU_HAS_SSE3    0x00000040\n#define CPU_HAS_SSE41   0x00000100\n#define CPU_HAS_SSE42   0x00000200\n#define CPU_HAS_AVX     0x00000400\n#define CPU_HAS_AVX2    0x00000800\n\n#if SDL_ALTIVEC_BLITTERS && HAVE_SETJMP && !__MACOSX__ && !__OpenBSD__\n/* This is the brute force way of detecting instruction sets...\n   the idea is borrowed from the libmpeg2 library - thanks!\n */\nstatic jmp_buf jmpbuf;\nstatic void\nillegal_instruction(int sig)\n{\n    longjmp(jmpbuf, 1);\n}\n#endif /* HAVE_SETJMP */\n\nstatic int\nCPU_haveCPUID(void)\n{\n    int has_CPUID = 0;\n/* *INDENT-OFF* */\n#ifndef SDL_CPUINFO_DISABLED\n#if defined(__GNUC__) && defined(i386)\n    __asm__ (\n\"        pushfl                      # Get original EFLAGS             \\n\"\n\"        popl    %%eax                                                 \\n\"\n\"        movl    %%eax,%%ecx                                           \\n\"\n\"        xorl    $0x200000,%%eax     # Flip ID bit in EFLAGS           \\n\"\n\"        pushl   %%eax               # Save new EFLAGS value on stack  \\n\"\n\"        popfl                       # Replace current EFLAGS value    \\n\"\n\"        pushfl                      # Get new EFLAGS                  \\n\"\n\"        popl    %%eax               # Store new EFLAGS in EAX         \\n\"\n\"        xorl    %%ecx,%%eax         # Can not toggle ID bit,          \\n\"\n\"        jz      1f                  # Processor=80486                 \\n\"\n\"        movl    $1,%0               # We have CPUID support           \\n\"\n\"1:                                                                    \\n\"\n    : \"=m\" (has_CPUID)\n    :\n    : \"%eax\", \"%ecx\"\n    );\n#elif defined(__GNUC__) && defined(__x86_64__)\n/* Technically, if this is being compiled under __x86_64__ then it has \n   CPUid by definition.  But it's nice to be able to prove it.  :)      */\n    __asm__ (\n\"        pushfq                      # Get original EFLAGS             \\n\"\n\"        popq    %%rax                                                 \\n\"\n\"        movq    %%rax,%%rcx                                           \\n\"\n\"        xorl    $0x200000,%%eax     # Flip ID bit in EFLAGS           \\n\"\n\"        pushq   %%rax               # Save new EFLAGS value on stack  \\n\"\n\"        popfq                       # Replace current EFLAGS value    \\n\"\n\"        pushfq                      # Get new EFLAGS                  \\n\"\n\"        popq    %%rax               # Store new EFLAGS in EAX         \\n\"\n\"        xorl    %%ecx,%%eax         # Can not toggle ID bit,          \\n\"\n\"        jz      1f                  # Processor=80486                 \\n\"\n\"        movl    $1,%0               # We have CPUID support           \\n\"\n\"1:                                                                    \\n\"\n    : \"=m\" (has_CPUID)\n    :\n    : \"%rax\", \"%rcx\"\n    );\n#elif (defined(_MSC_VER) && defined(_M_IX86)) || defined(__WATCOMC__)\n    __asm {\n        pushfd                      ; Get original EFLAGS\n        pop     eax\n        mov     ecx, eax\n        xor     eax, 200000h        ; Flip ID bit in EFLAGS\n        push    eax                 ; Save new EFLAGS value on stack\n        popfd                       ; Replace current EFLAGS value\n        pushfd                      ; Get new EFLAGS\n        pop     eax                 ; Store new EFLAGS in EAX\n        xor     eax, ecx            ; Can not toggle ID bit,\n        jz      done                ; Processor=80486\n        mov     has_CPUID,1         ; We have CPUID support\ndone:\n    }\n#elif defined(_MSC_VER) && defined(_M_X64)\n    has_CPUID = 1;\n#elif defined(__sun) && defined(__i386)\n    __asm (\n\"       pushfl                 \\n\"\n\"       popl    %eax           \\n\"\n\"       movl    %eax,%ecx      \\n\"\n\"       xorl    $0x200000,%eax \\n\"\n\"       pushl   %eax           \\n\"\n\"       popfl                  \\n\"\n\"       pushfl                 \\n\"\n\"       popl    %eax           \\n\"\n\"       xorl    %ecx,%eax      \\n\"\n\"       jz      1f             \\n\"\n\"       movl    $1,-8(%ebp)    \\n\"\n\"1:                            \\n\"\n    );\n#elif defined(__sun) && defined(__amd64)\n    __asm (\n\"       pushfq                 \\n\"\n\"       popq    %rax           \\n\"\n\"       movq    %rax,%rcx      \\n\"\n\"       xorl    $0x200000,%eax \\n\"\n\"       pushq   %rax           \\n\"\n\"       popfq                  \\n\"\n\"       pushfq                 \\n\"\n\"       popq    %rax           \\n\"\n\"       xorl    %ecx,%eax      \\n\"\n\"       jz      1f             \\n\"\n\"       movl    $1,-8(%rbp)    \\n\"\n\"1:                            \\n\"\n    );\n#endif\n#endif\n/* *INDENT-ON* */\n    return has_CPUID;\n}\n\n#if defined(__GNUC__) && defined(i386)\n#define cpuid(func, a, b, c, d) \\\n    __asm__ __volatile__ ( \\\n\"        pushl %%ebx        \\n\" \\\n\"        xorl %%ecx,%%ecx   \\n\" \\\n\"        cpuid              \\n\" \\\n\"        movl %%ebx, %%esi  \\n\" \\\n\"        popl %%ebx         \\n\" : \\\n            \"=a\" (a), \"=S\" (b), \"=c\" (c), \"=d\" (d) : \"a\" (func))\n#elif defined(__GNUC__) && defined(__x86_64__)\n#define cpuid(func, a, b, c, d) \\\n    __asm__ __volatile__ ( \\\n\"        pushq %%rbx        \\n\" \\\n\"        xorq %%rcx,%%rcx   \\n\" \\\n\"        cpuid              \\n\" \\\n\"        movq %%rbx, %%rsi  \\n\" \\\n\"        popq %%rbx         \\n\" : \\\n            \"=a\" (a), \"=S\" (b), \"=c\" (c), \"=d\" (d) : \"a\" (func))\n#elif (defined(_MSC_VER) && defined(_M_IX86)) || defined(__WATCOMC__)\n#define cpuid(func, a, b, c, d) \\\n    __asm { \\\n        __asm mov eax, func \\\n        __asm xor ecx, ecx \\\n        __asm cpuid \\\n        __asm mov a, eax \\\n        __asm mov b, ebx \\\n        __asm mov c, ecx \\\n        __asm mov d, edx \\\n}\n#elif defined(_MSC_VER) && defined(_M_X64)\n#define cpuid(func, a, b, c, d) \\\n{ \\\n    int CPUInfo[4]; \\\n    __cpuid(CPUInfo, func); \\\n    a = CPUInfo[0]; \\\n    b = CPUInfo[1]; \\\n    c = CPUInfo[2]; \\\n    d = CPUInfo[3]; \\\n}\n#else\n#define cpuid(func, a, b, c, d) \\\n    a = b = c = d = 0\n#endif\n\nstatic int\nCPU_getCPUIDFeatures(void)\n{\n    int features = 0;\n    int a, b, c, d;\n\n    cpuid(0, a, b, c, d);\n    if (a >= 1) {\n        cpuid(1, a, b, c, d);\n        features = d;\n    }\n    return features;\n}\n\nstatic SDL_bool\nCPU_OSSavesYMM(void)\n{\n    int a, b, c, d;\n\n    /* Check to make sure we can call xgetbv */\n    cpuid(0, a, b, c, d);\n    if (a < 1) {\n        return SDL_FALSE;\n    }\n    cpuid(1, a, b, c, d);\n    if (!(c & 0x08000000)) {\n        return SDL_FALSE;\n    }\n\n    /* Call xgetbv to see if YMM register state is saved */\n    a = 0;\n#if defined(__GNUC__) && (defined(i386) || defined(__x86_64__))\n    asm(\".byte 0x0f, 0x01, 0xd0\" : \"=a\" (a) : \"c\" (0) : \"%edx\");\n#elif defined(_MSC_VER) && (defined(_M_IX86) || defined(_M_X64)) && (_MSC_FULL_VER >= 160040219) /* VS2010 SP1 */\n    a = (int)_xgetbv(0);\n#elif (defined(_MSC_VER) && defined(_M_IX86)) || defined(__WATCOMC__)\n    __asm\n    {\n        xor ecx, ecx\n        _asm _emit 0x0f _asm _emit 0x01 _asm _emit 0xd0\n        mov a, eax\n    }\n#endif\n    return ((a & 6) == 6) ? SDL_TRUE : SDL_FALSE;\n}\n\nstatic int\nCPU_haveRDTSC(void)\n{\n    if (CPU_haveCPUID()) {\n        return (CPU_getCPUIDFeatures() & 0x00000010);\n    }\n    return 0;\n}\n\nstatic int\nCPU_haveAltiVec(void)\n{\n    volatile int altivec = 0;\n#ifndef SDL_CPUINFO_DISABLED\n#if (defined(__MACOSX__) && (defined(__ppc__) || defined(__ppc64__))) || (defined(__OpenBSD__) && defined(__powerpc__))\n#ifdef __OpenBSD__\n    int selectors[2] = { CTL_MACHDEP, CPU_ALTIVEC };\n#else\n    int selectors[2] = { CTL_HW, HW_VECTORUNIT };\n#endif\n    int hasVectorUnit = 0;\n    size_t length = sizeof(hasVectorUnit);\n    int error = sysctl(selectors, 2, &hasVectorUnit, &length, NULL, 0);\n    if (0 == error)\n        altivec = (hasVectorUnit != 0);\n#elif SDL_ALTIVEC_BLITTERS && HAVE_SETJMP\n    void (*handler) (int sig);\n    handler = signal(SIGILL, illegal_instruction);\n    if (setjmp(jmpbuf) == 0) {\n        asm volatile (\"mtspr 256, %0\\n\\t\" \"vand %%v0, %%v0, %%v0\"::\"r\" (-1));\n        altivec = 1;\n    }\n    signal(SIGILL, handler);\n#endif\n#endif\n    return altivec;\n}\n\nstatic int\nCPU_haveMMX(void)\n{\n    if (CPU_haveCPUID()) {\n        return (CPU_getCPUIDFeatures() & 0x00800000);\n    }\n    return 0;\n}\n\nstatic int\nCPU_have3DNow(void)\n{\n    if (CPU_haveCPUID()) {\n        int a, b, c, d;\n\n        cpuid(0x80000000, a, b, c, d);\n        if (a >= 0x80000001) {\n            cpuid(0x80000001, a, b, c, d);\n            return (d & 0x80000000);\n        }\n    }\n    return 0;\n}\n\nstatic int\nCPU_haveSSE(void)\n{\n    if (CPU_haveCPUID()) {\n        return (CPU_getCPUIDFeatures() & 0x02000000);\n    }\n    return 0;\n}\n\nstatic int\nCPU_haveSSE2(void)\n{\n    if (CPU_haveCPUID()) {\n        return (CPU_getCPUIDFeatures() & 0x04000000);\n    }\n    return 0;\n}\n\nstatic int\nCPU_haveSSE3(void)\n{\n    if (CPU_haveCPUID()) {\n        int a, b, c, d;\n\n        cpuid(0, a, b, c, d);\n        if (a >= 1) {\n            cpuid(1, a, b, c, d);\n            return (c & 0x00000001);\n        }\n    }\n    return 0;\n}\n\nstatic int\nCPU_haveSSE41(void)\n{\n    if (CPU_haveCPUID()) {\n        int a, b, c, d;\n\n        cpuid(0, a, b, c, d);\n        if (a >= 1) {\n            cpuid(1, a, b, c, d);\n            return (c & 0x00080000);\n        }\n    }\n    return 0;\n}\n\nstatic int\nCPU_haveSSE42(void)\n{\n    if (CPU_haveCPUID()) {\n        int a, b, c, d;\n\n        cpuid(0, a, b, c, d);\n        if (a >= 1) {\n            cpuid(1, a, b, c, d);\n            return (c & 0x00100000);\n        }\n    }\n    return 0;\n}\n\nstatic int\nCPU_haveAVX(void)\n{\n    if (CPU_haveCPUID() && CPU_OSSavesYMM()) {\n        int a, b, c, d;\n\n        cpuid(0, a, b, c, d);\n        if (a >= 1) {\n            cpuid(1, a, b, c, d);\n            return (c & 0x10000000);\n        }\n    }\n    return 0;\n}\n\nstatic int\nCPU_haveAVX2(void)\n{\n    if (CPU_haveCPUID() && CPU_OSSavesYMM()) {\n        int a, b, c, d;\n\n        cpuid(0, a, b, c, d);\n        if (a >= 7) {\n            cpuid(7, a, b, c, d);\n            return (b & 0x00000020);\n        }\n    }\n    return 0;\n}\n\nstatic int SDL_CPUCount = 0;\n\nint\nSDL_GetCPUCount(void)\n{\n    if (!SDL_CPUCount) {\n#ifndef SDL_CPUINFO_DISABLED\n#if defined(HAVE_SYSCONF) && defined(_SC_NPROCESSORS_ONLN)\n        if (SDL_CPUCount <= 0) {\n            SDL_CPUCount = (int)sysconf(_SC_NPROCESSORS_ONLN);\n        }\n#endif\n#ifdef HAVE_SYSCTLBYNAME\n        if (SDL_CPUCount <= 0) {\n            size_t size = sizeof(SDL_CPUCount);\n            sysctlbyname(\"hw.ncpu\", &SDL_CPUCount, &size, NULL, 0);\n        }\n#endif\n#ifdef __WIN32__\n        if (SDL_CPUCount <= 0) {\n            SYSTEM_INFO info;\n            GetSystemInfo(&info);\n            SDL_CPUCount = info.dwNumberOfProcessors;\n        }\n#endif\n#endif\n        /* There has to be at least 1, right? :) */\n        if (SDL_CPUCount <= 0) {\n            SDL_CPUCount = 1;\n        }\n    }\n    return SDL_CPUCount;\n}\n\n/* Oh, such a sweet sweet trick, just not very useful. :) */\nstatic const char *\nSDL_GetCPUType(void)\n{\n    static char SDL_CPUType[13];\n\n    if (!SDL_CPUType[0]) {\n        int i = 0;\n\n        if (CPU_haveCPUID()) {\n            int a, b, c, d;\n            cpuid(0x00000000, a, b, c, d);\n            (void) a;\n            SDL_CPUType[i++] = (char)(b & 0xff); b >>= 8;\n            SDL_CPUType[i++] = (char)(b & 0xff); b >>= 8;\n            SDL_CPUType[i++] = (char)(b & 0xff); b >>= 8;\n            SDL_CPUType[i++] = (char)(b & 0xff);\n\n            SDL_CPUType[i++] = (char)(d & 0xff); d >>= 8;\n            SDL_CPUType[i++] = (char)(d & 0xff); d >>= 8;\n            SDL_CPUType[i++] = (char)(d & 0xff); d >>= 8;\n            SDL_CPUType[i++] = (char)(d & 0xff);\n\n            SDL_CPUType[i++] = (char)(c & 0xff); c >>= 8;\n            SDL_CPUType[i++] = (char)(c & 0xff); c >>= 8;\n            SDL_CPUType[i++] = (char)(c & 0xff); c >>= 8;\n            SDL_CPUType[i++] = (char)(c & 0xff);\n        }\n        if (!SDL_CPUType[0]) {\n            SDL_strlcpy(SDL_CPUType, \"Unknown\", sizeof(SDL_CPUType));\n        }\n    }\n    return SDL_CPUType;\n}\n\n\n#ifdef TEST_MAIN  /* !!! FIXME: only used for test at the moment. */\nstatic const char *\nSDL_GetCPUName(void)\n{\n    static char SDL_CPUName[48];\n\n    if (!SDL_CPUName[0]) {\n        int i = 0;\n        int a, b, c, d;\n\n        if (CPU_haveCPUID()) {\n            cpuid(0x80000000, a, b, c, d);\n            if (a >= 0x80000004) {\n                cpuid(0x80000002, a, b, c, d);\n                SDL_CPUName[i++] = (char)(a & 0xff); a >>= 8;\n                SDL_CPUName[i++] = (char)(a & 0xff); a >>= 8;\n                SDL_CPUName[i++] = (char)(a & 0xff); a >>= 8;\n                SDL_CPUName[i++] = (char)(a & 0xff); a >>= 8;\n                SDL_CPUName[i++] = (char)(b & 0xff); b >>= 8;\n                SDL_CPUName[i++] = (char)(b & 0xff); b >>= 8;\n                SDL_CPUName[i++] = (char)(b & 0xff); b >>= 8;\n                SDL_CPUName[i++] = (char)(b & 0xff); b >>= 8;\n                SDL_CPUName[i++] = (char)(c & 0xff); c >>= 8;\n                SDL_CPUName[i++] = (char)(c & 0xff); c >>= 8;\n                SDL_CPUName[i++] = (char)(c & 0xff); c >>= 8;\n                SDL_CPUName[i++] = (char)(c & 0xff); c >>= 8;\n                SDL_CPUName[i++] = (char)(d & 0xff); d >>= 8;\n                SDL_CPUName[i++] = (char)(d & 0xff); d >>= 8;\n                SDL_CPUName[i++] = (char)(d & 0xff); d >>= 8;\n                SDL_CPUName[i++] = (char)(d & 0xff); d >>= 8;\n                cpuid(0x80000003, a, b, c, d);\n                SDL_CPUName[i++] = (char)(a & 0xff); a >>= 8;\n                SDL_CPUName[i++] = (char)(a & 0xff); a >>= 8;\n                SDL_CPUName[i++] = (char)(a & 0xff); a >>= 8;\n                SDL_CPUName[i++] = (char)(a & 0xff); a >>= 8;\n                SDL_CPUName[i++] = (char)(b & 0xff); b >>= 8;\n                SDL_CPUName[i++] = (char)(b & 0xff); b >>= 8;\n                SDL_CPUName[i++] = (char)(b & 0xff); b >>= 8;\n                SDL_CPUName[i++] = (char)(b & 0xff); b >>= 8;\n                SDL_CPUName[i++] = (char)(c & 0xff); c >>= 8;\n                SDL_CPUName[i++] = (char)(c & 0xff); c >>= 8;\n                SDL_CPUName[i++] = (char)(c & 0xff); c >>= 8;\n                SDL_CPUName[i++] = (char)(c & 0xff); c >>= 8;\n                SDL_CPUName[i++] = (char)(d & 0xff); d >>= 8;\n                SDL_CPUName[i++] = (char)(d & 0xff); d >>= 8;\n                SDL_CPUName[i++] = (char)(d & 0xff); d >>= 8;\n                SDL_CPUName[i++] = (char)(d & 0xff); d >>= 8;\n                cpuid(0x80000004, a, b, c, d);\n                SDL_CPUName[i++] = (char)(a & 0xff); a >>= 8;\n                SDL_CPUName[i++] = (char)(a & 0xff); a >>= 8;\n                SDL_CPUName[i++] = (char)(a & 0xff); a >>= 8;\n                SDL_CPUName[i++] = (char)(a & 0xff); a >>= 8;\n                SDL_CPUName[i++] = (char)(b & 0xff); b >>= 8;\n                SDL_CPUName[i++] = (char)(b & 0xff); b >>= 8;\n                SDL_CPUName[i++] = (char)(b & 0xff); b >>= 8;\n                SDL_CPUName[i++] = (char)(b & 0xff); b >>= 8;\n                SDL_CPUName[i++] = (char)(c & 0xff); c >>= 8;\n                SDL_CPUName[i++] = (char)(c & 0xff); c >>= 8;\n                SDL_CPUName[i++] = (char)(c & 0xff); c >>= 8;\n                SDL_CPUName[i++] = (char)(c & 0xff); c >>= 8;\n                SDL_CPUName[i++] = (char)(d & 0xff); d >>= 8;\n                SDL_CPUName[i++] = (char)(d & 0xff); d >>= 8;\n                SDL_CPUName[i++] = (char)(d & 0xff); d >>= 8;\n                SDL_CPUName[i++] = (char)(d & 0xff); d >>= 8;\n            }\n        }\n        if (!SDL_CPUName[0]) {\n            SDL_strlcpy(SDL_CPUName, \"Unknown\", sizeof(SDL_CPUName));\n        }\n    }\n    return SDL_CPUName;\n}\n#endif\n\nint\nSDL_GetCPUCacheLineSize(void)\n{\n    const char *cpuType = SDL_GetCPUType();\n    int a, b, c, d;\n    (void) a; (void) b; (void) c; (void) d;\n    if (SDL_strcmp(cpuType, \"GenuineIntel\") == 0) {\n        cpuid(0x00000001, a, b, c, d);\n        return (((b >> 8) & 0xff) * 8);\n    } else if (SDL_strcmp(cpuType, \"AuthenticAMD\") == 0) {\n        cpuid(0x80000005, a, b, c, d);\n        return (c & 0xff);\n    } else {\n        /* Just make a guess here... */\n        return SDL_CACHELINE_SIZE;\n    }\n}\n\nstatic Uint32 SDL_CPUFeatures = 0xFFFFFFFF;\n\nstatic Uint32\nSDL_GetCPUFeatures(void)\n{\n    if (SDL_CPUFeatures == 0xFFFFFFFF) {\n        SDL_CPUFeatures = 0;\n        if (CPU_haveRDTSC()) {\n            SDL_CPUFeatures |= CPU_HAS_RDTSC;\n        }\n        if (CPU_haveAltiVec()) {\n            SDL_CPUFeatures |= CPU_HAS_ALTIVEC;\n        }\n        if (CPU_haveMMX()) {\n            SDL_CPUFeatures |= CPU_HAS_MMX;\n        }\n        if (CPU_have3DNow()) {\n            SDL_CPUFeatures |= CPU_HAS_3DNOW;\n        }\n        if (CPU_haveSSE()) {\n            SDL_CPUFeatures |= CPU_HAS_SSE;\n        }\n        if (CPU_haveSSE2()) {\n            SDL_CPUFeatures |= CPU_HAS_SSE2;\n        }\n        if (CPU_haveSSE3()) {\n            SDL_CPUFeatures |= CPU_HAS_SSE3;\n        }\n        if (CPU_haveSSE41()) {\n            SDL_CPUFeatures |= CPU_HAS_SSE41;\n        }\n        if (CPU_haveSSE42()) {\n            SDL_CPUFeatures |= CPU_HAS_SSE42;\n        }\n        if (CPU_haveAVX()) {\n            SDL_CPUFeatures |= CPU_HAS_AVX;\n        }\n        if (CPU_haveAVX2()) {\n            SDL_CPUFeatures |= CPU_HAS_AVX2;\n        }\n    }\n    return SDL_CPUFeatures;\n}\n\nSDL_bool\nSDL_HasRDTSC(void)\n{\n    if (SDL_GetCPUFeatures() & CPU_HAS_RDTSC) {\n        return SDL_TRUE;\n    }\n    return SDL_FALSE;\n}\n\nSDL_bool\nSDL_HasAltiVec(void)\n{\n    if (SDL_GetCPUFeatures() & CPU_HAS_ALTIVEC) {\n        return SDL_TRUE;\n    }\n    return SDL_FALSE;\n}\n\nSDL_bool\nSDL_HasMMX(void)\n{\n    if (SDL_GetCPUFeatures() & CPU_HAS_MMX) {\n        return SDL_TRUE;\n    }\n    return SDL_FALSE;\n}\n\nSDL_bool\nSDL_Has3DNow(void)\n{\n    if (SDL_GetCPUFeatures() & CPU_HAS_3DNOW) {\n        return SDL_TRUE;\n    }\n    return SDL_FALSE;\n}\n\nSDL_bool\nSDL_HasSSE(void)\n{\n    if (SDL_GetCPUFeatures() & CPU_HAS_SSE) {\n        return SDL_TRUE;\n    }\n    return SDL_FALSE;\n}\n\nSDL_bool\nSDL_HasSSE2(void)\n{\n    if (SDL_GetCPUFeatures() & CPU_HAS_SSE2) {\n        return SDL_TRUE;\n    }\n    return SDL_FALSE;\n}\n\nSDL_bool\nSDL_HasSSE3(void)\n{\n    if (SDL_GetCPUFeatures() & CPU_HAS_SSE3) {\n        return SDL_TRUE;\n    }\n    return SDL_FALSE;\n}\n\nSDL_bool\nSDL_HasSSE41(void)\n{\n    if (SDL_GetCPUFeatures() & CPU_HAS_SSE41) {\n        return SDL_TRUE;\n    }\n    return SDL_FALSE;\n}\n\nSDL_bool\nSDL_HasSSE42(void)\n{\n    if (SDL_GetCPUFeatures() & CPU_HAS_SSE42) {\n        return SDL_TRUE;\n    }\n    return SDL_FALSE;\n}\n\nSDL_bool\nSDL_HasAVX(void)\n{\n    if (SDL_GetCPUFeatures() & CPU_HAS_AVX) {\n        return SDL_TRUE;\n    }\n    return SDL_FALSE;\n}\n\nSDL_bool\nSDL_HasAVX2(void)\n{\n    if (SDL_GetCPUFeatures() & CPU_HAS_AVX2) {\n        return SDL_TRUE;\n    }\n    return SDL_FALSE;\n}\n\nstatic int SDL_SystemRAM = 0;\n\nint\nSDL_GetSystemRAM(void)\n{\n    if (!SDL_SystemRAM) {\n#ifndef SDL_CPUINFO_DISABLED\n#if defined(HAVE_SYSCONF) && defined(_SC_PHYS_PAGES) && defined(_SC_PAGESIZE)\n        if (SDL_SystemRAM <= 0) {\n            SDL_SystemRAM = (int)((Sint64)sysconf(_SC_PHYS_PAGES) * sysconf(_SC_PAGESIZE) / (1024*1024));\n        }\n#endif\n#ifdef HAVE_SYSCTLBYNAME\n        if (SDL_SystemRAM <= 0) {\n#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)\n#ifdef HW_REALMEM\n            int mib[2] = {CTL_HW, HW_REALMEM};\n#else\n            /* might only report up to 2 GiB */\n            int mib[2] = {CTL_HW, HW_PHYSMEM};\n#endif /* HW_REALMEM */\n#else\n            int mib[2] = {CTL_HW, HW_MEMSIZE};\n#endif /* __FreeBSD__ || __FreeBSD_kernel__ */\n            Uint64 memsize = 0;\n            size_t len = sizeof(memsize);\n            \n            if (sysctl(mib, 2, &memsize, &len, NULL, 0) == 0) {\n                SDL_SystemRAM = (int)(memsize / (1024*1024));\n            }\n        }\n#endif\n#ifdef __WIN32__\n        if (SDL_SystemRAM <= 0) {\n            MEMORYSTATUSEX stat;\n            stat.dwLength = sizeof(stat);\n            if (GlobalMemoryStatusEx(&stat)) {\n                SDL_SystemRAM = (int)(stat.ullTotalPhys / (1024 * 1024));\n            }\n        }\n#endif\n#endif\n    }\n    return SDL_SystemRAM;\n}\n\n\n#ifdef TEST_MAIN\n\n#include <stdio.h>\n\nint\nmain()\n{\n    printf(\"CPU count: %d\\n\", SDL_GetCPUCount());\n    printf(\"CPU type: %s\\n\", SDL_GetCPUType());\n    printf(\"CPU name: %s\\n\", SDL_GetCPUName());\n    printf(\"CacheLine size: %d\\n\", SDL_GetCPUCacheLineSize());\n    printf(\"RDTSC: %d\\n\", SDL_HasRDTSC());\n    printf(\"Altivec: %d\\n\", SDL_HasAltiVec());\n    printf(\"MMX: %d\\n\", SDL_HasMMX());\n    printf(\"3DNow: %d\\n\", SDL_Has3DNow());\n    printf(\"SSE: %d\\n\", SDL_HasSSE());\n    printf(\"SSE2: %d\\n\", SDL_HasSSE2());\n    printf(\"SSE3: %d\\n\", SDL_HasSSE3());\n    printf(\"SSE4.1: %d\\n\", SDL_HasSSE41());\n    printf(\"SSE4.2: %d\\n\", SDL_HasSSE42());\n    printf(\"AVX: %d\\n\", SDL_HasAVX());\n    printf(\"AVX2: %d\\n\", SDL_HasAVX2());\n    printf(\"RAM: %d MB\\n\", SDL_GetSystemRAM());\n    return 0;\n}\n\n#endif /* TEST_MAIN */\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n/* Need this so Linux systems define fseek64o, ftell64o and off64_t */\n#define _LARGEFILE64_SOURCE\n#include \"../SDL_internal.h\"\n\n#if defined(__WIN32__)\n#include \"../core/windows/SDL_windows.h\"\n#endif\n\n\n/* This file provides a general interface for SDL to read and write\n   data sources.  It can easily be extended to files, memory, etc.\n*/\n\n#include \"SDL_endian.h\"\n#include \"SDL_rwops.h\"\n\n#ifdef __APPLE__\n#include \"cocoa/SDL_rwopsbundlesupport.h\"\n#endif /* __APPLE__ */\n\n#ifdef __ANDROID__\n#include \"../core/android/SDL_android.h\"\n#include \"SDL_system.h\"\n#endif\n\n#if __NACL__\n#include \"nacl_io/nacl_io.h\"\n#endif\n\n#ifdef __WIN32__\n\n/* Functions to read/write Win32 API file pointers */\n\n#ifndef INVALID_SET_FILE_POINTER\n#define INVALID_SET_FILE_POINTER 0xFFFFFFFF\n#endif\n\n#define READAHEAD_BUFFER_SIZE   1024\n\nstatic int SDLCALL\nwindows_file_open(SDL_RWops * context, const char *filename, const char *mode)\n{\n    UINT old_error_mode;\n    HANDLE h;\n    DWORD r_right, w_right;\n    DWORD must_exist, truncate;\n    int a_mode;\n\n    if (!context)\n        return -1;              /* failed (invalid call) */\n\n    context->hidden.windowsio.h = INVALID_HANDLE_VALUE;   /* mark this as unusable */\n    context->hidden.windowsio.buffer.data = NULL;\n    context->hidden.windowsio.buffer.size = 0;\n    context->hidden.windowsio.buffer.left = 0;\n\n    /* \"r\" = reading, file must exist */\n    /* \"w\" = writing, truncate existing, file may not exist */\n    /* \"r+\"= reading or writing, file must exist            */\n    /* \"a\" = writing, append file may not exist             */\n    /* \"a+\"= append + read, file may not exist              */\n    /* \"w+\" = read, write, truncate. file may not exist    */\n\n    must_exist = (SDL_strchr(mode, 'r') != NULL) ? OPEN_EXISTING : 0;\n    truncate = (SDL_strchr(mode, 'w') != NULL) ? CREATE_ALWAYS : 0;\n    r_right = (SDL_strchr(mode, '+') != NULL\n               || must_exist) ? GENERIC_READ : 0;\n    a_mode = (SDL_strchr(mode, 'a') != NULL) ? OPEN_ALWAYS : 0;\n    w_right = (a_mode || SDL_strchr(mode, '+')\n               || truncate) ? GENERIC_WRITE : 0;\n\n    if (!r_right && !w_right)   /* inconsistent mode */\n        return -1;              /* failed (invalid call) */\n\n    context->hidden.windowsio.buffer.data =\n        (char *) SDL_malloc(READAHEAD_BUFFER_SIZE);\n    if (!context->hidden.windowsio.buffer.data) {\n        return SDL_OutOfMemory();\n    }\n    /* Do not open a dialog box if failure */\n    old_error_mode =\n        SetErrorMode(SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS);\n\n    {\n        LPTSTR tstr = WIN_UTF8ToString(filename);\n        h = CreateFile(tstr, (w_right | r_right),\n                       (w_right) ? 0 : FILE_SHARE_READ, NULL,\n                       (must_exist | truncate | a_mode),\n                       FILE_ATTRIBUTE_NORMAL, NULL);\n        SDL_free(tstr);\n    }\n\n    /* restore old behavior */\n    SetErrorMode(old_error_mode);\n\n    if (h == INVALID_HANDLE_VALUE) {\n        SDL_free(context->hidden.windowsio.buffer.data);\n        context->hidden.windowsio.buffer.data = NULL;\n        SDL_SetError(\"Couldn't open %s\", filename);\n        return -2;              /* failed (CreateFile) */\n    }\n    context->hidden.windowsio.h = h;\n    context->hidden.windowsio.append = a_mode ? SDL_TRUE : SDL_FALSE;\n\n    return 0;                   /* ok */\n}\n\nstatic Sint64 SDLCALL\nwindows_file_size(SDL_RWops * context)\n{\n    LARGE_INTEGER size;\n\n    if (!context || context->hidden.windowsio.h == INVALID_HANDLE_VALUE) {\n        return SDL_SetError(\"windows_file_size: invalid context/file not opened\");\n    }\n\n    if (!GetFileSizeEx(context->hidden.windowsio.h, &size)) {\n        return WIN_SetError(\"windows_file_size\");\n    }\n\n    return size.QuadPart;\n}\n\nstatic Sint64 SDLCALL\nwindows_file_seek(SDL_RWops * context, Sint64 offset, int whence)\n{\n    DWORD windowswhence;\n    LARGE_INTEGER windowsoffset;\n\n    if (!context || context->hidden.windowsio.h == INVALID_HANDLE_VALUE) {\n        return SDL_SetError(\"windows_file_seek: invalid context/file not opened\");\n    }\n\n    /* FIXME: We may be able to satisfy the seek within buffered data */\n    if (whence == RW_SEEK_CUR && context->hidden.windowsio.buffer.left) {\n        offset -= (long)context->hidden.windowsio.buffer.left;\n    }\n    context->hidden.windowsio.buffer.left = 0;\n\n    switch (whence) {\n    case RW_SEEK_SET:\n        windowswhence = FILE_BEGIN;\n        break;\n    case RW_SEEK_CUR:\n        windowswhence = FILE_CURRENT;\n        break;\n    case RW_SEEK_END:\n        windowswhence = FILE_END;\n        break;\n    default:\n        return SDL_SetError(\"windows_file_seek: Unknown value for 'whence'\");\n    }\n\n    windowsoffset.QuadPart = offset;\n    if (!SetFilePointerEx(context->hidden.windowsio.h, windowsoffset, &windowsoffset, windowswhence)) {\n        return WIN_SetError(\"windows_file_seek\");\n    }\n    return windowsoffset.QuadPart;\n}\n\nstatic size_t SDLCALL\nwindows_file_read(SDL_RWops * context, void *ptr, size_t size, size_t maxnum)\n{\n    size_t total_need;\n    size_t total_read = 0;\n    size_t read_ahead;\n    DWORD byte_read;\n\n    total_need = size * maxnum;\n\n    if (!context || context->hidden.windowsio.h == INVALID_HANDLE_VALUE\n        || !total_need)\n        return 0;\n\n    if (context->hidden.windowsio.buffer.left > 0) {\n        void *data = (char *) context->hidden.windowsio.buffer.data +\n            context->hidden.windowsio.buffer.size -\n            context->hidden.windowsio.buffer.left;\n        read_ahead =\n            SDL_min(total_need, context->hidden.windowsio.buffer.left);\n        SDL_memcpy(ptr, data, read_ahead);\n        context->hidden.windowsio.buffer.left -= read_ahead;\n\n        if (read_ahead == total_need) {\n            return maxnum;\n        }\n        ptr = (char *) ptr + read_ahead;\n        total_need -= read_ahead;\n        total_read += read_ahead;\n    }\n\n    if (total_need < READAHEAD_BUFFER_SIZE) {\n        if (!ReadFile\n            (context->hidden.windowsio.h, context->hidden.windowsio.buffer.data,\n             READAHEAD_BUFFER_SIZE, &byte_read, NULL)) {\n            SDL_Error(SDL_EFREAD);\n            return 0;\n        }\n        read_ahead = SDL_min(total_need, (int) byte_read);\n        SDL_memcpy(ptr, context->hidden.windowsio.buffer.data, read_ahead);\n        context->hidden.windowsio.buffer.size = byte_read;\n        context->hidden.windowsio.buffer.left = byte_read - read_ahead;\n        total_read += read_ahead;\n    } else {\n        if (!ReadFile\n            (context->hidden.windowsio.h, ptr, (DWORD)total_need, &byte_read, NULL)) {\n            SDL_Error(SDL_EFREAD);\n            return 0;\n        }\n        total_read += byte_read;\n    }\n    return (total_read / size);\n}\n\nstatic size_t SDLCALL\nwindows_file_write(SDL_RWops * context, const void *ptr, size_t size,\n                 size_t num)\n{\n\n    size_t total_bytes;\n    DWORD byte_written;\n    size_t nwritten;\n\n    total_bytes = size * num;\n\n    if (!context || context->hidden.windowsio.h == INVALID_HANDLE_VALUE\n        || total_bytes <= 0 || !size)\n        return 0;\n\n    if (context->hidden.windowsio.buffer.left) {\n        SetFilePointer(context->hidden.windowsio.h,\n                       -(LONG)context->hidden.windowsio.buffer.left, NULL,\n                       FILE_CURRENT);\n        context->hidden.windowsio.buffer.left = 0;\n    }\n\n    /* if in append mode, we must go to the EOF before write */\n    if (context->hidden.windowsio.append) {\n        if (SetFilePointer(context->hidden.windowsio.h, 0L, NULL, FILE_END) ==\n            INVALID_SET_FILE_POINTER) {\n            SDL_Error(SDL_EFWRITE);\n            return 0;\n        }\n    }\n\n    if (!WriteFile\n        (context->hidden.windowsio.h, ptr, (DWORD)total_bytes, &byte_written, NULL)) {\n        SDL_Error(SDL_EFWRITE);\n        return 0;\n    }\n\n    nwritten = byte_written / size;\n    return nwritten;\n}\n\nstatic int SDLCALL\nwindows_file_close(SDL_RWops * context)\n{\n\n    if (context) {\n        if (context->hidden.windowsio.h != INVALID_HANDLE_VALUE) {\n            CloseHandle(context->hidden.windowsio.h);\n            context->hidden.windowsio.h = INVALID_HANDLE_VALUE;   /* to be sure */\n        }\n        SDL_free(context->hidden.windowsio.buffer.data);\n        context->hidden.windowsio.buffer.data = NULL;\n        SDL_FreeRW(context);\n    }\n    return 0;\n}\n#endif /* __WIN32__ */\n\n#ifdef HAVE_STDIO_H\n\n/* Functions to read/write stdio file pointers */\n\nstatic Sint64 SDLCALL\nstdio_size(SDL_RWops * context)\n{\n    Sint64 pos, size;\n\n    pos = SDL_RWseek(context, 0, RW_SEEK_CUR);\n    if (pos < 0) {\n        return -1;\n    }\n    size = SDL_RWseek(context, 0, RW_SEEK_END);\n\n    SDL_RWseek(context, pos, RW_SEEK_SET);\n    return size;\n}\n\nstatic Sint64 SDLCALL\nstdio_seek(SDL_RWops * context, Sint64 offset, int whence)\n{\n#ifdef HAVE_FSEEKO64\n    if (fseeko64(context->hidden.stdio.fp, (off64_t)offset, whence) == 0) {\n        return ftello64(context->hidden.stdio.fp);\n    }\n#elif defined(HAVE_FSEEKO)\n    if (fseeko(context->hidden.stdio.fp, (off_t)offset, whence) == 0) {\n        return ftello(context->hidden.stdio.fp);\n    }\n#elif defined(HAVE__FSEEKI64)\n    if (_fseeki64(context->hidden.stdio.fp, offset, whence) == 0) {\n        return _ftelli64(context->hidden.stdio.fp);\n    }\n#else\n    if (fseek(context->hidden.stdio.fp, offset, whence) == 0) {\n        return ftell(context->hidden.stdio.fp);\n    }\n#endif\n    return SDL_Error(SDL_EFSEEK);\n}\n\nstatic size_t SDLCALL\nstdio_read(SDL_RWops * context, void *ptr, size_t size, size_t maxnum)\n{\n    size_t nread;\n\n    nread = fread(ptr, size, maxnum, context->hidden.stdio.fp);\n    if (nread == 0 && ferror(context->hidden.stdio.fp)) {\n        SDL_Error(SDL_EFREAD);\n    }\n    return nread;\n}\n\nstatic size_t SDLCALL\nstdio_write(SDL_RWops * context, const void *ptr, size_t size, size_t num)\n{\n    size_t nwrote;\n\n    nwrote = fwrite(ptr, size, num, context->hidden.stdio.fp);\n    if (nwrote == 0 && ferror(context->hidden.stdio.fp)) {\n        SDL_Error(SDL_EFWRITE);\n    }\n    return nwrote;\n}\n\nstatic int SDLCALL\nstdio_close(SDL_RWops * context)\n{\n    int status = 0;\n    if (context) {\n        if (context->hidden.stdio.autoclose) {\n            /* WARNING:  Check the return value here! */\n            if (fclose(context->hidden.stdio.fp) != 0) {\n                status = SDL_Error(SDL_EFWRITE);\n            }\n        }\n        SDL_FreeRW(context);\n    }\n    return status;\n}\n#endif /* !HAVE_STDIO_H */\n\n/* Functions to read/write memory pointers */\n\nstatic Sint64 SDLCALL\nmem_size(SDL_RWops * context)\n{\n    return (Sint64)(context->hidden.mem.stop - context->hidden.mem.base);\n}\n\nstatic Sint64 SDLCALL\nmem_seek(SDL_RWops * context, Sint64 offset, int whence)\n{\n    Uint8 *newpos;\n\n    switch (whence) {\n    case RW_SEEK_SET:\n        newpos = context->hidden.mem.base + offset;\n        break;\n    case RW_SEEK_CUR:\n        newpos = context->hidden.mem.here + offset;\n        break;\n    case RW_SEEK_END:\n        newpos = context->hidden.mem.stop + offset;\n        break;\n    default:\n        return SDL_SetError(\"Unknown value for 'whence'\");\n    }\n    if (newpos < context->hidden.mem.base) {\n        newpos = context->hidden.mem.base;\n    }\n    if (newpos > context->hidden.mem.stop) {\n        newpos = context->hidden.mem.stop;\n    }\n    context->hidden.mem.here = newpos;\n    return (Sint64)(context->hidden.mem.here - context->hidden.mem.base);\n}\n\nstatic size_t SDLCALL\nmem_read(SDL_RWops * context, void *ptr, size_t size, size_t maxnum)\n{\n    size_t total_bytes;\n    size_t mem_available;\n\n    total_bytes = (maxnum * size);\n    if ((maxnum <= 0) || (size <= 0)\n        || ((total_bytes / maxnum) != (size_t) size)) {\n        return 0;\n    }\n\n    mem_available = (context->hidden.mem.stop - context->hidden.mem.here);\n    if (total_bytes > mem_available) {\n        total_bytes = mem_available;\n    }\n\n    SDL_memcpy(ptr, context->hidden.mem.here, total_bytes);\n    context->hidden.mem.here += total_bytes;\n\n    return (total_bytes / size);\n}\n\nstatic size_t SDLCALL\nmem_write(SDL_RWops * context, const void *ptr, size_t size, size_t num)\n{\n    if ((context->hidden.mem.here + (num * size)) > context->hidden.mem.stop) {\n        num = (context->hidden.mem.stop - context->hidden.mem.here) / size;\n    }\n    SDL_memcpy(context->hidden.mem.here, ptr, num * size);\n    context->hidden.mem.here += num * size;\n    return num;\n}\n\nstatic size_t SDLCALL\nmem_writeconst(SDL_RWops * context, const void *ptr, size_t size, size_t num)\n{\n    SDL_SetError(\"Can't write to read-only memory\");\n    return 0;\n}\n\nstatic int SDLCALL\nmem_close(SDL_RWops * context)\n{\n    if (context) {\n        SDL_FreeRW(context);\n    }\n    return 0;\n}\n\n\n/* Functions to create SDL_RWops structures from various data sources */\n\nSDL_RWops *\nSDL_RWFromFile(const char *file, const char *mode)\n{\n    SDL_RWops *rwops = NULL;\n    if (!file || !*file || !mode || !*mode) {\n        SDL_SetError(\"SDL_RWFromFile(): No file or no mode specified\");\n        return NULL;\n    }\n#if defined(__ANDROID__)\n#ifdef HAVE_STDIO_H\n    /* Try to open the file on the filesystem first */\n    if (*file == '/') {\n        FILE *fp = fopen(file, mode);\n        if (fp) {\n            return SDL_RWFromFP(fp, 1);\n        }\n    } else {\n        /* Try opening it from internal storage if it's a relative path */\n        char *path;\n        FILE *fp;\n\n        path = SDL_stack_alloc(char, PATH_MAX);\n        if (path) {\n            SDL_snprintf(path, PATH_MAX, \"%s/%s\",\n                         SDL_AndroidGetInternalStoragePath(), file);\n            fp = fopen(path, mode);\n            SDL_stack_free(path);\n            if (fp) {\n                return SDL_RWFromFP(fp, 1);\n            }\n        }\n    }\n#endif /* HAVE_STDIO_H */\n\n    /* Try to open the file from the asset system */\n    rwops = SDL_AllocRW();\n    if (!rwops)\n        return NULL;            /* SDL_SetError already setup by SDL_AllocRW() */\n    if (Android_JNI_FileOpen(rwops, file, mode) < 0) {\n        SDL_FreeRW(rwops);\n        return NULL;\n    }\n    rwops->size = Android_JNI_FileSize;\n    rwops->seek = Android_JNI_FileSeek;\n    rwops->read = Android_JNI_FileRead;\n    rwops->write = Android_JNI_FileWrite;\n    rwops->close = Android_JNI_FileClose;\n    rwops->type = SDL_RWOPS_JNIFILE;\n\n#elif defined(__WIN32__)\n    rwops = SDL_AllocRW();\n    if (!rwops)\n        return NULL;            /* SDL_SetError already setup by SDL_AllocRW() */\n    if (windows_file_open(rwops, file, mode) < 0) {\n        SDL_FreeRW(rwops);\n        return NULL;\n    }\n    rwops->size = windows_file_size;\n    rwops->seek = windows_file_seek;\n    rwops->read = windows_file_read;\n    rwops->write = windows_file_write;\n    rwops->close = windows_file_close;\n    rwops->type = SDL_RWOPS_WINFILE;\n\n#elif HAVE_STDIO_H\n    {\n        #ifdef __APPLE__\n        FILE *fp = SDL_OpenFPFromBundleOrFallback(file, mode);\n        #elif __WINRT__\n        FILE *fp = NULL;\n        fopen_s(&fp, file, mode);\n        #else\n        FILE *fp = fopen(file, mode);\n        #endif\n        if (fp == NULL) {\n            SDL_SetError(\"Couldn't open %s\", file);\n        } else {\n            rwops = SDL_RWFromFP(fp, 1);\n        }\n    }\n#else\n    SDL_SetError(\"SDL not compiled with stdio support\");\n#endif /* !HAVE_STDIO_H */\n\n    return rwops;\n}\n\n#ifdef HAVE_STDIO_H\nSDL_RWops *\nSDL_RWFromFP(FILE * fp, SDL_bool autoclose)\n{\n    SDL_RWops *rwops = NULL;\n\n    rwops = SDL_AllocRW();\n    if (rwops != NULL) {\n        rwops->size = stdio_size;\n        rwops->seek = stdio_seek;\n        rwops->read = stdio_read;\n        rwops->write = stdio_write;\n        rwops->close = stdio_close;\n        rwops->hidden.stdio.fp = fp;\n        rwops->hidden.stdio.autoclose = autoclose;\n        rwops->type = SDL_RWOPS_STDFILE;\n    }\n    return rwops;\n}\n#else\nSDL_RWops *\nSDL_RWFromFP(void * fp, SDL_bool autoclose)\n{\n    SDL_SetError(\"SDL not compiled with stdio support\");\n    return NULL;\n}\n#endif /* HAVE_STDIO_H */\n\nSDL_RWops *\nSDL_RWFromMem(void *mem, int size)\n{\n    SDL_RWops *rwops = NULL;\n    if (!mem) {\n      SDL_InvalidParamError(\"mem\");\n      return rwops;\n    }\n    if (!size) {\n      SDL_InvalidParamError(\"size\");\n      return rwops;\n    }\n\n    rwops = SDL_AllocRW();\n    if (rwops != NULL) {\n        rwops->size = mem_size;\n        rwops->seek = mem_seek;\n        rwops->read = mem_read;\n        rwops->write = mem_write;\n        rwops->close = mem_close;\n        rwops->hidden.mem.base = (Uint8 *) mem;\n        rwops->hidden.mem.here = rwops->hidden.mem.base;\n        rwops->hidden.mem.stop = rwops->hidden.mem.base + size;\n        rwops->type = SDL_RWOPS_MEMORY;\n    }\n    return rwops;\n}\n\nSDL_RWops *\nSDL_RWFromConstMem(const void *mem, int size)\n{\n    SDL_RWops *rwops = NULL;\n    if (!mem) {\n      SDL_InvalidParamError(\"mem\");\n      return rwops;\n    }\n    if (!size) {\n      SDL_InvalidParamError(\"size\");\n      return rwops;\n    }\n\n    rwops = SDL_AllocRW();\n    if (rwops != NULL) {\n        rwops->size = mem_size;\n        rwops->seek = mem_seek;\n        rwops->read = mem_read;\n        rwops->write = mem_writeconst;\n        rwops->close = mem_close;\n        rwops->hidden.mem.base = (Uint8 *) mem;\n        rwops->hidden.mem.here = rwops->hidden.mem.base;\n        rwops->hidden.mem.stop = rwops->hidden.mem.base + size;\n        rwops->type = SDL_RWOPS_MEMORY_RO;\n    }\n    return rwops;\n}\n\nSDL_RWops *\nSDL_AllocRW(void)\n{\n    SDL_RWops *area;\n\n    area = (SDL_RWops *) SDL_malloc(sizeof *area);\n    if (area == NULL) {\n        SDL_OutOfMemory();\n    } else {\n        area->type = SDL_RWOPS_UNKNOWN;\n    }\n    return area;\n}\n\nvoid\nSDL_FreeRW(SDL_RWops * area)\n{\n    SDL_free(area);\n}\n\n/* Functions for dynamically reading and writing endian-specific values */\n\nUint8\nSDL_ReadU8(SDL_RWops * src)\n{\n    Uint8 value = 0;\n\n    SDL_RWread(src, &value, sizeof (value), 1);\n    return value;\n}\n\nUint16\nSDL_ReadLE16(SDL_RWops * src)\n{\n    Uint16 value = 0;\n\n    SDL_RWread(src, &value, sizeof (value), 1);\n    return SDL_SwapLE16(value);\n}\n\nUint16\nSDL_ReadBE16(SDL_RWops * src)\n{\n    Uint16 value = 0;\n\n    SDL_RWread(src, &value, sizeof (value), 1);\n    return SDL_SwapBE16(value);\n}\n\nUint32\nSDL_ReadLE32(SDL_RWops * src)\n{\n    Uint32 value = 0;\n\n    SDL_RWread(src, &value, sizeof (value), 1);\n    return SDL_SwapLE32(value);\n}\n\nUint32\nSDL_ReadBE32(SDL_RWops * src)\n{\n    Uint32 value = 0;\n\n    SDL_RWread(src, &value, sizeof (value), 1);\n    return SDL_SwapBE32(value);\n}\n\nUint64\nSDL_ReadLE64(SDL_RWops * src)\n{\n    Uint64 value = 0;\n\n    SDL_RWread(src, &value, sizeof (value), 1);\n    return SDL_SwapLE64(value);\n}\n\nUint64\nSDL_ReadBE64(SDL_RWops * src)\n{\n    Uint64 value = 0;\n\n    SDL_RWread(src, &value, sizeof (value), 1);\n    return SDL_SwapBE64(value);\n}\n\nsize_t\nSDL_WriteU8(SDL_RWops * dst, Uint8 value)\n{\n    return SDL_RWwrite(dst, &value, sizeof (value), 1);\n}\n\nsize_t\nSDL_WriteLE16(SDL_RWops * dst, Uint16 value)\n{\n    const Uint16 swapped = SDL_SwapLE16(value);\n    return SDL_RWwrite(dst, &swapped, sizeof (swapped), 1);\n}\n\nsize_t\nSDL_WriteBE16(SDL_RWops * dst, Uint16 value)\n{\n    const Uint16 swapped = SDL_SwapBE16(value);\n    return SDL_RWwrite(dst, &swapped, sizeof (swapped), 1);\n}\n\nsize_t\nSDL_WriteLE32(SDL_RWops * dst, Uint32 value)\n{\n    const Uint32 swapped = SDL_SwapLE32(value);\n    return SDL_RWwrite(dst, &swapped, sizeof (swapped), 1);\n}\n\nsize_t\nSDL_WriteBE32(SDL_RWops * dst, Uint32 value)\n{\n    const Uint32 swapped = SDL_SwapBE32(value);\n    return SDL_RWwrite(dst, &swapped, sizeof (swapped), 1);\n}\n\nsize_t\nSDL_WriteLE64(SDL_RWops * dst, Uint64 value)\n{\n    const Uint64 swapped = SDL_SwapLE64(value);\n    return SDL_RWwrite(dst, &swapped, sizeof (swapped), 1);\n}\n\nsize_t\nSDL_WriteBE64(SDL_RWops * dst, Uint64 value)\n{\n    const Uint64 swapped = SDL_SwapBE64(value);\n    return SDL_RWwrite(dst, &swapped, sizeof (swapped), 1);\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../SDL_internal.h\"\n\n/*\n   Code to load and save surfaces in Windows BMP format.\n\n   Why support BMP format?  Well, it's a native format for Windows, and\n   most image processing programs can read and write it.  It would be nice\n   to be able to have at least one image format that we can natively load\n   and save, and since PNG is so complex that it would bloat the library,\n   BMP is a good alternative.\n\n   This code currently supports Win32 DIBs in uncompressed 8 and 24 bpp.\n*/\n\n#include \"SDL_video.h\"\n#include \"SDL_assert.h\"\n#include \"SDL_endian.h\"\n#include \"SDL_pixels_c.h\"\n\n#define SAVE_32BIT_BMP\n\n/* Compression encodings for BMP files */\n#ifndef BI_RGB\n#define BI_RGB      0\n#define BI_RLE8     1\n#define BI_RLE4     2\n#define BI_BITFIELDS    3\n#endif\n\n\nstatic void CorrectAlphaChannel(SDL_Surface *surface)\n{\n    /* Check to see if there is any alpha channel data */\n    SDL_bool hasAlpha = SDL_FALSE;\n#if SDL_BYTEORDER == SDL_BIG_ENDIAN\n    int alphaChannelOffset = 0;\n#else\n    int alphaChannelOffset = 3;\n#endif\n    Uint8 *alpha = ((Uint8*)surface->pixels) + alphaChannelOffset;\n    Uint8 *end = alpha + surface->h * surface->pitch;\n\n    while (alpha < end) {\n        if (*alpha != 0) {\n            hasAlpha = SDL_TRUE;\n            break;\n        }\n        alpha += 4;\n    }\n\n    if (!hasAlpha) {\n        alpha = ((Uint8*)surface->pixels) + alphaChannelOffset;\n        while (alpha < end) {\n            *alpha = SDL_ALPHA_OPAQUE;\n            alpha += 4;\n        }\n    }\n}\n\nSDL_Surface *\nSDL_LoadBMP_RW(SDL_RWops * src, int freesrc)\n{\n    SDL_bool was_error;\n    Sint64 fp_offset = 0;\n    int bmpPitch;\n    int i, pad;\n    SDL_Surface *surface;\n    Uint32 Rmask = 0;\n    Uint32 Gmask = 0;\n    Uint32 Bmask = 0;\n    Uint32 Amask = 0;\n    SDL_Palette *palette;\n    Uint8 *bits;\n    Uint8 *top, *end;\n    SDL_bool topDown;\n    int ExpandBMP;\n    SDL_bool haveRGBMasks = SDL_FALSE;\n    SDL_bool haveAlphaMask = SDL_FALSE;\n    SDL_bool correctAlpha = SDL_FALSE;\n\n    /* The Win32 BMP file header (14 bytes) */\n    char magic[2];\n    /* Uint32 bfSize = 0; */\n    /* Uint16 bfReserved1 = 0; */\n    /* Uint16 bfReserved2 = 0; */\n    Uint32 bfOffBits = 0;\n\n    /* The Win32 BITMAPINFOHEADER struct (40 bytes) */\n    Uint32 biSize = 0;\n    Sint32 biWidth = 0;\n    Sint32 biHeight = 0;\n    /* Uint16 biPlanes = 0; */\n    Uint16 biBitCount = 0;\n    Uint32 biCompression = 0;\n    /* Uint32 biSizeImage = 0; */\n    /* Sint32 biXPelsPerMeter = 0; */\n    /* Sint32 biYPelsPerMeter = 0; */\n    Uint32 biClrUsed = 0;\n    /* Uint32 biClrImportant = 0; */\n\n    /* Make sure we are passed a valid data source */\n    surface = NULL;\n    was_error = SDL_FALSE;\n    if (src == NULL) {\n        was_error = SDL_TRUE;\n        goto done;\n    }\n\n    /* Read in the BMP file header */\n    fp_offset = SDL_RWtell(src);\n    SDL_ClearError();\n    if (SDL_RWread(src, magic, 1, 2) != 2) {\n        SDL_Error(SDL_EFREAD);\n        was_error = SDL_TRUE;\n        goto done;\n    }\n    if (SDL_strncmp(magic, \"BM\", 2) != 0) {\n        SDL_SetError(\"File is not a Windows BMP file\");\n        was_error = SDL_TRUE;\n        goto done;\n    }\n    /* bfSize = */ SDL_ReadLE32(src);\n    /* bfReserved1 = */ SDL_ReadLE16(src);\n    /* bfReserved2 = */ SDL_ReadLE16(src);\n    bfOffBits = SDL_ReadLE32(src);\n\n    /* Read the Win32 BITMAPINFOHEADER */\n    biSize = SDL_ReadLE32(src);\n    if (biSize == 12) {   /* really old BITMAPCOREHEADER */\n        biWidth = (Uint32) SDL_ReadLE16(src);\n        biHeight = (Uint32) SDL_ReadLE16(src);\n        /* biPlanes = */ SDL_ReadLE16(src);\n        biBitCount = SDL_ReadLE16(src);\n        biCompression = BI_RGB;\n    } else if (biSize >= 40) {  /* some version of BITMAPINFOHEADER */\n        Uint32 headerSize;\n        biWidth = SDL_ReadLE32(src);\n        biHeight = SDL_ReadLE32(src);\n        /* biPlanes = */ SDL_ReadLE16(src);\n        biBitCount = SDL_ReadLE16(src);\n        biCompression = SDL_ReadLE32(src);\n        /* biSizeImage = */ SDL_ReadLE32(src);\n        /* biXPelsPerMeter = */ SDL_ReadLE32(src);\n        /* biYPelsPerMeter = */ SDL_ReadLE32(src);\n        biClrUsed = SDL_ReadLE32(src);\n        /* biClrImportant = */ SDL_ReadLE32(src);\n\n        /* 64 == BITMAPCOREHEADER2, an incompatible OS/2 2.x extension. Skip this stuff for now. */\n        if (biSize == 64) {\n            /* ignore these extra fields. */\n            if (biCompression == BI_BITFIELDS) {\n                /* this value is actually huffman compression in this variant. */\n                SDL_SetError(\"Compressed BMP files not supported\");\n                was_error = SDL_TRUE;\n                goto done;\n            }\n        } else {\n            /* This is complicated. If compression is BI_BITFIELDS, then\n               we have 3 DWORDS that specify the RGB masks. This is either\n               stored here in an BITMAPV2INFOHEADER (which only differs in\n               that it adds these RGB masks) and biSize >= 52, or we've got\n               these masks stored in the exact same place, but strictly\n               speaking, this is the bmiColors field in BITMAPINFO immediately\n               following the legacy v1 info header, just past biSize. */\n            if (biCompression == BI_BITFIELDS) {\n                haveRGBMasks = SDL_TRUE;\n                Rmask = SDL_ReadLE32(src);\n                Gmask = SDL_ReadLE32(src);\n                Bmask = SDL_ReadLE32(src);\n\n                /* ...v3 adds an alpha mask. */\n                if (biSize >= 56) {  /* BITMAPV3INFOHEADER; adds alpha mask */\n                    haveAlphaMask = SDL_TRUE;\n                    Amask = SDL_ReadLE32(src);\n                }\n            } else {\n                /* the mask fields are ignored for v2+ headers if not BI_BITFIELD. */\n                if (biSize >= 52) {  /* BITMAPV2INFOHEADER; adds RGB masks */\n                    /*Rmask = */ SDL_ReadLE32(src);\n                    /*Gmask = */ SDL_ReadLE32(src);\n                    /*Bmask = */ SDL_ReadLE32(src);\n                }\n                if (biSize >= 56) {  /* BITMAPV3INFOHEADER; adds alpha mask */\n                    /*Amask = */ SDL_ReadLE32(src);\n                }\n            }\n\n            /* Insert other fields here; Wikipedia and MSDN say we're up to\n               v5 of this header, but we ignore those for now (they add gamma,\n               color spaces, etc). Ignoring the weird OS/2 2.x format, we\n               currently parse up to v3 correctly (hopefully!). */\n        }\n\n        /* skip any header bytes we didn't handle... */\n        headerSize = (Uint32) (SDL_RWtell(src) - (fp_offset + 14));\n        if (biSize > headerSize) {\n            SDL_RWseek(src, (biSize - headerSize), RW_SEEK_CUR);\n        }\n    }\n    if (biHeight < 0) {\n        topDown = SDL_TRUE;\n        biHeight = -biHeight;\n    } else {\n        topDown = SDL_FALSE;\n    }\n\n    /* Check for read error */\n    if (SDL_strcmp(SDL_GetError(), \"\") != 0) {\n        was_error = SDL_TRUE;\n        goto done;\n    }\n\n    /* Expand 1 and 4 bit bitmaps to 8 bits per pixel */\n    switch (biBitCount) {\n    case 1:\n    case 4:\n        ExpandBMP = biBitCount;\n        biBitCount = 8;\n        break;\n    default:\n        ExpandBMP = 0;\n        break;\n    }\n\n    /* We don't support any BMP compression right now */\n    switch (biCompression) {\n    case BI_RGB:\n        /* If there are no masks, use the defaults */\n        SDL_assert(!haveRGBMasks);\n        SDL_assert(!haveAlphaMask);\n        /* Default values for the BMP format */\n        switch (biBitCount) {\n        case 15:\n        case 16:\n            Rmask = 0x7C00;\n            Gmask = 0x03E0;\n            Bmask = 0x001F;\n            break;\n        case 24:\n#if SDL_BYTEORDER == SDL_BIG_ENDIAN\n            Rmask = 0x000000FF;\n            Gmask = 0x0000FF00;\n            Bmask = 0x00FF0000;\n#else\n            Rmask = 0x00FF0000;\n            Gmask = 0x0000FF00;\n            Bmask = 0x000000FF;\n#endif\n            break;\n        case 32:\n            /* We don't know if this has alpha channel or not */\n            correctAlpha = SDL_TRUE;\n            Amask = 0xFF000000;\n            Rmask = 0x00FF0000;\n            Gmask = 0x0000FF00;\n            Bmask = 0x000000FF;\n            break;\n        default:\n            break;\n        }\n        break;\n\n    case BI_BITFIELDS:\n        break;  /* we handled this in the info header. */\n\n    default:\n        SDL_SetError(\"Compressed BMP files not supported\");\n        was_error = SDL_TRUE;\n        goto done;\n    }\n\n    /* Create a compatible surface, note that the colors are RGB ordered */\n    surface =\n        SDL_CreateRGBSurface(0, biWidth, biHeight, biBitCount, Rmask, Gmask,\n                             Bmask, Amask);\n    if (surface == NULL) {\n        was_error = SDL_TRUE;\n        goto done;\n    }\n\n    /* Load the palette, if any */\n    palette = (surface->format)->palette;\n    if (palette) {\n        SDL_assert(biBitCount <= 8);\n        if (biClrUsed == 0) {\n            biClrUsed = 1 << biBitCount;\n        }\n        if ((int) biClrUsed > palette->ncolors) {\n            SDL_Color *colors;\n            int ncolors = biClrUsed;\n            colors =\n                (SDL_Color *) SDL_realloc(palette->colors,\n                                          ncolors *\n                                          sizeof(*palette->colors));\n            if (!colors) {\n                SDL_OutOfMemory();\n                was_error = SDL_TRUE;\n                goto done;\n            }\n            palette->ncolors = ncolors;\n            palette->colors = colors;\n        } else if ((int) biClrUsed < palette->ncolors) {\n            palette->ncolors = biClrUsed;\n        }\n        if (biSize == 12) {\n            for (i = 0; i < (int) biClrUsed; ++i) {\n                SDL_RWread(src, &palette->colors[i].b, 1, 1);\n                SDL_RWread(src, &palette->colors[i].g, 1, 1);\n                SDL_RWread(src, &palette->colors[i].r, 1, 1);\n                palette->colors[i].a = SDL_ALPHA_OPAQUE;\n            }\n        } else {\n            for (i = 0; i < (int) biClrUsed; ++i) {\n                SDL_RWread(src, &palette->colors[i].b, 1, 1);\n                SDL_RWread(src, &palette->colors[i].g, 1, 1);\n                SDL_RWread(src, &palette->colors[i].r, 1, 1);\n                SDL_RWread(src, &palette->colors[i].a, 1, 1);\n\n                /* According to Microsoft documentation, the fourth element\n                   is reserved and must be zero, so we shouldn't treat it as\n                   alpha.\n                */\n                palette->colors[i].a = SDL_ALPHA_OPAQUE;\n            }\n        }\n    }\n\n    /* Read the surface pixels.  Note that the bmp image is upside down */\n    if (SDL_RWseek(src, fp_offset + bfOffBits, RW_SEEK_SET) < 0) {\n        SDL_Error(SDL_EFSEEK);\n        was_error = SDL_TRUE;\n        goto done;\n    }\n    top = (Uint8 *)surface->pixels;\n    end = (Uint8 *)surface->pixels+(surface->h*surface->pitch);\n    switch (ExpandBMP) {\n    case 1:\n        bmpPitch = (biWidth + 7) >> 3;\n        pad = (((bmpPitch) % 4) ? (4 - ((bmpPitch) % 4)) : 0);\n        break;\n    case 4:\n        bmpPitch = (biWidth + 1) >> 1;\n        pad = (((bmpPitch) % 4) ? (4 - ((bmpPitch) % 4)) : 0);\n        break;\n    default:\n        pad = ((surface->pitch % 4) ? (4 - (surface->pitch % 4)) : 0);\n        break;\n    }\n    if (topDown) {\n        bits = top;\n    } else {\n        bits = end - surface->pitch;\n    }\n    while (bits >= top && bits < end) {\n        switch (ExpandBMP) {\n        case 1:\n        case 4:{\n                Uint8 pixel = 0;\n                int shift = (8 - ExpandBMP);\n                for (i = 0; i < surface->w; ++i) {\n                    if (i % (8 / ExpandBMP) == 0) {\n                        if (!SDL_RWread(src, &pixel, 1, 1)) {\n                            SDL_SetError(\"Error reading from BMP\");\n                            was_error = SDL_TRUE;\n                            goto done;\n                        }\n                    }\n                    *(bits + i) = (pixel >> shift);\n                    pixel <<= ExpandBMP;\n                }\n            }\n            break;\n\n        default:\n            if (SDL_RWread(src, bits, 1, surface->pitch)\n                != surface->pitch) {\n                SDL_Error(SDL_EFREAD);\n                was_error = SDL_TRUE;\n                goto done;\n            }\n#if SDL_BYTEORDER == SDL_BIG_ENDIAN\n            /* Byte-swap the pixels if needed. Note that the 24bpp\n               case has already been taken care of above. */\n            switch (biBitCount) {\n            case 15:\n            case 16:{\n                    Uint16 *pix = (Uint16 *) bits;\n                    for (i = 0; i < surface->w; i++)\n                        pix[i] = SDL_Swap16(pix[i]);\n                    break;\n                }\n\n            case 32:{\n                    Uint32 *pix = (Uint32 *) bits;\n                    for (i = 0; i < surface->w; i++)\n                        pix[i] = SDL_Swap32(pix[i]);\n                    break;\n                }\n            }\n#endif\n            break;\n        }\n        /* Skip padding bytes, ugh */\n        if (pad) {\n            Uint8 padbyte;\n            for (i = 0; i < pad; ++i) {\n                SDL_RWread(src, &padbyte, 1, 1);\n            }\n        }\n        if (topDown) {\n            bits += surface->pitch;\n        } else {\n            bits -= surface->pitch;\n        }\n    }\n    if (correctAlpha) {\n        CorrectAlphaChannel(surface);\n    }\n  done:\n    if (was_error) {\n        if (src) {\n            SDL_RWseek(src, fp_offset, RW_SEEK_SET);\n        }\n        SDL_FreeSurface(surface);\n        surface = NULL;\n    }\n    if (freesrc && src) {\n        SDL_RWclose(src);\n    }\n    return (surface);\n}\n\nint\nSDL_SaveBMP_RW(SDL_Surface * saveme, SDL_RWops * dst, int freedst)\n{\n    Sint64 fp_offset;\n    int i, pad;\n    SDL_Surface *surface;\n    Uint8 *bits;\n\n    /* The Win32 BMP file header (14 bytes) */\n    char magic[2] = { 'B', 'M' };\n    Uint32 bfSize;\n    Uint16 bfReserved1;\n    Uint16 bfReserved2;\n    Uint32 bfOffBits;\n\n    /* The Win32 BITMAPINFOHEADER struct (40 bytes) */\n    Uint32 biSize;\n    Sint32 biWidth;\n    Sint32 biHeight;\n    Uint16 biPlanes;\n    Uint16 biBitCount;\n    Uint32 biCompression;\n    Uint32 biSizeImage;\n    Sint32 biXPelsPerMeter;\n    Sint32 biYPelsPerMeter;\n    Uint32 biClrUsed;\n    Uint32 biClrImportant;\n\n    /* Make sure we have somewhere to save */\n    surface = NULL;\n    if (dst) {\n        SDL_bool save32bit = SDL_FALSE;\n#ifdef SAVE_32BIT_BMP\n        /* We can save alpha information in a 32-bit BMP */\n        if (saveme->map->info.flags & SDL_COPY_COLORKEY ||\n            saveme->format->Amask) {\n            save32bit = SDL_TRUE;\n        }\n#endif /* SAVE_32BIT_BMP */\n\n        if (saveme->format->palette && !save32bit) {\n            if (saveme->format->BitsPerPixel == 8) {\n                surface = saveme;\n            } else {\n                SDL_SetError(\"%d bpp BMP files not supported\",\n                             saveme->format->BitsPerPixel);\n            }\n        } else if ((saveme->format->BitsPerPixel == 24) &&\n#if SDL_BYTEORDER == SDL_LIL_ENDIAN\n                   (saveme->format->Rmask == 0x00FF0000) &&\n                   (saveme->format->Gmask == 0x0000FF00) &&\n                   (saveme->format->Bmask == 0x000000FF)\n#else\n                   (saveme->format->Rmask == 0x000000FF) &&\n                   (saveme->format->Gmask == 0x0000FF00) &&\n                   (saveme->format->Bmask == 0x00FF0000)\n#endif\n            ) {\n            surface = saveme;\n        } else {\n            SDL_PixelFormat format;\n\n            /* If the surface has a colorkey or alpha channel we'll save a\n               32-bit BMP with alpha channel, otherwise save a 24-bit BMP. */\n            if (save32bit) {\n                SDL_InitFormat(&format,\n#if SDL_BYTEORDER == SDL_LIL_ENDIAN\n                               SDL_PIXELFORMAT_ARGB8888\n#else\n                               SDL_PIXELFORMAT_BGRA8888\n#endif\n                               );\n            } else {\n                SDL_InitFormat(&format, SDL_PIXELFORMAT_BGR24);\n            }\n            surface = SDL_ConvertSurface(saveme, &format, 0);\n            if (!surface) {\n                SDL_SetError(\"Couldn't convert image to %d bpp\",\n                             format.BitsPerPixel);\n            }\n        }\n    }\n\n    if (surface && (SDL_LockSurface(surface) == 0)) {\n        const int bw = surface->w * surface->format->BytesPerPixel;\n\n        /* Set the BMP file header values */\n        bfSize = 0;             /* We'll write this when we're done */\n        bfReserved1 = 0;\n        bfReserved2 = 0;\n        bfOffBits = 0;          /* We'll write this when we're done */\n\n        /* Write the BMP file header values */\n        fp_offset = SDL_RWtell(dst);\n        SDL_ClearError();\n        SDL_RWwrite(dst, magic, 2, 1);\n        SDL_WriteLE32(dst, bfSize);\n        SDL_WriteLE16(dst, bfReserved1);\n        SDL_WriteLE16(dst, bfReserved2);\n        SDL_WriteLE32(dst, bfOffBits);\n\n        /* Set the BMP info values */\n        biSize = 40;\n        biWidth = surface->w;\n        biHeight = surface->h;\n        biPlanes = 1;\n        biBitCount = surface->format->BitsPerPixel;\n        biCompression = BI_RGB;\n        biSizeImage = surface->h * surface->pitch;\n        biXPelsPerMeter = 0;\n        biYPelsPerMeter = 0;\n        if (surface->format->palette) {\n            biClrUsed = surface->format->palette->ncolors;\n        } else {\n            biClrUsed = 0;\n        }\n        biClrImportant = 0;\n\n        /* Write the BMP info values */\n        SDL_WriteLE32(dst, biSize);\n        SDL_WriteLE32(dst, biWidth);\n        SDL_WriteLE32(dst, biHeight);\n        SDL_WriteLE16(dst, biPlanes);\n        SDL_WriteLE16(dst, biBitCount);\n        SDL_WriteLE32(dst, biCompression);\n        SDL_WriteLE32(dst, biSizeImage);\n        SDL_WriteLE32(dst, biXPelsPerMeter);\n        SDL_WriteLE32(dst, biYPelsPerMeter);\n        SDL_WriteLE32(dst, biClrUsed);\n        SDL_WriteLE32(dst, biClrImportant);\n\n        /* Write the palette (in BGR color order) */\n        if (surface->format->palette) {\n            SDL_Color *colors;\n            int ncolors;\n\n            colors = surface->format->palette->colors;\n            ncolors = surface->format->palette->ncolors;\n            for (i = 0; i < ncolors; ++i) {\n                SDL_RWwrite(dst, &colors[i].b, 1, 1);\n                SDL_RWwrite(dst, &colors[i].g, 1, 1);\n                SDL_RWwrite(dst, &colors[i].r, 1, 1);\n                SDL_RWwrite(dst, &colors[i].a, 1, 1);\n            }\n        }\n\n        /* Write the bitmap offset */\n        bfOffBits = (Uint32)(SDL_RWtell(dst) - fp_offset);\n        if (SDL_RWseek(dst, fp_offset + 10, RW_SEEK_SET) < 0) {\n            SDL_Error(SDL_EFSEEK);\n        }\n        SDL_WriteLE32(dst, bfOffBits);\n        if (SDL_RWseek(dst, fp_offset + bfOffBits, RW_SEEK_SET) < 0) {\n            SDL_Error(SDL_EFSEEK);\n        }\n\n        /* Write the bitmap image upside down */\n        bits = (Uint8 *) surface->pixels + (surface->h * surface->pitch);\n        pad = ((bw % 4) ? (4 - (bw % 4)) : 0);\n        while (bits > (Uint8 *) surface->pixels) {\n            bits -= surface->pitch;\n            if (SDL_RWwrite(dst, bits, 1, bw) != bw) {\n                SDL_Error(SDL_EFWRITE);\n                break;\n            }\n            if (pad) {\n                const Uint8 padbyte = 0;\n                for (i = 0; i < pad; ++i) {\n                    SDL_RWwrite(dst, &padbyte, 1, 1);\n                }\n            }\n        }\n\n        /* Write the BMP file size */\n        bfSize = (Uint32)(SDL_RWtell(dst) - fp_offset);\n        if (SDL_RWseek(dst, fp_offset + 2, RW_SEEK_SET) < 0) {\n            SDL_Error(SDL_EFSEEK);\n        }\n        SDL_WriteLE32(dst, bfSize);\n        if (SDL_RWseek(dst, fp_offset + bfSize, RW_SEEK_SET) < 0) {\n            SDL_Error(SDL_EFSEEK);\n        }\n\n        /* Close it up.. */\n        SDL_UnlockSurface(surface);\n        if (surface != saveme) {\n            SDL_FreeSurface(surface);\n        }\n    }\n\n    if (freedst && dst) {\n        SDL_RWclose(dst);\n    }\n    return ((SDL_strcmp(SDL_GetError(), \"\") == 0) ? 0 : -1);\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n"]}